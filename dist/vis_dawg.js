/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/dawg.ts":
/*!*********************!*\
  !*** ./src/dawg.ts ***!
  \*********************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DAWG = void 0;
class Node {
    constructor(birth_time, depth, children = undefined, slink = undefined) {
        this.birth_time = birth_time;
        this.depth = depth;
        this.children = new Map();
        if (children !== undefined) {
            for (const [k, v] of children.entries()) {
                this.children.set(k, v);
            }
        }
        this.slink = slink ? slink : this;
    }
}
// SuperNode is a virtual node such that
// it is a node pointing root's suffix link
// it can be moved to root by any characters.
class SuperNode extends Node {
    constructor(root) {
        super(-1, -1);
        this.depth = -1;
        this.children = { get: undefined };
        root.slink = this;
        this.children.get = (char) => {
            return root;
        };
        this.children.has = (char) => {
            return true;
        };
    }
}
class DAWG {
    constructor() {
        this.nodes = [];
        this.root = this.create_node(0);
        this.tail = this.root;
        this.supernode = new SuperNode(this.root);
    }
    create_node(depth) {
        const node = new Node(this.nodes.length, depth);
        this.nodes.push(node);
        return node;
    }
    copy_node(node) {
        const new_node = new Node(this.nodes.length, node.depth, node.children, node.slink);
        this.nodes.push(new_node);
        return new_node;
    }
    insert(char) {
        let cur = this.tail;
        this.tail = this.create_node(this.tail.depth + 1);
        while (!cur.children.has(char)) {
            // console.log('cur', cur)
            cur.children.set(char, this.tail);
            cur = cur.slink;
        }
        const child = cur.children.get(char);
        if (cur.depth + 1 === child.depth) {
            this.tail.slink = child;
        }
        else {
            const new_node = this.copy_node(child);
            new_node.depth = cur.depth + 1;
            cur.children.set(char, new_node);
            this.tail.slink = new_node;
            child.slink = new_node;
            cur = cur.slink;
            while (cur.depth + 1 < cur.children.get(char).depth) {
                cur.children.set(char, new_node);
                cur = cur.slink;
            }
        }
    }
    json(show_suffix_links = true) {
        const nodes = [];
        let edges = [];
        const nid = new Map();
        let max_diff_depth = 0;
        const min_roundness = 0.2;
        const max_roundness = 0.5;
        this.nodes.forEach((node) => {
            max_diff_depth = Math.max(max_diff_depth, node.depth);
        });
        const roundness = (diff_depth) => {
            return (min_roundness +
                ((max_roundness - min_roundness) * diff_depth) / max_diff_depth);
        };
        const create_json_node = (node) => {
            // console.log('json_node', node, nid[node], nid)
            if (!nid.has(node)) {
                nid.set(node, node.birth_time);
                const ndic = {
                    label: "" + nid.get(node),
                    id: nid.get(node),
                    level: node.depth,
                };
                nodes.push(ndic);
            }
        };
        this.nodes.forEach((from_node) => {
            create_json_node(from_node);
            from_node.children.forEach((to_node, label) => {
                create_json_node(to_node);
                const diff_depth = Math.abs(to_node.depth - from_node.depth);
                const edge = {
                    from: nid.get(from_node),
                    to: nid.get(to_node),
                    id: nid.get(from_node) + "-" + nid.get(to_node),
                    label: label,
                    font: { align: "top" },
                    smooth: { type: "curvedCW", roundness: roundness(diff_depth) },
                };
                edges.push(edge);
            });
        });
        // suffix link
        if (show_suffix_links) {
            const slinks = [];
            for (const from_node of this.nodes) {
                if (from_node === this.root)
                    continue;
                const to_node = from_node.slink;
                console.log("from_node", from_node);
                const diff_depth = Math.abs(to_node.depth - from_node.depth);
                const slink = {
                    from: nid.get(from_node),
                    to: nid.get(to_node),
                    id: "s" + nid.get(from_node) + "-" + nid.get(to_node),
                    dashes: true,
                    // color: { color: '#848484' },
                    color: { color: "#ff0000" },
                    smooth: { type: "curvedCW", roundness: roundness(diff_depth) },
                };
                slinks.push(slink);
            }
            edges = edges.concat(slinks);
        }
        return { root: nid.get(this.root), nodes: nodes, edges: edges };
    }
    buld_suffix_links() { }
}
exports.DAWG = DAWG;
function main(text) {
    const dawg = new DAWG();
    for (let i = 0; i < text.length; i++) {
        dawg.insert(text[i]);
    }
    console.log(dawg);
    console.log(dawg.json);
}
if (__webpack_require__.c[__webpack_require__.s] === module) {
    if (process.argv.length === 3) {
        main(process.argv[2]);
    }
    else {
        const usage = process.argv[1] +
            " input_str\n" +
            "\tbuild suffix tree of input_str and show the structure in json format.";
        console.log(usage);
    }
}


/***/ }),

/***/ "./src/vis_dawg.ts":
/*!*************************!*\
  !*** ./src/vis_dawg.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const standalone_1 = __webpack_require__(/*! vis-network/standalone */ "./node_modules/vis-network/standalone/index.js");
const dawg_1 = __webpack_require__(/*! ./dawg */ "./src/dawg.ts");
const visjs_default_options = __webpack_require__(/*! ./visjs_default_options */ "./src/visjs_default_options.ts");
const options = visjs_default_options.options;
const container = document.getElementById("network");
const network = new standalone_1.Network(container, {}, options);
let networkData = {
    nodes: new standalone_1.DataSet([]),
    edges: new standalone_1.DataSet([]),
};
let dawg = new dawg_1.DAWG();
const load_params_from_url = () => {
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    let params = {
        input_text: "cocoa",
        show_suffix_links: true,
    };
    const urlkey = urlParams.get("input_text");
    if (urlkey !== null)
        params.input_text = urlkey;
    params.show_suffix_links = urlParams.get("show_suffix_links") === "true";
    return params;
};
const load_params_from_html = () => {
    const input_text = document.getElementById("input_text")
        .value;
    const show_suffix_links = document.getElementById("show_suffix_links").checked;
    const params = {
        input_text: input_text,
        show_suffix_links: show_suffix_links,
    };
    return params;
};
const set_params_to_url = (params) => {
    const url = new URL(window.location.toString());
    for (let key of Object.keys(params)) {
        url.searchParams.set(key, params[key].toString());
    }
    history.replaceState({}, "", url.toString());
};
const set_params_to_html = (params) => {
    console.log("setparams");
    const input_text = document.getElementById("input_text");
    const show_suffix_links = document.getElementById("show_suffix_links");
    const implicit_cdawg = document.getElementById("implicit_cdawg");
    input_text.value = params.input_text;
    show_suffix_links.checked = params.show_suffix_links;
};
const redraw = function () {
    // set params to url
    const params = load_params_from_html();
    set_params_to_url(params);
    dawg = new dawg_1.DAWG();
    for (let i = 0; i < params.input_text.length; i++) {
        dawg.insert(params.input_text[i]);
    }
    const json = dawg.json(params.show_suffix_links);
    console.log("json", json);
    networkData = {
        nodes: new standalone_1.DataSet(json.nodes),
        edges: new standalone_1.DataSet(json.edges),
    };
    network.setData(networkData);
};
/**
 * Make a map from node id to the strings from root to the node.
 */
// const make_node_strs = (): Map<number, Set<string>> => {
const make_node_strs = () => {
    const json = dawg.json();
    const map = new Map();
    // const map = new Map<number, Set<string>>();
    // const map = new Map<number, Set<string>>();
    const children = (nid) => {
        let res = [];
        for (let edge of json.edges) {
            if (edge.id[0] === "s")
                continue;
            if (edge.from !== nid)
                continue;
            res.push(edge);
        }
        return res;
    };
    const rec = (nid, prefix) => {
        if (!map.has(nid)) {
            // map.set(nid, new Set());
            map.set(nid, []);
        }
        map.get(nid).push(prefix);
        for (let edge of children(nid)) {
            if (edge.from !== nid)
                continue;
            rec(edge.to, prefix + edge.label);
        }
    };
    rec(json.root, "");
    for (let [k, v] of map.entries()) {
        v.sort((a, b) => {
            return b.length - a.length;
        });
    }
    return map;
};
const show_node_str = (nid) => {
    const elm = document.getElementById("node_str");
    let text = "";
    if (nid !== null) {
        const nstrs = make_node_strs();
        for (let nstr of nstrs.get(nid)) {
            text += "<p>" + nstr + "</p>";
        }
    }
    elm.innerHTML = text;
};
const main = () => {
    // set event listener
    const input_text = document.getElementById("input_text");
    input_text.addEventListener("input", redraw);
    input_text.addEventListener("propertychange", redraw);
    const show_sl_btn = document.getElementById("show_suffix_links");
    show_sl_btn.addEventListener("change", redraw);
    network.on("hoverEdge", function (e) {
        console.log("hoverEdge", e);
        // console.log('networkData.edges', networkData.edges.get(e.edge))
        // @ts-ignore
        networkData.edges.update({ id: e.edge, font: { size: 34 } });
        // @ts-ignore
        const nid = networkData.edges.get(e.edge).to;
        show_node_str(nid);
    });
    network.on("blurEdge", function (e) {
        console.log("blurEdge", e);
        // @ts-ignore
        networkData.edges.update({ id: e.edge, font: { size: 14 } });
        // show_node_str(null);
    });
    network.on("hoverNode", (n) => {
        show_node_str(n.node);
    });
    network.on("blurNode", (n) => {
        // show_node_str(null);
    });
    // load and set parameters
    const params = load_params_from_url();
    set_params_to_html(params);
    redraw();
};
main();


/***/ }),

/***/ "./src/visjs_default_options.ts":
/*!**************************************!*\
  !*** ./src/visjs_default_options.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.options = void 0;
exports.options = {
    height: "100%",
    layout: {
        hierarchical: {
            // enabled: true
            // direction: 'UD',
            direction: "LR",
            // sortMethod: 'directed',
            treeSpacing: 185,
            levelSeparation: 95,
            nodeSpacing: 40,
        },
    },
    nodes: {
        size: 10,
    },
    edges: {
        arrows: {
            to: {
                enabled: true,
                scaleFactor: 0.5,
            },
        },
        // edge label is not displayed at the center of the edge
        // if `smooth` is specified
        smooth: {
            enabled: true,
            // type: 'dynamic',
            type: "vertical",
            // type: 'horizontal', // This is better for UD
            // type: 'continuous',
            // type: 'curvedCCW',
            // type: 'straightCross',
            roundness: 1.0,
        },
    },
    interaction: {
        hover: true,
        navigationButtons: true,
    },
    physics: false,
};


/***/ }),

/***/ "./node_modules/vis-network/standalone/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/vis-network/standalone/esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataSet": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.DataSet),
/* harmony export */   "DataView": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.DataView),
/* harmony export */   "Network": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.Network),
/* harmony export */   "NetworkImages": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.NetworkImages),
/* harmony export */   "Queue": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.Queue),
/* harmony export */   "data": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.data),
/* harmony export */   "networkDOTParser": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.networkDOTParser),
/* harmony export */   "networkGephiParser": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.networkGephiParser),
/* harmony export */   "networkOptions": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.networkOptions),
/* harmony export */   "parseDOTNetwork": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.parseDOTNetwork),
/* harmony export */   "parseGephiNetwork": () => (/* reexport safe */ _vis_network__WEBPACK_IMPORTED_MODULE_0__.parseGephiNetwork)
/* harmony export */ });
/* harmony import */ var _vis_network__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vis-network */ "./node_modules/vis-network/standalone/esm/vis-network.js");



/***/ }),

/***/ "./node_modules/vis-network/standalone/esm/vis-network.js":
/*!****************************************************************!*\
  !*** ./node_modules/vis-network/standalone/esm/vis-network.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataSet": () => (/* binding */ DataSet),
/* harmony export */   "DataView": () => (/* binding */ DataView),
/* harmony export */   "Network": () => (/* binding */ Network),
/* harmony export */   "NetworkImages": () => (/* binding */ Images),
/* harmony export */   "Queue": () => (/* binding */ Queue),
/* harmony export */   "data": () => (/* binding */ index),
/* harmony export */   "networkDOTParser": () => (/* binding */ dotparser),
/* harmony export */   "networkGephiParser": () => (/* binding */ gephiParser),
/* harmony export */   "networkOptions": () => (/* binding */ options),
/* harmony export */   "parseDOTNetwork": () => (/* binding */ parseDOTNetwork),
/* harmony export */   "parseGephiNetwork": () => (/* binding */ parseGephi)
/* harmony export */ });
/**
 * vis-network
 * https://visjs.github.io/vis-network/
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 9.1.2
 * @date    2022-03-28T20:13:51.046Z
 *
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs
 *
 * @license
 * vis.js is dual licensed under both
 *
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   and
 *
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 *
 * vis.js may be distributed under either license.
 */

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

var check = function (it) {
  return it && it.Math == Math && it;
}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


var global$P = // eslint-disable-next-line es/no-global-this -- safe
check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
function () {
  return this;
}() || Function('return this')();

var fails$t = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

var fails$s = fails$t;
var functionBindNative = !fails$s(function () {
  var test = function () {
    /* empty */
  }.bind(); // eslint-disable-next-line no-prototype-builtins -- safe


  return typeof test != 'function' || test.hasOwnProperty('prototype');
});

var NATIVE_BIND$4 = functionBindNative;
var FunctionPrototype$3 = Function.prototype;
var apply$6 = FunctionPrototype$3.apply;
var call$d = FunctionPrototype$3.call; // eslint-disable-next-line es/no-reflect -- safe

var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$4 ? call$d.bind(apply$6) : function () {
  return call$d.apply(apply$6, arguments);
});

var NATIVE_BIND$3 = functionBindNative;
var FunctionPrototype$2 = Function.prototype;
var bind$d = FunctionPrototype$2.bind;
var call$c = FunctionPrototype$2.call;
var uncurryThis$w = NATIVE_BIND$3 && bind$d.bind(call$c, call$c);
var functionUncurryThis = NATIVE_BIND$3 ? function (fn) {
  return fn && uncurryThis$w(fn);
} : function (fn) {
  return fn && function () {
    return call$c.apply(fn, arguments);
  };
};

// https://tc39.es/ecma262/#sec-iscallable

var isCallable$h = function (argument) {
  return typeof argument == 'function';
};

var objectGetOwnPropertyDescriptor = {};

var fails$r = fails$t; // Detect IE8's incomplete defineProperty implementation

var descriptors = !fails$r(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, {
    get: function () {
      return 7;
    }
  })[1] != 7;
});

var NATIVE_BIND$2 = functionBindNative;
var call$b = Function.prototype.call;
var functionCall = NATIVE_BIND$2 ? call$b.bind(call$b) : function () {
  return call$b.apply(call$b, arguments);
};

var objectPropertyIsEnumerable = {};

var $propertyIsEnumerable$2 = {}.propertyIsEnumerable; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

var getOwnPropertyDescriptor$8 = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

var NASHORN_BUG = getOwnPropertyDescriptor$8 && !$propertyIsEnumerable$2.call({
  1: 2
}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable

objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$8(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable$2;

var createPropertyDescriptor$5 = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var uncurryThis$v = functionUncurryThis;
var toString$a = uncurryThis$v({}.toString);
var stringSlice$1 = uncurryThis$v(''.slice);

var classofRaw$1 = function (it) {
  return stringSlice$1(toString$a(it), 8, -1);
};

var global$O = global$P;
var uncurryThis$u = functionUncurryThis;
var fails$q = fails$t;
var classof$f = classofRaw$1;
var Object$a = global$O.Object;
var split = uncurryThis$u(''.split); // fallback for non-array-like ES3 and non-enumerable old V8 strings

var indexedObject = fails$q(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object$a('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof$f(it) == 'String' ? split(it, '') : Object$a(it);
} : Object$a;

var global$N = global$P;
var TypeError$j = global$N.TypeError; // `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible

var requireObjectCoercible$5 = function (it) {
  if (it == undefined) throw TypeError$j("Can't call method on " + it);
  return it;
};

var IndexedObject$3 = indexedObject;
var requireObjectCoercible$4 = requireObjectCoercible$5;

var toIndexedObject$b = function (it) {
  return IndexedObject$3(requireObjectCoercible$4(it));
};

var isCallable$g = isCallable$h;

var isObject$j = function (it) {
  return typeof it == 'object' ? it !== null : isCallable$g(it);
};

var path$y = {};

var path$x = path$y;
var global$M = global$P;
var isCallable$f = isCallable$h;

var aFunction = function (variable) {
  return isCallable$f(variable) ? variable : undefined;
};

var getBuiltIn$9 = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path$x[namespace]) || aFunction(global$M[namespace]) : path$x[namespace] && path$x[namespace][method] || global$M[namespace] && global$M[namespace][method];
};

var uncurryThis$t = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$t({}.isPrototypeOf);

var getBuiltIn$8 = getBuiltIn$9;
var engineUserAgent = getBuiltIn$8('navigator', 'userAgent') || '';

var global$L = global$P;
var userAgent$3 = engineUserAgent;
var process = global$L.process;
var Deno = global$L.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.'); // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us

  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
} // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0


if (!version && userAgent$3) {
  match = userAgent$3.match(/Edge\/(\d+)/);

  if (!match || match[1] >= 74) {
    match = userAgent$3.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

var engineV8Version = version;

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION$2 = engineV8Version;
var fails$p = fails$t; // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing

var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$p(function () {
  var symbol = Symbol(); // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances

  return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && V8_VERSION$2 && V8_VERSION$2 < 41;
});

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL$2 = nativeSymbol;
var useSymbolAsUid = NATIVE_SYMBOL$2 && !Symbol.sham && typeof Symbol.iterator == 'symbol';

var global$K = global$P;
var getBuiltIn$7 = getBuiltIn$9;
var isCallable$e = isCallable$h;
var isPrototypeOf$m = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var Object$9 = global$K.Object;
var isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn$7('Symbol');
  return isCallable$e($Symbol) && isPrototypeOf$m($Symbol.prototype, Object$9(it));
};

var global$J = global$P;
var String$4 = global$J.String;

var tryToString$4 = function (argument) {
  try {
    return String$4(argument);
  } catch (error) {
    return 'Object';
  }
};

var global$I = global$P;
var isCallable$d = isCallable$h;
var tryToString$3 = tryToString$4;
var TypeError$i = global$I.TypeError; // `Assert: IsCallable(argument) is true`

var aCallable$7 = function (argument) {
  if (isCallable$d(argument)) return argument;
  throw TypeError$i(tryToString$3(argument) + ' is not a function');
};

var aCallable$6 = aCallable$7; // `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod

var getMethod$3 = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable$6(func);
};

var global$H = global$P;
var call$a = functionCall;
var isCallable$c = isCallable$h;
var isObject$i = isObject$j;
var TypeError$h = global$H.TypeError; // `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive

var ordinaryToPrimitive$1 = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable$c(fn = input.toString) && !isObject$i(val = call$a(fn, input))) return val;
  if (isCallable$c(fn = input.valueOf) && !isObject$i(val = call$a(fn, input))) return val;
  if (pref !== 'string' && isCallable$c(fn = input.toString) && !isObject$i(val = call$a(fn, input))) return val;
  throw TypeError$h("Can't convert object to primitive value");
};

var shared$4 = {exports: {}};

var global$G = global$P; // eslint-disable-next-line es/no-object-defineproperty -- safe

var defineProperty$e = Object.defineProperty;

var setGlobal$1 = function (key, value) {
  try {
    defineProperty$e(global$G, key, {
      value: value,
      configurable: true,
      writable: true
    });
  } catch (error) {
    global$G[key] = value;
  }

  return value;
};

var global$F = global$P;
var setGlobal = setGlobal$1;
var SHARED = '__core-js_shared__';
var store$3 = global$F[SHARED] || setGlobal(SHARED, {});
var sharedStore = store$3;

var store$2 = sharedStore;
(shared$4.exports = function (key, value) {
  return store$2[key] || (store$2[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.21.1',
  mode: 'pure' ,
  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});

var global$E = global$P;
var requireObjectCoercible$3 = requireObjectCoercible$5;
var Object$8 = global$E.Object; // `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject

var toObject$e = function (argument) {
  return Object$8(requireObjectCoercible$3(argument));
};

var uncurryThis$s = functionUncurryThis;
var toObject$d = toObject$e;
var hasOwnProperty = uncurryThis$s({}.hasOwnProperty); // `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty

var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject$d(it), key);
};

var uncurryThis$r = functionUncurryThis;
var id$2 = 0;
var postfix = Math.random();
var toString$9 = uncurryThis$r(1.0.toString);

var uid$4 = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$9(++id$2 + postfix, 36);
};

var global$D = global$P;
var shared$3 = shared$4.exports;
var hasOwn$h = hasOwnProperty_1;
var uid$3 = uid$4;
var NATIVE_SYMBOL$1 = nativeSymbol;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var WellKnownSymbolsStore$1 = shared$3('wks');
var Symbol$3 = global$D.Symbol;
var symbolFor = Symbol$3 && Symbol$3['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$3 : Symbol$3 && Symbol$3.withoutSetter || uid$3;

var wellKnownSymbol$j = function (name) {
  if (!hasOwn$h(WellKnownSymbolsStore$1, name) || !(NATIVE_SYMBOL$1 || typeof WellKnownSymbolsStore$1[name] == 'string')) {
    var description = 'Symbol.' + name;

    if (NATIVE_SYMBOL$1 && hasOwn$h(Symbol$3, name)) {
      WellKnownSymbolsStore$1[name] = Symbol$3[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore$1[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore$1[name] = createWellKnownSymbol(description);
    }
  }

  return WellKnownSymbolsStore$1[name];
};

var global$C = global$P;
var call$9 = functionCall;
var isObject$h = isObject$j;
var isSymbol$2 = isSymbol$3;
var getMethod$2 = getMethod$3;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$i = wellKnownSymbol$j;
var TypeError$g = global$C.TypeError;
var TO_PRIMITIVE$1 = wellKnownSymbol$i('toPrimitive'); // `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive

var toPrimitive$1 = function (input, pref) {
  if (!isObject$h(input) || isSymbol$2(input)) return input;
  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE$1);
  var result;

  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call$9(exoticToPrim, input, pref);
    if (!isObject$h(result) || isSymbol$2(result)) return result;
    throw TypeError$g("Can't convert object to primitive value");
  }

  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};

var toPrimitive = toPrimitive$1;
var isSymbol$1 = isSymbol$3; // `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey

var toPropertyKey$4 = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol$1(key) ? key : key + '';
};

var global$B = global$P;
var isObject$g = isObject$j;
var document$1 = global$B.document; // typeof document.createElement is 'object' in old IE

var EXISTS$1 = isObject$g(document$1) && isObject$g(document$1.createElement);

var documentCreateElement$1 = function (it) {
  return EXISTS$1 ? document$1.createElement(it) : {};
};

var DESCRIPTORS$h = descriptors;
var fails$o = fails$t;
var createElement = documentCreateElement$1; // Thanks to IE8 for its funny defineProperty

var ie8DomDefine = !DESCRIPTORS$h && !fails$o(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

var DESCRIPTORS$g = descriptors;
var call$8 = functionCall;
var propertyIsEnumerableModule$2 = objectPropertyIsEnumerable;
var createPropertyDescriptor$4 = createPropertyDescriptor$5;
var toIndexedObject$a = toIndexedObject$b;
var toPropertyKey$3 = toPropertyKey$4;
var hasOwn$g = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

objectGetOwnPropertyDescriptor.f = DESCRIPTORS$g ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$a(O);
  P = toPropertyKey$3(P);
  if (IE8_DOM_DEFINE$1) try {
    return $getOwnPropertyDescriptor$2(O, P);
  } catch (error) {
    /* empty */
  }
  if (hasOwn$g(O, P)) return createPropertyDescriptor$4(!call$8(propertyIsEnumerableModule$2.f, O, P), O[P]);
};

var fails$n = fails$t;
var isCallable$b = isCallable$h;
var replacement = /#|\.prototype\./;

var isForced$1 = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$b(detection) ? fails$n(detection) : !!detection;
};

var normalize = isForced$1.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced$1.data = {};
var NATIVE = isForced$1.NATIVE = 'N';
var POLYFILL = isForced$1.POLYFILL = 'P';
var isForced_1 = isForced$1;

var uncurryThis$q = functionUncurryThis;
var aCallable$5 = aCallable$7;
var NATIVE_BIND$1 = functionBindNative;
var bind$c = uncurryThis$q(uncurryThis$q.bind); // optional / simple context binding

var functionBindContext = function (fn, that) {
  aCallable$5(fn);
  return that === undefined ? fn : NATIVE_BIND$1 ? bind$c(fn, that) : function
    /* ...args */
  () {
    return fn.apply(that, arguments);
  };
};

var objectDefineProperty = {};

var DESCRIPTORS$f = descriptors;
var fails$m = fails$t; // V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334

var v8PrototypeDefineBug = DESCRIPTORS$f && fails$m(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () {
    /* empty */
  }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});

var global$A = global$P;
var isObject$f = isObject$j;
var String$3 = global$A.String;
var TypeError$f = global$A.TypeError; // `Assert: Type(argument) is Object`

var anObject$d = function (argument) {
  if (isObject$f(argument)) return argument;
  throw TypeError$f(String$3(argument) + ' is not an object');
};

var global$z = global$P;
var DESCRIPTORS$e = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$c = anObject$d;
var toPropertyKey$2 = toPropertyKey$4;
var TypeError$e = global$z.TypeError; // eslint-disable-next-line es/no-object-defineproperty -- safe

var $defineProperty$1 = Object.defineProperty; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE$1 = 'configurable';
var WRITABLE = 'writable'; // `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty

objectDefineProperty.f = DESCRIPTORS$e ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
  anObject$c(O);
  P = toPropertyKey$2(P);
  anObject$c(Attributes);

  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor$1(O, P);

    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }

  return $defineProperty$1(O, P, Attributes);
} : $defineProperty$1 : function defineProperty(O, P, Attributes) {
  anObject$c(O);
  P = toPropertyKey$2(P);
  anObject$c(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty$1(O, P, Attributes);
  } catch (error) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError$e('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var DESCRIPTORS$d = descriptors;
var definePropertyModule$4 = objectDefineProperty;
var createPropertyDescriptor$3 = createPropertyDescriptor$5;
var createNonEnumerableProperty$6 = DESCRIPTORS$d ? function (object, key, value) {
  return definePropertyModule$4.f(object, key, createPropertyDescriptor$3(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var global$y = global$P;
var apply$5 = functionApply;
var uncurryThis$p = functionUncurryThis;
var isCallable$a = isCallable$h;
var getOwnPropertyDescriptor$7 = objectGetOwnPropertyDescriptor.f;
var isForced = isForced_1;
var path$w = path$y;
var bind$b = functionBindContext;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
var hasOwn$f = hasOwnProperty_1;

var wrapConstructor = function (NativeConstructor) {
  var Wrapper = function (a, b, c) {
    if (this instanceof Wrapper) {
      switch (arguments.length) {
        case 0:
          return new NativeConstructor();

        case 1:
          return new NativeConstructor(a);

        case 2:
          return new NativeConstructor(a, b);
      }

      return new NativeConstructor(a, b, c);
    }

    return apply$5(NativeConstructor, this, arguments);
  };

  Wrapper.prototype = NativeConstructor.prototype;
  return Wrapper;
};
/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
  options.name        - the .name of the function if it does not match the key
*/


var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var PROTO = options.proto;
  var nativeSource = GLOBAL ? global$y : STATIC ? global$y[TARGET] : (global$y[TARGET] || {}).prototype;
  var target = GLOBAL ? path$w : path$w[TARGET] || createNonEnumerableProperty$5(path$w, TARGET, {})[TARGET];
  var targetPrototype = target.prototype;
  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

  for (key in source) {
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contains in native

    USE_NATIVE = !FORCED && nativeSource && hasOwn$f(nativeSource, key);
    targetProperty = target[key];
    if (USE_NATIVE) if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor$7(nativeSource, key);
      nativeProperty = descriptor && descriptor.value;
    } else nativeProperty = nativeSource[key]; // export native or implementation

    sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue; // bind timers to global for call from export context

    if (options.bind && USE_NATIVE) resultProperty = bind$b(sourceProperty, global$y); // wrap global constructors for prevent changs in this version
    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty); // make static versions for prototype methods
    else if (PROTO && isCallable$a(sourceProperty)) resultProperty = uncurryThis$p(sourceProperty); // default case
    else resultProperty = sourceProperty; // add a flag to not completely full polyfills

    if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty$5(resultProperty, 'sham', true);
    }

    createNonEnumerableProperty$5(target, key, resultProperty);

    if (PROTO) {
      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';

      if (!hasOwn$f(path$w, VIRTUAL_PROTOTYPE)) {
        createNonEnumerableProperty$5(path$w, VIRTUAL_PROTOTYPE, {});
      } // export virtual prototype methods


      createNonEnumerableProperty$5(path$w[VIRTUAL_PROTOTYPE], key, sourceProperty); // export real prototype methods

      if (options.real && targetPrototype && !targetPrototype[key]) {
        createNonEnumerableProperty$5(targetPrototype, key, sourceProperty);
      }
    }
  }
};

var ceil = Math.ceil;
var floor$1 = Math.floor; // `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity

var toIntegerOrInfinity$4 = function (argument) {
  var number = +argument; // eslint-disable-next-line no-self-compare -- safe

  return number !== number || number === 0 ? 0 : (number > 0 ? floor$1 : ceil)(number);
};

var toIntegerOrInfinity$3 = toIntegerOrInfinity$4;
var max$3 = Math.max;
var min$2 = Math.min; // Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

var toAbsoluteIndex$5 = function (index, length) {
  var integer = toIntegerOrInfinity$3(index);
  return integer < 0 ? max$3(integer + length, 0) : min$2(integer, length);
};

var toIntegerOrInfinity$2 = toIntegerOrInfinity$4;
var min$1 = Math.min; // `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength

var toLength$1 = function (argument) {
  return argument > 0 ? min$1(toIntegerOrInfinity$2(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var toLength = toLength$1; // `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike

var lengthOfArrayLike$d = function (obj) {
  return toLength(obj.length);
};

var toIndexedObject$9 = toIndexedObject$b;
var toAbsoluteIndex$4 = toAbsoluteIndex$5;
var lengthOfArrayLike$c = lengthOfArrayLike$d; // `Array.prototype.{ indexOf, includes }` methods implementation

var createMethod$5 = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject$9($this);
    var length = lengthOfArrayLike$c(O);
    var index = toAbsoluteIndex$4(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare -- NaN check

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$5(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$5(false)
};

var hiddenKeys$6 = {};

var uncurryThis$o = functionUncurryThis;
var hasOwn$e = hasOwnProperty_1;
var toIndexedObject$8 = toIndexedObject$b;
var indexOf$4 = arrayIncludes.indexOf;
var hiddenKeys$5 = hiddenKeys$6;
var push$5 = uncurryThis$o([].push);

var objectKeysInternal = function (object, names) {
  var O = toIndexedObject$8(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) !hasOwn$e(hiddenKeys$5, key) && hasOwn$e(O, key) && push$5(result, key); // Don't enum bug & hidden keys


  while (names.length > i) if (hasOwn$e(O, key = names[i++])) {
    ~indexOf$4(result, key) || push$5(result, key);
  }

  return result;
};

var enumBugKeys$3 = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3; // `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe

var objectKeys$4 = Object.keys || function keys(O) {
  return internalObjectKeys$1(O, enumBugKeys$2);
};

var objectGetOwnPropertySymbols = {};

objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

var DESCRIPTORS$c = descriptors;
var uncurryThis$n = functionUncurryThis;
var call$7 = functionCall;
var fails$l = fails$t;
var objectKeys$3 = objectKeys$4;
var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var toObject$c = toObject$e;
var IndexedObject$2 = indexedObject; // eslint-disable-next-line es/no-object-assign -- safe

var $assign = Object.assign; // eslint-disable-next-line es/no-object-defineproperty -- required for testing

var defineProperty$d = Object.defineProperty;
var concat$6 = uncurryThis$n([].concat); // `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign

var objectAssign = !$assign || fails$l(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS$c && $assign({
    b: 1
  }, $assign(defineProperty$d({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty$d(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), {
    b: 2
  })).b !== 1) return true; // should work with symbols and should have deterministic property order (V8 bug)

  var A = {};
  var B = {}; // eslint-disable-next-line es/no-symbol -- safe

  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) {
    B[chr] = chr;
  });
  return $assign({}, A)[symbol] != 7 || objectKeys$3($assign({}, B)).join('') != alphabet;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars -- required for `.length`
  var T = toObject$c(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule$2.f;
  var propertyIsEnumerable = propertyIsEnumerableModule$1.f;

  while (argumentsLength > index) {
    var S = IndexedObject$2(arguments[index++]);
    var keys = getOwnPropertySymbols ? concat$6(objectKeys$3(S), getOwnPropertySymbols(S)) : objectKeys$3(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS$c || call$7(propertyIsEnumerable, S, key)) T[key] = S[key];
    }
  }

  return T;
} : $assign;

var $$J = _export;
var assign$5 = objectAssign; // `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es/no-object-assign -- required for testing

$$J({
  target: 'Object',
  stat: true,
  forced: Object.assign !== assign$5
}, {
  assign: assign$5
});

var path$v = path$y;
var assign$4 = path$v.Object.assign;

var parent$1a = assign$4;
var assign$3 = parent$1a;

var assign$2 = assign$3;

var uncurryThis$m = functionUncurryThis;
var arraySlice$5 = uncurryThis$m([].slice);

var global$x = global$P;
var uncurryThis$l = functionUncurryThis;
var aCallable$4 = aCallable$7;
var isObject$e = isObject$j;
var hasOwn$d = hasOwnProperty_1;
var arraySlice$4 = arraySlice$5;
var NATIVE_BIND = functionBindNative;
var Function$2 = global$x.Function;
var concat$5 = uncurryThis$l([].concat);
var join = uncurryThis$l([].join);
var factories = {};

var construct$4 = function (C, argsLength, args) {
  if (!hasOwn$d(factories, argsLength)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';

    factories[argsLength] = Function$2('C,a', 'return new C(' + join(list, ',') + ')');
  }

  return factories[argsLength](C, args);
}; // `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind


var functionBind = NATIVE_BIND ? Function$2.bind : function bind(that
/* , ...args */
) {
  var F = aCallable$4(this);
  var Prototype = F.prototype;
  var partArgs = arraySlice$4(arguments, 1);

  var boundFunction = function
    /* args... */
  bound() {
    var args = concat$5(partArgs, arraySlice$4(arguments));
    return this instanceof boundFunction ? construct$4(F, args.length, args) : F.apply(that, args);
  };

  if (isObject$e(Prototype)) boundFunction.prototype = Prototype;
  return boundFunction;
};

var $$I = _export;
var bind$a = functionBind; // `Function.prototype.bind` method
// https://tc39.es/ecma262/#sec-function.prototype.bind

$$I({
  target: 'Function',
  proto: true,
  forced: Function.bind !== bind$a
}, {
  bind: bind$a
});

var path$u = path$y;

var entryVirtual$l = function (CONSTRUCTOR) {
  return path$u[CONSTRUCTOR + 'Prototype'];
};

var entryVirtual$k = entryVirtual$l;
var bind$9 = entryVirtual$k('Function').bind;

var isPrototypeOf$l = objectIsPrototypeOf;
var method$h = bind$9;
var FunctionPrototype$1 = Function.prototype;

var bind$8 = function (it) {
  var own = it.bind;
  return it === FunctionPrototype$1 || isPrototypeOf$l(FunctionPrototype$1, it) && own === FunctionPrototype$1.bind ? method$h : own;
};

var parent$19 = bind$8;
var bind$7 = parent$19;

var bind$6 = bind$7;

/**
 * Draw a circle.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - The radius of the circle.
 */
function drawCircle(ctx, x, y, r) {
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 2 * Math.PI, false);
  ctx.closePath();
}
/**
 * Draw a square.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the width and height of the square.
 */

function drawSquare(ctx, x, y, r) {
  ctx.beginPath();
  ctx.rect(x - r, y - r, r * 2, r * 2);
  ctx.closePath();
}
/**
 * Draw an equilateral triangle standing on a side.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the length of the sides.
 * @remarks
 * http://en.wikipedia.org/wiki/Equilateral_triangle
 */

function drawTriangle(ctx, x, y, r) {
  ctx.beginPath(); // the change in radius and the offset is here to center the shape

  r *= 1.15;
  y += 0.275 * r;
  var s = r * 2;
  var s2 = s / 2;
  var ir = Math.sqrt(3) / 6 * s; // radius of inner circle

  var h = Math.sqrt(s * s - s2 * s2); // height

  ctx.moveTo(x, y - (h - ir));
  ctx.lineTo(x + s2, y + ir);
  ctx.lineTo(x - s2, y + ir);
  ctx.lineTo(x, y - (h - ir));
  ctx.closePath();
}
/**
 * Draw an equilateral triangle standing on a vertex.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the length of the sides.
 * @remarks
 * http://en.wikipedia.org/wiki/Equilateral_triangle
 */

function drawTriangleDown(ctx, x, y, r) {
  ctx.beginPath(); // the change in radius and the offset is here to center the shape

  r *= 1.15;
  y -= 0.275 * r;
  var s = r * 2;
  var s2 = s / 2;
  var ir = Math.sqrt(3) / 6 * s; // radius of inner circle

  var h = Math.sqrt(s * s - s2 * s2); // height

  ctx.moveTo(x, y + (h - ir));
  ctx.lineTo(x + s2, y - ir);
  ctx.lineTo(x - s2, y - ir);
  ctx.lineTo(x, y + (h - ir));
  ctx.closePath();
}
/**
 * Draw a star.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - The outer radius of the star.
 */

function drawStar(ctx, x, y, r) {
  // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
  ctx.beginPath(); // the change in radius and the offset is here to center the shape

  r *= 0.82;
  y += 0.1 * r;

  for (var n = 0; n < 10; n++) {
    var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;
    ctx.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));
  }

  ctx.closePath();
}
/**
 * Draw a diamond.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the width and height of the diamond.
 * @remarks
 * http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
 */

function drawDiamond(ctx, x, y, r) {
  ctx.beginPath();
  ctx.lineTo(x, y + r);
  ctx.lineTo(x + r, y);
  ctx.lineTo(x, y - r);
  ctx.lineTo(x - r, y);
  ctx.closePath();
}
/**
 * Draw a rectangle with rounded corners.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param w - The width of the rectangle.
 * @param h - The height of the rectangle.
 * @param r - The radius of the corners.
 * @remarks
 * http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
 */

function drawRoundRect(ctx, x, y, w, h, r) {
  var r2d = Math.PI / 180;

  if (w - 2 * r < 0) {
    r = w / 2;
  } //ensure that the radius isn't too large for x


  if (h - 2 * r < 0) {
    r = h / 2;
  } //ensure that the radius isn't too large for y


  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);
  ctx.lineTo(x + w, y + h - r);
  ctx.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);
  ctx.lineTo(x + r, y + h);
  ctx.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);
  ctx.lineTo(x, y + r);
  ctx.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);
  ctx.closePath();
}
/**
 * Draw an ellipse.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param w - The width of the ellipse.
 * @param h - The height of the ellipse.
 * @remarks
 * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
 *
 * Postfix '_vis' added to discern it from standard method ellipse().
 */

function drawEllipse(ctx, x, y, w, h) {
  var kappa = 0.5522848,
      ox = w / 2 * kappa,
      // control point offset horizontal
  oy = h / 2 * kappa,
      // control point offset vertical
  xe = x + w,
      // x-end
  ye = y + h,
      // y-end
  xm = x + w / 2,
      // x-middle
  ym = y + h / 2; // y-middle

  ctx.beginPath();
  ctx.moveTo(x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  ctx.closePath();
}
/**
 * Draw an isometric cylinder.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param w - The width of the database.
 * @param h - The height of the database.
 * @remarks
 * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
 */

function drawDatabase(ctx, x, y, w, h) {
  var f = 1 / 3;
  var wEllipse = w;
  var hEllipse = h * f;
  var kappa = 0.5522848,
      ox = wEllipse / 2 * kappa,
      // control point offset horizontal
  oy = hEllipse / 2 * kappa,
      // control point offset vertical
  xe = x + wEllipse,
      // x-end
  ye = y + hEllipse,
      // y-end
  xm = x + wEllipse / 2,
      // x-middle
  ym = y + hEllipse / 2,
      // y-middle
  ymb = y + (h - hEllipse / 2),
      // y-midlle, bottom ellipse
  yeb = y + h; // y-end, bottom ellipse

  ctx.beginPath();
  ctx.moveTo(xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
  ctx.lineTo(xe, ymb);
  ctx.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);
  ctx.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);
  ctx.lineTo(x, ym);
}
/**
 * Draw a dashed line.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The start position on the x axis.
 * @param y - The start position on the y axis.
 * @param x2 - The end position on the x axis.
 * @param y2 - The end position on the y axis.
 * @param pattern - List of lengths starting with line and then alternating between space and line.
 * @author David Jordan
 * @remarks
 * date 2012-08-08
 * http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas
 */

function drawDashedLine(ctx, x, y, x2, y2, pattern) {
  ctx.beginPath();
  ctx.moveTo(x, y);
  var patternLength = pattern.length;
  var dx = x2 - x;
  var dy = y2 - y;
  var slope = dy / dx;
  var distRemaining = Math.sqrt(dx * dx + dy * dy);
  var patternIndex = 0;
  var draw = true;
  var xStep = 0;
  var dashLength = +pattern[0];

  while (distRemaining >= 0.1) {
    dashLength = +pattern[patternIndex++ % patternLength];

    if (dashLength > distRemaining) {
      dashLength = distRemaining;
    }

    xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
    xStep = dx < 0 ? -xStep : xStep;
    x += xStep;
    y += slope * xStep;

    if (draw === true) {
      ctx.lineTo(x, y);
    } else {
      ctx.moveTo(x, y);
    }

    distRemaining -= dashLength;
    draw = !draw;
  }
}
/**
 * Draw a hexagon.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - The radius of the hexagon.
 */

function drawHexagon(ctx, x, y, r) {
  ctx.beginPath();
  var sides = 6;
  var a = Math.PI * 2 / sides;
  ctx.moveTo(x + r, y);

  for (var i = 1; i < sides; i++) {
    ctx.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i));
  }

  ctx.closePath();
}
var shapeMap = {
  circle: drawCircle,
  dashedLine: drawDashedLine,
  database: drawDatabase,
  diamond: drawDiamond,
  ellipse: drawEllipse,
  ellipse_vis: drawEllipse,
  hexagon: drawHexagon,
  roundRect: drawRoundRect,
  square: drawSquare,
  star: drawStar,
  triangle: drawTriangle,
  triangleDown: drawTriangleDown
};
/**
 * Returns either custom or native drawing function base on supplied name.
 *
 * @param name - The name of the function. Either the name of a
 * CanvasRenderingContext2D property or an export from shapes.ts without the
 * draw prefix.
 * @returns The function that can be used for rendering. In case of native
 * CanvasRenderingContext2D function the API is normalized to
 * `(ctx: CanvasRenderingContext2D, ...originalArgs) => void`.
 */

function getShape(name) {
  if (Object.prototype.hasOwnProperty.call(shapeMap, name)) {
    return shapeMap[name];
  } else {
    return function (ctx) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      CanvasRenderingContext2D.prototype[name].call(ctx, args);
    };
  }
}

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$6 = ".vis-overlay {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n\n  /* Must be displayed above for example selected Timeline items */\n  z-index: 10;\n}\n\n.vis-active {\n  box-shadow: 0 0 10px #86d5f8;\n}\n";
styleInject(css_248z$6);

var css_248z$5 = "/* override some bootstrap styles screwing up the timelines css */\n\n.vis [class*=\"span\"] {\n  min-height: 0;\n  width: auto;\n}\n";
styleInject(css_248z$5);

var css_248z$4 = "div.vis-color-picker {\n  position: absolute;\n  top: 0px;\n  left: 30px;\n  margin-top: -140px;\n  margin-left: 30px;\n  width: 310px;\n  height: 444px;\n  z-index: 1;\n  padding: 10px;\n  border-radius: 15px;\n  background-color: #ffffff;\n  display: none;\n  box-shadow: rgba(0, 0, 0, 0.5) 0px 0px 10px 0px;\n}\n\ndiv.vis-color-picker div.vis-arrow {\n  position: absolute;\n  top: 147px;\n  left: 5px;\n}\n\ndiv.vis-color-picker div.vis-arrow::after,\ndiv.vis-color-picker div.vis-arrow::before {\n  right: 100%;\n  top: 50%;\n  border: solid transparent;\n  content: \" \";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\ndiv.vis-color-picker div.vis-arrow:after {\n  border-color: rgba(255, 255, 255, 0);\n  border-right-color: #ffffff;\n  border-width: 30px;\n  margin-top: -30px;\n}\n\ndiv.vis-color-picker div.vis-color {\n  position: absolute;\n  width: 289px;\n  height: 289px;\n  cursor: pointer;\n}\n\ndiv.vis-color-picker div.vis-brightness {\n  position: absolute;\n  top: 313px;\n}\n\ndiv.vis-color-picker div.vis-opacity {\n  position: absolute;\n  top: 350px;\n}\n\ndiv.vis-color-picker div.vis-selector {\n  position: absolute;\n  top: 137px;\n  left: 137px;\n  width: 15px;\n  height: 15px;\n  border-radius: 15px;\n  border: 1px solid #ffffff;\n  background: #4c4c4c; /* Old browsers */\n  background: -moz-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #4c4c4c),\n    color-stop(12%, #595959),\n    color-stop(25%, #666666),\n    color-stop(39%, #474747),\n    color-stop(50%, #2c2c2c),\n    color-stop(51%, #000000),\n    color-stop(60%, #111111),\n    color-stop(76%, #2b2b2b),\n    color-stop(91%, #1c1c1c),\n    color-stop(100%, #131313)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* IE10+ */\n  background: linear-gradient(\n    to bottom,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#4c4c4c', endColorstr='#131313',GradientType=0 ); /* IE6-9 */\n}\n\ndiv.vis-color-picker div.vis-new-color {\n  position: absolute;\n  width: 140px;\n  height: 20px;\n  border: 1px solid rgba(0, 0, 0, 0.1);\n  border-radius: 5px;\n  top: 380px;\n  left: 159px;\n  text-align: right;\n  padding-right: 2px;\n  font-size: 10px;\n  color: rgba(0, 0, 0, 0.4);\n  vertical-align: middle;\n  line-height: 20px;\n}\n\ndiv.vis-color-picker div.vis-initial-color {\n  position: absolute;\n  width: 140px;\n  height: 20px;\n  border: 1px solid rgba(0, 0, 0, 0.1);\n  border-radius: 5px;\n  top: 380px;\n  left: 10px;\n  text-align: left;\n  padding-left: 2px;\n  font-size: 10px;\n  color: rgba(0, 0, 0, 0.4);\n  vertical-align: middle;\n  line-height: 20px;\n}\n\ndiv.vis-color-picker div.vis-label {\n  position: absolute;\n  width: 300px;\n  left: 10px;\n}\n\ndiv.vis-color-picker div.vis-label.vis-brightness {\n  top: 300px;\n}\n\ndiv.vis-color-picker div.vis-label.vis-opacity {\n  top: 338px;\n}\n\ndiv.vis-color-picker div.vis-button {\n  position: absolute;\n  width: 68px;\n  height: 25px;\n  border-radius: 10px;\n  vertical-align: middle;\n  text-align: center;\n  line-height: 25px;\n  top: 410px;\n  border: 2px solid #d9d9d9;\n  background-color: #f7f7f7;\n  cursor: pointer;\n}\n\ndiv.vis-color-picker div.vis-button.vis-cancel {\n  /*border:2px solid #ff4e33;*/\n  /*background-color: #ff7761;*/\n  left: 5px;\n}\ndiv.vis-color-picker div.vis-button.vis-load {\n  /*border:2px solid #a153e6;*/\n  /*background-color: #cb8dff;*/\n  left: 82px;\n}\ndiv.vis-color-picker div.vis-button.vis-apply {\n  /*border:2px solid #4588e6;*/\n  /*background-color: #82b6ff;*/\n  left: 159px;\n}\ndiv.vis-color-picker div.vis-button.vis-save {\n  /*border:2px solid #45e655;*/\n  /*background-color: #6dff7c;*/\n  left: 236px;\n}\n\ndiv.vis-color-picker input.vis-range {\n  width: 290px;\n  height: 20px;\n}\n\n/* TODO: is this redundant?\ndiv.vis-color-picker input.vis-range-brightness {\n  width: 289px !important;\n}\n\n\ndiv.vis-color-picker input.vis-saturation-range {\n  width: 289px !important;\n}*/\n";
styleInject(css_248z$4);

var css_248z$3 = "div.vis-configuration {\n  position: relative;\n  display: block;\n  float: left;\n  font-size: 12px;\n}\n\ndiv.vis-configuration-wrapper {\n  display: block;\n  width: 700px;\n}\n\ndiv.vis-configuration-wrapper::after {\n  clear: both;\n  content: \"\";\n  display: block;\n}\n\ndiv.vis-configuration.vis-config-option-container {\n  display: block;\n  width: 495px;\n  background-color: #ffffff;\n  border: 2px solid #f7f8fa;\n  border-radius: 4px;\n  margin-top: 20px;\n  left: 10px;\n  padding-left: 5px;\n}\n\ndiv.vis-configuration.vis-config-button {\n  display: block;\n  width: 495px;\n  height: 25px;\n  vertical-align: middle;\n  line-height: 25px;\n  background-color: #f7f8fa;\n  border: 2px solid #ceced0;\n  border-radius: 4px;\n  margin-top: 20px;\n  left: 10px;\n  padding-left: 5px;\n  cursor: pointer;\n  margin-bottom: 30px;\n}\n\ndiv.vis-configuration.vis-config-button.hover {\n  background-color: #4588e6;\n  border: 2px solid #214373;\n  color: #ffffff;\n}\n\ndiv.vis-configuration.vis-config-item {\n  display: block;\n  float: left;\n  width: 495px;\n  height: 25px;\n  vertical-align: middle;\n  line-height: 25px;\n}\n\ndiv.vis-configuration.vis-config-item.vis-config-s2 {\n  left: 10px;\n  background-color: #f7f8fa;\n  padding-left: 5px;\n  border-radius: 3px;\n}\ndiv.vis-configuration.vis-config-item.vis-config-s3 {\n  left: 20px;\n  background-color: #e4e9f0;\n  padding-left: 5px;\n  border-radius: 3px;\n}\ndiv.vis-configuration.vis-config-item.vis-config-s4 {\n  left: 30px;\n  background-color: #cfd8e6;\n  padding-left: 5px;\n  border-radius: 3px;\n}\n\ndiv.vis-configuration.vis-config-header {\n  font-size: 18px;\n  font-weight: bold;\n}\n\ndiv.vis-configuration.vis-config-label {\n  width: 120px;\n  height: 25px;\n  line-height: 25px;\n}\n\ndiv.vis-configuration.vis-config-label.vis-config-s3 {\n  width: 110px;\n}\ndiv.vis-configuration.vis-config-label.vis-config-s4 {\n  width: 100px;\n}\n\ndiv.vis-configuration.vis-config-colorBlock {\n  top: 1px;\n  width: 30px;\n  height: 19px;\n  border: 1px solid #444444;\n  border-radius: 2px;\n  padding: 0px;\n  margin: 0px;\n  cursor: pointer;\n}\n\ninput.vis-configuration.vis-config-checkbox {\n  left: -5px;\n}\n\ninput.vis-configuration.vis-config-rangeinput {\n  position: relative;\n  top: -5px;\n  width: 60px;\n  /*height:13px;*/\n  padding: 1px;\n  margin: 0;\n  pointer-events: none;\n}\n\ninput.vis-configuration.vis-config-range {\n  /*removes default webkit styles*/\n  -webkit-appearance: none;\n\n  /*fix for FF unable to apply focus style bug */\n  border: 0px solid white;\n  background-color: rgba(0, 0, 0, 0);\n\n  /*required for proper track sizing in FF*/\n  width: 300px;\n  height: 20px;\n}\ninput.vis-configuration.vis-config-range::-webkit-slider-runnable-track {\n  width: 300px;\n  height: 5px;\n  background: #dedede; /* Old browsers */\n  background: -moz-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #dedede),\n    color-stop(99%, #c8c8c8)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* IE10+ */\n  background: linear-gradient(to bottom, #dedede 0%, #c8c8c8 99%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#dedede', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */\n\n  border: 1px solid #999999;\n  box-shadow: #aaaaaa 0px 0px 3px 0px;\n  border-radius: 3px;\n}\ninput.vis-configuration.vis-config-range::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  border: 1px solid #14334b;\n  height: 17px;\n  width: 17px;\n  border-radius: 50%;\n  background: #3876c2; /* Old browsers */\n  background: -moz-linear-gradient(top, #3876c2 0%, #385380 100%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #3876c2),\n    color-stop(100%, #385380)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #3876c2 0%,\n    #385380 100%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #3876c2 0%,\n    #385380 100%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #3876c2 0%, #385380 100%); /* IE10+ */\n  background: linear-gradient(to bottom, #3876c2 0%, #385380 100%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#3876c2', endColorstr='#385380',GradientType=0 ); /* IE6-9 */\n  box-shadow: #111927 0px 0px 1px 0px;\n  margin-top: -7px;\n}\ninput.vis-configuration.vis-config-range:focus {\n  outline: none;\n}\ninput.vis-configuration.vis-config-range:focus::-webkit-slider-runnable-track {\n  background: #9d9d9d; /* Old browsers */\n  background: -moz-linear-gradient(top, #9d9d9d 0%, #c8c8c8 99%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #9d9d9d),\n    color-stop(99%, #c8c8c8)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #9d9d9d 0%,\n    #c8c8c8 99%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #9d9d9d 0%,\n    #c8c8c8 99%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #9d9d9d 0%, #c8c8c8 99%); /* IE10+ */\n  background: linear-gradient(to bottom, #9d9d9d 0%, #c8c8c8 99%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#9d9d9d', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */\n}\n\ninput.vis-configuration.vis-config-range::-moz-range-track {\n  width: 300px;\n  height: 10px;\n  background: #dedede; /* Old browsers */\n  background: -moz-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #dedede),\n    color-stop(99%, #c8c8c8)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* IE10+ */\n  background: linear-gradient(to bottom, #dedede 0%, #c8c8c8 99%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#dedede', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */\n\n  border: 1px solid #999999;\n  box-shadow: #aaaaaa 0px 0px 3px 0px;\n  border-radius: 3px;\n}\ninput.vis-configuration.vis-config-range::-moz-range-thumb {\n  border: none;\n  height: 16px;\n  width: 16px;\n\n  border-radius: 50%;\n  background: #385380;\n}\n\n/*hide the outline behind the border*/\ninput.vis-configuration.vis-config-range:-moz-focusring {\n  outline: 1px solid white;\n  outline-offset: -1px;\n}\n\ninput.vis-configuration.vis-config-range::-ms-track {\n  width: 300px;\n  height: 5px;\n\n  /*remove bg colour from the track, we'll use ms-fill-lower and ms-fill-upper instead */\n  background: transparent;\n\n  /*leave room for the larger thumb to overflow with a transparent border */\n  border-color: transparent;\n  border-width: 6px 0;\n\n  /*remove default tick marks*/\n  color: transparent;\n}\ninput.vis-configuration.vis-config-range::-ms-fill-lower {\n  background: #777;\n  border-radius: 10px;\n}\ninput.vis-configuration.vis-config-range::-ms-fill-upper {\n  background: #ddd;\n  border-radius: 10px;\n}\ninput.vis-configuration.vis-config-range::-ms-thumb {\n  border: none;\n  height: 16px;\n  width: 16px;\n  border-radius: 50%;\n  background: #385380;\n}\ninput.vis-configuration.vis-config-range:focus::-ms-fill-lower {\n  background: #888;\n}\ninput.vis-configuration.vis-config-range:focus::-ms-fill-upper {\n  background: #ccc;\n}\n\n.vis-configuration-popup {\n  position: absolute;\n  background: rgba(57, 76, 89, 0.85);\n  border: 2px solid #f2faff;\n  line-height: 30px;\n  height: 30px;\n  width: 150px;\n  text-align: center;\n  color: #ffffff;\n  font-size: 14px;\n  border-radius: 4px;\n  -webkit-transition: opacity 0.3s ease-in-out;\n  -moz-transition: opacity 0.3s ease-in-out;\n  transition: opacity 0.3s ease-in-out;\n}\n.vis-configuration-popup:after,\n.vis-configuration-popup:before {\n  left: 100%;\n  top: 50%;\n  border: solid transparent;\n  content: \" \";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.vis-configuration-popup:after {\n  border-color: rgba(136, 183, 213, 0);\n  border-left-color: rgba(57, 76, 89, 0.85);\n  border-width: 8px;\n  margin-top: -8px;\n}\n.vis-configuration-popup:before {\n  border-color: rgba(194, 225, 245, 0);\n  border-left-color: #f2faff;\n  border-width: 12px;\n  margin-top: -12px;\n}\n";
styleInject(css_248z$3);

var css_248z$2 = "div.vis-tooltip {\n  position: absolute;\n  visibility: hidden;\n  padding: 5px;\n  white-space: nowrap;\n\n  font-family: verdana;\n  font-size: 14px;\n  color: #000000;\n  background-color: #f5f4ed;\n\n  -moz-border-radius: 3px;\n  -webkit-border-radius: 3px;\n  border-radius: 3px;\n  border: 1px solid #808074;\n\n  box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\n  pointer-events: none;\n\n  z-index: 5;\n}\n";
styleInject(css_248z$2);

var componentEmitter = {exports: {}};

(function (module) {
  /**
   * Expose `Emitter`.
   */
  {
    module.exports = Emitter;
  }
  /**
   * Initialize a new `Emitter`.
   *
   * @api public
   */


  function Emitter(obj) {
    if (obj) return mixin(obj);
  }
  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }

    return obj;
  }
  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
    return this;
  };
  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.once = function (event, fn) {
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }

    on.fn = fn;
    this.on(event, on);
    return this;
  };
  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {}; // all

    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    } // specific event


    var callbacks = this._callbacks['$' + event];
    if (!callbacks) return this; // remove all handlers

    if (1 == arguments.length) {
      delete this._callbacks['$' + event];
      return this;
    } // remove specific handler


    var cb;

    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];

      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    } // Remove event specific arrays for event types that no
    // one is subscribed for to avoid memory leak.


    if (callbacks.length === 0) {
      delete this._callbacks['$' + event];
    }

    return this;
  };
  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */


  Emitter.prototype.emit = function (event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1),
        callbacks = this._callbacks['$' + event];

    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }

    if (callbacks) {
      callbacks = callbacks.slice(0);

      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  };
  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */


  Emitter.prototype.listeners = function (event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks['$' + event] || [];
  };
  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */


  Emitter.prototype.hasListeners = function (event) {
    return !!this.listeners(event).length;
  };
})(componentEmitter);

var Emitter = componentEmitter.exports;

var wellKnownSymbol$h = wellKnownSymbol$j;
var TO_STRING_TAG$3 = wellKnownSymbol$h('toStringTag');
var test$2 = {};
test$2[TO_STRING_TAG$3] = 'z';
var toStringTagSupport = String(test$2) === '[object z]';

var global$w = global$P;
var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
var isCallable$9 = isCallable$h;
var classofRaw = classofRaw$1;
var wellKnownSymbol$g = wellKnownSymbol$j;
var TO_STRING_TAG$2 = wellKnownSymbol$g('toStringTag');
var Object$7 = global$w.Object; // ES3 wrong here

var CORRECT_ARGUMENTS = classofRaw(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) {
    /* empty */
  }
}; // getting tag from ES6+ `Object.prototype.toString`


var classof$e = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (tag = tryGet(O = Object$7(it), TO_STRING_TAG$2)) == 'string' ? tag // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && isCallable$9(O.callee) ? 'Arguments' : result;
};

var global$v = global$P;
var classof$d = classof$e;
var String$2 = global$v.String;

var toString$8 = function (argument) {
  if (classof$d(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return String$2(argument);
};

var uncurryThis$k = functionUncurryThis;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
var toString$7 = toString$8;
var requireObjectCoercible$2 = requireObjectCoercible$5;
var charAt$3 = uncurryThis$k(''.charAt);
var charCodeAt$1 = uncurryThis$k(''.charCodeAt);
var stringSlice = uncurryThis$k(''.slice);

var createMethod$4 = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString$7(requireObjectCoercible$2($this));
    var position = toIntegerOrInfinity$1(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt$1(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt$1(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt$3(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$4(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$4(true)
};

var uncurryThis$j = functionUncurryThis;
var isCallable$8 = isCallable$h;
var store$1 = sharedStore;
var functionToString = uncurryThis$j(Function.toString); // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper

if (!isCallable$8(store$1.inspectSource)) {
  store$1.inspectSource = function (it) {
    return functionToString(it);
  };
}

var inspectSource$2 = store$1.inspectSource;

var global$u = global$P;
var isCallable$7 = isCallable$h;
var inspectSource$1 = inspectSource$2;
var WeakMap$1 = global$u.WeakMap;
var nativeWeakMap = isCallable$7(WeakMap$1) && /native code/.test(inspectSource$1(WeakMap$1));

var shared$2 = shared$4.exports;
var uid$2 = uid$4;
var keys$7 = shared$2('keys');

var sharedKey$4 = function (key) {
  return keys$7[key] || (keys$7[key] = uid$2(key));
};

var NATIVE_WEAK_MAP$1 = nativeWeakMap;
var global$t = global$P;
var uncurryThis$i = functionUncurryThis;
var isObject$d = isObject$j;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
var hasOwn$c = hasOwnProperty_1;
var shared$1 = sharedStore;
var sharedKey$3 = sharedKey$4;
var hiddenKeys$4 = hiddenKeys$6;
var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError$d = global$t.TypeError;
var WeakMap = global$t.WeakMap;
var set$3, get$6, has;

var enforce = function (it) {
  return has(it) ? get$6(it) : set$3(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;

    if (!isObject$d(it) || (state = get$6(it)).type !== TYPE) {
      throw TypeError$d('Incompatible receiver, ' + TYPE + ' required');
    }

    return state;
  };
};

if (NATIVE_WEAK_MAP$1 || shared$1.state) {
  var store = shared$1.state || (shared$1.state = new WeakMap());
  var wmget = uncurryThis$i(store.get);
  var wmhas = uncurryThis$i(store.has);
  var wmset = uncurryThis$i(store.set);

  set$3 = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError$d(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };

  get$6 = function (it) {
    return wmget(store, it) || {};
  };

  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey$3('state');
  hiddenKeys$4[STATE] = true;

  set$3 = function (it, metadata) {
    if (hasOwn$c(it, STATE)) throw new TypeError$d(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$4(it, STATE, metadata);
    return metadata;
  };

  get$6 = function (it) {
    return hasOwn$c(it, STATE) ? it[STATE] : {};
  };

  has = function (it) {
    return hasOwn$c(it, STATE);
  };
}

var internalState = {
  set: set$3,
  get: get$6,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

var DESCRIPTORS$b = descriptors;
var hasOwn$b = hasOwnProperty_1;
var FunctionPrototype = Function.prototype; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

var getDescriptor = DESCRIPTORS$b && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$b(FunctionPrototype, 'name'); // additional protection from minified / mangled / dropped function names

var PROPER = EXISTS && function something() {
  /* empty */
}.name === 'something';

var CONFIGURABLE = EXISTS && (!DESCRIPTORS$b || DESCRIPTORS$b && getDescriptor(FunctionPrototype, 'name').configurable);
var functionName = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};

var objectDefineProperties = {};

var DESCRIPTORS$a = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$3 = objectDefineProperty;
var anObject$b = anObject$d;
var toIndexedObject$7 = toIndexedObject$b;
var objectKeys$2 = objectKeys$4; // `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe

objectDefineProperties.f = DESCRIPTORS$a && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$b(O);
  var props = toIndexedObject$7(Properties);
  var keys = objectKeys$2(Properties);
  var length = keys.length;
  var index = 0;
  var key;

  while (length > index) definePropertyModule$3.f(O, key = keys[index++], props[key]);

  return O;
};

var getBuiltIn$6 = getBuiltIn$9;
var html$1 = getBuiltIn$6('document', 'documentElement');

/* global ActiveXObject -- old IE, WSH */
var anObject$a = anObject$d;
var definePropertiesModule$1 = objectDefineProperties;
var enumBugKeys$1 = enumBugKeys$3;
var hiddenKeys$3 = hiddenKeys$6;
var html = html$1;
var documentCreateElement = documentCreateElement$1;
var sharedKey$2 = sharedKey$4;
var GT = '>';
var LT = '<';
var PROTOTYPE$1 = 'prototype';
var SCRIPT = 'script';
var IE_PROTO$1 = sharedKey$2('IE_PROTO');

var EmptyConstructor = function () {
  /* empty */
};

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
}; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak

  return temp;
}; // Create object with fake `null` prototype: use iframe Object with cleared prototype


var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
}; // Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug


var activeXDocument;

var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) {
    /* ignore */
  }

  NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE
  : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH

  var length = enumBugKeys$1.length;

  while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys$1[length]];

  return NullProtoObject();
};

hiddenKeys$3[IE_PROTO$1] = true; // `Object.create` method
// https://tc39.es/ecma262/#sec-object.create

var objectCreate = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    EmptyConstructor[PROTOTYPE$1] = anObject$a(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE$1] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO$1] = O;
  } else result = NullProtoObject();

  return Properties === undefined ? result : definePropertiesModule$1.f(result, Properties);
};

var fails$k = fails$t;
var correctPrototypeGetter = !fails$k(function () {
  function F() {
    /* empty */
  }

  F.prototype.constructor = null; // eslint-disable-next-line es/no-object-getprototypeof -- required for testing

  return Object.getPrototypeOf(new F()) !== F.prototype;
});

var global$s = global$P;
var hasOwn$a = hasOwnProperty_1;
var isCallable$6 = isCallable$h;
var toObject$b = toObject$e;
var sharedKey$1 = sharedKey$4;
var CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter;
var IE_PROTO = sharedKey$1('IE_PROTO');
var Object$6 = global$s.Object;
var ObjectPrototype$2 = Object$6.prototype; // `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof

var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER$1 ? Object$6.getPrototypeOf : function (O) {
  var object = toObject$b(O);
  if (hasOwn$a(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;

  if (isCallable$6(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }

  return object instanceof Object$6 ? ObjectPrototype$2 : null;
};

var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;

var redefine$4 = function (target, key, value, options) {
  if (options && options.enumerable) target[key] = value;else createNonEnumerableProperty$3(target, key, value);
};

var fails$j = fails$t;
var isCallable$5 = isCallable$h;
var create$a = objectCreate;
var getPrototypeOf$8 = objectGetPrototypeOf;
var redefine$3 = redefine$4;
var wellKnownSymbol$f = wellKnownSymbol$j;
var ITERATOR$6 = wellKnownSymbol$f('iterator');
var BUGGY_SAFARI_ITERATORS$1 = false; // `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object

var IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;
/* eslint-disable es/no-array-prototype-keys -- safe */

if ([].keys) {
  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$8(getPrototypeOf$8(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$1 == undefined || fails$j(function () {
  var test = {}; // FF44- legacy iterators case

  return IteratorPrototype$1[ITERATOR$6].call(test) !== test;
});
if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$1 = {};else IteratorPrototype$1 = create$a(IteratorPrototype$1); // `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator

if (!isCallable$5(IteratorPrototype$1[ITERATOR$6])) {
  redefine$3(IteratorPrototype$1, ITERATOR$6, function () {
    return this;
  });
}

var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$1,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};

var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
var classof$c = classof$e; // `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring

var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {
  return '[object ' + classof$c(this) + ']';
};

var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var defineProperty$c = objectDefineProperty.f;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;
var hasOwn$9 = hasOwnProperty_1;
var toString$6 = objectToString;
var wellKnownSymbol$e = wellKnownSymbol$j;
var TO_STRING_TAG$1 = wellKnownSymbol$e('toStringTag');

var setToStringTag$5 = function (it, TAG, STATIC, SET_METHOD) {
  if (it) {
    var target = STATIC ? it : it.prototype;

    if (!hasOwn$9(target, TO_STRING_TAG$1)) {
      defineProperty$c(target, TO_STRING_TAG$1, {
        configurable: true,
        value: TAG
      });
    }

    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
      createNonEnumerableProperty$2(target, 'toString', toString$6);
    }
  }
};

var iterators = {};

var IteratorPrototype = iteratorsCore.IteratorPrototype;
var create$9 = objectCreate;
var createPropertyDescriptor$2 = createPropertyDescriptor$5;
var setToStringTag$4 = setToStringTag$5;
var Iterators$5 = iterators;

var returnThis$1 = function () {
  return this;
};

var createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create$9(IteratorPrototype, {
    next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next)
  });
  setToStringTag$4(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators$5[TO_STRING_TAG] = returnThis$1;
  return IteratorConstructor;
};

var global$r = global$P;
var isCallable$4 = isCallable$h;
var String$1 = global$r.String;
var TypeError$c = global$r.TypeError;

var aPossiblePrototype$1 = function (argument) {
  if (typeof argument == 'object' || isCallable$4(argument)) return argument;
  throw TypeError$c("Can't set " + String$1(argument) + ' as a prototype');
};

/* eslint-disable no-proto -- safe */
var uncurryThis$h = functionUncurryThis;
var anObject$9 = anObject$d;
var aPossiblePrototype = aPossiblePrototype$1; // `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe

var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;

  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    setter = uncurryThis$h(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) {
    /* empty */
  }

  return function setPrototypeOf(O, proto) {
    anObject$9(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);else O.__proto__ = proto;
    return O;
  };
}() : undefined);

var $$H = _export;
var call$6 = functionCall;
var FunctionName = functionName;
var createIteratorConstructor = createIteratorConstructor$1;
var getPrototypeOf$7 = objectGetPrototypeOf;
var setToStringTag$3 = setToStringTag$5;
var redefine$2 = redefine$4;
var wellKnownSymbol$d = wellKnownSymbol$j;
var Iterators$4 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$5 = wellKnownSymbol$d('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () {
  return this;
};

var defineIterator$3 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS:
        return function keys() {
          return new IteratorConstructor(this, KIND);
        };

      case VALUES:
        return function values() {
          return new IteratorConstructor(this, KIND);
        };

      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }

    return function () {
      return new IteratorConstructor(this);
    };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$5] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY; // fix native

  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf$7(anyNativeIterator.call(new Iterable()));

    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {


      setToStringTag$3(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      Iterators$4[TO_STRING_TAG] = returnThis;
    }
  } // fix Array.prototype.{ values, @@iterator }.name in V8 / FF


  if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    {
      INCORRECT_VALUES_NAME = true;

      defaultIterator = function values() {
        return call$6(nativeIterator, this);
      };
    }
  } // export additional methods


  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine$2(IterablePrototype, KEY, methods[KEY]);
      }
    } else $$H({
      target: NAME,
      proto: true,
      forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
    }, methods);
  } // define iterator


  if ((FORCED) && IterablePrototype[ITERATOR$5] !== defaultIterator) {
    redefine$2(IterablePrototype, ITERATOR$5, defaultIterator, {
      name: DEFAULT
    });
  }

  Iterators$4[NAME] = defaultIterator;
  return methods;
};

var charAt$2 = stringMultibyte.charAt;
var toString$5 = toString$8;
var InternalStateModule$5 = internalState;
var defineIterator$2 = defineIterator$3;
var STRING_ITERATOR = 'String Iterator';
var setInternalState$5 = InternalStateModule$5.set;
var getInternalState$2 = InternalStateModule$5.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator

defineIterator$2(String, 'String', function (iterated) {
  setInternalState$5(this, {
    type: STRING_ITERATOR,
    string: toString$5(iterated),
    index: 0
  }); // `%StringIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState$2(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return {
    value: undefined,
    done: true
  };
  point = charAt$2(string, index);
  state.index += point.length;
  return {
    value: point,
    done: false
  };
});

var call$5 = functionCall;
var anObject$8 = anObject$d;
var getMethod$1 = getMethod$3;

var iteratorClose$2 = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject$8(iterator);

  try {
    innerResult = getMethod$1(iterator, 'return');

    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }

    innerResult = call$5(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }

  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject$8(innerResult);
  return value;
};

var anObject$7 = anObject$d;
var iteratorClose$1 = iteratorClose$2; // call something on iterator step with safe closing on error

var callWithSafeIterationClosing$1 = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject$7(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose$1(iterator, 'throw', error);
  }
};

var wellKnownSymbol$c = wellKnownSymbol$j;
var Iterators$3 = iterators;
var ITERATOR$4 = wellKnownSymbol$c('iterator');
var ArrayPrototype$i = Array.prototype; // check on default Array iterator

var isArrayIteratorMethod$2 = function (it) {
  return it !== undefined && (Iterators$3.Array === it || ArrayPrototype$i[ITERATOR$4] === it);
};

var uncurryThis$g = functionUncurryThis;
var fails$i = fails$t;
var isCallable$3 = isCallable$h;
var classof$b = classof$e;
var getBuiltIn$5 = getBuiltIn$9;
var inspectSource = inspectSource$2;

var noop = function () {
  /* empty */
};

var empty = [];
var construct$3 = getBuiltIn$5('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$2 = uncurryThis$g(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$3(argument)) return false;

  try {
    construct$3(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable$3(argument)) return false;

  switch (classof$b(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction':
      return false;
  }

  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true; // `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor

var isConstructor$4 = !construct$3 || fails$i(function () {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;

var toPropertyKey$1 = toPropertyKey$4;
var definePropertyModule$2 = objectDefineProperty;
var createPropertyDescriptor$1 = createPropertyDescriptor$5;

var createProperty$6 = function (object, key, value) {
  var propertyKey = toPropertyKey$1(key);
  if (propertyKey in object) definePropertyModule$2.f(object, propertyKey, createPropertyDescriptor$1(0, value));else object[propertyKey] = value;
};

var classof$a = classof$e;
var getMethod = getMethod$3;
var Iterators$2 = iterators;
var wellKnownSymbol$b = wellKnownSymbol$j;
var ITERATOR$3 = wellKnownSymbol$b('iterator');

var getIteratorMethod$8 = function (it) {
  if (it != undefined) return getMethod(it, ITERATOR$3) || getMethod(it, '@@iterator') || Iterators$2[classof$a(it)];
};

var global$q = global$P;
var call$4 = functionCall;
var aCallable$3 = aCallable$7;
var anObject$6 = anObject$d;
var tryToString$2 = tryToString$4;
var getIteratorMethod$7 = getIteratorMethod$8;
var TypeError$b = global$q.TypeError;

var getIterator$7 = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$7(argument) : usingIterator;
  if (aCallable$3(iteratorMethod)) return anObject$6(call$4(iteratorMethod, argument));
  throw TypeError$b(tryToString$2(argument) + ' is not iterable');
};

var global$p = global$P;
var bind$5 = functionBindContext;
var call$3 = functionCall;
var toObject$a = toObject$e;
var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
var isArrayIteratorMethod$1 = isArrayIteratorMethod$2;
var isConstructor$3 = isConstructor$4;
var lengthOfArrayLike$b = lengthOfArrayLike$d;
var createProperty$5 = createProperty$6;
var getIterator$6 = getIterator$7;
var getIteratorMethod$6 = getIteratorMethod$8;
var Array$5 = global$p.Array; // `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from

var arrayFrom = function from(arrayLike
/* , mapfn = undefined, thisArg = undefined */
) {
  var O = toObject$a(arrayLike);
  var IS_CONSTRUCTOR = isConstructor$3(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  if (mapping) mapfn = bind$5(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
  var iteratorMethod = getIteratorMethod$6(O);
  var index = 0;
  var length, result, step, iterator, next, value; // if the target is not iterable or it's an array with the default iterator - use a simple case

  if (iteratorMethod && !(this == Array$5 && isArrayIteratorMethod$1(iteratorMethod))) {
    iterator = getIterator$6(O, iteratorMethod);
    next = iterator.next;
    result = IS_CONSTRUCTOR ? new this() : [];

    for (; !(step = call$3(next, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty$5(result, index, value);
    }
  } else {
    length = lengthOfArrayLike$b(O);
    result = IS_CONSTRUCTOR ? new this(length) : Array$5(length);

    for (; length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty$5(result, index, value);
    }
  }

  result.length = index;
  return result;
};

var wellKnownSymbol$a = wellKnownSymbol$j;
var ITERATOR$2 = wellKnownSymbol$a('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return {
        done: !!called++
      };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };

  iteratorWithReturn[ITERATOR$2] = function () {
    return this;
  }; // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing


  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {
  /* empty */
}

var checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;

  try {
    var object = {};

    object[ITERATOR$2] = function () {
      return {
        next: function () {
          return {
            done: ITERATION_SUPPORT = true
          };
        }
      };
    };

    exec(object);
  } catch (error) {
    /* empty */
  }

  return ITERATION_SUPPORT;
};

var $$G = _export;
var from$6 = arrayFrom;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  // eslint-disable-next-line es/no-array-from -- required for testing
  Array.from(iterable);
}); // `Array.from` method
// https://tc39.es/ecma262/#sec-array.from

$$G({
  target: 'Array',
  stat: true,
  forced: INCORRECT_ITERATION
}, {
  from: from$6
});

var path$t = path$y;
var from$5 = path$t.Array.from;

var parent$18 = from$5;
var from$4 = parent$18;

var from$3 = from$4;

var toIndexedObject$6 = toIndexedObject$b;
var Iterators$1 = iterators;
var InternalStateModule$4 = internalState;
objectDefineProperty.f;
var defineIterator$1 = defineIterator$3;
var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState$4 = InternalStateModule$4.set;
var getInternalState$1 = InternalStateModule$4.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator

defineIterator$1(Array, 'Array', function (iterated, kind) {
  setInternalState$4(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject$6(iterated),
    // target
    index: 0,
    // next index
    kind: kind // kind

  }); // `%ArrayIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState$1(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;

  if (!target || index >= target.length) {
    state.target = undefined;
    return {
      value: undefined,
      done: true
    };
  }

  if (kind == 'keys') return {
    value: index,
    done: false
  };
  if (kind == 'values') return {
    value: target[index],
    done: false
  };
  return {
    value: [index, target[index]],
    done: false
  };
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject

Iterators$1.Arguments = Iterators$1.Array; // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

var getIteratorMethod$5 = getIteratorMethod$8;
var getIteratorMethod_1 = getIteratorMethod$5;

// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods

var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

var DOMIterables$4 = domIterables;
var global$o = global$P;
var classof$9 = classof$e;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;
var Iterators = iterators;
var wellKnownSymbol$9 = wellKnownSymbol$j;
var TO_STRING_TAG = wellKnownSymbol$9('toStringTag');

for (var COLLECTION_NAME in DOMIterables$4) {
  var Collection = global$o[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;

  if (CollectionPrototype && classof$9(CollectionPrototype) !== TO_STRING_TAG) {
    createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
  }

  Iterators[COLLECTION_NAME] = Iterators.Array;
}

var parent$17 = getIteratorMethod_1;
var getIteratorMethod$4 = parent$17;

var parent$16 = getIteratorMethod$4;
var getIteratorMethod$3 = parent$16;

var parent$15 = getIteratorMethod$3;
var getIteratorMethod$2 = parent$15;

var getIteratorMethod$1 = getIteratorMethod$2;

var classof$8 = classofRaw$1; // `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe

var isArray$d = Array.isArray || function isArray(argument) {
  return classof$8(argument) == 'Array';
};

var objectGetOwnPropertyNames = {};

var internalObjectKeys = objectKeysInternal;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys$2 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe

objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys$2);
};

var objectGetOwnPropertyNamesExternal = {};

var global$n = global$P;
var toAbsoluteIndex$3 = toAbsoluteIndex$5;
var lengthOfArrayLike$a = lengthOfArrayLike$d;
var createProperty$4 = createProperty$6;
var Array$4 = global$n.Array;
var max$2 = Math.max;

var arraySliceSimple = function (O, start, end) {
  var length = lengthOfArrayLike$a(O);
  var k = toAbsoluteIndex$3(start, length);
  var fin = toAbsoluteIndex$3(end === undefined ? length : end, length);
  var result = Array$4(max$2(fin - k, 0));

  for (var n = 0; k < fin; k++, n++) createProperty$4(result, n, O[k]);

  result.length = n;
  return result;
};

/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof$7 = classofRaw$1;
var toIndexedObject$5 = toIndexedObject$b;
var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var arraySlice$3 = arraySliceSimple;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames$1(it);
  } catch (error) {
    return arraySlice$3(windowNames);
  }
}; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
  return windowNames && classof$7(it) == 'Window' ? getWindowNames(it) : $getOwnPropertyNames$1(toIndexedObject$5(it));
};

var wellKnownSymbolWrapped = {};

var wellKnownSymbol$8 = wellKnownSymbol$j;
wellKnownSymbolWrapped.f = wellKnownSymbol$8;

var path$s = path$y;
var hasOwn$8 = hasOwnProperty_1;
var wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
var defineProperty$b = objectDefineProperty.f;

var defineWellKnownSymbol$l = function (NAME) {
  var Symbol = path$s.Symbol || (path$s.Symbol = {});
  if (!hasOwn$8(Symbol, NAME)) defineProperty$b(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule$1.f(NAME)
  });
};

var global$m = global$P;
var isArray$c = isArray$d;
var isConstructor$2 = isConstructor$4;
var isObject$c = isObject$j;
var wellKnownSymbol$7 = wellKnownSymbol$j;
var SPECIES$3 = wellKnownSymbol$7('species');
var Array$3 = global$m.Array; // a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate

var arraySpeciesConstructor$1 = function (originalArray) {
  var C;

  if (isArray$c(originalArray)) {
    C = originalArray.constructor; // cross-realm fallback

    if (isConstructor$2(C) && (C === Array$3 || isArray$c(C.prototype))) C = undefined;else if (isObject$c(C)) {
      C = C[SPECIES$3];
      if (C === null) C = undefined;
    }
  }

  return C === undefined ? Array$3 : C;
};

var arraySpeciesConstructor = arraySpeciesConstructor$1; // `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate

var arraySpeciesCreate$4 = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};

var bind$4 = functionBindContext;
var uncurryThis$f = functionUncurryThis;
var IndexedObject$1 = indexedObject;
var toObject$9 = toObject$e;
var lengthOfArrayLike$9 = lengthOfArrayLike$d;
var arraySpeciesCreate$3 = arraySpeciesCreate$4;
var push$4 = uncurryThis$f([].push); // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation

var createMethod$3 = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject$9($this);
    var self = IndexedObject$1(O);
    var boundFunction = bind$4(callbackfn, that);
    var length = lengthOfArrayLike$9(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate$3;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;

    for (; length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);

      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3:
            return true;
          // some

          case 5:
            return value;
          // find

          case 6:
            return index;
          // findIndex

          case 2:
            push$4(target, value);
          // filter
        } else switch (TYPE) {
          case 4:
            return false;
          // every

          case 7:
            push$4(target, value);
          // filterReject
        }
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$3(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod$3(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod$3(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod$3(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod$3(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod$3(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$3(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod$3(7)
};

var $$F = _export;
var global$l = global$P;
var getBuiltIn$4 = getBuiltIn$9;
var apply$4 = functionApply;
var call$2 = functionCall;
var uncurryThis$e = functionUncurryThis;
var DESCRIPTORS$9 = descriptors;
var NATIVE_SYMBOL = nativeSymbol;
var fails$h = fails$t;
var hasOwn$7 = hasOwnProperty_1;
var isArray$b = isArray$d;
var isCallable$2 = isCallable$h;
var isObject$b = isObject$j;
var isPrototypeOf$k = objectIsPrototypeOf;
var isSymbol = isSymbol$3;
var anObject$5 = anObject$d;
var toObject$8 = toObject$e;
var toIndexedObject$4 = toIndexedObject$b;
var toPropertyKey = toPropertyKey$4;
var $toString = toString$8;
var createPropertyDescriptor = createPropertyDescriptor$5;
var nativeObjectCreate = objectCreate;
var objectKeys$1 = objectKeys$4;
var getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var getOwnPropertyDescriptorModule$2 = objectGetOwnPropertyDescriptor;
var definePropertyModule$1 = objectDefineProperty;
var definePropertiesModule = objectDefineProperties;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var arraySlice$2 = arraySlice$5;
var redefine$1 = redefine$4;
var shared = shared$4.exports;
var sharedKey = sharedKey$4;
var hiddenKeys$1 = hiddenKeys$6;
var uid$1 = uid$4;
var wellKnownSymbol$6 = wellKnownSymbol$j;
var wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var defineWellKnownSymbol$k = defineWellKnownSymbol$l;
var setToStringTag$2 = setToStringTag$5;
var InternalStateModule$3 = internalState;
var $forEach$1 = arrayIteration.forEach;
var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol$6('toPrimitive');
var setInternalState$3 = InternalStateModule$3.set;
var getInternalState = InternalStateModule$3.getterFor(SYMBOL);
var ObjectPrototype$1 = Object[PROTOTYPE];
var $Symbol = global$l.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var TypeError$a = global$l.TypeError;
var QObject = global$l.QObject;
var $stringify$1 = getBuiltIn$4('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor$1 = getOwnPropertyDescriptorModule$2.f;
var nativeDefineProperty = definePropertyModule$1.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push$3 = uncurryThis$e([].push);
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks'); // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDescriptor = DESCRIPTORS$9 && fails$h(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () {
      return nativeDefineProperty(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype$1, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype$1[P];
  nativeDefineProperty(O, P, Attributes);

  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$1) {
    nativeDefineProperty(ObjectPrototype$1, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap$1 = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState$3(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS$9) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype$1) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject$5(O);
  var key = toPropertyKey(P);
  anObject$5(Attributes);

  if (hasOwn$7(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn$7(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn$7(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, {
        enumerable: createPropertyDescriptor(0, false)
      });
    }

    return setSymbolDescriptor(O, key, Attributes);
  }

  return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject$5(O);
  var properties = toIndexedObject$4(Properties);
  var keys = objectKeys$1(properties).concat($getOwnPropertySymbols(properties));
  $forEach$1(keys, function (key) {
    if (!DESCRIPTORS$9 || call$2($propertyIsEnumerable$1, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable$1 = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call$2(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype$1 && hasOwn$7(AllSymbols, P) && !hasOwn$7(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn$7(this, P) || !hasOwn$7(AllSymbols, P) || hasOwn$7(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject$4(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype$1 && hasOwn$7(AllSymbols, key) && !hasOwn$7(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);

  if (descriptor && hasOwn$7(AllSymbols, key) && !(hasOwn$7(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }

  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject$4(O));
  var result = [];
  $forEach$1(names, function (key) {
    if (!hasOwn$7(AllSymbols, key) && !hasOwn$7(hiddenKeys$1, key)) push$3(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$1;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$4(O));
  var result = [];
  $forEach$1(names, function (key) {
    if (hasOwn$7(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$7(ObjectPrototype$1, key))) {
      push$3(result, AllSymbols[key]);
    }
  });
  return result;
}; // `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor


if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf$k(SymbolPrototype, this)) throw TypeError$a('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid$1(description);

    var setter = function (value) {
      if (this === ObjectPrototype$1) call$2(setter, ObjectPrototypeSymbols, value);
      if (hasOwn$7(this, HIDDEN) && hasOwn$7(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };

    if (DESCRIPTORS$9 && USE_SETTER) setSymbolDescriptor(ObjectPrototype$1, tag, {
      configurable: true,
      set: setter
    });
    return wrap$1(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];
  redefine$1(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });
  redefine$1($Symbol, 'withoutSetter', function (description) {
    return wrap$1(uid$1(description), description);
  });
  propertyIsEnumerableModule.f = $propertyIsEnumerable$1;
  definePropertyModule$1.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule$2.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule$2.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule$1.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap$1(wellKnownSymbol$6(name), name);
  };

  if (DESCRIPTORS$9) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
  }
}

$$F({
  global: true,
  wrap: true,
  forced: !NATIVE_SYMBOL,
  sham: !NATIVE_SYMBOL
}, {
  Symbol: $Symbol
});
$forEach$1(objectKeys$1(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol$k(name);
});
$$F({
  target: SYMBOL,
  stat: true,
  forced: !NATIVE_SYMBOL
}, {
  // `Symbol.for` method
  // https://tc39.es/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = $toString(key);
    if (hasOwn$7(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.es/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError$a(sym + ' is not a symbol');
    if (hasOwn$7(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () {
    USE_SETTER = true;
  },
  useSimple: function () {
    USE_SETTER = false;
  }
});
$$F({
  target: 'Object',
  stat: true,
  forced: !NATIVE_SYMBOL,
  sham: !DESCRIPTORS$9
}, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});
$$F({
  target: 'Object',
  stat: true,
  forced: !NATIVE_SYMBOL
}, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443

$$F({
  target: 'Object',
  stat: true,
  forced: fails$h(function () {
    getOwnPropertySymbolsModule$1.f(1);
  })
}, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule$1.f(toObject$8(it));
  }
}); // `JSON.stringify` method behavior with symbols
// https://tc39.es/ecma262/#sec-json.stringify

if ($stringify$1) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails$h(function () {
    var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}

    return $stringify$1([symbol]) != '[null]' // WebKit converts symbol values to JSON as null
    || $stringify$1({
      a: symbol
    }) != '{}' // V8 throws on boxed symbols
    || $stringify$1(Object(symbol)) != '{}';
  });
  $$F({
    target: 'JSON',
    stat: true,
    forced: FORCED_JSON_STRINGIFY
  }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice$2(arguments);
      var $replacer = replacer;
      if (!isObject$b(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

      if (!isArray$b(replacer)) replacer = function (key, value) {
        if (isCallable$2($replacer)) value = call$2($replacer, this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return apply$4($stringify$1, null, args);
    }
  });
} // `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive


if (!SymbolPrototype[TO_PRIMITIVE]) {
  var valueOf = SymbolPrototype.valueOf; // eslint-disable-next-line no-unused-vars -- required for .length

  redefine$1(SymbolPrototype, TO_PRIMITIVE, function (hint) {
    // TODO: improve hint logic
    return call$2(valueOf, this);
  });
} // `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag


setToStringTag$2($Symbol, SYMBOL);
hiddenKeys$1[HIDDEN] = true;

var path$r = path$y;
var getOwnPropertySymbols$2 = path$r.Object.getOwnPropertySymbols;

var parent$14 = getOwnPropertySymbols$2;
var getOwnPropertySymbols$1 = parent$14;

var getOwnPropertySymbols = getOwnPropertySymbols$1;

var getOwnPropertyDescriptor$6 = {exports: {}};

var $$E = _export;
var fails$g = fails$t;
var toIndexedObject$3 = toIndexedObject$b;
var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var DESCRIPTORS$8 = descriptors;
var FAILS_ON_PRIMITIVES$4 = fails$g(function () {
  nativeGetOwnPropertyDescriptor(1);
});
var FORCED$6 = !DESCRIPTORS$8 || FAILS_ON_PRIMITIVES$4; // `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

$$E({
  target: 'Object',
  stat: true,
  forced: FORCED$6,
  sham: !DESCRIPTORS$8
}, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject$3(it), key);
  }
});

var path$q = path$y;
var Object$5 = path$q.Object;

var getOwnPropertyDescriptor$5 = getOwnPropertyDescriptor$6.exports = function getOwnPropertyDescriptor(it, key) {
  return Object$5.getOwnPropertyDescriptor(it, key);
};

if (Object$5.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor$5.sham = true;

var parent$13 = getOwnPropertyDescriptor$6.exports;
var getOwnPropertyDescriptor$4 = parent$13;

var getOwnPropertyDescriptor$3 = getOwnPropertyDescriptor$4;

var getBuiltIn$3 = getBuiltIn$9;
var uncurryThis$d = functionUncurryThis;
var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var anObject$4 = anObject$d;
var concat$4 = uncurryThis$d([].concat); // all object keys, includes non-enumerable and symbols

var ownKeys$a = getBuiltIn$3('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule$1.f(anObject$4(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat$4(keys, getOwnPropertySymbols(it)) : keys;
};

var $$D = _export;
var DESCRIPTORS$7 = descriptors;
var ownKeys$9 = ownKeys$a;
var toIndexedObject$2 = toIndexedObject$b;
var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
var createProperty$3 = createProperty$6; // `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors

$$D({
  target: 'Object',
  stat: true,
  sham: !DESCRIPTORS$7
}, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject$2(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule$1.f;
    var keys = ownKeys$9(O);
    var result = {};
    var index = 0;
    var key, descriptor;

    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty$3(result, key, descriptor);
    }

    return result;
  }
});

var path$p = path$y;
var getOwnPropertyDescriptors$2 = path$p.Object.getOwnPropertyDescriptors;

var parent$12 = getOwnPropertyDescriptors$2;
var getOwnPropertyDescriptors$1 = parent$12;

var getOwnPropertyDescriptors = getOwnPropertyDescriptors$1;

var defineProperties$4 = {exports: {}};

var $$C = _export;
var DESCRIPTORS$6 = descriptors;
var defineProperties$3 = objectDefineProperties.f; // `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe

$$C({
  target: 'Object',
  stat: true,
  forced: Object.defineProperties !== defineProperties$3,
  sham: !DESCRIPTORS$6
}, {
  defineProperties: defineProperties$3
});

var path$o = path$y;
var Object$4 = path$o.Object;

var defineProperties$2 = defineProperties$4.exports = function defineProperties(T, D) {
  return Object$4.defineProperties(T, D);
};

if (Object$4.defineProperties.sham) defineProperties$2.sham = true;

var parent$11 = defineProperties$4.exports;
var defineProperties$1 = parent$11;

var defineProperties = defineProperties$1;

var defineProperty$a = {exports: {}};

var $$B = _export;
var DESCRIPTORS$5 = descriptors;
var defineProperty$9 = objectDefineProperty.f; // `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es/no-object-defineproperty -- safe

$$B({
  target: 'Object',
  stat: true,
  forced: Object.defineProperty !== defineProperty$9,
  sham: !DESCRIPTORS$5
}, {
  defineProperty: defineProperty$9
});

var path$n = path$y;
var Object$3 = path$n.Object;

var defineProperty$8 = defineProperty$a.exports = function defineProperty(it, key, desc) {
  return Object$3.defineProperty(it, key, desc);
};

if (Object$3.defineProperty.sham) defineProperty$8.sham = true;

var parent$10 = defineProperty$a.exports;
var defineProperty$7 = parent$10;

var defineProperty$6 = defineProperty$7;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var parent$$ = defineProperty$7;
var defineProperty$5 = parent$$;

var parent$_ = defineProperty$5;
var defineProperty$4 = parent$_;

var defineProperty$3 = defineProperty$4;

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;

    defineProperty$3(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);

  defineProperty$3(Constructor, "prototype", {
    writable: false
  });

  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    defineProperty$3(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var $$A = _export;
var isArray$a = isArray$d; // `Array.isArray` method
// https://tc39.es/ecma262/#sec-array.isarray

$$A({
  target: 'Array',
  stat: true
}, {
  isArray: isArray$a
});

var path$m = path$y;
var isArray$9 = path$m.Array.isArray;

var parent$Z = isArray$9;
var isArray$8 = parent$Z;

var parent$Y = isArray$8;
var isArray$7 = parent$Y;

var parent$X = isArray$7;
var isArray$6 = parent$X;

var isArray$5 = isArray$6;

function _arrayWithHoles(arr) {
  if (isArray$5(arr)) return arr;
}

var fails$f = fails$t;
var wellKnownSymbol$5 = wellKnownSymbol$j;
var V8_VERSION$1 = engineV8Version;
var SPECIES$2 = wellKnownSymbol$5('species');

var arrayMethodHasSpeciesSupport$5 = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION$1 >= 51 || !fails$f(function () {
    var array = [];
    var constructor = array.constructor = {};

    constructor[SPECIES$2] = function () {
      return {
        foo: 1
      };
    };

    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

var $$z = _export;
var global$k = global$P;
var fails$e = fails$t;
var isArray$4 = isArray$d;
var isObject$a = isObject$j;
var toObject$7 = toObject$e;
var lengthOfArrayLike$8 = lengthOfArrayLike$d;
var createProperty$2 = createProperty$6;
var arraySpeciesCreate$2 = arraySpeciesCreate$4;
var arrayMethodHasSpeciesSupport$4 = arrayMethodHasSpeciesSupport$5;
var wellKnownSymbol$4 = wellKnownSymbol$j;
var V8_VERSION = engineV8Version;
var IS_CONCAT_SPREADABLE = wellKnownSymbol$4('isConcatSpreadable');
var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';
var TypeError$9 = global$k.TypeError; // We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679

var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails$e(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport$4('concat');

var isConcatSpreadable = function (O) {
  if (!isObject$a(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray$4(O);
};

var FORCED$5 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species

$$z({
  target: 'Array',
  proto: true,
  forced: FORCED$5
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject$7(this);
    var A = arraySpeciesCreate$2(O, 0);
    var n = 0;
    var i, k, length, len, E;

    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];

      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike$8(E);
        if (n + len > MAX_SAFE_INTEGER$1) throw TypeError$9(MAXIMUM_ALLOWED_INDEX_EXCEEDED);

        for (k = 0; k < len; k++, n++) if (k in E) createProperty$2(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER$1) throw TypeError$9(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty$2(A, n++, E);
      }
    }

    A.length = n;
    return A;
  }
});

var defineWellKnownSymbol$j = defineWellKnownSymbol$l; // `Symbol.asyncIterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.asynciterator

defineWellKnownSymbol$j('asyncIterator');

var defineWellKnownSymbol$i = defineWellKnownSymbol$l; // `Symbol.hasInstance` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.hasinstance

defineWellKnownSymbol$i('hasInstance');

var defineWellKnownSymbol$h = defineWellKnownSymbol$l; // `Symbol.isConcatSpreadable` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable

defineWellKnownSymbol$h('isConcatSpreadable');

var defineWellKnownSymbol$g = defineWellKnownSymbol$l; // `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator

defineWellKnownSymbol$g('iterator');

var defineWellKnownSymbol$f = defineWellKnownSymbol$l; // `Symbol.match` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.match

defineWellKnownSymbol$f('match');

var defineWellKnownSymbol$e = defineWellKnownSymbol$l; // `Symbol.matchAll` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.matchall

defineWellKnownSymbol$e('matchAll');

var defineWellKnownSymbol$d = defineWellKnownSymbol$l; // `Symbol.replace` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.replace

defineWellKnownSymbol$d('replace');

var defineWellKnownSymbol$c = defineWellKnownSymbol$l; // `Symbol.search` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.search

defineWellKnownSymbol$c('search');

var defineWellKnownSymbol$b = defineWellKnownSymbol$l; // `Symbol.species` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.species

defineWellKnownSymbol$b('species');

var defineWellKnownSymbol$a = defineWellKnownSymbol$l; // `Symbol.split` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.split

defineWellKnownSymbol$a('split');

var defineWellKnownSymbol$9 = defineWellKnownSymbol$l; // `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive

defineWellKnownSymbol$9('toPrimitive');

var defineWellKnownSymbol$8 = defineWellKnownSymbol$l; // `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag

defineWellKnownSymbol$8('toStringTag');

var defineWellKnownSymbol$7 = defineWellKnownSymbol$l; // `Symbol.unscopables` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.unscopables

defineWellKnownSymbol$7('unscopables');

var global$j = global$P;
var setToStringTag$1 = setToStringTag$5; // JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag

setToStringTag$1(global$j.JSON, 'JSON', true);

var path$l = path$y;
var symbol$5 = path$l.Symbol;

var parent$W = symbol$5;
var symbol$4 = parent$W;

var parent$V = symbol$4;
var symbol$3 = parent$V;

var defineWellKnownSymbol$6 = defineWellKnownSymbol$l; // `Symbol.asyncDispose` well-known symbol
// https://github.com/tc39/proposal-using-statement

defineWellKnownSymbol$6('asyncDispose');

var defineWellKnownSymbol$5 = defineWellKnownSymbol$l; // `Symbol.dispose` well-known symbol
// https://github.com/tc39/proposal-using-statement

defineWellKnownSymbol$5('dispose');

var defineWellKnownSymbol$4 = defineWellKnownSymbol$l; // `Symbol.matcher` well-known symbol
// https://github.com/tc39/proposal-pattern-matching

defineWellKnownSymbol$4('matcher');

var defineWellKnownSymbol$3 = defineWellKnownSymbol$l; // `Symbol.metadata` well-known symbol
// https://github.com/tc39/proposal-decorators

defineWellKnownSymbol$3('metadata');

var defineWellKnownSymbol$2 = defineWellKnownSymbol$l; // `Symbol.observable` well-known symbol
// https://github.com/tc39/proposal-observable

defineWellKnownSymbol$2('observable');

var defineWellKnownSymbol$1 = defineWellKnownSymbol$l; // `Symbol.patternMatch` well-known symbol
// https://github.com/tc39/proposal-pattern-matching

defineWellKnownSymbol$1('patternMatch');

var defineWellKnownSymbol = defineWellKnownSymbol$l;
defineWellKnownSymbol('replaceAll');

var parent$U = symbol$3; // TODO: Remove from `core-js@4`
// TODO: Remove from `core-js@4`

var symbol$2 = parent$U;

var symbol$1 = symbol$2;

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof symbol$1 !== "undefined" && getIteratorMethod$1(arr) || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

var $$y = _export;
var global$i = global$P;
var isArray$3 = isArray$d;
var isConstructor$1 = isConstructor$4;
var isObject$9 = isObject$j;
var toAbsoluteIndex$2 = toAbsoluteIndex$5;
var lengthOfArrayLike$7 = lengthOfArrayLike$d;
var toIndexedObject$1 = toIndexedObject$b;
var createProperty$1 = createProperty$6;
var wellKnownSymbol$3 = wellKnownSymbol$j;
var arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$5;
var un$Slice = arraySlice$5;
var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport$3('slice');
var SPECIES$1 = wellKnownSymbol$3('species');
var Array$2 = global$i.Array;
var max$1 = Math.max; // `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects

$$y({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT$3
}, {
  slice: function slice(start, end) {
    var O = toIndexedObject$1(this);
    var length = lengthOfArrayLike$7(O);
    var k = toAbsoluteIndex$2(start, length);
    var fin = toAbsoluteIndex$2(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

    var Constructor, result, n;

    if (isArray$3(O)) {
      Constructor = O.constructor; // cross-realm fallback

      if (isConstructor$1(Constructor) && (Constructor === Array$2 || isArray$3(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject$9(Constructor)) {
        Constructor = Constructor[SPECIES$1];
        if (Constructor === null) Constructor = undefined;
      }

      if (Constructor === Array$2 || Constructor === undefined) {
        return un$Slice(O, k, fin);
      }
    }

    result = new (Constructor === undefined ? Array$2 : Constructor)(max$1(fin - k, 0));

    for (n = 0; k < fin; k++, n++) if (k in O) createProperty$1(result, n, O[k]);

    result.length = n;
    return result;
  }
});

var entryVirtual$j = entryVirtual$l;
var slice$6 = entryVirtual$j('Array').slice;

var isPrototypeOf$j = objectIsPrototypeOf;
var method$g = slice$6;
var ArrayPrototype$h = Array.prototype;

var slice$5 = function (it) {
  var own = it.slice;
  return it === ArrayPrototype$h || isPrototypeOf$j(ArrayPrototype$h, it) && own === ArrayPrototype$h.slice ? method$g : own;
};

var parent$T = slice$5;
var slice$4 = parent$T;

var parent$S = slice$4;
var slice$3 = parent$S;

var parent$R = slice$3;
var slice$2 = parent$R;

var slice$1 = slice$2;

var parent$Q = from$4;
var from$2 = parent$Q;

var parent$P = from$2;
var from$1 = parent$P;

var from = from$1;

function _arrayLikeToArray$9(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray$9(o, minLen) {
  var _context;

  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$9(o, minLen);

  var n = slice$1(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);

  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$9(arr, i) || _nonIterableRest();
}

var WrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var iterator$5 = WrappedWellKnownSymbolModule.f('iterator');

var parent$O = iterator$5;
var iterator$4 = parent$O;

var parent$N = iterator$4;
var iterator$3 = parent$N;

var parent$M = iterator$3;
var iterator$2 = parent$M;

var iterator$1 = iterator$2;

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof symbol$1 && "symbol" == typeof iterator$1 ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof symbol$1 && obj.constructor === symbol$1 && obj !== symbol$1.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _arrayWithoutHoles(arr) {
  if (isArray$5(arr)) return _arrayLikeToArray$9(arr);
}

function _iterableToArray(iter) {
  if (typeof symbol$1 !== "undefined" && getIteratorMethod$1(iter) != null || iter["@@iterator"] != null) return from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$9(arr) || _nonIterableSpread();
}

var symbol = symbol$4;

var entryVirtual$i = entryVirtual$l;
var concat$3 = entryVirtual$i('Array').concat;

var isPrototypeOf$i = objectIsPrototypeOf;
var method$f = concat$3;
var ArrayPrototype$g = Array.prototype;

var concat$2 = function (it) {
  var own = it.concat;
  return it === ArrayPrototype$g || isPrototypeOf$i(ArrayPrototype$g, it) && own === ArrayPrototype$g.concat ? method$f : own;
};

var parent$L = concat$2;
var concat$1 = parent$L;

var concat = concat$1;

var slice = slice$4;

var $$x = _export;
var ownKeys$8 = ownKeys$a; // `Reflect.ownKeys` method
// https://tc39.es/ecma262/#sec-reflect.ownkeys

$$x({
  target: 'Reflect',
  stat: true
}, {
  ownKeys: ownKeys$8
});

var path$k = path$y;
var ownKeys$7 = path$k.Reflect.ownKeys;

var parent$K = ownKeys$7;
var ownKeys$6 = parent$K;

var ownKeys$5 = ownKeys$6;

var isArray$2 = isArray$8;

var $$w = _export;
var $map = arrayIteration.map;
var arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$2('map'); // `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species

$$w({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT$2
}, {
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$h = entryVirtual$l;
var map$6 = entryVirtual$h('Array').map;

var isPrototypeOf$h = objectIsPrototypeOf;
var method$e = map$6;
var ArrayPrototype$f = Array.prototype;

var map$5 = function (it) {
  var own = it.map;
  return it === ArrayPrototype$f || isPrototypeOf$h(ArrayPrototype$f, it) && own === ArrayPrototype$f.map ? method$e : own;
};

var parent$J = map$5;
var map$4 = parent$J;

var map$3 = map$4;

var $$v = _export;
var toObject$6 = toObject$e;
var nativeKeys = objectKeys$4;
var fails$d = fails$t;
var FAILS_ON_PRIMITIVES$3 = fails$d(function () {
  nativeKeys(1);
}); // `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys

$$v({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES$3
}, {
  keys: function keys(it) {
    return nativeKeys(toObject$6(it));
  }
});

var path$j = path$y;
var keys$6 = path$j.Object.keys;

var parent$I = keys$6;
var keys$5 = parent$I;

var keys$4 = keys$5;

var $$u = _export;
var global$h = global$P;
var uncurryThis$c = functionUncurryThis;
var Date$1 = global$h.Date;
var getTime = uncurryThis$c(Date$1.prototype.getTime); // `Date.now` method
// https://tc39.es/ecma262/#sec-date.now

$$u({
  target: 'Date',
  stat: true
}, {
  now: function now() {
    return getTime(new Date$1());
  }
});

var path$i = path$y;
var now$3 = path$i.Date.now;

var parent$H = now$3;
var now$2 = parent$H;

var now$1 = now$2;

var fails$c = fails$t;

var arrayMethodIsStrict$6 = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails$c(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () {
      return 1;
    }, 1);
  });
};

var $forEach = arrayIteration.forEach;
var arrayMethodIsStrict$5 = arrayMethodIsStrict$6;
var STRICT_METHOD$5 = arrayMethodIsStrict$5('forEach'); // `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach

var arrayForEach = !STRICT_METHOD$5 ? function forEach(callbackfn
/* , thisArg */
) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); // eslint-disable-next-line es/no-array-prototype-foreach -- safe
} : [].forEach;

var $$t = _export;
var forEach$6 = arrayForEach; // `Array.prototype.forEach` method
// https://tc39.es/ecma262/#sec-array.prototype.foreach
// eslint-disable-next-line es/no-array-prototype-foreach -- safe

$$t({
  target: 'Array',
  proto: true,
  forced: [].forEach != forEach$6
}, {
  forEach: forEach$6
});

var entryVirtual$g = entryVirtual$l;
var forEach$5 = entryVirtual$g('Array').forEach;

var parent$G = forEach$5;
var forEach$4 = parent$G;

var classof$6 = classof$e;
var hasOwn$6 = hasOwnProperty_1;
var isPrototypeOf$g = objectIsPrototypeOf;
var method$d = forEach$4;
var ArrayPrototype$e = Array.prototype;
var DOMIterables$3 = {
  DOMTokenList: true,
  NodeList: true
};

var forEach$3 = function (it) {
  var own = it.forEach;
  return it === ArrayPrototype$e || isPrototypeOf$g(ArrayPrototype$e, it) && own === ArrayPrototype$e.forEach || hasOwn$6(DOMIterables$3, classof$6(it)) ? method$d : own;
};

var forEach$2 = forEach$3;

var $$s = _export;
var uncurryThis$b = functionUncurryThis;
var isArray$1 = isArray$d;
var un$Reverse = uncurryThis$b([].reverse);
var test$1 = [1, 2]; // `Array.prototype.reverse` method
// https://tc39.es/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794

$$s({
  target: 'Array',
  proto: true,
  forced: String(test$1) === String(test$1.reverse())
}, {
  reverse: function reverse() {
    // eslint-disable-next-line no-self-assign -- dirty hack
    if (isArray$1(this)) this.length = this.length;
    return un$Reverse(this);
  }
});

var entryVirtual$f = entryVirtual$l;
var reverse$3 = entryVirtual$f('Array').reverse;

var isPrototypeOf$f = objectIsPrototypeOf;
var method$c = reverse$3;
var ArrayPrototype$d = Array.prototype;

var reverse$2 = function (it) {
  var own = it.reverse;
  return it === ArrayPrototype$d || isPrototypeOf$f(ArrayPrototype$d, it) && own === ArrayPrototype$d.reverse ? method$c : own;
};

var parent$F = reverse$2;
var reverse$1 = parent$F;

var reverse = reverse$1;

var $$r = _export;
var global$g = global$P;
var toAbsoluteIndex$1 = toAbsoluteIndex$5;
var toIntegerOrInfinity = toIntegerOrInfinity$4;
var lengthOfArrayLike$6 = lengthOfArrayLike$d;
var toObject$5 = toObject$e;
var arraySpeciesCreate$1 = arraySpeciesCreate$4;
var createProperty = createProperty$6;
var arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$1('splice');
var TypeError$8 = global$g.TypeError;
var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species

$$r({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT$1
}, {
  splice: function splice(start, deleteCount
  /* , ...items */
  ) {
    var O = toObject$5(this);
    var len = lengthOfArrayLike$6(O);
    var actualStart = toAbsoluteIndex$1(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;

    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
    }

    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError$8(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }

    A = arraySpeciesCreate$1(O, actualDeleteCount);

    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }

    A.length = actualDeleteCount;

    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];else delete O[to];
      }

      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];else delete O[to];
      }
    }

    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }

    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});

var entryVirtual$e = entryVirtual$l;
var splice$4 = entryVirtual$e('Array').splice;

var isPrototypeOf$e = objectIsPrototypeOf;
var method$b = splice$4;
var ArrayPrototype$c = Array.prototype;

var splice$3 = function (it) {
  var own = it.splice;
  return it === ArrayPrototype$c || isPrototypeOf$e(ArrayPrototype$c, it) && own === ArrayPrototype$c.splice ? method$b : own;
};

var parent$E = splice$3;
var splice$2 = parent$E;

var splice$1 = splice$2;

var $$q = _export;
var $includes = arrayIncludes.includes;
// https://tc39.es/ecma262/#sec-array.prototype.includes

$$q({
  target: 'Array',
  proto: true
}, {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

var entryVirtual$d = entryVirtual$l;
var includes$4 = entryVirtual$d('Array').includes;

var isObject$8 = isObject$j;
var classof$5 = classofRaw$1;
var wellKnownSymbol$2 = wellKnownSymbol$j;
var MATCH$1 = wellKnownSymbol$2('match'); // `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp

var isRegexp = function (it) {
  var isRegExp;
  return isObject$8(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$5(it) == 'RegExp');
};

var global$f = global$P;
var isRegExp = isRegexp;
var TypeError$7 = global$f.TypeError;

var notARegexp = function (it) {
  if (isRegExp(it)) {
    throw TypeError$7("The method doesn't accept regular expressions");
  }

  return it;
};

var wellKnownSymbol$1 = wellKnownSymbol$j;
var MATCH = wellKnownSymbol$1('match');

var correctIsRegexpLogic = function (METHOD_NAME) {
  var regexp = /./;

  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) {
      /* empty */
    }
  }

  return false;
};

var $$p = _export;
var uncurryThis$a = functionUncurryThis;
var notARegExp = notARegexp;
var requireObjectCoercible$1 = requireObjectCoercible$5;
var toString$4 = toString$8;
var correctIsRegExpLogic = correctIsRegexpLogic;
var stringIndexOf = uncurryThis$a(''.indexOf); // `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes

$$p({
  target: 'String',
  proto: true,
  forced: !correctIsRegExpLogic('includes')
}, {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~stringIndexOf(toString$4(requireObjectCoercible$1(this)), toString$4(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$c = entryVirtual$l;
var includes$3 = entryVirtual$c('String').includes;

var isPrototypeOf$d = objectIsPrototypeOf;
var arrayMethod = includes$4;
var stringMethod = includes$3;
var ArrayPrototype$b = Array.prototype;
var StringPrototype = String.prototype;

var includes$2 = function (it) {
  var own = it.includes;
  if (it === ArrayPrototype$b || isPrototypeOf$d(ArrayPrototype$b, it) && own === ArrayPrototype$b.includes) return arrayMethod;

  if (typeof it == 'string' || it === StringPrototype || isPrototypeOf$d(StringPrototype, it) && own === StringPrototype.includes) {
    return stringMethod;
  }

  return own;
};

var parent$D = includes$2;
var includes$1 = parent$D;

var includes = includes$1;

var $$o = _export;
var fails$b = fails$t;
var toObject$4 = toObject$e;
var nativeGetPrototypeOf = objectGetPrototypeOf;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var FAILS_ON_PRIMITIVES$2 = fails$b(function () {
  nativeGetPrototypeOf(1);
}); // `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof

$$o({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES$2,
  sham: !CORRECT_PROTOTYPE_GETTER
}, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject$4(it));
  }
});

var path$h = path$y;
var getPrototypeOf$6 = path$h.Object.getPrototypeOf;

var parent$C = getPrototypeOf$6;
var getPrototypeOf$5 = parent$C;

var getPrototypeOf$4 = getPrototypeOf$5;

var $$n = _export;
var $filter = arrayIteration.filter;
var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter'); // `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species

$$n({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT
}, {
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$b = entryVirtual$l;
var filter$3 = entryVirtual$b('Array').filter;

var isPrototypeOf$c = objectIsPrototypeOf;
var method$a = filter$3;
var ArrayPrototype$a = Array.prototype;

var filter$2 = function (it) {
  var own = it.filter;
  return it === ArrayPrototype$a || isPrototypeOf$c(ArrayPrototype$a, it) && own === ArrayPrototype$a.filter ? method$a : own;
};

var parent$B = filter$2;
var filter$1 = parent$B;

var filter = filter$1;

var DESCRIPTORS$4 = descriptors;
var uncurryThis$9 = functionUncurryThis;
var objectKeys = objectKeys$4;
var toIndexedObject = toIndexedObject$b;
var $propertyIsEnumerable = objectPropertyIsEnumerable.f;
var propertyIsEnumerable = uncurryThis$9($propertyIsEnumerable);
var push$2 = uncurryThis$9([].push); // `Object.{ entries, values }` methods implementation

var createMethod$2 = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      key = keys[i++];

      if (!DESCRIPTORS$4 || propertyIsEnumerable(O, key)) {
        push$2(result, TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

var objectToArray = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod$2(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod$2(false)
};

var $$m = _export;
var $values = objectToArray.values; // `Object.values` method
// https://tc39.es/ecma262/#sec-object.values

$$m({
  target: 'Object',
  stat: true
}, {
  values: function values(O) {
    return $values(O);
  }
});

var path$g = path$y;
path$g.Object.values;

var whitespaces$4 = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' + '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var uncurryThis$8 = functionUncurryThis;
var requireObjectCoercible = requireObjectCoercible$5;
var toString$3 = toString$8;
var whitespaces$3 = whitespaces$4;
var replace$1 = uncurryThis$8(''.replace);
var whitespace = '[' + whitespaces$3 + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

var createMethod$1 = function (TYPE) {
  return function ($this) {
    var string = toString$3(requireObjectCoercible($this));
    if (TYPE & 1) string = replace$1(string, ltrim, '');
    if (TYPE & 2) string = replace$1(string, rtrim, '');
    return string;
  };
};

var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod$1(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod$1(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod$1(3)
};

var global$e = global$P;
var fails$a = fails$t;
var uncurryThis$7 = functionUncurryThis;
var toString$2 = toString$8;
var trim$1 = stringTrim.trim;
var whitespaces$2 = whitespaces$4;
var $parseInt$1 = global$e.parseInt;
var Symbol$2 = global$e.Symbol;
var ITERATOR$1 = Symbol$2 && Symbol$2.iterator;
var hex = /^[+-]?0x/i;
var exec$1 = uncurryThis$7(hex.exec);
var FORCED$4 = $parseInt$1(whitespaces$2 + '08') !== 8 || $parseInt$1(whitespaces$2 + '0x16') !== 22 // MS Edge 18- broken with boxed symbols
|| ITERATOR$1 && !fails$a(function () {
  $parseInt$1(Object(ITERATOR$1));
}); // `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix

var numberParseInt = FORCED$4 ? function parseInt(string, radix) {
  var S = trim$1(toString$2(string));
  return $parseInt$1(S, radix >>> 0 || (exec$1(hex, S) ? 16 : 10));
} : $parseInt$1;

var $$l = _export;
var $parseInt = numberParseInt; // `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix

$$l({
  global: true,
  forced: parseInt != $parseInt
}, {
  parseInt: $parseInt
});

var path$f = path$y;
var _parseInt$2 = path$f.parseInt;

var parent$A = _parseInt$2;
var _parseInt$1 = parent$A;

var _parseInt = _parseInt$1;

/* eslint-disable es/no-array-prototype-indexof -- required for testing */


var $$k = _export;
var uncurryThis$6 = functionUncurryThis;
var $IndexOf = arrayIncludes.indexOf;
var arrayMethodIsStrict$4 = arrayMethodIsStrict$6;
var un$IndexOf = uncurryThis$6([].indexOf);
var NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;
var STRICT_METHOD$4 = arrayMethodIsStrict$4('indexOf'); // `Array.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.indexof

$$k({
  target: 'Array',
  proto: true,
  forced: NEGATIVE_ZERO || !STRICT_METHOD$4
}, {
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
    return NEGATIVE_ZERO // convert -0 to +0
    ? un$IndexOf(this, searchElement, fromIndex) || 0 : $IndexOf(this, searchElement, fromIndex);
  }
});

var entryVirtual$a = entryVirtual$l;
var indexOf$3 = entryVirtual$a('Array').indexOf;

var isPrototypeOf$b = objectIsPrototypeOf;
var method$9 = indexOf$3;
var ArrayPrototype$9 = Array.prototype;

var indexOf$2 = function (it) {
  var own = it.indexOf;
  return it === ArrayPrototype$9 || isPrototypeOf$b(ArrayPrototype$9, it) && own === ArrayPrototype$9.indexOf ? method$9 : own;
};

var parent$z = indexOf$2;
var indexOf$1 = parent$z;

var indexOf = indexOf$1;

var PROPER_FUNCTION_NAME = functionName.PROPER;
var fails$9 = fails$t;
var whitespaces$1 = whitespaces$4;
var non = '\u200B\u0085\u180E'; // check that a method works with the correct list
// of whitespaces and has a correct name

var stringTrimForced = function (METHOD_NAME) {
  return fails$9(function () {
    return !!whitespaces$1[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces$1[METHOD_NAME].name !== METHOD_NAME;
  });
};

var $$j = _export;
var $trim = stringTrim.trim;
var forcedStringTrimMethod = stringTrimForced; // `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim

$$j({
  target: 'String',
  proto: true,
  forced: forcedStringTrimMethod('trim')
}, {
  trim: function trim() {
    return $trim(this);
  }
});

var entryVirtual$9 = entryVirtual$l;
entryVirtual$9('String').trim;

var $$i = _export;
var DESCRIPTORS$3 = descriptors;
var create$8 = objectCreate; // `Object.create` method
// https://tc39.es/ecma262/#sec-object.create

$$i({
  target: 'Object',
  stat: true,
  sham: !DESCRIPTORS$3
}, {
  create: create$8
});

var path$e = path$y;
var Object$2 = path$e.Object;

var create$7 = function create(P, D) {
  return Object$2.create(P, D);
};

var parent$y = create$7;
var create$6 = parent$y;

var create$5 = create$6;

var $$h = _export;
var global$d = global$P;
var getBuiltIn$2 = getBuiltIn$9;
var apply$3 = functionApply;
var uncurryThis$5 = functionUncurryThis;
var fails$8 = fails$t;
var Array$1 = global$d.Array;
var $stringify = getBuiltIn$2('JSON', 'stringify');
var exec = uncurryThis$5(/./.exec);
var charAt$1 = uncurryThis$5(''.charAt);
var charCodeAt = uncurryThis$5(''.charCodeAt);
var replace = uncurryThis$5(''.replace);
var numberToString = uncurryThis$5(1.0.toString);
var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var fix = function (match, offset, string) {
  var prev = charAt$1(string, offset - 1);
  var next = charAt$1(string, offset + 1);

  if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  }

  return match;
};

var FORCED$3 = fails$8(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"' || $stringify('\uDEAD') !== '"\\udead"';
});

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  // https://github.com/tc39/proposal-well-formed-stringify
  $$h({
    target: 'JSON',
    stat: true,
    forced: FORCED$3
  }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      for (var i = 0, l = arguments.length, args = Array$1(l); i < l; i++) args[i] = arguments[i];

      var result = apply$3($stringify, null, args);
      return typeof result == 'string' ? replace(result, tester, fix) : result;
    }
  });
}

var path$d = path$y;
var apply$2 = functionApply; // eslint-disable-next-line es/no-json -- safe

if (!path$d.JSON) path$d.JSON = {
  stringify: JSON.stringify
}; // eslint-disable-next-line no-unused-vars -- required for `.length`

var stringify$3 = function stringify(it, replacer, space) {
  return apply$2(path$d.JSON.stringify, null, arguments);
};

var parent$x = stringify$3;
var stringify$2 = parent$x;

var stringify$1 = stringify$2;

var global$c = global$P;
var TypeError$6 = global$c.TypeError;

var validateArgumentsLength$1 = function (passed, required) {
  if (passed < required) throw TypeError$6('Not enough arguments');
  return passed;
};

var $$g = _export;
var global$b = global$P;
var apply$1 = functionApply;
var isCallable$1 = isCallable$h;
var userAgent$2 = engineUserAgent;
var arraySlice$1 = arraySlice$5;
var validateArgumentsLength = validateArgumentsLength$1;
var MSIE = /MSIE .\./.test(userAgent$2); // <- dirty ie9- check

var Function$1 = global$b.Function;

var wrap = function (scheduler) {
  return function (handler, timeout
  /* , ...arguments */
  ) {
    var boundArgs = validateArgumentsLength(arguments.length, 1) > 2;
    var fn = isCallable$1(handler) ? handler : Function$1(handler);
    var args = boundArgs ? arraySlice$1(arguments, 2) : undefined;
    return scheduler(boundArgs ? function () {
      apply$1(fn, this, args);
    } : fn, timeout);
  };
}; // ie9- setTimeout & setInterval additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers


$$g({
  global: true,
  bind: true,
  forced: MSIE
}, {
  // `setTimeout` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
  setTimeout: wrap(global$b.setTimeout),
  // `setInterval` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
  setInterval: wrap(global$b.setInterval)
});

var path$c = path$y;
var setTimeout$2 = path$c.setTimeout;

var setTimeout$1 = setTimeout$2;

var toObject$3 = toObject$e;
var toAbsoluteIndex = toAbsoluteIndex$5;
var lengthOfArrayLike$5 = lengthOfArrayLike$d; // `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill

var arrayFill = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject$3(this);
  var length = lengthOfArrayLike$5(O);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) O[index++] = value;

  return O;
};

var $$f = _export;
var fill$4 = arrayFill;
// https://tc39.es/ecma262/#sec-array.prototype.fill

$$f({
  target: 'Array',
  proto: true
}, {
  fill: fill$4
}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

var entryVirtual$8 = entryVirtual$l;
var fill$3 = entryVirtual$8('Array').fill;

var isPrototypeOf$a = objectIsPrototypeOf;
var method$8 = fill$3;
var ArrayPrototype$8 = Array.prototype;

var fill$2 = function (it) {
  var own = it.fill;
  return it === ArrayPrototype$8 || isPrototypeOf$a(ArrayPrototype$8, it) && own === ArrayPrototype$8.fill ? method$8 : own;
};

var parent$w = fill$2;
var fill$1 = parent$w;

var fill = fill$1;

/*! Hammer.JS - v2.0.17-rc - 2019-12-16
 * http://naver.github.io/egjs
 *
 * Forked By Naver egjs
 * Copyright (c) hammerjs
 * Licensed under the MIT license */
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized$1(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
/**
 * @private
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */


var assign;

if (typeof Object.assign !== 'function') {
  assign = function assign(target) {
    if (target === undefined || target === null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var output = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      var source = arguments[index];

      if (source !== undefined && source !== null) {
        for (var nextKey in source) {
          if (source.hasOwnProperty(nextKey)) {
            output[nextKey] = source[nextKey];
          }
        }
      }
    }

    return output;
  };
} else {
  assign = Object.assign;
}

var assign$1 = assign;
var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = typeof document === "undefined" ? {
  style: {}
} : document.createElement('div');
var TYPE_FUNCTION = 'function';
var round = Math.round,
    abs$1 = Math.abs;
var now = Date.now;
/**
 * @private
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */

function prefixed(obj, property) {
  var prefix;
  var prop;
  var camelProp = property[0].toUpperCase() + property.slice(1);
  var i = 0;

  while (i < VENDOR_PREFIXES.length) {
    prefix = VENDOR_PREFIXES[i];
    prop = prefix ? prefix + camelProp : property;

    if (prop in obj) {
      return prop;
    }

    i++;
  }

  return undefined;
}
/* eslint-disable no-new-func, no-nested-ternary */


var win;

if (typeof window === "undefined") {
  // window is undefined in node.js
  win = {};
} else {
  win = window;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

function getTouchActionProps() {
  if (!NATIVE_TOUCH_ACTION) {
    return false;
  }

  var touchMap = {};
  var cssSupports = win.CSS && win.CSS.supports;
  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
    // If css.supports is not supported but there is native touch-action assume it supports
    // all values. This is the case for IE 10 and 11.
    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;
  });
  return touchMap;
}

var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();
var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
var SUPPORT_TOUCH = ('ontouchstart' in win);
var SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';
var COMPUTE_INTERVAL = 25;
var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;
var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;
var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];
/**
 * @private
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */

function each(obj, iterator, context) {
  var i;

  if (!obj) {
    return;
  }

  if (obj.forEach) {
    obj.forEach(iterator, context);
  } else if (obj.length !== undefined) {
    i = 0;

    while (i < obj.length) {
      iterator.call(context, obj[i], i, obj);
      i++;
    }
  } else {
    for (i in obj) {
      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
    }
  }
}
/**
 * @private
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */


function boolOrFn(val, args) {
  if (typeof val === TYPE_FUNCTION) {
    return val.apply(args ? args[0] || undefined : undefined, args);
  }

  return val;
}
/**
 * @private
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */


function inStr(str, find) {
  return str.indexOf(find) > -1;
}
/**
 * @private
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */


function cleanTouchActions(actions) {
  // none
  if (inStr(actions, TOUCH_ACTION_NONE)) {
    return TOUCH_ACTION_NONE;
  }

  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
  // for different directions, e.g. horizontal pan but vertical swipe?)
  // we need none (as otherwise with pan-x pan-y combined none of these
  // recognizers will work, since the browser would handle all panning

  if (hasPanX && hasPanY) {
    return TOUCH_ACTION_NONE;
  } // pan-x OR pan-y


  if (hasPanX || hasPanY) {
    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
  } // manipulation


  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
    return TOUCH_ACTION_MANIPULATION;
  }

  return TOUCH_ACTION_AUTO;
}
/**
 * @private
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */


var TouchAction = /*#__PURE__*/function () {
  function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
  }
  /**
   * @private
   * set the touchAction value on the element or enable the polyfill
   * @param {String} value
   */


  var _proto = TouchAction.prototype;

  _proto.set = function set(value) {
    // find out the touch-action by the event handlers
    if (value === TOUCH_ACTION_COMPUTE) {
      value = this.compute();
    }

    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
    }

    this.actions = value.toLowerCase().trim();
  };
  /**
   * @private
   * just re-set the touchAction value
   */


  _proto.update = function update() {
    this.set(this.manager.options.touchAction);
  };
  /**
   * @private
   * compute the value for the touchAction property based on the recognizer's settings
   * @returns {String} value
   */


  _proto.compute = function compute() {
    var actions = [];
    each(this.manager.recognizers, function (recognizer) {
      if (boolOrFn(recognizer.options.enable, [recognizer])) {
        actions = actions.concat(recognizer.getTouchAction());
      }
    });
    return cleanTouchActions(actions.join(' '));
  };
  /**
   * @private
   * this method is called on each input cycle and provides the preventing of the browser behavior
   * @param {Object} input
   */


  _proto.preventDefaults = function preventDefaults(input) {
    var srcEvent = input.srcEvent;
    var direction = input.offsetDirection; // if the touch action did prevented once this session

    if (this.manager.session.prevented) {
      srcEvent.preventDefault();
      return;
    }

    var actions = this.actions;
    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

    if (hasNone) {
      // do not prevent defaults if this is a tap gesture
      var isTapPointer = input.pointers.length === 1;
      var isTapMovement = input.distance < 2;
      var isTapTouchTime = input.deltaTime < 250;

      if (isTapPointer && isTapMovement && isTapTouchTime) {
        return;
      }
    }

    if (hasPanX && hasPanY) {
      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
      return;
    }

    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
      return this.preventSrc(srcEvent);
    }
  };
  /**
   * @private
   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
   * @param {Object} srcEvent
   */


  _proto.preventSrc = function preventSrc(srcEvent) {
    this.manager.session.prevented = true;
    srcEvent.preventDefault();
  };

  return TouchAction;
}();
/**
 * @private
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */


function hasParent(node, parent) {
  while (node) {
    if (node === parent) {
      return true;
    }

    node = node.parentNode;
  }

  return false;
}
/**
 * @private
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */


function getCenter(pointers) {
  var pointersLength = pointers.length; // no need to loop when only one touch

  if (pointersLength === 1) {
    return {
      x: round(pointers[0].clientX),
      y: round(pointers[0].clientY)
    };
  }

  var x = 0;
  var y = 0;
  var i = 0;

  while (i < pointersLength) {
    x += pointers[i].clientX;
    y += pointers[i].clientY;
    i++;
  }

  return {
    x: round(x / pointersLength),
    y: round(y / pointersLength)
  };
}
/**
 * @private
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */


function simpleCloneInputData(input) {
  // make a simple copy of the pointers because we will get a reference if we don't
  // we only need clientXY for the calculations
  var pointers = [];
  var i = 0;

  while (i < input.pointers.length) {
    pointers[i] = {
      clientX: round(input.pointers[i].clientX),
      clientY: round(input.pointers[i].clientY)
    };
    i++;
  }

  return {
    timeStamp: now(),
    pointers: pointers,
    center: getCenter(pointers),
    deltaX: input.deltaX,
    deltaY: input.deltaY
  };
}
/**
 * @private
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */


function getDistance(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }

  var x = p2[props[0]] - p1[props[0]];
  var y = p2[props[1]] - p1[props[1]];
  return Math.sqrt(x * x + y * y);
}
/**
 * @private
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */


function getAngle(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }

  var x = p2[props[0]] - p1[props[0]];
  var y = p2[props[1]] - p1[props[1]];
  return Math.atan2(y, x) * 180 / Math.PI;
}
/**
 * @private
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */


function getDirection(x, y) {
  if (x === y) {
    return DIRECTION_NONE;
  }

  if (abs$1(x) >= abs$1(y)) {
    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
  }

  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

function computeDeltaXY(session, input) {
  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;
  // jscs throwing error on defalut destructured values and without defaults tests fail

  var offset = session.offsetDelta || {};
  var prevDelta = session.prevDelta || {};
  var prevInput = session.prevInput || {};

  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
    prevDelta = session.prevDelta = {
      x: prevInput.deltaX || 0,
      y: prevInput.deltaY || 0
    };
    offset = session.offsetDelta = {
      x: center.x,
      y: center.y
    };
  }

  input.deltaX = prevDelta.x + (center.x - offset.x);
  input.deltaY = prevDelta.y + (center.y - offset.y);
}
/**
 * @private
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */


function getVelocity(deltaTime, x, y) {
  return {
    x: x / deltaTime || 0,
    y: y / deltaTime || 0
  };
}
/**
 * @private
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */


function getScale(start, end) {
  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}
/**
 * @private
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */


function getRotation(start, end) {
  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}
/**
 * @private
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */


function computeIntervalInputData(session, input) {
  var last = session.lastInterval || input;
  var deltaTime = input.timeStamp - last.timeStamp;
  var velocity;
  var velocityX;
  var velocityY;
  var direction;

  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
    var deltaX = input.deltaX - last.deltaX;
    var deltaY = input.deltaY - last.deltaY;
    var v = getVelocity(deltaTime, deltaX, deltaY);
    velocityX = v.x;
    velocityY = v.y;
    velocity = abs$1(v.x) > abs$1(v.y) ? v.x : v.y;
    direction = getDirection(deltaX, deltaY);
    session.lastInterval = input;
  } else {
    // use latest velocity info if it doesn't overtake a minimum period
    velocity = last.velocity;
    velocityX = last.velocityX;
    velocityY = last.velocityY;
    direction = last.direction;
  }

  input.velocity = velocity;
  input.velocityX = velocityX;
  input.velocityY = velocityY;
  input.direction = direction;
}
/**
* @private
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */


function computeInputData(manager, input) {
  var session = manager.session;
  var pointers = input.pointers;
  var pointersLength = pointers.length; // store the first input to calculate the distance and direction

  if (!session.firstInput) {
    session.firstInput = simpleCloneInputData(input);
  } // to compute scale and rotation we need to store the multiple touches


  if (pointersLength > 1 && !session.firstMultiple) {
    session.firstMultiple = simpleCloneInputData(input);
  } else if (pointersLength === 1) {
    session.firstMultiple = false;
  }

  var firstInput = session.firstInput,
      firstMultiple = session.firstMultiple;
  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
  var center = input.center = getCenter(pointers);
  input.timeStamp = now();
  input.deltaTime = input.timeStamp - firstInput.timeStamp;
  input.angle = getAngle(offsetCenter, center);
  input.distance = getDistance(offsetCenter, center);
  computeDeltaXY(session, input);
  input.offsetDirection = getDirection(input.deltaX, input.deltaY);
  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
  input.overallVelocityX = overallVelocity.x;
  input.overallVelocityY = overallVelocity.y;
  input.overallVelocity = abs$1(overallVelocity.x) > abs$1(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
  computeIntervalInputData(session, input); // find the correct target

  var target = manager.element;
  var srcEvent = input.srcEvent;
  var srcEventTarget;

  if (srcEvent.composedPath) {
    srcEventTarget = srcEvent.composedPath()[0];
  } else if (srcEvent.path) {
    srcEventTarget = srcEvent.path[0];
  } else {
    srcEventTarget = srcEvent.target;
  }

  if (hasParent(srcEventTarget, target)) {
    target = srcEventTarget;
  }

  input.target = target;
}
/**
 * @private
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */


function inputHandler(manager, eventType, input) {
  var pointersLen = input.pointers.length;
  var changedPointersLen = input.changedPointers.length;
  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
  input.isFirst = !!isFirst;
  input.isFinal = !!isFinal;

  if (isFirst) {
    manager.session = {};
  } // source event is the normalized value of the domEvents
  // like 'touchstart, mouseup, pointerdown'


  input.eventType = eventType; // compute scale, rotation etc

  computeInputData(manager, input); // emit secret event

  manager.emit('hammer.input', input);
  manager.recognize(input);
  manager.session.prevInput = input;
}
/**
 * @private
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */


function splitStr(str) {
  return str.trim().split(/\s+/g);
}
/**
 * @private
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */


function addEventListeners(target, types, handler) {
  each(splitStr(types), function (type) {
    target.addEventListener(type, handler, false);
  });
}
/**
 * @private
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */


function removeEventListeners(target, types, handler) {
  each(splitStr(types), function (type) {
    target.removeEventListener(type, handler, false);
  });
}
/**
 * @private
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */


function getWindowForElement(element) {
  var doc = element.ownerDocument || element;
  return doc.defaultView || doc.parentWindow || window;
}
/**
 * @private
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */


var Input = /*#__PURE__*/function () {
  function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.

    this.domHandler = function (ev) {
      if (boolOrFn(manager.options.enable, [manager])) {
        self.handler(ev);
      }
    };

    this.init();
  }
  /**
   * @private
   * should handle the inputEvent data and trigger the callback
   * @virtual
   */


  var _proto = Input.prototype;

  _proto.handler = function handler() {};
  /**
   * @private
   * bind the events
   */


  _proto.init = function init() {
    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  };
  /**
   * @private
   * unbind the events
   */


  _proto.destroy = function destroy() {
    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  };

  return Input;
}();
/**
 * @private
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */


function inArray(src, find, findByKey) {
  if (src.indexOf && !findByKey) {
    return src.indexOf(find);
  } else {
    var i = 0;

    while (i < src.length) {
      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
        // do not use === here, test fails
        return i;
      }

      i++;
    }

    return -1;
  }
}

var POINTER_INPUT_MAP = {
  pointerdown: INPUT_START,
  pointermove: INPUT_MOVE,
  pointerup: INPUT_END,
  pointercancel: INPUT_CANCEL,
  pointerout: INPUT_CANCEL
}; // in IE10 the pointer types is defined as an enum

var IE10_POINTER_TYPE_ENUM = {
  2: INPUT_TYPE_TOUCH,
  3: INPUT_TYPE_PEN,
  4: INPUT_TYPE_MOUSE,
  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816

};
var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

if (win.MSPointerEvent && !win.PointerEvent) {
  POINTER_ELEMENT_EVENTS = 'MSPointerDown';
  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}
/**
 * @private
 * Pointer events input
 * @constructor
 * @extends Input
 */


var PointerEventInput = /*#__PURE__*/function (_Input) {
  _inheritsLoose(PointerEventInput, _Input);

  function PointerEventInput() {
    var _this;

    var proto = PointerEventInput.prototype;
    proto.evEl = POINTER_ELEMENT_EVENTS;
    proto.evWin = POINTER_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.store = _this.manager.session.pointerEvents = [];
    return _this;
  }
  /**
   * @private
   * handle mouse events
   * @param {Object} ev
   */


  var _proto = PointerEventInput.prototype;

  _proto.handler = function handler(ev) {
    var store = this.store;
    var removePointer = false;
    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store

    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
      if (storeIndex < 0) {
        store.push(ev);
        storeIndex = store.length - 1;
      }
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
      removePointer = true;
    } // it not found, so the pointer hasn't been down (so it's probably a hover)


    if (storeIndex < 0) {
      return;
    } // update the event in the store


    store[storeIndex] = ev;
    this.callback(this.manager, eventType, {
      pointers: store,
      changedPointers: [ev],
      pointerType: pointerType,
      srcEvent: ev
    });

    if (removePointer) {
      // remove from the store
      store.splice(storeIndex, 1);
    }
  };

  return PointerEventInput;
}(Input);
/**
 * @private
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */


function toArray(obj) {
  return Array.prototype.slice.call(obj, 0);
}
/**
 * @private
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */


function uniqueArray(src, key, sort) {
  var results = [];
  var values = [];
  var i = 0;

  while (i < src.length) {
    var val = key ? src[i][key] : src[i];

    if (inArray(values, val) < 0) {
      results.push(src[i]);
    }

    values[i] = val;
    i++;
  }

  if (sort) {
    if (!key) {
      results = results.sort();
    } else {
      results = results.sort(function (a, b) {
        return a[key] > b[key];
      });
    }
  }

  return results;
}

var TOUCH_INPUT_MAP = {
  touchstart: INPUT_START,
  touchmove: INPUT_MOVE,
  touchend: INPUT_END,
  touchcancel: INPUT_CANCEL
};
var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
/**
 * @private
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */

var TouchInput = /*#__PURE__*/function (_Input) {
  _inheritsLoose(TouchInput, _Input);

  function TouchInput() {
    var _this;

    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;

    return _this;
  }

  var _proto = TouchInput.prototype;

  _proto.handler = function handler(ev) {
    var type = TOUCH_INPUT_MAP[ev.type];
    var touches = getTouches.call(this, ev, type);

    if (!touches) {
      return;
    }

    this.callback(this.manager, type, {
      pointers: touches[0],
      changedPointers: touches[1],
      pointerType: INPUT_TYPE_TOUCH,
      srcEvent: ev
    });
  };

  return TouchInput;
}(Input);

function getTouches(ev, type) {
  var allTouches = toArray(ev.touches);
  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
    targetIds[allTouches[0].identifier] = true;
    return [allTouches, allTouches];
  }

  var i;
  var targetTouches;
  var changedTouches = toArray(ev.changedTouches);
  var changedTargetTouches = [];
  var target = this.target; // get target touches from touches

  targetTouches = allTouches.filter(function (touch) {
    return hasParent(touch.target, target);
  }); // collect touches

  if (type === INPUT_START) {
    i = 0;

    while (i < targetTouches.length) {
      targetIds[targetTouches[i].identifier] = true;
      i++;
    }
  } // filter changed touches to only contain touches that exist in the collected target ids


  i = 0;

  while (i < changedTouches.length) {
    if (targetIds[changedTouches[i].identifier]) {
      changedTargetTouches.push(changedTouches[i]);
    } // cleanup removed touches


    if (type & (INPUT_END | INPUT_CANCEL)) {
      delete targetIds[changedTouches[i].identifier];
    }

    i++;
  }

  if (!changedTargetTouches.length) {
    return;
  }

  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
}

var MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};
var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
/**
 * @private
 * Mouse events input
 * @constructor
 * @extends Input
 */

var MouseInput = /*#__PURE__*/function (_Input) {
  _inheritsLoose(MouseInput, _Input);

  function MouseInput() {
    var _this;

    var proto = MouseInput.prototype;
    proto.evEl = MOUSE_ELEMENT_EVENTS;
    proto.evWin = MOUSE_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.pressed = false; // mousedown state

    return _this;
  }
  /**
   * @private
   * handle mouse events
   * @param {Object} ev
   */


  var _proto = MouseInput.prototype;

  _proto.handler = function handler(ev) {
    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

    if (eventType & INPUT_START && ev.button === 0) {
      this.pressed = true;
    }

    if (eventType & INPUT_MOVE && ev.which !== 1) {
      eventType = INPUT_END;
    } // mouse must be down


    if (!this.pressed) {
      return;
    }

    if (eventType & INPUT_END) {
      this.pressed = false;
    }

    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: INPUT_TYPE_MOUSE,
      srcEvent: ev
    });
  };

  return MouseInput;
}(Input);
/**
 * @private
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */


var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function setLastTouch(eventData) {
  var _eventData$changedPoi = eventData.changedPointers,
      touch = _eventData$changedPoi[0];

  if (touch.identifier === this.primaryTouch) {
    var lastTouch = {
      x: touch.clientX,
      y: touch.clientY
    };
    var lts = this.lastTouches;
    this.lastTouches.push(lastTouch);

    var removeLastTouch = function removeLastTouch() {
      var i = lts.indexOf(lastTouch);

      if (i > -1) {
        lts.splice(i, 1);
      }
    };

    setTimeout(removeLastTouch, DEDUP_TIMEOUT);
  }
}

function recordTouches(eventType, eventData) {
  if (eventType & INPUT_START) {
    this.primaryTouch = eventData.changedPointers[0].identifier;
    setLastTouch.call(this, eventData);
  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
    setLastTouch.call(this, eventData);
  }
}

function isSyntheticEvent(eventData) {
  var x = eventData.srcEvent.clientX;
  var y = eventData.srcEvent.clientY;

  for (var i = 0; i < this.lastTouches.length; i++) {
    var t = this.lastTouches[i];
    var dx = Math.abs(x - t.x);
    var dy = Math.abs(y - t.y);

    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
      return true;
    }
  }

  return false;
}

var TouchMouseInput = /*#__PURE__*/function () {
  var TouchMouseInput = /*#__PURE__*/function (_Input) {
    _inheritsLoose(TouchMouseInput, _Input);

    function TouchMouseInput(_manager, callback) {
      var _this;

      _this = _Input.call(this, _manager, callback) || this;

      _this.handler = function (manager, inputEvent, inputData) {
        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;
        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
          return;
        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event


        if (isTouch) {
          recordTouches.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputData)) {
          return;
        }

        _this.callback(manager, inputEvent, inputData);
      };

      _this.touch = new TouchInput(_this.manager, _this.handler);
      _this.mouse = new MouseInput(_this.manager, _this.handler);
      _this.primaryTouch = null;
      _this.lastTouches = [];
      return _this;
    }
    /**
     * @private
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */


    var _proto = TouchMouseInput.prototype;
    /**
     * @private
     * remove the event listeners
     */

    _proto.destroy = function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    };

    return TouchMouseInput;
  }(Input);

  return TouchMouseInput;
}();
/**
 * @private
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */


function createInputInstance(manager) {
  var Type; // let inputClass = manager.options.inputClass;

  var inputClass = manager.options.inputClass;

  if (inputClass) {
    Type = inputClass;
  } else if (SUPPORT_POINTER_EVENTS) {
    Type = PointerEventInput;
  } else if (SUPPORT_ONLY_TOUCH) {
    Type = TouchInput;
  } else if (!SUPPORT_TOUCH) {
    Type = MouseInput;
  } else {
    Type = TouchMouseInput;
  }

  return new Type(manager, inputHandler);
}
/**
 * @private
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */


function invokeArrayArg(arg, fn, context) {
  if (Array.isArray(arg)) {
    each(arg, context[fn], context);
    return true;
  }

  return false;
}

var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;
/**
 * @private
 * get a unique id
 * @returns {number} uniqueId
 */

var _uniqueId = 1;

function uniqueId() {
  return _uniqueId++;
}
/**
 * @private
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */


function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
  var manager = recognizer.manager;

  if (manager) {
    return manager.get(otherRecognizer);
  }

  return otherRecognizer;
}
/**
 * @private
 * get a usable string, used as event postfix
 * @param {constant} state
 * @returns {String} state
 */


function stateStr(state) {
  if (state & STATE_CANCELLED) {
    return 'cancel';
  } else if (state & STATE_ENDED) {
    return 'end';
  } else if (state & STATE_CHANGED) {
    return 'move';
  } else if (state & STATE_BEGAN) {
    return 'start';
  }

  return '';
}
/**
 * @private
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */

/**
 * @private
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */


var Recognizer = /*#__PURE__*/function () {
  function Recognizer(options) {
    if (options === void 0) {
      options = {};
    }

    this.options = _extends({
      enable: true
    }, options);
    this.id = uniqueId();
    this.manager = null; // default is enable true

    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
  }
  /**
   * @private
   * set options
   * @param {Object} options
   * @return {Recognizer}
   */


  var _proto = Recognizer.prototype;

  _proto.set = function set(options) {
    assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

    this.manager && this.manager.touchAction.update();
    return this;
  };
  /**
   * @private
   * recognize simultaneous with an other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.recognizeWith = function recognizeWith(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
      return this;
    }

    var simultaneous = this.simultaneous;
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

    if (!simultaneous[otherRecognizer.id]) {
      simultaneous[otherRecognizer.id] = otherRecognizer;
      otherRecognizer.recognizeWith(this);
    }

    return this;
  };
  /**
   * @private
   * drop the simultaneous link. it doesnt remove the link on the other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
      return this;
    }

    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    delete this.simultaneous[otherRecognizer.id];
    return this;
  };
  /**
   * @private
   * recognizer can only run when an other is failing
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.requireFailure = function requireFailure(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
      return this;
    }

    var requireFail = this.requireFail;
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

    if (inArray(requireFail, otherRecognizer) === -1) {
      requireFail.push(otherRecognizer);
      otherRecognizer.requireFailure(this);
    }

    return this;
  };
  /**
   * @private
   * drop the requireFailure link. it does not remove the link on the other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */


  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
      return this;
    }

    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    var index = inArray(this.requireFail, otherRecognizer);

    if (index > -1) {
      this.requireFail.splice(index, 1);
    }

    return this;
  };
  /**
   * @private
   * has require failures boolean
   * @returns {boolean}
   */


  _proto.hasRequireFailures = function hasRequireFailures() {
    return this.requireFail.length > 0;
  };
  /**
   * @private
   * if the recognizer can recognize simultaneous with an other recognizer
   * @param {Recognizer} otherRecognizer
   * @returns {Boolean}
   */


  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {
    return !!this.simultaneous[otherRecognizer.id];
  };
  /**
   * @private
   * You should use `tryEmit` instead of `emit` directly to check
   * that all the needed recognizers has failed before emitting.
   * @param {Object} input
   */


  _proto.emit = function emit(input) {
    var self = this;
    var state = this.state;

    function emit(event) {
      self.manager.emit(event, input);
    } // 'panstart' and 'panmove'


    if (state < STATE_ENDED) {
      emit(self.options.event + stateStr(state));
    }

    emit(self.options.event); // simple 'eventName' events

    if (input.additionalEvent) {
      // additional event(panleft, panright, pinchin, pinchout...)
      emit(input.additionalEvent);
    } // panend and pancancel


    if (state >= STATE_ENDED) {
      emit(self.options.event + stateStr(state));
    }
  };
  /**
   * @private
   * Check that all the require failure recognizers has failed,
   * if true, it emits a gesture event,
   * otherwise, setup the state to FAILED.
   * @param {Object} input
   */


  _proto.tryEmit = function tryEmit(input) {
    if (this.canEmit()) {
      return this.emit(input);
    } // it's failing anyway


    this.state = STATE_FAILED;
  };
  /**
   * @private
   * can we emit?
   * @returns {boolean}
   */


  _proto.canEmit = function canEmit() {
    var i = 0;

    while (i < this.requireFail.length) {
      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
        return false;
      }

      i++;
    }

    return true;
  };
  /**
   * @private
   * update the recognizer
   * @param {Object} inputData
   */


  _proto.recognize = function recognize(inputData) {
    // make a new copy of the inputData
    // so we can change the inputData without messing up the other recognizers
    var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?

    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
      this.reset();
      this.state = STATE_FAILED;
      return;
    } // reset when we've reached the end


    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
      this.state = STATE_POSSIBLE;
    }

    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
    // so trigger an event

    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
      this.tryEmit(inputDataClone);
    }
  };
  /**
   * @private
   * return the state of the recognizer
   * the actual recognizing happens in this method
   * @virtual
   * @param {Object} inputData
   * @returns {constant} STATE
   */

  /* jshint ignore:start */


  _proto.process = function process(inputData) {};
  /* jshint ignore:end */

  /**
   * @private
   * return the preferred touch-action
   * @virtual
   * @returns {Array}
   */


  _proto.getTouchAction = function getTouchAction() {};
  /**
   * @private
   * called when the gesture isn't allowed to recognize
   * like when another is being recognized or it is disabled
   * @virtual
   */


  _proto.reset = function reset() {};

  return Recognizer;
}();
/**
 * @private
 * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */


var TapRecognizer = /*#__PURE__*/function (_Recognizer) {
  _inheritsLoose(TapRecognizer, _Recognizer);

  function TapRecognizer(options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _Recognizer.call(this, _extends({
      event: 'tap',
      pointers: 1,
      taps: 1,
      interval: 300,
      // max time between the multi-tap taps
      time: 250,
      // max time of the pointer to be down (like finger on the screen)
      threshold: 9,
      // a minimal movement is ok, but keep it low
      posThreshold: 10
    }, options)) || this; // previous time and center,
    // used for tap counting

    _this.pTime = false;
    _this.pCenter = false;
    _this._timer = null;
    _this._input = null;
    _this.count = 0;
    return _this;
  }

  var _proto = TapRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_MANIPULATION];
  };

  _proto.process = function process(input) {
    var _this2 = this;

    var options = this.options;
    var validPointers = input.pointers.length === options.pointers;
    var validMovement = input.distance < options.threshold;
    var validTouchTime = input.deltaTime < options.time;
    this.reset();

    if (input.eventType & INPUT_START && this.count === 0) {
      return this.failTimeout();
    } // we only allow little movement
    // and we've reached an end event, so a tap is possible


    if (validMovement && validTouchTime && validPointers) {
      if (input.eventType !== INPUT_END) {
        return this.failTimeout();
      }

      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
      this.pTime = input.timeStamp;
      this.pCenter = input.center;

      if (!validMultiTap || !validInterval) {
        this.count = 1;
      } else {
        this.count += 1;
      }

      this._input = input; // if tap count matches we have recognized it,
      // else it has began recognizing...

      var tapCount = this.count % options.taps;

      if (tapCount === 0) {
        // no failing requirements, immediately trigger the tap event
        // or wait as long as the multitap interval to trigger
        if (!this.hasRequireFailures()) {
          return STATE_RECOGNIZED;
        } else {
          this._timer = setTimeout(function () {
            _this2.state = STATE_RECOGNIZED;

            _this2.tryEmit();
          }, options.interval);
          return STATE_BEGAN;
        }
      }
    }

    return STATE_FAILED;
  };

  _proto.failTimeout = function failTimeout() {
    var _this3 = this;

    this._timer = setTimeout(function () {
      _this3.state = STATE_FAILED;
    }, this.options.interval);
    return STATE_FAILED;
  };

  _proto.reset = function reset() {
    clearTimeout(this._timer);
  };

  _proto.emit = function emit() {
    if (this.state === STATE_RECOGNIZED) {
      this._input.tapCount = this.count;
      this.manager.emit(this.options.event, this._input);
    }
  };

  return TapRecognizer;
}(Recognizer);
/**
 * @private
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */


var AttrRecognizer = /*#__PURE__*/function (_Recognizer) {
  _inheritsLoose(AttrRecognizer, _Recognizer);

  function AttrRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _Recognizer.call(this, _extends({
      pointers: 1
    }, options)) || this;
  }
  /**
   * @private
   * Used to check if it the recognizer receives valid input, like input.distance > 10.
   * @memberof AttrRecognizer
   * @param {Object} input
   * @returns {Boolean} recognized
   */


  var _proto = AttrRecognizer.prototype;

  _proto.attrTest = function attrTest(input) {
    var optionPointers = this.options.pointers;
    return optionPointers === 0 || input.pointers.length === optionPointers;
  };
  /**
   * @private
   * Process the input and return the state for the recognizer
   * @memberof AttrRecognizer
   * @param {Object} input
   * @returns {*} State
   */


  _proto.process = function process(input) {
    var state = this.state;
    var eventType = input.eventType;
    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
      return state | STATE_CANCELLED;
    } else if (isRecognized || isValid) {
      if (eventType & INPUT_END) {
        return state | STATE_ENDED;
      } else if (!(state & STATE_BEGAN)) {
        return STATE_BEGAN;
      }

      return state | STATE_CHANGED;
    }

    return STATE_FAILED;
  };

  return AttrRecognizer;
}(Recognizer);
/**
 * @private
 * direction cons to string
 * @param {constant} direction
 * @returns {String}
 */


function directionStr(direction) {
  if (direction === DIRECTION_DOWN) {
    return 'down';
  } else if (direction === DIRECTION_UP) {
    return 'up';
  } else if (direction === DIRECTION_LEFT) {
    return 'left';
  } else if (direction === DIRECTION_RIGHT) {
    return 'right';
  }

  return '';
}
/**
 * @private
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */


var PanRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
  _inheritsLoose(PanRecognizer, _AttrRecognizer);

  function PanRecognizer(options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _AttrRecognizer.call(this, _extends({
      event: 'pan',
      threshold: 10,
      pointers: 1,
      direction: DIRECTION_ALL
    }, options)) || this;
    _this.pX = null;
    _this.pY = null;
    return _this;
  }

  var _proto = PanRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    var direction = this.options.direction;
    var actions = [];

    if (direction & DIRECTION_HORIZONTAL) {
      actions.push(TOUCH_ACTION_PAN_Y);
    }

    if (direction & DIRECTION_VERTICAL) {
      actions.push(TOUCH_ACTION_PAN_X);
    }

    return actions;
  };

  _proto.directionTest = function directionTest(input) {
    var options = this.options;
    var hasMoved = true;
    var distance = input.distance;
    var direction = input.direction;
    var x = input.deltaX;
    var y = input.deltaY; // lock to axis?

    if (!(direction & options.direction)) {
      if (options.direction & DIRECTION_HORIZONTAL) {
        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        hasMoved = x !== this.pX;
        distance = Math.abs(input.deltaX);
      } else {
        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        hasMoved = y !== this.pY;
        distance = Math.abs(input.deltaY);
      }
    }

    input.direction = direction;
    return hasMoved && distance > options.threshold && direction & options.direction;
  };

  _proto.attrTest = function attrTest(input) {
    return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call
    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
  };

  _proto.emit = function emit(input) {
    this.pX = input.deltaX;
    this.pY = input.deltaY;
    var direction = directionStr(input.direction);

    if (direction) {
      input.additionalEvent = this.options.event + direction;
    }

    _AttrRecognizer.prototype.emit.call(this, input);
  };

  return PanRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */


var SwipeRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);

  function SwipeRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _AttrRecognizer.call(this, _extends({
      event: 'swipe',
      threshold: 10,
      velocity: 0.3,
      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
      pointers: 1
    }, options)) || this;
  }

  var _proto = SwipeRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return PanRecognizer.prototype.getTouchAction.call(this);
  };

  _proto.attrTest = function attrTest(input) {
    var direction = this.options.direction;
    var velocity;

    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
      velocity = input.overallVelocity;
    } else if (direction & DIRECTION_HORIZONTAL) {
      velocity = input.overallVelocityX;
    } else if (direction & DIRECTION_VERTICAL) {
      velocity = input.overallVelocityY;
    }

    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs$1(velocity) > this.options.velocity && input.eventType & INPUT_END;
  };

  _proto.emit = function emit(input) {
    var direction = directionStr(input.offsetDirection);

    if (direction) {
      this.manager.emit(this.options.event + direction, input);
    }

    this.manager.emit(this.options.event, input);
  };

  return SwipeRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */


var PinchRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
  _inheritsLoose(PinchRecognizer, _AttrRecognizer);

  function PinchRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _AttrRecognizer.call(this, _extends({
      event: 'pinch',
      threshold: 0,
      pointers: 2
    }, options)) || this;
  }

  var _proto = PinchRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_NONE];
  };

  _proto.attrTest = function attrTest(input) {
    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
  };

  _proto.emit = function emit(input) {
    if (input.scale !== 1) {
      var inOut = input.scale < 1 ? 'in' : 'out';
      input.additionalEvent = this.options.event + inOut;
    }

    _AttrRecognizer.prototype.emit.call(this, input);
  };

  return PinchRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */


var RotateRecognizer = /*#__PURE__*/function (_AttrRecognizer) {
  _inheritsLoose(RotateRecognizer, _AttrRecognizer);

  function RotateRecognizer(options) {
    if (options === void 0) {
      options = {};
    }

    return _AttrRecognizer.call(this, _extends({
      event: 'rotate',
      threshold: 0,
      pointers: 2
    }, options)) || this;
  }

  var _proto = RotateRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_NONE];
  };

  _proto.attrTest = function attrTest(input) {
    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
  };

  return RotateRecognizer;
}(AttrRecognizer);
/**
 * @private
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */


var PressRecognizer = /*#__PURE__*/function (_Recognizer) {
  _inheritsLoose(PressRecognizer, _Recognizer);

  function PressRecognizer(options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _Recognizer.call(this, _extends({
      event: 'press',
      pointers: 1,
      time: 251,
      // minimal time of the pointer to be pressed
      threshold: 9
    }, options)) || this;
    _this._timer = null;
    _this._input = null;
    return _this;
  }

  var _proto = PressRecognizer.prototype;

  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_AUTO];
  };

  _proto.process = function process(input) {
    var _this2 = this;

    var options = this.options;
    var validPointers = input.pointers.length === options.pointers;
    var validMovement = input.distance < options.threshold;
    var validTime = input.deltaTime > options.time;
    this._input = input; // we only allow little movement
    // and we've reached an end event, so a tap is possible

    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
      this.reset();
    } else if (input.eventType & INPUT_START) {
      this.reset();
      this._timer = setTimeout(function () {
        _this2.state = STATE_RECOGNIZED;

        _this2.tryEmit();
      }, options.time);
    } else if (input.eventType & INPUT_END) {
      return STATE_RECOGNIZED;
    }

    return STATE_FAILED;
  };

  _proto.reset = function reset() {
    clearTimeout(this._timer);
  };

  _proto.emit = function emit(input) {
    if (this.state !== STATE_RECOGNIZED) {
      return;
    }

    if (input && input.eventType & INPUT_END) {
      this.manager.emit(this.options.event + "up", input);
    } else {
      this._input.timeStamp = now();
      this.manager.emit(this.options.event, this._input);
    }
  };

  return PressRecognizer;
}(Recognizer);

var defaults = {
  /**
   * @private
   * set if DOM events are being triggered.
   * But this is slower and unused by simple implementations, so disabled by default.
   * @type {Boolean}
   * @default false
   */
  domEvents: false,

  /**
   * @private
   * The value for the touchAction property/fallback.
   * When set to `compute` it will magically set the correct value based on the added recognizers.
   * @type {String}
   * @default compute
   */
  touchAction: TOUCH_ACTION_COMPUTE,

  /**
   * @private
   * @type {Boolean}
   * @default true
   */
  enable: true,

  /**
   * @private
   * EXPERIMENTAL FEATURE -- can be removed/changed
   * Change the parent input target element.
   * If Null, then it is being set the to main element.
   * @type {Null|EventTarget}
   * @default null
   */
  inputTarget: null,

  /**
   * @private
   * force an input class
   * @type {Null|Function}
   * @default null
   */
  inputClass: null,

  /**
   * @private
   * Some CSS properties can be used to improve the working of Hammer.
   * Add them to this method and they will be set when creating a new Manager.
   * @namespace
   */
  cssProps: {
    /**
     * @private
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */
    userSelect: "none",

    /**
     * @private
     * Disable the Windows Phone grippers when pressing an element.
     * @type {String}
     * @default 'none'
     */
    touchSelect: "none",

    /**
     * @private
     * Disables the default callout shown when you touch and hold a touch target.
     * On iOS, when you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     * @type {String}
     * @default 'none'
     */
    touchCallout: "none",

    /**
     * @private
     * Specifies whether zooming is enabled. Used by IE10>
     * @type {String}
     * @default 'none'
     */
    contentZooming: "none",

    /**
     * @private
     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */
    userDrag: "none",

    /**
     * @private
     * Overrides the highlight color shown when the user taps a link or a JavaScript
     * clickable element in iOS. This property obeys the alpha value, if specified.
     * @type {String}
     * @default 'rgba(0,0,0,0)'
     */
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};
/**
 * @private
 * Default recognizer setup when calling `Hammer()`
 * When creating a new Manager these will be skipped.
 * This is separated with other defaults because of tree-shaking.
 * @type {Array}
 */

var preset = [[RotateRecognizer, {
  enable: false
}], [PinchRecognizer, {
  enable: false
}, ['rotate']], [SwipeRecognizer, {
  direction: DIRECTION_HORIZONTAL
}], [PanRecognizer, {
  direction: DIRECTION_HORIZONTAL
}, ['swipe']], [TapRecognizer], [TapRecognizer, {
  event: 'doubletap',
  taps: 2
}, ['tap']], [PressRecognizer]];
var STOP = 1;
var FORCED_STOP = 2;
/**
 * @private
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */

function toggleCssProps(manager, add) {
  var element = manager.element;

  if (!element.style) {
    return;
  }

  var prop;
  each(manager.options.cssProps, function (value, name) {
    prop = prefixed(element.style, name);

    if (add) {
      manager.oldCssProps[prop] = element.style[prop];
      element.style[prop] = value;
    } else {
      element.style[prop] = manager.oldCssProps[prop] || "";
    }
  });

  if (!add) {
    manager.oldCssProps = {};
  }
}
/**
 * @private
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */


function triggerDomEvent(event, data) {
  var gestureEvent = document.createEvent("Event");
  gestureEvent.initEvent(event, true, true);
  gestureEvent.gesture = data;
  data.target.dispatchEvent(gestureEvent);
}
/**
* @private
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */


var Manager = /*#__PURE__*/function () {
  function Manager(element, options) {
    var _this = this;

    this.options = assign$1({}, defaults, options || {});
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};
    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(this.options.recognizers, function (item) {
      var recognizer = _this.add(new item[0](item[1]));

      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }
  /**
   * @private
   * set options
   * @param {Object} options
   * @returns {Manager}
   */


  var _proto = Manager.prototype;

  _proto.set = function set(options) {
    assign$1(this.options, options); // Options that need a little more setup

    if (options.touchAction) {
      this.touchAction.update();
    }

    if (options.inputTarget) {
      // Clean up existing event listeners and reinitialize
      this.input.destroy();
      this.input.target = options.inputTarget;
      this.input.init();
    }

    return this;
  };
  /**
   * @private
   * stop recognizing for this session.
   * This session will be discarded, when a new [input]start event is fired.
   * When forced, the recognizer cycle is stopped immediately.
   * @param {Boolean} [force]
   */


  _proto.stop = function stop(force) {
    this.session.stopped = force ? FORCED_STOP : STOP;
  };
  /**
   * @private
   * run the recognizers!
   * called by the inputHandler function on every movement of the pointers (touches)
   * it walks through all the recognizers and tries to detect the gesture that is being made
   * @param {Object} inputData
   */


  _proto.recognize = function recognize(inputData) {
    var session = this.session;

    if (session.stopped) {
      return;
    } // run the touch-action polyfill


    this.touchAction.preventDefaults(inputData);
    var recognizer;
    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
    // if no recognizer is detecting a thing, it is set to `null`

    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
    // or when we're in a new session

    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
      session.curRecognizer = null;
      curRecognizer = null;
    }

    var i = 0;

    while (i < recognizers.length) {
      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
      // 1.   allow if the session is NOT forced stopped (see the .stop() method)
      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
      //      that is being recognized.
      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
      //      this can be setup with the `recognizeWith()` method on the recognizer.

      if (session.stopped !== FORCED_STOP && ( // 1
      !curRecognizer || recognizer === curRecognizer || // 2
      recognizer.canRecognizeWith(curRecognizer))) {
        // 3
        recognizer.recognize(inputData);
      } else {
        recognizer.reset();
      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
      // current active recognizer. but only if we don't already have an active recognizer


      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
        session.curRecognizer = recognizer;
        curRecognizer = recognizer;
      }

      i++;
    }
  };
  /**
   * @private
   * get a recognizer by its event name.
   * @param {Recognizer|String} recognizer
   * @returns {Recognizer|Null}
   */


  _proto.get = function get(recognizer) {
    if (recognizer instanceof Recognizer) {
      return recognizer;
    }

    var recognizers = this.recognizers;

    for (var i = 0; i < recognizers.length; i++) {
      if (recognizers[i].options.event === recognizer) {
        return recognizers[i];
      }
    }

    return null;
  };
  /**
   * @private add a recognizer to the manager
   * existing recognizers with the same event name will be removed
   * @param {Recognizer} recognizer
   * @returns {Recognizer|Manager}
   */


  _proto.add = function add(recognizer) {
    if (invokeArrayArg(recognizer, "add", this)) {
      return this;
    } // remove existing


    var existing = this.get(recognizer.options.event);

    if (existing) {
      this.remove(existing);
    }

    this.recognizers.push(recognizer);
    recognizer.manager = this;
    this.touchAction.update();
    return recognizer;
  };
  /**
   * @private
   * remove a recognizer by name or instance
   * @param {Recognizer|String} recognizer
   * @returns {Manager}
   */


  _proto.remove = function remove(recognizer) {
    if (invokeArrayArg(recognizer, "remove", this)) {
      return this;
    }

    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists

    if (recognizer) {
      var recognizers = this.recognizers;
      var index = inArray(recognizers, targetRecognizer);

      if (index !== -1) {
        recognizers.splice(index, 1);
        this.touchAction.update();
      }
    }

    return this;
  };
  /**
   * @private
   * bind event
   * @param {String} events
   * @param {Function} handler
   * @returns {EventEmitter} this
   */


  _proto.on = function on(events, handler) {
    if (events === undefined || handler === undefined) {
      return this;
    }

    var handlers = this.handlers;
    each(splitStr(events), function (event) {
      handlers[event] = handlers[event] || [];
      handlers[event].push(handler);
    });
    return this;
  };
  /**
   * @private unbind event, leave emit blank to remove all handlers
   * @param {String} events
   * @param {Function} [handler]
   * @returns {EventEmitter} this
   */


  _proto.off = function off(events, handler) {
    if (events === undefined) {
      return this;
    }

    var handlers = this.handlers;
    each(splitStr(events), function (event) {
      if (!handler) {
        delete handlers[event];
      } else {
        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
      }
    });
    return this;
  };
  /**
   * @private emit event to the listeners
   * @param {String} event
   * @param {Object} data
   */


  _proto.emit = function emit(event, data) {
    // we also want to trigger dom events
    if (this.options.domEvents) {
      triggerDomEvent(event, data);
    } // no handlers, so skip it all


    var handlers = this.handlers[event] && this.handlers[event].slice();

    if (!handlers || !handlers.length) {
      return;
    }

    data.type = event;

    data.preventDefault = function () {
      data.srcEvent.preventDefault();
    };

    var i = 0;

    while (i < handlers.length) {
      handlers[i](data);
      i++;
    }
  };
  /**
   * @private
   * destroy the manager and unbinds all events
   * it doesn't unbind dom events, that is the user own responsibility
   */


  _proto.destroy = function destroy() {
    this.element && toggleCssProps(this, false);
    this.handlers = {};
    this.session = {};
    this.input.destroy();
    this.element = null;
  };

  return Manager;
}();

var SINGLE_TOUCH_INPUT_MAP = {
  touchstart: INPUT_START,
  touchmove: INPUT_MOVE,
  touchend: INPUT_END,
  touchcancel: INPUT_CANCEL
};
var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
/**
 * @private
 * Touch events input
 * @constructor
 * @extends Input
 */

var SingleTouchInput = /*#__PURE__*/function (_Input) {
  _inheritsLoose(SingleTouchInput, _Input);

  function SingleTouchInput() {
    var _this;

    var proto = SingleTouchInput.prototype;
    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.started = false;
    return _this;
  }

  var _proto = SingleTouchInput.prototype;

  _proto.handler = function handler(ev) {
    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

    if (type === INPUT_START) {
      this.started = true;
    }

    if (!this.started) {
      return;
    }

    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
      this.started = false;
    }

    this.callback(this.manager, type, {
      pointers: touches[0],
      changedPointers: touches[1],
      pointerType: INPUT_TYPE_TOUCH,
      srcEvent: ev
    });
  };

  return SingleTouchInput;
}(Input);

function normalizeSingleTouches(ev, type) {
  var all = toArray(ev.touches);
  var changed = toArray(ev.changedTouches);

  if (type & (INPUT_END | INPUT_CANCEL)) {
    all = uniqueArray(all.concat(changed), 'identifier', true);
  }

  return [all, changed];
}
/**
 * @private
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */


function deprecate(method, name, message) {
  var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
  return function () {
    var e = new Error('get-stack-trace');
    var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
    var log = window.console && (window.console.warn || window.console.log);

    if (log) {
      log.call(window.console, deprecationMessage, stack);
    }

    return method.apply(this, arguments);
  };
}
/**
 * @private
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */


var extend = deprecate(function (dest, src, merge) {
  var keys = Object.keys(src);
  var i = 0;

  while (i < keys.length) {
    if (!merge || merge && dest[keys[i]] === undefined) {
      dest[keys[i]] = src[keys[i]];
    }

    i++;
  }

  return dest;
}, 'extend', 'Use `assign`.');
/**
 * @private
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */

var merge$2 = deprecate(function (dest, src) {
  return extend(dest, src, true);
}, 'merge', 'Use `assign`.');
/**
 * @private
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */

function inherit(child, base, properties) {
  var baseP = base.prototype;
  var childP;
  childP = child.prototype = Object.create(baseP);
  childP.constructor = child;
  childP._super = baseP;

  if (properties) {
    assign$1(childP, properties);
  }
}
/**
 * @private
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */


function bindFn(fn, context) {
  return function boundFn() {
    return fn.apply(context, arguments);
  };
}
/**
 * @private
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */


var Hammer$2 = /*#__PURE__*/function () {
  var Hammer =
  /**
    * @private
    * @const {string}
    */
  function Hammer(element, options) {
    if (options === void 0) {
      options = {};
    }

    return new Manager(element, _extends({
      recognizers: preset.concat()
    }, options));
  };

  Hammer.VERSION = "2.0.17-rc";
  Hammer.DIRECTION_ALL = DIRECTION_ALL;
  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;
  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;
  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;
  Hammer.DIRECTION_UP = DIRECTION_UP;
  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
  Hammer.DIRECTION_NONE = DIRECTION_NONE;
  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;
  Hammer.INPUT_START = INPUT_START;
  Hammer.INPUT_MOVE = INPUT_MOVE;
  Hammer.INPUT_END = INPUT_END;
  Hammer.INPUT_CANCEL = INPUT_CANCEL;
  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;
  Hammer.STATE_BEGAN = STATE_BEGAN;
  Hammer.STATE_CHANGED = STATE_CHANGED;
  Hammer.STATE_ENDED = STATE_ENDED;
  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;
  Hammer.STATE_CANCELLED = STATE_CANCELLED;
  Hammer.STATE_FAILED = STATE_FAILED;
  Hammer.Manager = Manager;
  Hammer.Input = Input;
  Hammer.TouchAction = TouchAction;
  Hammer.TouchInput = TouchInput;
  Hammer.MouseInput = MouseInput;
  Hammer.PointerEventInput = PointerEventInput;
  Hammer.TouchMouseInput = TouchMouseInput;
  Hammer.SingleTouchInput = SingleTouchInput;
  Hammer.Recognizer = Recognizer;
  Hammer.AttrRecognizer = AttrRecognizer;
  Hammer.Tap = TapRecognizer;
  Hammer.Pan = PanRecognizer;
  Hammer.Swipe = SwipeRecognizer;
  Hammer.Pinch = PinchRecognizer;
  Hammer.Rotate = RotateRecognizer;
  Hammer.Press = PressRecognizer;
  Hammer.on = addEventListeners;
  Hammer.off = removeEventListeners;
  Hammer.each = each;
  Hammer.merge = merge$2;
  Hammer.extend = extend;
  Hammer.bindFn = bindFn;
  Hammer.assign = assign$1;
  Hammer.inherit = inherit;
  Hammer.bindFn = bindFn;
  Hammer.prefixed = prefixed;
  Hammer.toArray = toArray;
  Hammer.inArray = inArray;
  Hammer.uniqueArray = uniqueArray;
  Hammer.splitStr = splitStr;
  Hammer.boolOrFn = boolOrFn;
  Hammer.hasParent = hasParent;
  Hammer.addEventListeners = addEventListeners;
  Hammer.removeEventListeners = removeEventListeners;
  Hammer.defaults = assign$1({}, defaults, {
    preset: preset
  });
  return Hammer;
}(); //  style loader but by script tag, not by the loader.
var RealHammer = Hammer$2;

function _createForOfIteratorHelper$8(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$8(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$8(o, minLen) { var _context21; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$8(o, minLen); var n = slice(_context21 = Object.prototype.toString.call(o)).call(_context21, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen); }

function _arrayLikeToArray$8(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Use this symbol to delete properies in deepObjectAssign.
 */

var DELETE = symbol("DELETE");
/**
 * Pure version of deepObjectAssign, it doesn't modify any of it's arguments.
 *
 * @param base - The base object that fullfils the whole interface T.
 * @param updates - Updates that may change or delete props.
 * @returns A brand new instance with all the supplied objects deeply merged.
 */


function pureDeepObjectAssign(base) {
  var _context;

  for (var _len = arguments.length, updates = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    updates[_key - 1] = arguments[_key];
  }

  return deepObjectAssign.apply(void 0, concat(_context = [{}, base]).call(_context, updates));
}
/**
 * Deep version of object assign with additional deleting by the DELETE symbol.
 *
 * @param values - Objects to be deeply merged.
 * @returns The first object from values.
 */


function deepObjectAssign() {
  var merged = deepObjectAssignNonentry.apply(void 0, arguments);
  stripDelete(merged);
  return merged;
}
/**
 * Deep version of object assign with additional deleting by the DELETE symbol.
 *
 * @remarks
 * This doesn't strip the DELETE symbols so they may end up in the final object.
 * @param values - Objects to be deeply merged.
 * @returns The first object from values.
 */


function deepObjectAssignNonentry() {
  for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    values[_key2] = arguments[_key2];
  }

  if (values.length < 2) {
    return values[0];
  } else if (values.length > 2) {
    var _context2;

    return deepObjectAssignNonentry.apply(void 0, concat(_context2 = [deepObjectAssign(values[0], values[1])]).call(_context2, _toConsumableArray(slice(values).call(values, 2))));
  }

  var a = values[0];
  var b = values[1];

  var _iterator = _createForOfIteratorHelper$8(ownKeys$5(b)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var prop = _step.value;
      if (!Object.prototype.propertyIsEnumerable.call(b, prop)) ;else if (b[prop] === DELETE) {
        delete a[prop];
      } else if (a[prop] !== null && b[prop] !== null && _typeof(a[prop]) === "object" && _typeof(b[prop]) === "object" && !isArray$2(a[prop]) && !isArray$2(b[prop])) {
        a[prop] = deepObjectAssignNonentry(a[prop], b[prop]);
      } else {
        a[prop] = clone(b[prop]);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return a;
}
/**
 * Deep clone given object or array. In case of primitive simply return.
 *
 * @param a - Anything.
 * @returns Deep cloned object/array or unchanged a.
 */


function clone(a) {
  if (isArray$2(a)) {
    return map$3(a).call(a, function (value) {
      return clone(value);
    });
  } else if (_typeof(a) === "object" && a !== null) {
    return deepObjectAssignNonentry({}, a);
  } else {
    return a;
  }
}
/**
 * Strip DELETE from given object.
 *
 * @param a - Object which may contain DELETE but won't after this is executed.
 */


function stripDelete(a) {
  for (var _i = 0, _Object$keys = keys$4(a); _i < _Object$keys.length; _i++) {
    var prop = _Object$keys[_i];

    if (a[prop] === DELETE) {
      delete a[prop];
    } else if (_typeof(a[prop]) === "object" && a[prop] !== null) {
      stripDelete(a[prop]);
    }
  }
}
/**
 * Seedable, fast and reasonably good (not crypto but more than okay for our
 * needs) random number generator.
 *
 * @remarks
 * Adapted from {@link https://web.archive.org/web/20110429100736/http://baagoe.com:80/en/RandomMusings/javascript}.
 * Original algorithm created by Johannes Baagøe \<baagoe\@baagoe.com\> in 2010.
 */

/**
 * Create a seeded pseudo random generator based on Alea by Johannes Baagøe.
 *
 * @param seed - All supplied arguments will be used as a seed. In case nothing
 * is supplied the current time will be used to seed the generator.
 * @returns A ready to use seeded generator.
 */


function Alea() {
  for (var _len3 = arguments.length, seed = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    seed[_key3] = arguments[_key3];
  }

  return AleaImplementation(seed.length ? seed : [now$1()]);
}
/**
 * An implementation of [[Alea]] without user input validation.
 *
 * @param seed - The data that will be used to seed the generator.
 * @returns A ready to use seeded generator.
 */


function AleaImplementation(seed) {
  var _mashSeed = mashSeed(seed),
      _mashSeed2 = _slicedToArray(_mashSeed, 3),
      s0 = _mashSeed2[0],
      s1 = _mashSeed2[1],
      s2 = _mashSeed2[2];

  var c = 1;

  var random = function random() {
    var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32

    s0 = s1;
    s1 = s2;
    return s2 = t - (c = t | 0);
  };

  random.uint32 = function () {
    return random() * 0x100000000;
  }; // 2^32


  random.fract53 = function () {
    return random() + (random() * 0x200000 | 0) * 1.1102230246251565e-16;
  }; // 2^-53


  random.algorithm = "Alea";
  random.seed = seed;
  random.version = "0.9";
  return random;
}
/**
 * Turn arbitrary data into values [[AleaImplementation]] can use to generate
 * random numbers.
 *
 * @param seed - Arbitrary data that will be used as the seed.
 * @returns Three numbers to use as initial values for [[AleaImplementation]].
 */


function mashSeed() {
  var mash = Mash();
  var s0 = mash(" ");
  var s1 = mash(" ");
  var s2 = mash(" ");

  for (var i = 0; i < arguments.length; i++) {
    s0 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);

    if (s0 < 0) {
      s0 += 1;
    }

    s1 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);

    if (s1 < 0) {
      s1 += 1;
    }

    s2 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);

    if (s2 < 0) {
      s2 += 1;
    }
  }

  return [s0, s1, s2];
}
/**
 * Create a new mash function.
 *
 * @returns A nonpure function that takes arbitrary [[Mashable]] data and turns
 * them into numbers.
 */


function Mash() {
  var n = 0xefc8249d;
  return function (data) {
    var string = data.toString();

    for (var i = 0; i < string.length; i++) {
      n += string.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }

    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };
}
/**
 * Setup a mock hammer.js object, for unit testing.
 *
 * Inspiration: https://github.com/uber/deck.gl/pull/658
 *
 * @returns {{on: noop, off: noop, destroy: noop, emit: noop, get: get}}
 */


function hammerMock() {
  var noop = function noop() {};

  return {
    on: noop,
    off: noop,
    destroy: noop,
    emit: noop,
    get: function get() {
      return {
        set: noop
      };
    }
  };
}

var Hammer$1 = typeof window !== "undefined" ? window.Hammer || RealHammer : function () {
  // hammer.js is only available in a browser, not in node.js. Replacing it with a mock object.
  return hammerMock();
};
/**
 * Turn an element into an clickToUse element.
 * When not active, the element has a transparent overlay. When the overlay is
 * clicked, the mode is changed to active.
 * When active, the element is displayed with a blue border around it, and
 * the interactive contents of the element can be used. When clicked outside
 * the element, the elements mode is changed to inactive.
 *
 * @param {Element} container
 * @class Activator
 */

function Activator$1(container) {
  var _this = this,
      _context3;

  this._cleanupQueue = [];
  this.active = false;
  this._dom = {
    container: container,
    overlay: document.createElement("div")
  };

  this._dom.overlay.classList.add("vis-overlay");

  this._dom.container.appendChild(this._dom.overlay);

  this._cleanupQueue.push(function () {
    _this._dom.overlay.parentNode.removeChild(_this._dom.overlay);
  });

  var hammer = Hammer$1(this._dom.overlay);
  hammer.on("tap", bind$6(_context3 = this._onTapOverlay).call(_context3, this));

  this._cleanupQueue.push(function () {
    hammer.destroy(); // FIXME: cleaning up hammer instances doesn't work (Timeline not removed
    // from memory)
  }); // block all touch events (except tap)


  var events = ["tap", "doubletap", "press", "pinch", "pan", "panstart", "panmove", "panend"];

  forEach$2(events).call(events, function (event) {
    hammer.on(event, function (event) {
      event.srcEvent.stopPropagation();
    });
  }); // attach a click event to the window, in order to deactivate when clicking outside the timeline


  if (document && document.body) {
    this._onClick = function (event) {
      if (!_hasParent(event.target, container)) {
        _this.deactivate();
      }
    };

    document.body.addEventListener("click", this._onClick);

    this._cleanupQueue.push(function () {
      document.body.removeEventListener("click", _this._onClick);
    });
  } // prepare escape key listener for deactivating when active


  this._escListener = function (event) {
    if ("key" in event ? event.key === "Escape" : event.keyCode === 27
    /* the keyCode is for IE11 */
    ) {
      _this.deactivate();
    }
  };
} // turn into an event emitter


Emitter(Activator$1.prototype); // The currently active activator

Activator$1.current = null;
/**
 * Destroy the activator. Cleans up all created DOM and event listeners
 */

Activator$1.prototype.destroy = function () {
  var _context4, _context5;

  this.deactivate();

  var _iterator2 = _createForOfIteratorHelper$8(reverse(_context4 = splice$1(_context5 = this._cleanupQueue).call(_context5, 0)).call(_context4)),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var callback = _step2.value;
      callback();
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
};
/**
 * Activate the element
 * Overlay is hidden, element is decorated with a blue shadow border
 */


Activator$1.prototype.activate = function () {
  // we allow only one active activator at a time
  if (Activator$1.current) {
    Activator$1.current.deactivate();
  }

  Activator$1.current = this;
  this.active = true;
  this._dom.overlay.style.display = "none";

  this._dom.container.classList.add("vis-active");

  this.emit("change");
  this.emit("activate"); // ugly hack: bind ESC after emitting the events, as the Network rebinds all
  // keyboard events on a 'change' event

  document.body.addEventListener("keydown", this._escListener);
};
/**
 * Deactivate the element
 * Overlay is displayed on top of the element
 */


Activator$1.prototype.deactivate = function () {
  this.active = false;
  this._dom.overlay.style.display = "block";

  this._dom.container.classList.remove("vis-active");

  document.body.removeEventListener("keydown", this._escListener);
  this.emit("change");
  this.emit("deactivate");
};
/**
 * Handle a tap event: activate the container
 *
 * @param {Event}  event   The event
 * @private
 */


Activator$1.prototype._onTapOverlay = function (event) {
  // activate the container
  this.activate();
  event.srcEvent.stopPropagation();
};
/**
 * Test whether the element has the requested parent element somewhere in
 * its chain of parent nodes.
 *
 * @param {HTMLElement} element
 * @param {HTMLElement} parent
 * @returns {boolean} Returns true when the parent is found somewhere in the
 *                    chain of parent nodes.
 * @private
 */


function _hasParent(element, parent) {
  while (element) {
    if (element === parent) {
      return true;
    }

    element = element.parentNode;
  }

  return false;
} // utility functions

var fullHexRE = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
var shortHexRE = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
var rgbRE = /^rgb\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *\)$/i;
var rgbaRE = /^rgba\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *([01]|0?\.\d+) *\)$/i;
/**
 * Remove everything in the DOM object.
 *
 * @param DOMobject - Node whose child nodes will be recursively deleted.
 */


function recursiveDOMDelete(DOMobject) {
  if (DOMobject) {
    while (DOMobject.hasChildNodes() === true) {
      var child = DOMobject.firstChild;

      if (child) {
        recursiveDOMDelete(child);
        DOMobject.removeChild(child);
      }
    }
  }
}
/**
 * Test whether given object is a string.
 *
 * @param value - Input value of unknown type.
 * @returns True if string, false otherwise.
 */


function isString(value) {
  return value instanceof String || typeof value === "string";
}
/**
 * Test whether given object is a object (not primitive or null).
 *
 * @param value - Input value of unknown type.
 * @returns True if not null object, false otherwise.
 */


function isObject$7(value) {
  return _typeof(value) === "object" && value !== null;
}
/**
 * Copy property from b to a if property present in a.
 * If property in b explicitly set to null, delete it if `allowDeletion` set.
 *
 * Internal helper routine, should not be exported. Not added to `exports` for that reason.
 *
 * @param a - Target object.
 * @param b - Source object.
 * @param prop - Name of property to copy from b to a.
 * @param allowDeletion - If true, delete property in a if explicitly set to null in b.
 */


function copyOrDelete(a, b, prop, allowDeletion) {
  var doDeletion = false;

  if (allowDeletion === true) {
    doDeletion = b[prop] === null && a[prop] !== undefined;
  }

  if (doDeletion) {
    delete a[prop];
  } else {
    a[prop] = b[prop]; // Remember, this is a reference copy!
  }
}
/**
 * Fill an object with a possibly partially defined other object.
 *
 * Only copies values for the properties already present in a.
 * That means an object is not created on a property if only the b object has it.
 *
 * @param a - The object that will have it's properties updated.
 * @param b - The object with property updates.
 * @param allowDeletion - If true, delete properties in a that are explicitly set to null in b.
 */


function fillIfDefined(a, b) {
  var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  // NOTE: iteration of properties of a
  // NOTE: prototype properties iterated over as well
  for (var prop in a) {
    if (b[prop] !== undefined) {
      if (b[prop] === null || _typeof(b[prop]) !== "object") {
        // Note: typeof null === 'object'
        copyOrDelete(a, b, prop, allowDeletion);
      } else {
        var aProp = a[prop];
        var bProp = b[prop];

        if (isObject$7(aProp) && isObject$7(bProp)) {
          fillIfDefined(aProp, bProp, allowDeletion);
        }
      }
    }
  }
}
/**
 * Extend object a with selected properties of object b.
 * Only properties with defined values are copied.
 *
 * @remarks
 * Previous version of this routine implied that multiple source objects could
 * be used; however, the implementation was **wrong**. Since multiple (\>1)
 * sources weren't used anywhere in the `vis.js` code, this has been removed
 * @param props - Names of first-level properties to copy over.
 * @param a - Target object.
 * @param b - Source object.
 * @param allowDeletion - If true, delete property in a if explicitly set to null in b.
 * @returns Argument a.
 */


function selectiveDeepExtend(props, a, b) {
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  // TODO: add support for Arrays to deepExtend
  if (isArray$2(b)) {
    throw new TypeError("Arrays are not supported by deepExtend");
  }

  for (var p = 0; p < props.length; p++) {
    var prop = props[p];

    if (Object.prototype.hasOwnProperty.call(b, prop)) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }

        if (a[prop].constructor === Object) {
          deepExtend(a[prop], b[prop], false, allowDeletion);
        } else {
          copyOrDelete(a, b, prop, allowDeletion);
        }
      } else if (isArray$2(b[prop])) {
        throw new TypeError("Arrays are not supported by deepExtend");
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    }
  }

  return a;
}
/**
 * Extend object `a` with properties of object `b`, ignoring properties which
 * are explicitly specified to be excluded.
 *
 * @remarks
 * The properties of `b` are considered for copying. Properties which are
 * themselves objects are are also extended. Only properties with defined
 * values are copied.
 * @param propsToExclude - Names of properties which should *not* be copied.
 * @param a - Object to extend.
 * @param b - Object to take properties from for extension.
 * @param allowDeletion - If true, delete properties in a that are explicitly
 * set to null in b.
 * @returns Argument a.
 */


function selectiveNotDeepExtend(propsToExclude, a, b) {
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  // TODO: add support for Arrays to deepExtend
  // NOTE: array properties have an else-below; apparently, there is a problem here.
  if (isArray$2(b)) {
    throw new TypeError("Arrays are not supported by deepExtend");
  }

  for (var prop in b) {
    if (!Object.prototype.hasOwnProperty.call(b, prop)) {
      continue;
    } // Handle local properties only


    if (includes(propsToExclude).call(propsToExclude, prop)) {
      continue;
    } // In exclusion list, skip


    if (b[prop] && b[prop].constructor === Object) {
      if (a[prop] === undefined) {
        a[prop] = {};
      }

      if (a[prop].constructor === Object) {
        deepExtend(a[prop], b[prop]); // NOTE: allowDeletion not propagated!
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    } else if (isArray$2(b[prop])) {
      a[prop] = [];

      for (var i = 0; i < b[prop].length; i++) {
        a[prop].push(b[prop][i]);
      }
    } else {
      copyOrDelete(a, b, prop, allowDeletion);
    }
  }

  return a;
}
/**
 * Deep extend an object a with the properties of object b.
 *
 * @param a - Target object.
 * @param b - Source object.
 * @param protoExtend - If true, the prototype values will also be extended.
 * (That is the options objects that inherit from others will also get the
 * inherited options).
 * @param allowDeletion - If true, the values of fields that are null will be deleted.
 * @returns Argument a.
 */


function deepExtend(a, b) {
  var protoExtend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  for (var prop in b) {
    if (Object.prototype.hasOwnProperty.call(b, prop) || protoExtend === true) {
      if (_typeof(b[prop]) === "object" && b[prop] !== null && getPrototypeOf$4(b[prop]) === Object.prototype) {
        if (a[prop] === undefined) {
          a[prop] = deepExtend({}, b[prop], protoExtend); // NOTE: allowDeletion not propagated!
        } else if (_typeof(a[prop]) === "object" && a[prop] !== null && getPrototypeOf$4(a[prop]) === Object.prototype) {
          deepExtend(a[prop], b[prop], protoExtend); // NOTE: allowDeletion not propagated!
        } else {
          copyOrDelete(a, b, prop, allowDeletion);
        }
      } else if (isArray$2(b[prop])) {
        var _context6;

        a[prop] = slice(_context6 = b[prop]).call(_context6);
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    }
  }

  return a;
}
/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr - First part.
 * @param newValue - The value to be aadded into the array.
 * @returns A new array with all items from arr and newValue (which is last).
 */


function copyAndExtendArray(arr, newValue) {
  var _context7;

  return concat(_context7 = []).call(_context7, _toConsumableArray(arr), [newValue]);
}
/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr - The array to be copied.
 * @returns Shallow copy of arr.
 */


function copyArray(arr) {
  return slice(arr).call(arr);
}
/**
 * Retrieve the absolute left value of a DOM element.
 *
 * @param elem - A dom element, for example a div.
 * @returns The absolute left position of this element in the browser page.
 */


function getAbsoluteLeft(elem) {
  return elem.getBoundingClientRect().left;
}
/**
 * Retrieve the absolute top value of a DOM element.
 *
 * @param elem - A dom element, for example a div.
 * @returns The absolute top position of this element in the browser page.
 */


function getAbsoluteTop(elem) {
  return elem.getBoundingClientRect().top;
}
/**
 * For each method for both arrays and objects.
 * In case of an array, the built-in Array.forEach() is applied (**No, it's not!**).
 * In case of an Object, the method loops over all properties of the object.
 *
 * @param object - An Object or Array to be iterated over.
 * @param callback - Array.forEach-like callback.
 */


function forEach$1(object, callback) {
  if (isArray$2(object)) {
    // array
    var len = object.length;

    for (var i = 0; i < len; i++) {
      callback(object[i], i, object);
    }
  } else {
    // object
    for (var key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        callback(object[key], key, object);
      }
    }
  }
}
/**
 * Add and event listener. Works for all browsers.
 *
 * @param element - The element to bind the event listener to.
 * @param action - Same as Element.addEventListener(action, —, —).
 * @param listener - Same as Element.addEventListener(—, listener, —).
 * @param useCapture - Same as Element.addEventListener(—, —, useCapture).
 */


function addEventListener(element, action, listener, useCapture) {
  if (element.addEventListener) {
    var _context8;

    if (useCapture === undefined) {
      useCapture = false;
    }

    if (action === "mousewheel" && includes(_context8 = navigator.userAgent).call(_context8, "Firefox")) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.addEventListener(action, listener, useCapture);
  } else {
    // @TODO: IE types? Does anyone care?
    element.attachEvent("on" + action, listener); // IE browsers
  }
}
/**
 * Remove an event listener from an element.
 *
 * @param element - The element to bind the event listener to.
 * @param action - Same as Element.removeEventListener(action, —, —).
 * @param listener - Same as Element.removeEventListener(—, listener, —).
 * @param useCapture - Same as Element.removeEventListener(—, —, useCapture).
 */


function removeEventListener(element, action, listener, useCapture) {
  if (element.removeEventListener) {
    var _context9;

    // non-IE browsers
    if (useCapture === undefined) {
      useCapture = false;
    }

    if (action === "mousewheel" && includes(_context9 = navigator.userAgent).call(_context9, "Firefox")) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.removeEventListener(action, listener, useCapture);
  } else {
    // @TODO: IE types? Does anyone care?
    element.detachEvent("on" + action, listener); // IE browsers
  }
}
/**
 * Convert hex color string into RGB color object.
 *
 * @remarks
 * {@link http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb}
 * @param hex - Hex color string (3 or 6 digits, with or without #).
 * @returns RGB color object.
 */

function hexToRGB(hex) {
  var result;

  switch (hex.length) {
    case 3:
    case 4:
      result = shortHexRE.exec(hex);
      return result ? {
        r: _parseInt(result[1] + result[1], 16),
        g: _parseInt(result[2] + result[2], 16),
        b: _parseInt(result[3] + result[3], 16)
      } : null;

    case 6:
    case 7:
      result = fullHexRE.exec(hex);
      return result ? {
        r: _parseInt(result[1], 16),
        g: _parseInt(result[2], 16),
        b: _parseInt(result[3], 16)
      } : null;

    default:
      return null;
  }
}
/**
 * This function takes string color in hex or RGB format and adds the opacity, RGBA is passed through unchanged.
 *
 * @param color - The color string (hex, RGB, RGBA).
 * @param opacity - The new opacity.
 * @returns RGBA string, for example 'rgba(255, 0, 127, 0.3)'.
 */


function overrideOpacity(color, opacity) {
  if (includes(color).call(color, "rgba")) {
    return color;
  } else if (includes(color).call(color, "rgb")) {
    var rgb = color.substr(indexOf(color).call(color, "(") + 1).replace(")", "").split(",");
    return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + opacity + ")";
  } else {
    var _rgb = hexToRGB(color);

    if (_rgb == null) {
      return color;
    } else {
      return "rgba(" + _rgb.r + "," + _rgb.g + "," + _rgb.b + "," + opacity + ")";
    }
  }
}
/**
 * Convert RGB \<0, 255\> into hex color string.
 *
 * @param red - Red channel.
 * @param green - Green channel.
 * @param blue - Blue channel.
 * @returns Hex color string (for example: '#0acdc0').
 */


function RGBToHex(red, green, blue) {
  var _context10;

  return "#" + slice(_context10 = ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16)).call(_context10, 1);
}
/**
 * Parse a color property into an object with border, background, and highlight colors.
 *
 * @param inputColor - Shorthand color string or input color object.
 * @param defaultColor - Full color object to fill in missing values in inputColor.
 * @returns Color object.
 */


function parseColor(inputColor, defaultColor) {
  if (isString(inputColor)) {
    var colorStr = inputColor;

    if (isValidRGB(colorStr)) {
      var _context11;

      var rgb = map$3(_context11 = colorStr.substr(4).substr(0, colorStr.length - 5).split(",")).call(_context11, function (value) {
        return _parseInt(value);
      });

      colorStr = RGBToHex(rgb[0], rgb[1], rgb[2]);
    }

    if (isValidHex(colorStr) === true) {
      var hsv = hexToHSV(colorStr);
      var lighterColorHSV = {
        h: hsv.h,
        s: hsv.s * 0.8,
        v: Math.min(1, hsv.v * 1.02)
      };
      var darkerColorHSV = {
        h: hsv.h,
        s: Math.min(1, hsv.s * 1.25),
        v: hsv.v * 0.8
      };
      var darkerColorHex = HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
      var lighterColorHex = HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
      return {
        background: colorStr,
        border: darkerColorHex,
        highlight: {
          background: lighterColorHex,
          border: darkerColorHex
        },
        hover: {
          background: lighterColorHex,
          border: darkerColorHex
        }
      };
    } else {
      return {
        background: colorStr,
        border: colorStr,
        highlight: {
          background: colorStr,
          border: colorStr
        },
        hover: {
          background: colorStr,
          border: colorStr
        }
      };
    }
  } else {
    if (defaultColor) {
      var color = {
        background: inputColor.background || defaultColor.background,
        border: inputColor.border || defaultColor.border,
        highlight: isString(inputColor.highlight) ? {
          border: inputColor.highlight,
          background: inputColor.highlight
        } : {
          background: inputColor.highlight && inputColor.highlight.background || defaultColor.highlight.background,
          border: inputColor.highlight && inputColor.highlight.border || defaultColor.highlight.border
        },
        hover: isString(inputColor.hover) ? {
          border: inputColor.hover,
          background: inputColor.hover
        } : {
          border: inputColor.hover && inputColor.hover.border || defaultColor.hover.border,
          background: inputColor.hover && inputColor.hover.background || defaultColor.hover.background
        }
      };
      return color;
    } else {
      var _color = {
        background: inputColor.background || undefined,
        border: inputColor.border || undefined,
        highlight: isString(inputColor.highlight) ? {
          border: inputColor.highlight,
          background: inputColor.highlight
        } : {
          background: inputColor.highlight && inputColor.highlight.background || undefined,
          border: inputColor.highlight && inputColor.highlight.border || undefined
        },
        hover: isString(inputColor.hover) ? {
          border: inputColor.hover,
          background: inputColor.hover
        } : {
          border: inputColor.hover && inputColor.hover.border || undefined,
          background: inputColor.hover && inputColor.hover.background || undefined
        }
      };
      return _color;
    }
  }
}
/**
 * Convert RGB \<0, 255\> into HSV object.
 *
 * @remarks
 * {@link http://www.javascripter.net/faq/rgb2hsv.htm}
 * @param red - Red channel.
 * @param green - Green channel.
 * @param blue - Blue channel.
 * @returns HSV color object.
 */


function RGBToHSV(red, green, blue) {
  red = red / 255;
  green = green / 255;
  blue = blue / 255;
  var minRGB = Math.min(red, Math.min(green, blue));
  var maxRGB = Math.max(red, Math.max(green, blue)); // Black-gray-white

  if (minRGB === maxRGB) {
    return {
      h: 0,
      s: 0,
      v: minRGB
    };
  } // Colors other than black-gray-white:


  var d = red === minRGB ? green - blue : blue === minRGB ? red - green : blue - red;
  var h = red === minRGB ? 3 : blue === minRGB ? 1 : 5;
  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
  var saturation = (maxRGB - minRGB) / maxRGB;
  var value = maxRGB;
  return {
    h: hue,
    s: saturation,
    v: value
  };
}
/**
 * Convert HSV \<0, 1\> into RGB color object.
 *
 * @remarks
 * {@link https://gist.github.com/mjijackson/5311256}
 * @param h - Hue.
 * @param s - Saturation.
 * @param v - Value.
 * @returns RGB color object.
 */


function HSVToRGB(h, s, v) {
  var r;
  var g;
  var b;
  var i = Math.floor(h * 6);
  var f = h * 6 - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;
      break;

    case 1:
      r = q, g = v, b = p;
      break;

    case 2:
      r = p, g = v, b = t;
      break;

    case 3:
      r = p, g = q, b = v;
      break;

    case 4:
      r = t, g = p, b = v;
      break;

    case 5:
      r = v, g = p, b = q;
      break;
  }

  return {
    r: Math.floor(r * 255),
    g: Math.floor(g * 255),
    b: Math.floor(b * 255)
  };
}
/**
 * Convert HSV \<0, 1\> into hex color string.
 *
 * @param h - Hue.
 * @param s - Saturation.
 * @param v - Value.
 * @returns Hex color string.
 */


function HSVToHex(h, s, v) {
  var rgb = HSVToRGB(h, s, v);
  return RGBToHex(rgb.r, rgb.g, rgb.b);
}
/**
 * Convert hex color string into HSV \<0, 1\>.
 *
 * @param hex - Hex color string.
 * @returns HSV color object.
 */


function hexToHSV(hex) {
  var rgb = hexToRGB(hex);

  if (!rgb) {
    throw new TypeError("'".concat(hex, "' is not a valid color."));
  }

  return RGBToHSV(rgb.r, rgb.g, rgb.b);
}
/**
 * Validate hex color string.
 *
 * @param hex - Unknown string that may contain a color.
 * @returns True if the string is valid, false otherwise.
 */


function isValidHex(hex) {
  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  return isOk;
}
/**
 * Validate RGB color string.
 *
 * @param rgb - Unknown string that may contain a color.
 * @returns True if the string is valid, false otherwise.
 */


function isValidRGB(rgb) {
  return rgbRE.test(rgb);
}
/**
 * Validate RGBA color string.
 *
 * @param rgba - Unknown string that may contain a color.
 * @returns True if the string is valid, false otherwise.
 */


function isValidRGBA(rgba) {
  return rgbaRE.test(rgba);
}
/**
 * This recursively redirects the prototype of JSON objects to the referenceObject.
 * This is used for default options.
 *
 * @param referenceObject - The original object.
 * @returns The Element if the referenceObject is an Element, or a new object inheriting from the referenceObject.
 */


function bridgeObject(referenceObject) {
  if (referenceObject === null || _typeof(referenceObject) !== "object") {
    return null;
  }

  if (referenceObject instanceof Element) {
    // Avoid bridging DOM objects
    return referenceObject;
  }

  var objectTo = create$5(referenceObject);

  for (var i in referenceObject) {
    if (Object.prototype.hasOwnProperty.call(referenceObject, i)) {
      if (_typeof(referenceObject[i]) == "object") {
        objectTo[i] = bridgeObject(referenceObject[i]);
      }
    }
  }

  return objectTo;
}
/**
 * This is used to set the options of subobjects in the options object.
 *
 * A requirement of these subobjects is that they have an 'enabled' element
 * which is optional for the user but mandatory for the program.
 *
 * The added value here of the merge is that option 'enabled' is set as required.
 *
 * @param mergeTarget - Either this.options or the options used for the groups.
 * @param options - Options.
 * @param option - Option key in the options argument.
 * @param globalOptions - Global options, passed in to determine value of option 'enabled'.
 */


function mergeOptions(mergeTarget, options, option) {
  var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  // Local helpers
  var isPresent = function isPresent(obj) {
    return obj !== null && obj !== undefined;
  };

  var isObject = function isObject(obj) {
    return obj !== null && _typeof(obj) === "object";
  }; // https://stackoverflow.com/a/34491287/1223531


  var isEmpty = function isEmpty(obj) {
    for (var x in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, x)) {
        return false;
      }
    }

    return true;
  }; // Guards


  if (!isObject(mergeTarget)) {
    throw new Error("Parameter mergeTarget must be an object");
  }

  if (!isObject(options)) {
    throw new Error("Parameter options must be an object");
  }

  if (!isPresent(option)) {
    throw new Error("Parameter option must have a value");
  }

  if (!isObject(globalOptions)) {
    throw new Error("Parameter globalOptions must be an object");
  } //
  // Actual merge routine, separated from main logic
  // Only a single level of options is merged. Deeper levels are ref'd. This may actually be an issue.
  //


  var doMerge = function doMerge(target, options, option) {
    if (!isObject(target[option])) {
      target[option] = {};
    }

    var src = options[option];
    var dst = target[option];

    for (var prop in src) {
      if (Object.prototype.hasOwnProperty.call(src, prop)) {
        dst[prop] = src[prop];
      }
    }
  }; // Local initialization


  var srcOption = options[option];
  var globalPassed = isObject(globalOptions) && !isEmpty(globalOptions);
  var globalOption = globalPassed ? globalOptions[option] : undefined;
  var globalEnabled = globalOption ? globalOption.enabled : undefined; /////////////////////////////////////////
  // Main routine
  /////////////////////////////////////////

  if (srcOption === undefined) {
    return; // Nothing to do
  }

  if (typeof srcOption === "boolean") {
    if (!isObject(mergeTarget[option])) {
      mergeTarget[option] = {};
    }

    mergeTarget[option].enabled = srcOption;
    return;
  }

  if (srcOption === null && !isObject(mergeTarget[option])) {
    // If possible, explicit copy from globals
    if (isPresent(globalOption)) {
      mergeTarget[option] = create$5(globalOption);
    } else {
      return; // Nothing to do
    }
  }

  if (!isObject(srcOption)) {
    return;
  } //
  // Ensure that 'enabled' is properly set. It is required internally
  // Note that the value from options will always overwrite the existing value
  //


  var enabled = true; // default value

  if (srcOption.enabled !== undefined) {
    enabled = srcOption.enabled;
  } else {
    // Take from globals, if present
    if (globalEnabled !== undefined) {
      enabled = globalOption.enabled;
    }
  }

  doMerge(mergeTarget, options, option);
  mergeTarget[option].enabled = enabled;
}
/*
 * Easing Functions.
 * Only considering the t value for the range [0, 1] => [0, 1].
 *
 * Inspiration: from http://gizma.com/easing/
 * https://gist.github.com/gre/1650294
 */


var easingFunctions = {
  /**
   * Provides no easing and no acceleration.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  linear: function linear(t) {
    return t;
  },

  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuad: function easeInQuad(t) {
    return t * t;
  },

  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuad: function easeOutQuad(t) {
    return t * (2 - t);
  },

  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuad: function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },

  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInCubic: function easeInCubic(t) {
    return t * t * t;
  },

  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutCubic: function easeOutCubic(t) {
    return --t * t * t + 1;
  },

  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutCubic: function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },

  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuart: function easeInQuart(t) {
    return t * t * t * t;
  },

  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuart: function easeOutQuart(t) {
    return 1 - --t * t * t * t;
  },

  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuart: function easeInOutQuart(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },

  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuint: function easeInQuint(t) {
    return t * t * t * t * t;
  },

  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuint: function easeOutQuint(t) {
    return 1 + --t * t * t * t * t;
  },

  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuint: function easeInOutQuint(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
// It works only for single property objects,
// otherwise it combines all of the types in a union.
// export function topMost<K1 extends string, V1> (
//   pile: Record<K1, undefined | V1>[],
//   accessors: K1 | [K1]
// ): undefined | V1
// export function topMost<K1 extends string, K2 extends string, V1, V2> (
//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2>>[],
//   accessors: [K1, K2]
// ): undefined | V1 | V2
// export function topMost<K1 extends string, K2 extends string, K3 extends string, V1, V2, V3> (
//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2 | Record<K3, undefined | V3>>>[],
//   accessors: [K1, K2, K3]
// ): undefined | V1 | V2 | V3

/**
 * Get the top most property value from a pile of objects.
 *
 * @param pile - Array of objects, no required format.
 * @param accessors - Array of property names.
 * For example `object['foo']['bar']` → `['foo', 'bar']`.
 * @returns Value of the property with given accessors path from the first pile item where it's not undefined.
 */


function topMost(pile, accessors) {
  var candidate;

  if (!isArray$2(accessors)) {
    accessors = [accessors];
  }

  var _iterator3 = _createForOfIteratorHelper$8(pile),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var member = _step3.value;

      if (member) {
        candidate = member[accessors[0]];

        for (var i = 1; i < accessors.length; i++) {
          if (candidate) {
            candidate = candidate[accessors[i]];
          }
        }

        if (typeof candidate !== "undefined") {
          break;
        }
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return candidate;
}

var htmlColors = {
  black: "#000000",
  navy: "#000080",
  darkblue: "#00008B",
  mediumblue: "#0000CD",
  blue: "#0000FF",
  darkgreen: "#006400",
  green: "#008000",
  teal: "#008080",
  darkcyan: "#008B8B",
  deepskyblue: "#00BFFF",
  darkturquoise: "#00CED1",
  mediumspringgreen: "#00FA9A",
  lime: "#00FF00",
  springgreen: "#00FF7F",
  aqua: "#00FFFF",
  cyan: "#00FFFF",
  midnightblue: "#191970",
  dodgerblue: "#1E90FF",
  lightseagreen: "#20B2AA",
  forestgreen: "#228B22",
  seagreen: "#2E8B57",
  darkslategray: "#2F4F4F",
  limegreen: "#32CD32",
  mediumseagreen: "#3CB371",
  turquoise: "#40E0D0",
  royalblue: "#4169E1",
  steelblue: "#4682B4",
  darkslateblue: "#483D8B",
  mediumturquoise: "#48D1CC",
  indigo: "#4B0082",
  darkolivegreen: "#556B2F",
  cadetblue: "#5F9EA0",
  cornflowerblue: "#6495ED",
  mediumaquamarine: "#66CDAA",
  dimgray: "#696969",
  slateblue: "#6A5ACD",
  olivedrab: "#6B8E23",
  slategray: "#708090",
  lightslategray: "#778899",
  mediumslateblue: "#7B68EE",
  lawngreen: "#7CFC00",
  chartreuse: "#7FFF00",
  aquamarine: "#7FFFD4",
  maroon: "#800000",
  purple: "#800080",
  olive: "#808000",
  gray: "#808080",
  skyblue: "#87CEEB",
  lightskyblue: "#87CEFA",
  blueviolet: "#8A2BE2",
  darkred: "#8B0000",
  darkmagenta: "#8B008B",
  saddlebrown: "#8B4513",
  darkseagreen: "#8FBC8F",
  lightgreen: "#90EE90",
  mediumpurple: "#9370D8",
  darkviolet: "#9400D3",
  palegreen: "#98FB98",
  darkorchid: "#9932CC",
  yellowgreen: "#9ACD32",
  sienna: "#A0522D",
  brown: "#A52A2A",
  darkgray: "#A9A9A9",
  lightblue: "#ADD8E6",
  greenyellow: "#ADFF2F",
  paleturquoise: "#AFEEEE",
  lightsteelblue: "#B0C4DE",
  powderblue: "#B0E0E6",
  firebrick: "#B22222",
  darkgoldenrod: "#B8860B",
  mediumorchid: "#BA55D3",
  rosybrown: "#BC8F8F",
  darkkhaki: "#BDB76B",
  silver: "#C0C0C0",
  mediumvioletred: "#C71585",
  indianred: "#CD5C5C",
  peru: "#CD853F",
  chocolate: "#D2691E",
  tan: "#D2B48C",
  lightgrey: "#D3D3D3",
  palevioletred: "#D87093",
  thistle: "#D8BFD8",
  orchid: "#DA70D6",
  goldenrod: "#DAA520",
  crimson: "#DC143C",
  gainsboro: "#DCDCDC",
  plum: "#DDA0DD",
  burlywood: "#DEB887",
  lightcyan: "#E0FFFF",
  lavender: "#E6E6FA",
  darksalmon: "#E9967A",
  violet: "#EE82EE",
  palegoldenrod: "#EEE8AA",
  lightcoral: "#F08080",
  khaki: "#F0E68C",
  aliceblue: "#F0F8FF",
  honeydew: "#F0FFF0",
  azure: "#F0FFFF",
  sandybrown: "#F4A460",
  wheat: "#F5DEB3",
  beige: "#F5F5DC",
  whitesmoke: "#F5F5F5",
  mintcream: "#F5FFFA",
  ghostwhite: "#F8F8FF",
  salmon: "#FA8072",
  antiquewhite: "#FAEBD7",
  linen: "#FAF0E6",
  lightgoldenrodyellow: "#FAFAD2",
  oldlace: "#FDF5E6",
  red: "#FF0000",
  fuchsia: "#FF00FF",
  magenta: "#FF00FF",
  deeppink: "#FF1493",
  orangered: "#FF4500",
  tomato: "#FF6347",
  hotpink: "#FF69B4",
  coral: "#FF7F50",
  darkorange: "#FF8C00",
  lightsalmon: "#FFA07A",
  orange: "#FFA500",
  lightpink: "#FFB6C1",
  pink: "#FFC0CB",
  gold: "#FFD700",
  peachpuff: "#FFDAB9",
  navajowhite: "#FFDEAD",
  moccasin: "#FFE4B5",
  bisque: "#FFE4C4",
  mistyrose: "#FFE4E1",
  blanchedalmond: "#FFEBCD",
  papayawhip: "#FFEFD5",
  lavenderblush: "#FFF0F5",
  seashell: "#FFF5EE",
  cornsilk: "#FFF8DC",
  lemonchiffon: "#FFFACD",
  floralwhite: "#FFFAF0",
  snow: "#FFFAFA",
  yellow: "#FFFF00",
  lightyellow: "#FFFFE0",
  ivory: "#FFFFF0",
  white: "#FFFFFF"
};
/**
 * @param {number} [pixelRatio=1]
 */

var ColorPicker$1 = /*#__PURE__*/function () {
  /**
   * @param {number} [pixelRatio=1]
   */
  function ColorPicker$1() {
    var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

    _classCallCheck(this, ColorPicker$1);

    this.pixelRatio = pixelRatio;
    this.generated = false;
    this.centerCoordinates = {
      x: 289 / 2,
      y: 289 / 2
    };
    this.r = 289 * 0.49;
    this.color = {
      r: 255,
      g: 255,
      b: 255,
      a: 1.0
    };
    this.hueCircle = undefined;
    this.initialColor = {
      r: 255,
      g: 255,
      b: 255,
      a: 1.0
    };
    this.previousColor = undefined;
    this.applied = false; // bound by

    this.updateCallback = function () {};

    this.closeCallback = function () {}; // create all DOM elements


    this._create();
  }
  /**
   * this inserts the colorPicker into a div from the DOM
   *
   * @param {Element} container
   */


  _createClass(ColorPicker$1, [{
    key: "insertTo",
    value: function insertTo(container) {
      if (this.hammer !== undefined) {
        this.hammer.destroy();
        this.hammer = undefined;
      }

      this.container = container;
      this.container.appendChild(this.frame);

      this._bindHammer();

      this._setSize();
    }
    /**
     * the callback is executed on apply and save. Bind it to the application
     *
     * @param {Function} callback
     */

  }, {
    key: "setUpdateCallback",
    value: function setUpdateCallback(callback) {
      if (typeof callback === "function") {
        this.updateCallback = callback;
      } else {
        throw new Error("Function attempted to set as colorPicker update callback is not a function.");
      }
    }
    /**
     * the callback is executed on apply and save. Bind it to the application
     *
     * @param {Function} callback
     */

  }, {
    key: "setCloseCallback",
    value: function setCloseCallback(callback) {
      if (typeof callback === "function") {
        this.closeCallback = callback;
      } else {
        throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
      }
    }
    /**
     *
     * @param {string} color
     * @returns {string}
     * @private
     */

  }, {
    key: "_isColorString",
    value: function _isColorString(color) {
      if (typeof color === "string") {
        return htmlColors[color];
      }
    }
    /**
     * Set the color of the colorPicker
     * Supported formats:
     * 'red'                   --> HTML color string
     * '#ffffff'               --> hex string
     * 'rgb(255,255,255)'      --> rgb string
     * 'rgba(255,255,255,1.0)' --> rgba string
     * {r:255,g:255,b:255}     --> rgb object
     * {r:255,g:255,b:255,a:1.0} --> rgba object
     *
     * @param {string | object} color
     * @param {boolean} [setInitial=true]
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (color === "none") {
        return;
      }

      var rgba; // if a html color shorthand is used, convert to hex

      var htmlColor = this._isColorString(color);

      if (htmlColor !== undefined) {
        color = htmlColor;
      } // check format


      if (isString(color) === true) {
        if (isValidRGB(color) === true) {
          var rgbaArray = color.substr(4).substr(0, color.length - 5).split(",");
          rgba = {
            r: rgbaArray[0],
            g: rgbaArray[1],
            b: rgbaArray[2],
            a: 1.0
          };
        } else if (isValidRGBA(color) === true) {
          var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(",");

          rgba = {
            r: _rgbaArray[0],
            g: _rgbaArray[1],
            b: _rgbaArray[2],
            a: _rgbaArray[3]
          };
        } else if (isValidHex(color) === true) {
          var rgbObj = hexToRGB(color);
          rgba = {
            r: rgbObj.r,
            g: rgbObj.g,
            b: rgbObj.b,
            a: 1.0
          };
        }
      } else {
        if (color instanceof Object) {
          if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {
            var alpha = color.a !== undefined ? color.a : "1.0";
            rgba = {
              r: color.r,
              g: color.g,
              b: color.b,
              a: alpha
            };
          }
        }
      } // set color


      if (rgba === undefined) {
        throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + stringify$1(color));
      } else {
        this._setColor(rgba, setInitial);
      }
    }
    /**
     * this shows the color picker.
     * The hue circle is constructed once and stored.
     */

  }, {
    key: "show",
    value: function show() {
      if (this.closeCallback !== undefined) {
        this.closeCallback();
        this.closeCallback = undefined;
      }

      this.applied = false;
      this.frame.style.display = "block";

      this._generateHueCircle();
    } // ------------------------------------------ PRIVATE ----------------------------- //

    /**
     * Hide the picker. Is called by the cancel button.
     * Optional boolean to store the previous color for easy access later on.
     *
     * @param {boolean} [storePrevious=true]
     * @private
     */

  }, {
    key: "_hide",
    value: function _hide() {
      var _this2 = this;

      var storePrevious = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      // store the previous color for next time;
      if (storePrevious === true) {
        this.previousColor = assign$2({}, this.color);
      }

      if (this.applied === true) {
        this.updateCallback(this.initialColor);
      }

      this.frame.style.display = "none"; // call the closing callback, restoring the onclick method.
      // this is in a setTimeout because it will trigger the show again before the click is done.

      setTimeout$1(function () {
        if (_this2.closeCallback !== undefined) {
          _this2.closeCallback();

          _this2.closeCallback = undefined;
        }
      }, 0);
    }
    /**
     * bound to the save button. Saves and hides.
     *
     * @private
     */

  }, {
    key: "_save",
    value: function _save() {
      this.updateCallback(this.color);
      this.applied = false;

      this._hide();
    }
    /**
     * Bound to apply button. Saves but does not close. Is undone by the cancel button.
     *
     * @private
     */

  }, {
    key: "_apply",
    value: function _apply() {
      this.applied = true;
      this.updateCallback(this.color);

      this._updatePicker(this.color);
    }
    /**
     * load the color from the previous session.
     *
     * @private
     */

  }, {
    key: "_loadLast",
    value: function _loadLast() {
      if (this.previousColor !== undefined) {
        this.setColor(this.previousColor, false);
      } else {
        alert("There is no last color to load...");
      }
    }
    /**
     * set the color, place the picker
     *
     * @param {object} rgba
     * @param {boolean} [setInitial=true]
     * @private
     */

  }, {
    key: "_setColor",
    value: function _setColor(rgba) {
      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      // store the initial color
      if (setInitial === true) {
        this.initialColor = assign$2({}, rgba);
      }

      this.color = rgba;
      var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);
      var angleConvert = 2 * Math.PI;
      var radius = this.r * hsv.s;
      var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
      var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);
      this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + "px";
      this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + "px";

      this._updatePicker(rgba);
    }
    /**
     * bound to opacity control
     *
     * @param {number} value
     * @private
     */

  }, {
    key: "_setOpacity",
    value: function _setOpacity(value) {
      this.color.a = value / 100;

      this._updatePicker(this.color);
    }
    /**
     * bound to brightness control
     *
     * @param {number} value
     * @private
     */

  }, {
    key: "_setBrightness",
    value: function _setBrightness(value) {
      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.v = value / 100;
      var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba["a"] = this.color.a;
      this.color = rgba;

      this._updatePicker();
    }
    /**
     * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.
     *
     * @param {object} rgba
     * @private
     */

  }, {
    key: "_updatePicker",
    value: function _updatePicker() {
      var rgba = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.color;
      var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);
      var ctx = this.colorPickerCanvas.getContext("2d");

      if (this.pixelRation === undefined) {
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
      }

      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0); // clear the canvas

      var w = this.colorPickerCanvas.clientWidth;
      var h = this.colorPickerCanvas.clientHeight;
      ctx.clearRect(0, 0, w, h);
      ctx.putImageData(this.hueCircle, 0, 0);
      ctx.fillStyle = "rgba(0,0,0," + (1 - hsv.v) + ")";
      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);

      fill(ctx).call(ctx);

      this.brightnessRange.value = 100 * hsv.v;
      this.opacityRange.value = 100 * rgba.a;
      this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
      this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
    }
    /**
     * used by create to set the size of the canvas.
     *
     * @private
     */

  }, {
    key: "_setSize",
    value: function _setSize() {
      this.colorPickerCanvas.style.width = "100%";
      this.colorPickerCanvas.style.height = "100%";
      this.colorPickerCanvas.width = 289 * this.pixelRatio;
      this.colorPickerCanvas.height = 289 * this.pixelRatio;
    }
    /**
     * create all dom elements
     * TODO: cleanup, lots of similar dom elements
     *
     * @private
     */

  }, {
    key: "_create",
    value: function _create() {
      var _context16, _context17, _context18, _context19;

      this.frame = document.createElement("div");
      this.frame.className = "vis-color-picker";
      this.colorPickerDiv = document.createElement("div");
      this.colorPickerSelector = document.createElement("div");
      this.colorPickerSelector.className = "vis-selector";
      this.colorPickerDiv.appendChild(this.colorPickerSelector);
      this.colorPickerCanvas = document.createElement("canvas");
      this.colorPickerDiv.appendChild(this.colorPickerCanvas);

      if (!this.colorPickerCanvas.getContext) {
        var noCanvas = document.createElement("DIV");
        noCanvas.style.color = "red";
        noCanvas.style.fontWeight = "bold";
        noCanvas.style.padding = "10px";
        noCanvas.innerText = "Error: your browser does not support HTML canvas";
        this.colorPickerCanvas.appendChild(noCanvas);
      } else {
        var ctx = this.colorPickerCanvas.getContext("2d");
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      }

      this.colorPickerDiv.className = "vis-color";
      this.opacityDiv = document.createElement("div");
      this.opacityDiv.className = "vis-opacity";
      this.brightnessDiv = document.createElement("div");
      this.brightnessDiv.className = "vis-brightness";
      this.arrowDiv = document.createElement("div");
      this.arrowDiv.className = "vis-arrow";
      this.opacityRange = document.createElement("input");

      try {
        this.opacityRange.type = "range"; // Not supported on IE9

        this.opacityRange.min = "0";
        this.opacityRange.max = "100";
      } catch (err) {// TODO: Add some error handling.
      }

      this.opacityRange.value = "100";
      this.opacityRange.className = "vis-range";
      this.brightnessRange = document.createElement("input");

      try {
        this.brightnessRange.type = "range"; // Not supported on IE9

        this.brightnessRange.min = "0";
        this.brightnessRange.max = "100";
      } catch (err) {// TODO: Add some error handling.
      }

      this.brightnessRange.value = "100";
      this.brightnessRange.className = "vis-range";
      this.opacityDiv.appendChild(this.opacityRange);
      this.brightnessDiv.appendChild(this.brightnessRange);
      var me = this;

      this.opacityRange.onchange = function () {
        me._setOpacity(this.value);
      };

      this.opacityRange.oninput = function () {
        me._setOpacity(this.value);
      };

      this.brightnessRange.onchange = function () {
        me._setBrightness(this.value);
      };

      this.brightnessRange.oninput = function () {
        me._setBrightness(this.value);
      };

      this.brightnessLabel = document.createElement("div");
      this.brightnessLabel.className = "vis-label vis-brightness";
      this.brightnessLabel.innerText = "brightness:";
      this.opacityLabel = document.createElement("div");
      this.opacityLabel.className = "vis-label vis-opacity";
      this.opacityLabel.innerText = "opacity:";
      this.newColorDiv = document.createElement("div");
      this.newColorDiv.className = "vis-new-color";
      this.newColorDiv.innerText = "new";
      this.initialColorDiv = document.createElement("div");
      this.initialColorDiv.className = "vis-initial-color";
      this.initialColorDiv.innerText = "initial";
      this.cancelButton = document.createElement("div");
      this.cancelButton.className = "vis-button vis-cancel";
      this.cancelButton.innerText = "cancel";
      this.cancelButton.onclick = bind$6(_context16 = this._hide).call(_context16, this, false);
      this.applyButton = document.createElement("div");
      this.applyButton.className = "vis-button vis-apply";
      this.applyButton.innerText = "apply";
      this.applyButton.onclick = bind$6(_context17 = this._apply).call(_context17, this);
      this.saveButton = document.createElement("div");
      this.saveButton.className = "vis-button vis-save";
      this.saveButton.innerText = "save";
      this.saveButton.onclick = bind$6(_context18 = this._save).call(_context18, this);
      this.loadButton = document.createElement("div");
      this.loadButton.className = "vis-button vis-load";
      this.loadButton.innerText = "load last";
      this.loadButton.onclick = bind$6(_context19 = this._loadLast).call(_context19, this);
      this.frame.appendChild(this.colorPickerDiv);
      this.frame.appendChild(this.arrowDiv);
      this.frame.appendChild(this.brightnessLabel);
      this.frame.appendChild(this.brightnessDiv);
      this.frame.appendChild(this.opacityLabel);
      this.frame.appendChild(this.opacityDiv);
      this.frame.appendChild(this.newColorDiv);
      this.frame.appendChild(this.initialColorDiv);
      this.frame.appendChild(this.cancelButton);
      this.frame.appendChild(this.applyButton);
      this.frame.appendChild(this.saveButton);
      this.frame.appendChild(this.loadButton);
    }
    /**
     * bind hammer to the color picker
     *
     * @private
     */

  }, {
    key: "_bindHammer",
    value: function _bindHammer() {
      var _this3 = this;

      this.drag = {};
      this.pinch = {};
      this.hammer = new Hammer$1(this.colorPickerCanvas);
      this.hammer.get("pinch").set({
        enable: true
      });
      this.hammer.on("hammer.input", function (event) {
        if (event.isFirst) {
          _this3._moveSelector(event);
        }
      });
      this.hammer.on("tap", function (event) {
        _this3._moveSelector(event);
      });
      this.hammer.on("panstart", function (event) {
        _this3._moveSelector(event);
      });
      this.hammer.on("panmove", function (event) {
        _this3._moveSelector(event);
      });
      this.hammer.on("panend", function (event) {
        _this3._moveSelector(event);
      });
    }
    /**
     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
     *
     * @private
     */

  }, {
    key: "_generateHueCircle",
    value: function _generateHueCircle() {
      if (this.generated === false) {
        var ctx = this.colorPickerCanvas.getContext("2d");

        if (this.pixelRation === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }

        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0); // clear the canvas

        var w = this.colorPickerCanvas.clientWidth;
        var h = this.colorPickerCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h); // draw hue circle

        var x, y, hue, sat;
        this.centerCoordinates = {
          x: w * 0.5,
          y: h * 0.5
        };
        this.r = 0.49 * w;
        var angleConvert = 2 * Math.PI / 360;
        var hfac = 1 / 360;
        var sfac = 1 / this.r;
        var rgb;

        for (hue = 0; hue < 360; hue++) {
          for (sat = 0; sat < this.r; sat++) {
            x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
            y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
            rgb = HSVToRGB(hue * hfac, sat * sfac, 1);
            ctx.fillStyle = "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
            ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
          }
        }

        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
        ctx.stroke();
        this.hueCircle = ctx.getImageData(0, 0, w, h);
      }

      this.generated = true;
    }
    /**
     * move the selector. This is called by hammer functions.
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_moveSelector",
    value: function _moveSelector(event) {
      var rect = this.colorPickerDiv.getBoundingClientRect();
      var left = event.center.x - rect.left;
      var top = event.center.y - rect.top;
      var centerY = 0.5 * this.colorPickerDiv.clientHeight;
      var centerX = 0.5 * this.colorPickerDiv.clientWidth;
      var x = left - centerX;
      var y = top - centerY;
      var angle = Math.atan2(x, y);
      var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);
      var newTop = Math.cos(angle) * radius + centerY;
      var newLeft = Math.sin(angle) * radius + centerX;
      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + "px";
      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + "px"; // set color

      var h = angle / (2 * Math.PI);
      h = h < 0 ? h + 1 : h;
      var s = radius / this.r;
      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.h = h;
      hsv.s = s;
      var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba["a"] = this.color.a;
      this.color = rgba; // update previews

      this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
      this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
    }
  }]);

  return ColorPicker$1;
}();
/**
 * Wrap given text (last argument) in HTML elements (all preceding arguments).
 *
 * @param {...any} rest - List of tag names followed by inner text.
 * @returns An element or a text node.
 */


function wrapInTag() {
  for (var _len5 = arguments.length, rest = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    rest[_key5] = arguments[_key5];
  }

  if (rest.length < 1) {
    throw new TypeError("Invalid arguments.");
  } else if (rest.length === 1) {
    return document.createTextNode(rest[0]);
  } else {
    var element = document.createElement(rest[0]);
    element.appendChild(wrapInTag.apply(void 0, _toConsumableArray(slice(rest).call(rest, 1))));
    return element;
  }
}
/**
 * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.
 * Boolean options are recognised as Boolean
 * Number options should be written as array: [default value, min value, max value, stepsize]
 * Colors should be written as array: ['color', '#ffffff']
 * Strings with should be written as array: [option1, option2, option3, ..]
 *
 * The options are matched with their counterparts in each of the modules and the values used in the configuration are
 */


var Configurator$1 = /*#__PURE__*/function () {
  /**
   * @param {object} parentModule        | the location where parentModule.setOptions() can be called
   * @param {object} defaultContainer    | the default container of the module
   * @param {object} configureOptions    | the fully configured and predefined options set found in allOptions.js
   * @param {number} pixelRatio          | canvas pixel ratio
   * @param {Function} hideOption        | custom logic to dynamically hide options
   */
  function Configurator$1(parentModule, defaultContainer, configureOptions) {
    var pixelRatio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var hideOption = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {
      return false;
    };

    _classCallCheck(this, Configurator$1);

    this.parent = parentModule;
    this.changedOptions = [];
    this.container = defaultContainer;
    this.allowCreation = false;
    this.hideOption = hideOption;
    this.options = {};
    this.initialized = false;
    this.popupCounter = 0;
    this.defaultOptions = {
      enabled: false,
      filter: true,
      container: undefined,
      showButton: true
    };

    assign$2(this.options, this.defaultOptions);

    this.configureOptions = configureOptions;
    this.moduleOptions = {};
    this.domElements = [];
    this.popupDiv = {};
    this.popupLimit = 5;
    this.popupHistory = {};
    this.colorPicker = new ColorPicker$1(pixelRatio);
    this.wrapper = undefined;
  }
  /**
   * refresh all options.
   * Because all modules parse their options by themselves, we just use their options. We copy them here.
   *
   * @param {object} options
   */


  _createClass(Configurator$1, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        // reset the popup history because the indices may have been changed.
        this.popupHistory = {};

        this._removePopup();

        var enabled = true;

        if (typeof options === "string") {
          this.options.filter = options;
        } else if (isArray$2(options)) {
          this.options.filter = options.join();
        } else if (_typeof(options) === "object") {
          if (options == null) {
            throw new TypeError("options cannot be null");
          }

          if (options.container !== undefined) {
            this.options.container = options.container;
          }

          if (filter(options) !== undefined) {
            this.options.filter = filter(options);
          }

          if (options.showButton !== undefined) {
            this.options.showButton = options.showButton;
          }

          if (options.enabled !== undefined) {
            enabled = options.enabled;
          }
        } else if (typeof options === "boolean") {
          this.options.filter = true;
          enabled = options;
        } else if (typeof options === "function") {
          this.options.filter = options;
          enabled = true;
        }

        if (filter(this.options) === false) {
          enabled = false;
        }

        this.options.enabled = enabled;
      }

      this._clean();
    }
    /**
     *
     * @param {object} moduleOptions
     */

  }, {
    key: "setModuleOptions",
    value: function setModuleOptions(moduleOptions) {
      this.moduleOptions = moduleOptions;

      if (this.options.enabled === true) {
        this._clean();

        if (this.options.container !== undefined) {
          this.container = this.options.container;
        }

        this._create();
      }
    }
    /**
     * Create all DOM elements
     *
     * @private
     */

  }, {
    key: "_create",
    value: function _create() {
      this._clean();

      this.changedOptions = [];

      var filter$1 = filter(this.options);

      var counter = 0;
      var show = false;

      for (var _option in this.configureOptions) {
        if (Object.prototype.hasOwnProperty.call(this.configureOptions, _option)) {
          this.allowCreation = false;
          show = false;

          if (typeof filter$1 === "function") {
            show = filter$1(_option, []);
            show = show || this._handleObject(this.configureOptions[_option], [_option], true);
          } else if (filter$1 === true || indexOf(filter$1).call(filter$1, _option) !== -1) {
            show = true;
          }

          if (show !== false) {
            this.allowCreation = true; // linebreak between categories

            if (counter > 0) {
              this._makeItem([]);
            } // a header for the category


            this._makeHeader(_option); // get the sub options


            this._handleObject(this.configureOptions[_option], [_option]);
          }

          counter++;
        }
      }

      this._makeButton();

      this._push(); //~ this.colorPicker.insertTo(this.container);

    }
    /**
     * draw all DOM elements on the screen
     *
     * @private
     */

  }, {
    key: "_push",
    value: function _push() {
      this.wrapper = document.createElement("div");
      this.wrapper.className = "vis-configuration-wrapper";
      this.container.appendChild(this.wrapper);

      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.appendChild(this.domElements[i]);
      }

      this._showPopupIfNeeded();
    }
    /**
     * delete all DOM elements
     *
     * @private
     */

  }, {
    key: "_clean",
    value: function _clean() {
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.removeChild(this.domElements[i]);
      }

      if (this.wrapper !== undefined) {
        this.container.removeChild(this.wrapper);
        this.wrapper = undefined;
      }

      this.domElements = [];

      this._removePopup();
    }
    /**
     * get the value from the actualOptions if it exists
     *
     * @param {Array} path    | where to look for the actual option
     * @returns {*}
     * @private
     */

  }, {
    key: "_getValue",
    value: function _getValue(path) {
      var base = this.moduleOptions;

      for (var i = 0; i < path.length; i++) {
        if (base[path[i]] !== undefined) {
          base = base[path[i]];
        } else {
          base = undefined;
          break;
        }
      }

      return base;
    }
    /**
     * all option elements are wrapped in an item
     *
     * @param {Array} path    | where to look for the actual option
     * @param {Array.<Element>} domElements
     * @returns {number}
     * @private
     */

  }, {
    key: "_makeItem",
    value: function _makeItem(path) {
      if (this.allowCreation === true) {
        var item = document.createElement("div");
        item.className = "vis-configuration vis-config-item vis-config-s" + path.length;

        for (var _len6 = arguments.length, domElements = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
          domElements[_key6 - 1] = arguments[_key6];
        }

        forEach$2(domElements).call(domElements, function (element) {
          item.appendChild(element);
        });

        this.domElements.push(item);
        return this.domElements.length;
      }

      return 0;
    }
    /**
     * header for major subjects
     *
     * @param {string} name
     * @private
     */

  }, {
    key: "_makeHeader",
    value: function _makeHeader(name) {
      var div = document.createElement("div");
      div.className = "vis-configuration vis-config-header";
      div.innerText = name;

      this._makeItem([], div);
    }
    /**
     * make a label, if it is an object label, it gets different styling.
     *
     * @param {string} name
     * @param {Array} path    | where to look for the actual option
     * @param {string} objectLabel
     * @returns {HTMLElement}
     * @private
     */

  }, {
    key: "_makeLabel",
    value: function _makeLabel(name, path) {
      var objectLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var div = document.createElement("div");
      div.className = "vis-configuration vis-config-label vis-config-s" + path.length;

      if (objectLabel === true) {
        while (div.firstChild) {
          div.removeChild(div.firstChild);
        }

        div.appendChild(wrapInTag("i", "b", name));
      } else {
        div.innerText = name + ":";
      }

      return div;
    }
    /**
     * make a dropdown list for multiple possible string optoins
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeDropdown",
    value: function _makeDropdown(arr, value, path) {
      var select = document.createElement("select");
      select.className = "vis-configuration vis-config-select";
      var selectedValue = 0;

      if (value !== undefined) {
        if (indexOf(arr).call(arr, value) !== -1) {
          selectedValue = indexOf(arr).call(arr, value);
        }
      }

      for (var i = 0; i < arr.length; i++) {
        var _option2 = document.createElement("option");

        _option2.value = arr[i];

        if (i === selectedValue) {
          _option2.selected = "selected";
        }

        _option2.innerText = arr[i];
        select.appendChild(_option2);
      }

      var me = this;

      select.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, select);
    }
    /**
     * make a range object for numeric options
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeRange",
    value: function _makeRange(arr, value, path) {
      var defaultValue = arr[0];
      var min = arr[1];
      var max = arr[2];
      var step = arr[3];
      var range = document.createElement("input");
      range.className = "vis-configuration vis-config-range";

      try {
        range.type = "range"; // not supported on IE9

        range.min = min;
        range.max = max;
      } catch (err) {// TODO: Add some error handling.
      }

      range.step = step; // set up the popup settings in case they are needed.

      var popupString = "";
      var popupValue = 0;

      if (value !== undefined) {
        var factor = 1.2;

        if (value < 0 && value * factor < min) {
          range.min = Math.ceil(value * factor);
          popupValue = range.min;
          popupString = "range increased";
        } else if (value / factor < min) {
          range.min = Math.ceil(value / factor);
          popupValue = range.min;
          popupString = "range increased";
        }

        if (value * factor > max && max !== 1) {
          range.max = Math.ceil(value * factor);
          popupValue = range.max;
          popupString = "range increased";
        }

        range.value = value;
      } else {
        range.value = defaultValue;
      }

      var input = document.createElement("input");
      input.className = "vis-configuration vis-config-rangeinput";
      input.value = range.value;
      var me = this;

      range.onchange = function () {
        input.value = this.value;

        me._update(Number(this.value), path);
      };

      range.oninput = function () {
        input.value = this.value;
      };

      var label = this._makeLabel(path[path.length - 1], path);

      var itemIndex = this._makeItem(path, label, range, input); // if a popup is needed AND it has not been shown for this value, show it.


      if (popupString !== "" && this.popupHistory[itemIndex] !== popupValue) {
        this.popupHistory[itemIndex] = popupValue;

        this._setupPopup(popupString, itemIndex);
      }
    }
    /**
     * make a button object
     *
     * @private
     */

  }, {
    key: "_makeButton",
    value: function _makeButton() {
      var _this4 = this;

      if (this.options.showButton === true) {
        var generateButton = document.createElement("div");
        generateButton.className = "vis-configuration vis-config-button";
        generateButton.innerText = "generate options";

        generateButton.onclick = function () {
          _this4._printOptions();
        };

        generateButton.onmouseover = function () {
          generateButton.className = "vis-configuration vis-config-button hover";
        };

        generateButton.onmouseout = function () {
          generateButton.className = "vis-configuration vis-config-button";
        };

        this.optionsContainer = document.createElement("div");
        this.optionsContainer.className = "vis-configuration vis-config-option-container";
        this.domElements.push(this.optionsContainer);
        this.domElements.push(generateButton);
      }
    }
    /**
     * prepare the popup
     *
     * @param {string} string
     * @param {number} index
     * @private
     */

  }, {
    key: "_setupPopup",
    value: function _setupPopup(string, index) {
      var _this5 = this;

      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
        var div = document.createElement("div");
        div.id = "vis-configuration-popup";
        div.className = "vis-configuration-popup";
        div.innerText = string;

        div.onclick = function () {
          _this5._removePopup();
        };

        this.popupCounter += 1;
        this.popupDiv = {
          html: div,
          index: index
        };
      }
    }
    /**
     * remove the popup from the dom
     *
     * @private
     */

  }, {
    key: "_removePopup",
    value: function _removePopup() {
      if (this.popupDiv.html !== undefined) {
        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
        clearTimeout(this.popupDiv.hideTimeout);
        clearTimeout(this.popupDiv.deleteTimeout);
        this.popupDiv = {};
      }
    }
    /**
     * Show the popup if it is needed.
     *
     * @private
     */

  }, {
    key: "_showPopupIfNeeded",
    value: function _showPopupIfNeeded() {
      var _this6 = this;

      if (this.popupDiv.html !== undefined) {
        var correspondingElement = this.domElements[this.popupDiv.index];
        var rect = correspondingElement.getBoundingClientRect();
        this.popupDiv.html.style.left = rect.left + "px";
        this.popupDiv.html.style.top = rect.top - 30 + "px"; // 30 is the height;

        document.body.appendChild(this.popupDiv.html);
        this.popupDiv.hideTimeout = setTimeout$1(function () {
          _this6.popupDiv.html.style.opacity = 0;
        }, 1500);
        this.popupDiv.deleteTimeout = setTimeout$1(function () {
          _this6._removePopup();
        }, 1800);
      }
    }
    /**
     * make a checkbox for boolean options.
     *
     * @param {number} defaultValue
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeCheckbox",
    value: function _makeCheckbox(defaultValue, value, path) {
      var checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "vis-configuration vis-config-checkbox";
      checkbox.checked = defaultValue;

      if (value !== undefined) {
        checkbox.checked = value;

        if (value !== defaultValue) {
          if (_typeof(defaultValue) === "object") {
            if (value !== defaultValue.enabled) {
              this.changedOptions.push({
                path: path,
                value: value
              });
            }
          } else {
            this.changedOptions.push({
              path: path,
              value: value
            });
          }
        }
      }

      var me = this;

      checkbox.onchange = function () {
        me._update(this.checked, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, checkbox);
    }
    /**
     * make a text input field for string options.
     *
     * @param {number} defaultValue
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeTextInput",
    value: function _makeTextInput(defaultValue, value, path) {
      var checkbox = document.createElement("input");
      checkbox.type = "text";
      checkbox.className = "vis-configuration vis-config-text";
      checkbox.value = value;

      if (value !== defaultValue) {
        this.changedOptions.push({
          path: path,
          value: value
        });
      }

      var me = this;

      checkbox.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, checkbox);
    }
    /**
     * make a color field with a color picker for color fields
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_makeColorField",
    value: function _makeColorField(arr, value, path) {
      var _this7 = this;

      var defaultColor = arr[1];
      var div = document.createElement("div");
      value = value === undefined ? defaultColor : value;

      if (value !== "none") {
        div.className = "vis-configuration vis-config-colorBlock";
        div.style.backgroundColor = value;
      } else {
        div.className = "vis-configuration vis-config-colorBlock none";
      }

      value = value === undefined ? defaultColor : value;

      div.onclick = function () {
        _this7._showColorPicker(value, div, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);

      this._makeItem(path, label, div);
    }
    /**
     * used by the color buttons to call the color picker.
     *
     * @param {number} value
     * @param {HTMLElement} div
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_showColorPicker",
    value: function _showColorPicker(value, div, path) {
      var _this8 = this;

      // clear the callback from this div
      div.onclick = function () {};

      this.colorPicker.insertTo(div);
      this.colorPicker.show();
      this.colorPicker.setColor(value);
      this.colorPicker.setUpdateCallback(function (color) {
        var colorString = "rgba(" + color.r + "," + color.g + "," + color.b + "," + color.a + ")";
        div.style.backgroundColor = colorString;

        _this8._update(colorString, path);
      }); // on close of the colorpicker, restore the callback.

      this.colorPicker.setCloseCallback(function () {
        div.onclick = function () {
          _this8._showColorPicker(value, div, path);
        };
      });
    }
    /**
     * parse an object and draw the correct items
     *
     * @param {object} obj
     * @param {Array} [path=[]]    | where to look for the actual option
     * @param {boolean} [checkOnly=false]
     * @returns {boolean}
     * @private
     */

  }, {
    key: "_handleObject",
    value: function _handleObject(obj) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var checkOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var show = false;

      var filter$1 = filter(this.options);

      var visibleInSet = false;

      for (var subObj in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, subObj)) {
          show = true;
          var item = obj[subObj];
          var newPath = copyAndExtendArray(path, subObj);

          if (typeof filter$1 === "function") {
            show = filter$1(subObj, path); // if needed we must go deeper into the object.

            if (show === false) {
              if (!isArray$2(item) && typeof item !== "string" && typeof item !== "boolean" && item instanceof Object) {
                this.allowCreation = false;
                show = this._handleObject(item, newPath, true);
                this.allowCreation = checkOnly === false;
              }
            }
          }

          if (show !== false) {
            visibleInSet = true;

            var value = this._getValue(newPath);

            if (isArray$2(item)) {
              this._handleArray(item, value, newPath);
            } else if (typeof item === "string") {
              this._makeTextInput(item, value, newPath);
            } else if (typeof item === "boolean") {
              this._makeCheckbox(item, value, newPath);
            } else if (item instanceof Object) {
              // skip the options that are not enabled
              if (!this.hideOption(path, subObj, this.moduleOptions)) {
                // initially collapse options with an disabled enabled option.
                if (item.enabled !== undefined) {
                  var enabledPath = copyAndExtendArray(newPath, "enabled");

                  var enabledValue = this._getValue(enabledPath);

                  if (enabledValue === true) {
                    var label = this._makeLabel(subObj, newPath, true);

                    this._makeItem(newPath, label);

                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                  } else {
                    this._makeCheckbox(item, enabledValue, newPath);
                  }
                } else {
                  var _label = this._makeLabel(subObj, newPath, true);

                  this._makeItem(newPath, _label);

                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                }
              }
            } else {
              console.error("dont know how to handle", item, subObj, newPath);
            }
          }
        }
      }

      return visibleInSet;
    }
    /**
     * handle the array type of option
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_handleArray",
    value: function _handleArray(arr, value, path) {
      if (typeof arr[0] === "string" && arr[0] === "color") {
        this._makeColorField(arr, value, path);

        if (arr[1] !== value) {
          this.changedOptions.push({
            path: path,
            value: value
          });
        }
      } else if (typeof arr[0] === "string") {
        this._makeDropdown(arr, value, path);

        if (arr[0] !== value) {
          this.changedOptions.push({
            path: path,
            value: value
          });
        }
      } else if (typeof arr[0] === "number") {
        this._makeRange(arr, value, path);

        if (arr[0] !== value) {
          this.changedOptions.push({
            path: path,
            value: Number(value)
          });
        }
      }
    }
    /**
     * called to update the network with the new settings.
     *
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: "_update",
    value: function _update(value, path) {
      var options = this._constructOptions(value, path);

      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
        this.parent.body.emitter.emit("configChange", options);
      }

      this.initialized = true;
      this.parent.setOptions(options);
    }
    /**
     *
     * @param {string | boolean} value
     * @param {Array.<string>} path
     * @param {{}} optionsObj
     * @returns {{}}
     * @private
     */

  }, {
    key: "_constructOptions",
    value: function _constructOptions(value, path) {
      var optionsObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var pointer = optionsObj; // when dropdown boxes can be string or boolean, we typecast it into correct types

      value = value === "true" ? true : value;
      value = value === "false" ? false : value;

      for (var i = 0; i < path.length; i++) {
        if (path[i] !== "global") {
          if (pointer[path[i]] === undefined) {
            pointer[path[i]] = {};
          }

          if (i !== path.length - 1) {
            pointer = pointer[path[i]];
          } else {
            pointer[path[i]] = value;
          }
        }
      }

      return optionsObj;
    }
    /**
     * @private
     */

  }, {
    key: "_printOptions",
    value: function _printOptions() {
      var options = this.getOptions();

      while (this.optionsContainer.firstChild) {
        this.optionsContainer.removeChild(this.optionsContainer.firstChild);
      }

      this.optionsContainer.appendChild(wrapInTag("pre", "const options = " + stringify$1(options, null, 2)));
    }
    /**
     *
     * @returns {{}} options
     */

  }, {
    key: "getOptions",
    value: function getOptions() {
      var options = {};

      for (var i = 0; i < this.changedOptions.length; i++) {
        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
      }

      return options;
    }
  }]);

  return Configurator$1;
}();
/**
 * Popup is a class to create a popup window with some text
 */


var Popup$1 = /*#__PURE__*/function () {
  /**
   * @param {Element} container       The container object.
   * @param {string}  overflowMethod  How the popup should act to overflowing ('flip' or 'cap')
   */
  function Popup$1(container, overflowMethod) {
    _classCallCheck(this, Popup$1);

    this.container = container;
    this.overflowMethod = overflowMethod || "cap";
    this.x = 0;
    this.y = 0;
    this.padding = 5;
    this.hidden = false; // create the frame

    this.frame = document.createElement("div");
    this.frame.className = "vis-tooltip";
    this.container.appendChild(this.frame);
  }
  /**
   * @param {number} x   Horizontal position of the popup window
   * @param {number} y   Vertical position of the popup window
   */


  _createClass(Popup$1, [{
    key: "setPosition",
    value: function setPosition(x, y) {
      this.x = _parseInt(x);
      this.y = _parseInt(y);
    }
    /**
     * Set the content for the popup window. This can be HTML code or text.
     *
     * @param {string | Element} content
     */

  }, {
    key: "setText",
    value: function setText(content) {
      if (content instanceof Element) {
        while (this.frame.firstChild) {
          this.frame.removeChild(this.frame.firstChild);
        }

        this.frame.appendChild(content);
      } else {
        // String containing literal text, element has to be used for HTML due to
        // XSS risks associated with innerHTML (i.e. prevent XSS by accident).
        this.frame.innerText = content;
      }
    }
    /**
     * Show the popup window
     *
     * @param {boolean} [doShow]    Show or hide the window
     */

  }, {
    key: "show",
    value: function show(doShow) {
      if (doShow === undefined) {
        doShow = true;
      }

      if (doShow === true) {
        var height = this.frame.clientHeight;
        var width = this.frame.clientWidth;
        var maxHeight = this.frame.parentNode.clientHeight;
        var maxWidth = this.frame.parentNode.clientWidth;
        var left = 0,
            top = 0;

        if (this.overflowMethod == "flip") {
          var isLeft = false,
              isTop = true; // Where around the position it's located

          if (this.y - height < this.padding) {
            isTop = false;
          }

          if (this.x + width > maxWidth - this.padding) {
            isLeft = true;
          }

          if (isLeft) {
            left = this.x - width;
          } else {
            left = this.x;
          }

          if (isTop) {
            top = this.y - height;
          } else {
            top = this.y;
          }
        } else {
          top = this.y - height;

          if (top + height + this.padding > maxHeight) {
            top = maxHeight - height - this.padding;
          }

          if (top < this.padding) {
            top = this.padding;
          }

          left = this.x;

          if (left + width + this.padding > maxWidth) {
            left = maxWidth - width - this.padding;
          }

          if (left < this.padding) {
            left = this.padding;
          }
        }

        this.frame.style.left = left + "px";
        this.frame.style.top = top + "px";
        this.frame.style.visibility = "visible";
        this.hidden = false;
      } else {
        this.hide();
      }
    }
    /**
     * Hide the popup window
     */

  }, {
    key: "hide",
    value: function hide() {
      this.hidden = true;
      this.frame.style.left = "0";
      this.frame.style.top = "0";
      this.frame.style.visibility = "hidden";
    }
    /**
     * Remove the popup window
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.frame.parentNode.removeChild(this.frame); // Remove element from DOM
    }
  }]);

  return Popup$1;
}();

var errorFound = false;
var allOptions$1;
var VALIDATOR_PRINT_STYLE$1 = "background: #FFeeee; color: #dd0000";
/**
 *  Used to validate options.
 */

var Validator$1 = /*#__PURE__*/function () {
  function Validator$1() {
    _classCallCheck(this, Validator$1);
  }

  _createClass(Validator$1, null, [{
    key: "validate",
    value:
    /**
     * Main function to be called
     *
     * @param {object} options
     * @param {object} referenceOptions
     * @param {object} subObject
     * @returns {boolean}
     * @static
     */
    function validate(options, referenceOptions, subObject) {
      errorFound = false;
      allOptions$1 = referenceOptions;
      var usedOptions = referenceOptions;

      if (subObject !== undefined) {
        usedOptions = referenceOptions[subObject];
      }

      Validator$1.parse(options, usedOptions, []);
      return errorFound;
    }
    /**
     * Will traverse an object recursively and check every value
     *
     * @param {object} options
     * @param {object} referenceOptions
     * @param {Array} path    | where to look for the actual option
     * @static
     */

  }, {
    key: "parse",
    value: function parse(options, referenceOptions, path) {
      for (var _option3 in options) {
        if (Object.prototype.hasOwnProperty.call(options, _option3)) {
          Validator$1.check(_option3, options, referenceOptions, path);
        }
      }
    }
    /**
     * Check every value. If the value is an object, call the parse function on that object.
     *
     * @param {string} option
     * @param {object} options
     * @param {object} referenceOptions
     * @param {Array} path    | where to look for the actual option
     * @static
     */

  }, {
    key: "check",
    value: function check(option, options, referenceOptions, path) {
      if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {
        Validator$1.getSuggestion(option, referenceOptions, path);
        return;
      }

      var referenceOption = option;
      var is_object = true;

      if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {
        // NOTE: This only triggers if the __any__ is in the top level of the options object.
        //       THAT'S A REALLY BAD PLACE TO ALLOW IT!!!!
        // TODO: Examine if needed, remove if possible
        // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.
        referenceOption = "__any__"; // if the any-subgroup is not a predefined object in the configurator,
        // we do not look deeper into the object.

        is_object = Validator$1.getType(options[option]) === "object";
      }

      var refOptionObj = referenceOptions[referenceOption];

      if (is_object && refOptionObj.__type__ !== undefined) {
        refOptionObj = refOptionObj.__type__;
      }

      Validator$1.checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path);
    }
    /**
     *
     * @param {string}  option           | the option property
     * @param {object}  options          | The supplied options object
     * @param {object}  referenceOptions | The reference options containing all options and their allowed formats
     * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.
     * @param {string}  refOptionObj     | This is the type object from the reference options
     * @param {Array}   path             | where in the object is the option
     * @static
     */

  }, {
    key: "checkFields",
    value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {
      var log = function log(message) {
        console.error("%c" + message + Validator$1.printLocation(path, option), VALIDATOR_PRINT_STYLE$1);
      };

      var optionType = Validator$1.getType(options[option]);
      var refOptionType = refOptionObj[optionType];

      if (refOptionType !== undefined) {
        // if the type is correct, we check if it is supposed to be one of a few select values
        if (Validator$1.getType(refOptionType) === "array" && indexOf(refOptionType).call(refOptionType, options[option]) === -1) {
          log('Invalid option detected in "' + option + '".' + " Allowed values are:" + Validator$1.print(refOptionType) + ' not "' + options[option] + '". ');
          errorFound = true;
        } else if (optionType === "object" && referenceOption !== "__any__") {
          path = copyAndExtendArray(path, option);
          Validator$1.parse(options[option], referenceOptions[referenceOption], path);
        }
      } else if (refOptionObj["any"] === undefined) {
        // type of the field is incorrect and the field cannot be any
        log('Invalid type received for "' + option + '". Expected: ' + Validator$1.print(keys$4(refOptionObj)) + ". Received [" + optionType + '] "' + options[option] + '"');
        errorFound = true;
      }
    }
    /**
     *
     * @param {object | boolean | number | string | Array.<number> | Date | Node | Moment | undefined | null} object
     * @returns {string}
     * @static
     */

  }, {
    key: "getType",
    value: function getType(object) {
      var type = _typeof(object);

      if (type === "object") {
        if (object === null) {
          return "null";
        }

        if (object instanceof Boolean) {
          return "boolean";
        }

        if (object instanceof Number) {
          return "number";
        }

        if (object instanceof String) {
          return "string";
        }

        if (isArray$2(object)) {
          return "array";
        }

        if (object instanceof Date) {
          return "date";
        }

        if (object.nodeType !== undefined) {
          return "dom";
        }

        if (object._isAMomentObject === true) {
          return "moment";
        }

        return "object";
      } else if (type === "number") {
        return "number";
      } else if (type === "boolean") {
        return "boolean";
      } else if (type === "string") {
        return "string";
      } else if (type === undefined) {
        return "undefined";
      }

      return type;
    }
    /**
     * @param {string} option
     * @param {object} options
     * @param {Array.<string>} path
     * @static
     */

  }, {
    key: "getSuggestion",
    value: function getSuggestion(option, options, path) {
      var localSearch = Validator$1.findInOptions(option, options, path, false);
      var globalSearch = Validator$1.findInOptions(option, allOptions$1, [], true);
      var localSearchThreshold = 8;
      var globalSearchThreshold = 4;
      var msg;

      if (localSearch.indexMatch !== undefined) {
        msg = " in " + Validator$1.printLocation(localSearch.path, option, "") + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n';
      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
        msg = " in " + Validator$1.printLocation(localSearch.path, option, "") + "Perhaps it was misplaced? Matching option found at: " + Validator$1.printLocation(globalSearch.path, globalSearch.closestMatch, "");
      } else if (localSearch.distance <= localSearchThreshold) {
        msg = '. Did you mean "' + localSearch.closestMatch + '"?' + Validator$1.printLocation(localSearch.path, option);
      } else {
        msg = ". Did you mean one of these: " + Validator$1.print(keys$4(options)) + Validator$1.printLocation(path, option);
      }

      console.error('%cUnknown option detected: "' + option + '"' + msg, VALIDATOR_PRINT_STYLE$1);
      errorFound = true;
    }
    /**
     * traverse the options in search for a match.
     *
     * @param {string} option
     * @param {object} options
     * @param {Array} path    | where to look for the actual option
     * @param {boolean} [recursive=false]
     * @returns {{closestMatch: string, path: Array, distance: number}}
     * @static
     */

  }, {
    key: "findInOptions",
    value: function findInOptions(option, options, path) {
      var recursive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var min = 1e9;
      var closestMatch = "";
      var closestMatchPath = [];
      var lowerCaseOption = option.toLowerCase();
      var indexMatch = undefined;

      for (var op in options) {
        var distance = void 0;

        if (options[op].__type__ !== undefined && recursive === true) {
          var result = Validator$1.findInOptions(option, options[op], copyAndExtendArray(path, op));

          if (min > result.distance) {
            closestMatch = result.closestMatch;
            closestMatchPath = result.path;
            min = result.distance;
            indexMatch = result.indexMatch;
          }
        } else {
          var _context20;

          if (indexOf(_context20 = op.toLowerCase()).call(_context20, lowerCaseOption) !== -1) {
            indexMatch = op;
          }

          distance = Validator$1.levenshteinDistance(option, op);

          if (min > distance) {
            closestMatch = op;
            closestMatchPath = copyArray(path);
            min = distance;
          }
        }
      }

      return {
        closestMatch: closestMatch,
        path: closestMatchPath,
        distance: min,
        indexMatch: indexMatch
      };
    }
    /**
     * @param {Array.<string>} path
     * @param {object} option
     * @param {string} prefix
     * @returns {string}
     * @static
     */

  }, {
    key: "printLocation",
    value: function printLocation(path, option) {
      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "Problem value found at: \n";
      var str = "\n\n" + prefix + "options = {\n";

      for (var i = 0; i < path.length; i++) {
        for (var j = 0; j < i + 1; j++) {
          str += "  ";
        }

        str += path[i] + ": {\n";
      }

      for (var _j = 0; _j < path.length + 1; _j++) {
        str += "  ";
      }

      str += option + "\n";

      for (var _i3 = 0; _i3 < path.length + 1; _i3++) {
        for (var _j2 = 0; _j2 < path.length - _i3; _j2++) {
          str += "  ";
        }

        str += "}\n";
      }

      return str + "\n\n";
    }
    /**
     * @param {object} options
     * @returns {string}
     * @static
     */

  }, {
    key: "print",
    value: function print(options) {
      return stringify$1(options).replace(/(")|(\[)|(\])|(,"__type__")/g, "").replace(/(,)/g, ", ");
    }
    /**
     *  Compute the edit distance between the two given strings
     * http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
     *
     * Copyright (c) 2011 Andrei Mackenzie
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     *
     * @param {string} a
     * @param {string} b
     * @returns {Array.<Array.<number>>}}
     * @static
     */

  }, {
    key: "levenshteinDistance",
    value: function levenshteinDistance(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;
      var matrix = []; // increment along the first column of each row

      var i;

      for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      } // increment each column in the first row


      var j;

      for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      } // Fill in the rest of the matrix


      for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) == a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
            Math.min(matrix[i][j - 1] + 1, // insertion
            matrix[i - 1][j] + 1)); // deletion
          }
        }
      }

      return matrix[b.length][a.length];
    }
  }]);

  return Validator$1;
}();

var Activator = Activator$1;
var Configurator = Configurator$1;
var Hammer = Hammer$1;
var Popup = Popup$1;
var VALIDATOR_PRINT_STYLE = VALIDATOR_PRINT_STYLE$1;
var Validator = Validator$1;

/* eslint-disable no-prototype-builtins */

/* eslint-disable no-unused-vars */

/* eslint-disable no-var */

/**
 * Parse a text source containing data in DOT language into a JSON object.
 * The object contains two lists: one with nodes and one with edges.
 *
 * DOT language reference: http://www.graphviz.org/doc/info/lang.html
 *
 * DOT language attributes: http://graphviz.org/content/attrs
 *
 * @param {string} data     Text containing a graph in DOT-notation
 * @returns {object} graph   An object containing two parameters:
 *                          {Object[]} nodes
 *                          {Object[]} edges
 *
 * -------------------------------------------
 * TODO
 * ====
 *
 * For label handling, this is an incomplete implementation. From docs (quote #3015):
 *
 * > the escape sequences "\n", "\l" and "\r" divide the label into lines, centered,
 * > left-justified, and right-justified, respectively.
 *
 * Source: http://www.graphviz.org/content/attrs#kescString
 *
 * > As another aid for readability, dot allows double-quoted strings to span multiple physical
 * > lines using the standard C convention of a backslash immediately preceding a newline
 * > character
 * > In addition, double-quoted strings can be concatenated using a '+' operator.
 * > As HTML strings can contain newline characters, which are used solely for formatting,
 * > the language does not allow escaped newlines or concatenation operators to be used
 * > within them.
 *
 * - Currently, only '\\n' is handled
 * - Note that text explicitly says 'labels'; the dot parser currently handles escape
 *   sequences in **all** strings.
 */
function parseDOT(data) {
  dot = data;
  return parseGraph();
} // mapping of attributes from DOT (the keys) to vis.js (the values)

var NODE_ATTR_MAPPING = {
  fontsize: "font.size",
  fontcolor: "font.color",
  labelfontcolor: "font.color",
  fontname: "font.face",
  color: ["color.border", "color.background"],
  fillcolor: "color.background",
  tooltip: "title",
  labeltooltip: "title"
};

var EDGE_ATTR_MAPPING = create$5(NODE_ATTR_MAPPING);

EDGE_ATTR_MAPPING.color = "color.color";
EDGE_ATTR_MAPPING.style = "dashes"; // token types enumeration

var TOKENTYPE = {
  NULL: 0,
  DELIMITER: 1,
  IDENTIFIER: 2,
  UNKNOWN: 3
}; // map with all delimiters

var DELIMITERS = {
  "{": true,
  "}": true,
  "[": true,
  "]": true,
  ";": true,
  "=": true,
  ",": true,
  "->": true,
  "--": true
};
var dot = ""; // current dot file

var index$1 = 0; // current index in dot file

var c = ""; // current token character in expr

var token = ""; // current token

var tokenType = TOKENTYPE.NULL; // type of the token

/**
 * Get the first character from the dot file.
 * The character is stored into the char c. If the end of the dot file is
 * reached, the function puts an empty string in c.
 */

function first() {
  index$1 = 0;
  c = dot.charAt(0);
}
/**
 * Get the next character from the dot file.
 * The character is stored into the char c. If the end of the dot file is
 * reached, the function puts an empty string in c.
 */


function next() {
  index$1++;
  c = dot.charAt(index$1);
}
/**
 * Preview the next character from the dot file.
 *
 * @returns {string} cNext
 */


function nextPreview() {
  return dot.charAt(index$1 + 1);
}
/**
 * Test whether given character is alphabetic or numeric ( a-zA-Z_0-9.:# )
 *
 * @param {string} c
 * @returns {boolean} isAlphaNumeric
 */


function isAlphaNumeric(c) {
  var charCode = c.charCodeAt(0);

  if (charCode < 47) {
    // #.
    return charCode === 35 || charCode === 46;
  }

  if (charCode < 59) {
    // 0-9 and :
    return charCode > 47;
  }

  if (charCode < 91) {
    // A-Z
    return charCode > 64;
  }

  if (charCode < 96) {
    // _
    return charCode === 95;
  }

  if (charCode < 123) {
    // a-z
    return charCode > 96;
  }

  return false;
}
/**
 * Merge all options of object b into object b
 *
 * @param {object} a
 * @param {object} b
 * @returns {object} a
 */


function merge$1(a, b) {
  if (!a) {
    a = {};
  }

  if (b) {
    for (var name in b) {
      if (b.hasOwnProperty(name)) {
        a[name] = b[name];
      }
    }
  }

  return a;
}
/**
 * Set a value in an object, where the provided parameter name can be a
 * path with nested parameters. For example:
 *
 *     var obj = {a: 2};
 *     setValue(obj, 'b.c', 3);     // obj = {a: 2, b: {c: 3}}
 *
 * @param {object} obj
 * @param {string} path  A parameter name or dot-separated parameter path,
 *                      like "color.highlight.border".
 * @param {*} value
 */


function setValue(obj, path, value) {
  var keys = path.split(".");
  var o = obj;

  while (keys.length) {
    var key = keys.shift();

    if (keys.length) {
      // this isn't the end point
      if (!o[key]) {
        o[key] = {};
      }

      o = o[key];
    } else {
      // this is the end point
      o[key] = value;
    }
  }
}
/**
 * Add a node to a graph object. If there is already a node with
 * the same id, their attributes will be merged.
 *
 * @param {object} graph
 * @param {object} node
 */


function addNode(graph, node) {
  var i, len;
  var current = null; // find root graph (in case of subgraph)

  var graphs = [graph]; // list with all graphs from current graph to root graph

  var root = graph;

  while (root.parent) {
    graphs.push(root.parent);
    root = root.parent;
  } // find existing node (at root level) by its id


  if (root.nodes) {
    for (i = 0, len = root.nodes.length; i < len; i++) {
      if (node.id === root.nodes[i].id) {
        current = root.nodes[i];
        break;
      }
    }
  }

  if (!current) {
    // this is a new node
    current = {
      id: node.id
    };

    if (graph.node) {
      // clone default attributes
      current.attr = merge$1(current.attr, graph.node);
    }
  } // add node to this (sub)graph and all its parent graphs


  for (i = graphs.length - 1; i >= 0; i--) {
    var _context;

    var g = graphs[i];

    if (!g.nodes) {
      g.nodes = [];
    }

    if (indexOf(_context = g.nodes).call(_context, current) === -1) {
      g.nodes.push(current);
    }
  } // merge attributes


  if (node.attr) {
    current.attr = merge$1(current.attr, node.attr);
  }
}
/**
 * Add an edge to a graph object
 *
 * @param {object} graph
 * @param {object} edge
 */


function addEdge(graph, edge) {
  if (!graph.edges) {
    graph.edges = [];
  }

  graph.edges.push(edge);

  if (graph.edge) {
    var attr = merge$1({}, graph.edge); // clone default attributes

    edge.attr = merge$1(attr, edge.attr); // merge attributes
  }
}
/**
 * Create an edge to a graph object
 *
 * @param {object} graph
 * @param {string | number | object} from
 * @param {string | number | object} to
 * @param {string} type
 * @param {object | null} attr
 * @returns {object} edge
 */


function createEdge(graph, from, to, type, attr) {
  var edge = {
    from: from,
    to: to,
    type: type
  };

  if (graph.edge) {
    edge.attr = merge$1({}, graph.edge); // clone default attributes
  }

  edge.attr = merge$1(edge.attr || {}, attr); // merge attributes
  // Move arrows attribute from attr to edge temporally created in
  // parseAttributeList().

  if (attr != null) {
    if (attr.hasOwnProperty("arrows") && attr["arrows"] != null) {
      edge["arrows"] = {
        to: {
          enabled: true,
          type: attr.arrows.type
        }
      };
      attr["arrows"] = null;
    }
  }

  return edge;
}
/**
 * Get next token in the current dot file.
 * The token and token type are available as token and tokenType
 */


function getToken() {
  tokenType = TOKENTYPE.NULL;
  token = ""; // skip over whitespaces

  while (c === " " || c === "\t" || c === "\n" || c === "\r") {
    // space, tab, enter
    next();
  }

  do {
    var isComment = false; // skip comment

    if (c === "#") {
      // find the previous non-space character
      var i = index$1 - 1;

      while (dot.charAt(i) === " " || dot.charAt(i) === "\t") {
        i--;
      }

      if (dot.charAt(i) === "\n" || dot.charAt(i) === "") {
        // the # is at the start of a line, this is indeed a line comment
        while (c != "" && c != "\n") {
          next();
        }

        isComment = true;
      }
    }

    if (c === "/" && nextPreview() === "/") {
      // skip line comment
      while (c != "" && c != "\n") {
        next();
      }

      isComment = true;
    }

    if (c === "/" && nextPreview() === "*") {
      // skip block comment
      while (c != "") {
        if (c === "*" && nextPreview() === "/") {
          // end of block comment found. skip these last two characters
          next();
          next();
          break;
        } else {
          next();
        }
      }

      isComment = true;
    } // skip over whitespaces


    while (c === " " || c === "\t" || c === "\n" || c === "\r") {
      // space, tab, enter
      next();
    }
  } while (isComment); // check for end of dot file


  if (c === "") {
    // token is still empty
    tokenType = TOKENTYPE.DELIMITER;
    return;
  } // check for delimiters consisting of 2 characters


  var c2 = c + nextPreview();

  if (DELIMITERS[c2]) {
    tokenType = TOKENTYPE.DELIMITER;
    token = c2;
    next();
    next();
    return;
  } // check for delimiters consisting of 1 character


  if (DELIMITERS[c]) {
    tokenType = TOKENTYPE.DELIMITER;
    token = c;
    next();
    return;
  } // check for an identifier (number or string)
  // TODO: more precise parsing of numbers/strings (and the port separator ':')


  if (isAlphaNumeric(c) || c === "-") {
    token += c;
    next();

    while (isAlphaNumeric(c)) {
      token += c;
      next();
    }

    if (token === "false") {
      token = false; // convert to boolean
    } else if (token === "true") {
      token = true; // convert to boolean
    } else if (!isNaN(Number(token))) {
      token = Number(token); // convert to number
    }

    tokenType = TOKENTYPE.IDENTIFIER;
    return;
  } // check for a string enclosed by double quotes


  if (c === '"') {
    next();

    while (c != "" && (c != '"' || c === '"' && nextPreview() === '"')) {
      if (c === '"') {
        // skip the escape character
        token += c;
        next();
      } else if (c === "\\" && nextPreview() === "n") {
        // Honor a newline escape sequence
        token += "\n";
        next();
      } else {
        token += c;
      }

      next();
    }

    if (c != '"') {
      throw newSyntaxError('End of string " expected');
    }

    next();
    tokenType = TOKENTYPE.IDENTIFIER;
    return;
  } // something unknown is found, wrong characters, a syntax error


  tokenType = TOKENTYPE.UNKNOWN;

  while (c != "") {
    token += c;
    next();
  }

  throw new SyntaxError('Syntax error in part "' + chop(token, 30) + '"');
}
/**
 * Parse a graph.
 *
 * @returns {object} graph
 */


function parseGraph() {
  var graph = {};
  first();
  getToken(); // optional strict keyword

  if (token === "strict") {
    graph.strict = true;
    getToken();
  } // graph or digraph keyword


  if (token === "graph" || token === "digraph") {
    graph.type = token;
    getToken();
  } // optional graph id


  if (tokenType === TOKENTYPE.IDENTIFIER) {
    graph.id = token;
    getToken();
  } // open angle bracket


  if (token != "{") {
    throw newSyntaxError("Angle bracket { expected");
  }

  getToken(); // statements

  parseStatements(graph); // close angle bracket

  if (token != "}") {
    throw newSyntaxError("Angle bracket } expected");
  }

  getToken(); // end of file

  if (token !== "") {
    throw newSyntaxError("End of file expected");
  }

  getToken(); // remove temporary default options

  delete graph.node;
  delete graph.edge;
  delete graph.graph;
  return graph;
}
/**
 * Parse a list with statements.
 *
 * @param {object} graph
 */


function parseStatements(graph) {
  while (token !== "" && token != "}") {
    parseStatement(graph);

    if (token === ";") {
      getToken();
    }
  }
}
/**
 * Parse a single statement. Can be a an attribute statement, node
 * statement, a series of node statements and edge statements, or a
 * parameter.
 *
 * @param {object} graph
 */


function parseStatement(graph) {
  // parse subgraph
  var subgraph = parseSubgraph(graph);

  if (subgraph) {
    // edge statements
    parseEdge(graph, subgraph);
    return;
  } // parse an attribute statement


  var attr = parseAttributeStatement(graph);

  if (attr) {
    return;
  } // parse node


  if (tokenType != TOKENTYPE.IDENTIFIER) {
    throw newSyntaxError("Identifier expected");
  }

  var id = token; // id can be a string or a number

  getToken();

  if (token === "=") {
    // id statement
    getToken();

    if (tokenType != TOKENTYPE.IDENTIFIER) {
      throw newSyntaxError("Identifier expected");
    }

    graph[id] = token;
    getToken(); // TODO: implement comma separated list with "a_list: ID=ID [','] [a_list] "
  } else {
    parseNodeStatement(graph, id);
  }
}
/**
 * Parse a subgraph
 *
 * @param {object} graph    parent graph object
 * @returns {object | null} subgraph
 */


function parseSubgraph(graph) {
  var subgraph = null; // optional subgraph keyword

  if (token === "subgraph") {
    subgraph = {};
    subgraph.type = "subgraph";
    getToken(); // optional graph id

    if (tokenType === TOKENTYPE.IDENTIFIER) {
      subgraph.id = token;
      getToken();
    }
  } // open angle bracket


  if (token === "{") {
    getToken();

    if (!subgraph) {
      subgraph = {};
    }

    subgraph.parent = graph;
    subgraph.node = graph.node;
    subgraph.edge = graph.edge;
    subgraph.graph = graph.graph; // statements

    parseStatements(subgraph); // close angle bracket

    if (token != "}") {
      throw newSyntaxError("Angle bracket } expected");
    }

    getToken(); // remove temporary default options

    delete subgraph.node;
    delete subgraph.edge;
    delete subgraph.graph;
    delete subgraph.parent; // register at the parent graph

    if (!graph.subgraphs) {
      graph.subgraphs = [];
    }

    graph.subgraphs.push(subgraph);
  }

  return subgraph;
}
/**
 * parse an attribute statement like "node [shape=circle fontSize=16]".
 * Available keywords are 'node', 'edge', 'graph'.
 * The previous list with default attributes will be replaced
 *
 * @param {object} graph
 * @returns {string | null} keyword Returns the name of the parsed attribute
 *                                  (node, edge, graph), or null if nothing
 *                                  is parsed.
 */


function parseAttributeStatement(graph) {
  // attribute statements
  if (token === "node") {
    getToken(); // node attributes

    graph.node = parseAttributeList();
    return "node";
  } else if (token === "edge") {
    getToken(); // edge attributes

    graph.edge = parseAttributeList();
    return "edge";
  } else if (token === "graph") {
    getToken(); // graph attributes

    graph.graph = parseAttributeList();
    return "graph";
  }

  return null;
}
/**
 * parse a node statement
 *
 * @param {object} graph
 * @param {string | number} id
 */


function parseNodeStatement(graph, id) {
  // node statement
  var node = {
    id: id
  };
  var attr = parseAttributeList();

  if (attr) {
    node.attr = attr;
  }

  addNode(graph, node); // edge statements

  parseEdge(graph, id);
}
/**
 * Parse an edge or a series of edges
 *
 * @param {object} graph
 * @param {string | number} from        Id of the from node
 */


function parseEdge(graph, from) {
  while (token === "->" || token === "--") {
    var to;
    var type = token;
    getToken();
    var subgraph = parseSubgraph(graph);

    if (subgraph) {
      to = subgraph;
    } else {
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Identifier or subgraph expected");
      }

      to = token;
      addNode(graph, {
        id: to
      });
      getToken();
    } // parse edge attributes


    var attr = parseAttributeList(); // create edge

    var edge = createEdge(graph, from, to, type, attr);
    addEdge(graph, edge);
    from = to;
  }
}
/**
 * Parse a set with attributes,
 * for example [label="1.000", shape=solid]
 *
 * @returns {object | null} attr
 */


function parseAttributeList() {
  var i;
  var attr = null; // edge styles of dot and vis

  var edgeStyles = {
    dashed: true,
    solid: false,
    dotted: [1, 5]
  };
  /**
   * Define arrow types.
   * vis currently supports types defined in 'arrowTypes'.
   * Details of arrow shapes are described in
   * http://www.graphviz.org/content/arrow-shapes
   */

  var arrowTypes = {
    dot: "circle",
    box: "box",
    crow: "crow",
    curve: "curve",
    icurve: "inv_curve",
    normal: "triangle",
    inv: "inv_triangle",
    diamond: "diamond",
    tee: "bar",
    vee: "vee"
  };
  /**
   * 'attr_list' contains attributes for checking if some of them are affected
   * later. For instance, both of 'arrowhead' and 'dir' (edge style defined
   * in DOT) make changes to 'arrows' attribute in vis.
   */

  var attr_list = new Array();
  var attr_names = new Array(); // used for checking the case.
  // parse attributes

  while (token === "[") {
    getToken();
    attr = {};

    while (token !== "" && token != "]") {
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Attribute name expected");
      }

      var name = token;
      getToken();

      if (token != "=") {
        throw newSyntaxError("Equal sign = expected");
      }

      getToken();

      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Attribute value expected");
      }

      var value = token; // convert from dot style to vis

      if (name === "style") {
        value = edgeStyles[value];
      }

      var arrowType;

      if (name === "arrowhead") {
        arrowType = arrowTypes[value];
        name = "arrows";
        value = {
          to: {
            enabled: true,
            type: arrowType
          }
        };
      }

      if (name === "arrowtail") {
        arrowType = arrowTypes[value];
        name = "arrows";
        value = {
          from: {
            enabled: true,
            type: arrowType
          }
        };
      }

      attr_list.push({
        attr: attr,
        name: name,
        value: value
      });
      attr_names.push(name);
      getToken();

      if (token == ",") {
        getToken();
      }
    }

    if (token != "]") {
      throw newSyntaxError("Bracket ] expected");
    }

    getToken();
  }
  /**
   * As explained in [1], graphviz has limitations for combination of
   * arrow[head|tail] and dir. If attribute list includes 'dir',
   * following cases just be supported.
   *   1. both or none + arrowhead, arrowtail
   *   2. forward + arrowhead (arrowtail is not affedted)
   *   3. back + arrowtail (arrowhead is not affected)
   * [1] https://www.graphviz.org/doc/info/attrs.html#h:undir_note
   */


  if (includes(attr_names).call(attr_names, "dir")) {
    var idx = {}; // get index of 'arrows' and 'dir'

    idx.arrows = {};

    for (i = 0; i < attr_list.length; i++) {
      if (attr_list[i].name === "arrows") {
        if (attr_list[i].value.to != null) {
          idx.arrows.to = i;
        } else if (attr_list[i].value.from != null) {
          idx.arrows.from = i;
        } else {
          throw newSyntaxError("Invalid value of arrows");
        }
      } else if (attr_list[i].name === "dir") {
        idx.dir = i;
      }
    } // first, add default arrow shape if it is not assigned to avoid error


    var dir_type = attr_list[idx.dir].value;

    if (!includes(attr_names).call(attr_names, "arrows")) {
      if (dir_type === "both") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            to: {
              enabled: true
            }
          }
        });
        idx.arrows.to = attr_list.length - 1;
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            from: {
              enabled: true
            }
          }
        });
        idx.arrows.from = attr_list.length - 1;
      } else if (dir_type === "forward") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            to: {
              enabled: true
            }
          }
        });
        idx.arrows.to = attr_list.length - 1;
      } else if (dir_type === "back") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            from: {
              enabled: true
            }
          }
        });
        idx.arrows.from = attr_list.length - 1;
      } else if (dir_type === "none") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: ""
        });
        idx.arrows.to = attr_list.length - 1;
      } else {
        throw newSyntaxError('Invalid dir type "' + dir_type + '"');
      }
    }

    var from_type;
    var to_type; // update 'arrows' attribute from 'dir'.

    if (dir_type === "both") {
      // both of shapes of 'from' and 'to' are given
      if (idx.arrows.to && idx.arrows.from) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };

        splice$1(attr_list).call(attr_list, idx.arrows.from, 1); // shape of 'to' is assigned and use default to 'from'

      } else if (idx.arrows.to) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "arrow";
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // only shape of 'from' is assigned and use default for 'to'
      } else if (idx.arrows.from) {
        to_type = "arrow";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }
    } else if (dir_type === "back") {
      // given both of shapes, but use only 'from'
      if (idx.arrows.to && idx.arrows.from) {
        to_type = "";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // given shape of 'to', but does not use it
      } else if (idx.arrows.to) {
        to_type = "";
        from_type = "arrow";
        idx.arrows.from = idx.arrows.to;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // assign given 'from' shape
      } else if (idx.arrows.from) {
        to_type = "";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }

      attr_list[idx.arrows.from] = {
        attr: attr_list[idx.arrows.from].attr,
        name: attr_list[idx.arrows.from].name,
        value: {
          from: {
            enabled: true,
            type: attr_list[idx.arrows.from].value.from.type
          }
        }
      };
    } else if (dir_type === "none") {
      var idx_arrow;

      if (idx.arrows.to) {
        idx_arrow = idx.arrows.to;
      } else {
        idx_arrow = idx.arrows.from;
      }

      attr_list[idx_arrow] = {
        attr: attr_list[idx_arrow].attr,
        name: attr_list[idx_arrow].name,
        value: ""
      };
    } else if (dir_type === "forward") {
      // given both of shapes, but use only 'to'
      if (idx.arrows.to && idx.arrows.from) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "";
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // assign given 'to' shape
      } else if (idx.arrows.to) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "";
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        }; // given shape of 'from', but does not use it
      } else if (idx.arrows.from) {
        to_type = "arrow";
        from_type = "";
        idx.arrows.to = idx.arrows.from;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }

      attr_list[idx.arrows.to] = {
        attr: attr_list[idx.arrows.to].attr,
        name: attr_list[idx.arrows.to].name,
        value: {
          to: {
            enabled: true,
            type: attr_list[idx.arrows.to].value.to.type
          }
        }
      };
    } else {
      throw newSyntaxError('Invalid dir type "' + dir_type + '"');
    } // remove 'dir' attribute no need anymore


    splice$1(attr_list).call(attr_list, idx.dir, 1);
  } // parse 'penwidth'


  var nof_attr_list;

  if (includes(attr_names).call(attr_names, "penwidth")) {
    var tmp_attr_list = [];
    nof_attr_list = attr_list.length;

    for (i = 0; i < nof_attr_list; i++) {
      // exclude 'width' from attr_list if 'penwidth' exists
      if (attr_list[i].name !== "width") {
        if (attr_list[i].name === "penwidth") {
          attr_list[i].name = "width";
        }

        tmp_attr_list.push(attr_list[i]);
      }
    }

    attr_list = tmp_attr_list;
  }

  nof_attr_list = attr_list.length;

  for (i = 0; i < nof_attr_list; i++) {
    setValue(attr_list[i].attr, attr_list[i].name, attr_list[i].value);
  }

  return attr;
}
/**
 * Create a syntax error with extra information on current token and index.
 *
 * @param {string} message
 * @returns {SyntaxError} err
 */


function newSyntaxError(message) {
  return new SyntaxError(message + ', got "' + chop(token, 30) + '" (char ' + index$1 + ")");
}
/**
 * Chop off text after a maximum length
 *
 * @param {string} text
 * @param {number} maxLength
 * @returns {string}
 */


function chop(text, maxLength) {
  return text.length <= maxLength ? text : text.substr(0, 27) + "...";
}
/**
 * Execute a function fn for each pair of elements in two arrays
 *
 * @param {Array | *} array1
 * @param {Array | *} array2
 * @param {Function} fn
 */


function forEach2(array1, array2, fn) {
  if (isArray$2(array1)) {
    forEach$2(array1).call(array1, function (elem1) {
      if (isArray$2(array2)) {
        forEach$2(array2).call(array2, function (elem2) {
          fn(elem1, elem2);
        });
      } else {
        fn(elem1, array2);
      }
    });
  } else {
    if (isArray$2(array2)) {
      forEach$2(array2).call(array2, function (elem2) {
        fn(array1, elem2);
      });
    } else {
      fn(array1, array2);
    }
  }
}
/**
 * Set a nested property on an object
 * When nested objects are missing, they will be created.
 * For example setProp({}, 'font.color', 'red') will return {font: {color: 'red'}}
 *
 * @param {object} object
 * @param {string} path   A dot separated string like 'font.color'
 * @param {*} value       Value for the property
 * @returns {object} Returns the original object, allows for chaining.
 */


function setProp(object, path, value) {
  var names = path.split(".");
  var prop = names.pop(); // traverse over the nested objects

  var obj = object;

  for (var i = 0; i < names.length; i++) {
    var name = names[i];

    if (!(name in obj)) {
      obj[name] = {};
    }

    obj = obj[name];
  } // set the property value


  obj[prop] = value;
  return object;
}
/**
 * Convert an object with DOT attributes to their vis.js equivalents.
 *
 * @param {object} attr     Object with DOT attributes
 * @param {object} mapping
 * @returns {object}         Returns an object with vis.js attributes
 */


function convertAttr(attr, mapping) {
  var converted = {};

  for (var prop in attr) {
    if (attr.hasOwnProperty(prop)) {
      var visProp = mapping[prop];

      if (isArray$2(visProp)) {
        forEach$2(visProp).call(visProp, function (visPropI) {
          setProp(converted, visPropI, attr[prop]);
        });
      } else if (typeof visProp === "string") {
        setProp(converted, visProp, attr[prop]);
      } else {
        setProp(converted, prop, attr[prop]);
      }
    }
  }

  return converted;
}
/**
 * Convert a string containing a graph in DOT language into a map containing
 * with nodes and edges in the format of graph.
 *
 * @param {string} data         Text containing a graph in DOT-notation
 * @returns {object} graphData
 */


function DOTToGraph(data) {
  // parse the DOT file
  var dotData = parseDOT(data);
  var graphData = {
    nodes: [],
    edges: [],
    options: {}
  }; // copy the nodes

  if (dotData.nodes) {
    var _context2;

    forEach$2(_context2 = dotData.nodes).call(_context2, function (dotNode) {
      var graphNode = {
        id: dotNode.id,
        label: String(dotNode.label || dotNode.id)
      };
      merge$1(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));

      if (graphNode.image) {
        graphNode.shape = "image";
      }

      graphData.nodes.push(graphNode);
    });
  } // copy the edges


  if (dotData.edges) {
    var _context3;

    /**
     * Convert an edge in DOT format to an edge with VisGraph format
     *
     * @param {object} dotEdge
     * @returns {object} graphEdge
     */
    var convertEdge = function convertEdge(dotEdge) {
      var graphEdge = {
        from: dotEdge.from,
        to: dotEdge.to
      };
      merge$1(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING)); // Add arrows attribute to default styled arrow.
      // The reason why default style is not added in parseAttributeList() is
      // because only default is cleared before here.

      if (graphEdge.arrows == null && dotEdge.type === "->") {
        graphEdge.arrows = "to";
      }

      return graphEdge;
    };

    forEach$2(_context3 = dotData.edges).call(_context3, function (dotEdge) {
      var from, to;

      if (dotEdge.from instanceof Object) {
        from = dotEdge.from.nodes;
      } else {
        from = {
          id: dotEdge.from
        };
      }

      if (dotEdge.to instanceof Object) {
        to = dotEdge.to.nodes;
      } else {
        to = {
          id: dotEdge.to
        };
      }

      if (dotEdge.from instanceof Object && dotEdge.from.edges) {
        var _context4;

        forEach$2(_context4 = dotEdge.from.edges).call(_context4, function (subEdge) {
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });
      }

      forEach2(from, to, function (from, to) {
        var subEdge = createEdge(graphData, from.id, to.id, dotEdge.type, dotEdge.attr);
        var graphEdge = convertEdge(subEdge);
        graphData.edges.push(graphEdge);
      });

      if (dotEdge.to instanceof Object && dotEdge.to.edges) {
        var _context5;

        forEach$2(_context5 = dotEdge.to.edges).call(_context5, function (subEdge) {
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });
      }
    });
  } // copy the options


  if (dotData.attr) {
    graphData.options = dotData.attr;
  }

  return graphData;
}
/* eslint-enable no-var */

/* eslint-enable no-unused-vars */

/* eslint-enable no-prototype-builtins */

var dotparser = /*#__PURE__*/Object.freeze({
	__proto__: null,
	parseDOT: parseDOT,
	DOTToGraph: DOTToGraph
});

/**
 * Convert Gephi to Vis.
 *
 * @param gephiJSON - The parsed JSON data in Gephi format.
 * @param optionsObj - Additional options.
 * @returns The converted data ready to be used in Vis.
 */
function parseGephi(gephiJSON, optionsObj) {
  var _context;

  var options = {
    edges: {
      inheritColor: false
    },
    nodes: {
      fixed: false,
      parseColor: false
    }
  };

  if (optionsObj != null) {
    if (optionsObj.fixed != null) {
      options.nodes.fixed = optionsObj.fixed;
    }

    if (optionsObj.parseColor != null) {
      options.nodes.parseColor = optionsObj.parseColor;
    }

    if (optionsObj.inheritColor != null) {
      options.edges.inheritColor = optionsObj.inheritColor;
    }
  }

  var gEdges = gephiJSON.edges;

  var vEdges = map$3(gEdges).call(gEdges, function (gEdge) {
    var vEdge = {
      from: gEdge.source,
      id: gEdge.id,
      to: gEdge.target
    };

    if (gEdge.attributes != null) {
      vEdge.attributes = gEdge.attributes;
    }

    if (gEdge.label != null) {
      vEdge.label = gEdge.label;
    }

    if (gEdge.attributes != null && gEdge.attributes.title != null) {
      vEdge.title = gEdge.attributes.title;
    }

    if (gEdge.type === "Directed") {
      vEdge.arrows = "to";
    } // edge['value'] = gEdge.attributes != null ? gEdge.attributes.Weight : undefined;
    // edge['width'] = edge['value'] != null ? undefined : edgegEdge.size;


    if (gEdge.color && options.edges.inheritColor === false) {
      vEdge.color = gEdge.color;
    }

    return vEdge;
  });

  var vNodes = map$3(_context = gephiJSON.nodes).call(_context, function (gNode) {
    var vNode = {
      id: gNode.id,
      fixed: options.nodes.fixed && gNode.x != null && gNode.y != null
    };

    if (gNode.attributes != null) {
      vNode.attributes = gNode.attributes;
    }

    if (gNode.label != null) {
      vNode.label = gNode.label;
    }

    if (gNode.size != null) {
      vNode.size = gNode.size;
    }

    if (gNode.attributes != null && gNode.attributes.title != null) {
      vNode.title = gNode.attributes.title;
    }

    if (gNode.title != null) {
      vNode.title = gNode.title;
    }

    if (gNode.x != null) {
      vNode.x = gNode.x;
    }

    if (gNode.y != null) {
      vNode.y = gNode.y;
    }

    if (gNode.color != null) {
      if (options.nodes.parseColor === true) {
        vNode.color = gNode.color;
      } else {
        vNode.color = {
          background: gNode.color,
          border: gNode.color,
          highlight: {
            background: gNode.color,
            border: gNode.color
          },
          hover: {
            background: gNode.color,
            border: gNode.color
          }
        };
      }
    }

    return vNode;
  });

  return {
    nodes: vNodes,
    edges: vEdges
  };
}

var gephiParser = /*#__PURE__*/Object.freeze({
	__proto__: null,
	parseGephi: parseGephi
});

// English
var en = {
  addDescription: "Click in an empty space to place a new node.",
  addEdge: "Add Edge",
  addNode: "Add Node",
  back: "Back",
  close: "Close",
  createEdgeError: "Cannot link edges to a cluster.",
  del: "Delete selected",
  deleteClusterError: "Clusters cannot be deleted.",
  edgeDescription: "Click on a node and drag the edge to another node to connect them.",
  edit: "Edit",
  editClusterError: "Clusters cannot be edited.",
  editEdge: "Edit Edge",
  editEdgeDescription: "Click on the control points and drag them to a node to connect to it.",
  editNode: "Edit Node"
}; // German

var de = {
  addDescription: "Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.",
  addEdge: "Kante hinzuf\xFCgen",
  addNode: "Knoten hinzuf\xFCgen",
  back: "Zur\xFCck",
  close: "Schließen",
  createEdgeError: "Es ist nicht m\xF6glich, Kanten mit Clustern zu verbinden.",
  del: "L\xF6sche Auswahl",
  deleteClusterError: "Cluster k\xF6nnen nicht gel\xF6scht werden.",
  edgeDescription: "Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.",
  edit: "Editieren",
  editClusterError: "Cluster k\xF6nnen nicht editiert werden.",
  editEdge: "Kante editieren",
  editEdgeDescription: "Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.",
  editNode: "Knoten editieren"
}; // Spanish

var es = {
  addDescription: "Haga clic en un lugar vac\xEDo para colocar un nuevo nodo.",
  addEdge: "A\xF1adir arista",
  addNode: "A\xF1adir nodo",
  back: "Atr\xE1s",
  close: "Cerrar",
  createEdgeError: "No se puede conectar una arista a un grupo.",
  del: "Eliminar selecci\xF3n",
  deleteClusterError: "No es posible eliminar grupos.",
  edgeDescription: "Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.",
  edit: "Editar",
  editClusterError: "No es posible editar grupos.",
  editEdge: "Editar arista",
  editEdgeDescription: "Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.",
  editNode: "Editar nodo"
}; //Italiano

var it = {
  addDescription: "Clicca per aggiungere un nuovo nodo",
  addEdge: "Aggiungi un vertice",
  addNode: "Aggiungi un nodo",
  back: "Indietro",
  close: "Chiudere",
  createEdgeError: "Non si possono collegare vertici ad un cluster",
  del: "Cancella la selezione",
  deleteClusterError: "I cluster non possono essere cancellati",
  edgeDescription: "Clicca su un nodo e trascinalo ad un altro nodo per connetterli.",
  edit: "Modifica",
  editClusterError: "I clusters non possono essere modificati.",
  editEdge: "Modifica il vertice",
  editEdgeDescription: "Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.",
  editNode: "Modifica il nodo"
}; // Dutch

var nl = {
  addDescription: "Klik op een leeg gebied om een nieuwe node te maken.",
  addEdge: "Link toevoegen",
  addNode: "Node toevoegen",
  back: "Terug",
  close: "Sluiten",
  createEdgeError: "Kan geen link maken naar een cluster.",
  del: "Selectie verwijderen",
  deleteClusterError: "Clusters kunnen niet worden verwijderd.",
  edgeDescription: "Klik op een node en sleep de link naar een andere node om ze te verbinden.",
  edit: "Wijzigen",
  editClusterError: "Clusters kunnen niet worden aangepast.",
  editEdge: "Link wijzigen",
  editEdgeDescription: "Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.",
  editNode: "Node wijzigen"
}; // Portuguese Brazil

var pt = {
  addDescription: "Clique em um espaço em branco para adicionar um novo nó",
  addEdge: "Adicionar aresta",
  addNode: "Adicionar nó",
  back: "Voltar",
  close: "Fechar",
  createEdgeError: "Não foi possível linkar arestas a um cluster.",
  del: "Remover selecionado",
  deleteClusterError: "Clusters não puderam ser removidos.",
  edgeDescription: "Clique em um nó e arraste a aresta até outro nó para conectá-los",
  edit: "Editar",
  editClusterError: "Clusters não puderam ser editados.",
  editEdge: "Editar aresta",
  editEdgeDescription: "Clique nos pontos de controle e os arraste para um nó para conectá-los",
  editNode: "Editar nó"
}; // Russian

var ru = {
  addDescription: "Кликните в свободное место, чтобы добавить новый узел.",
  addEdge: "Добавить ребро",
  addNode: "Добавить узел",
  back: "Назад",
  close: "Закрывать",
  createEdgeError: "Невозможно соединить ребра в кластер.",
  del: "Удалить выбранное",
  deleteClusterError: "Кластеры не могут быть удалены",
  edgeDescription: "Кликните на узел и протяните ребро к другому узлу, чтобы соединить их.",
  edit: "Редактировать",
  editClusterError: "Кластеры недоступны для редактирования.",
  editEdge: "Редактировать ребро",
  editEdgeDescription: "Кликните на контрольные точки и перетащите их в узел, чтобы подключиться к нему.",
  editNode: "Редактировать узел"
}; // Chinese

var cn = {
  addDescription: "单击空白处放置新节点。",
  addEdge: "添加连接线",
  addNode: "添加节点",
  back: "返回",
  close: "關閉",
  createEdgeError: "无法将连接线连接到群集。",
  del: "删除选定",
  deleteClusterError: "无法删除群集。",
  edgeDescription: "单击某个节点并将该连接线拖动到另一个节点以连接它们。",
  edit: "编辑",
  editClusterError: "无法编辑群集。",
  editEdge: "编辑连接线",
  editEdgeDescription: "单击控制节点并将它们拖到节点上连接。",
  editNode: "编辑节点"
}; // Ukrainian

var uk = {
  addDescription: "Kлікніть на вільне місце, щоб додати новий вузол.",
  addEdge: "Додати край",
  addNode: "Додати вузол",
  back: "Назад",
  close: "Закрити",
  createEdgeError: "Не можливо об'єднати краї в групу.",
  del: "Видалити обране",
  deleteClusterError: "Групи не можуть бути видалені.",
  edgeDescription: "Клікніть на вузол і перетягніть край до іншого вузла, щоб їх з'єднати.",
  edit: "Редагувати",
  editClusterError: "Групи недоступні для редагування.",
  editEdge: "Редагувати край",
  editEdgeDescription: "Клікніть на контрольні точки і перетягніть їх у вузол, щоб підключитися до нього.",
  editNode: "Редагувати вузол"
}; // French

var fr = {
  addDescription: "Cliquez dans un endroit vide pour placer un nœud.",
  addEdge: "Ajouter un lien",
  addNode: "Ajouter un nœud",
  back: "Retour",
  close: "Fermer",
  createEdgeError: "Impossible de créer un lien vers un cluster.",
  del: "Effacer la sélection",
  deleteClusterError: "Les clusters ne peuvent pas être effacés.",
  edgeDescription: "Cliquez sur un nœud et glissez le lien vers un autre nœud pour les connecter.",
  edit: "Éditer",
  editClusterError: "Les clusters ne peuvent pas être édités.",
  editEdge: "Éditer le lien",
  editEdgeDescription: "Cliquez sur les points de contrôle et glissez-les pour connecter un nœud.",
  editNode: "Éditer le nœud"
}; // Czech

var cs = {
  addDescription: "Kluknutím do prázdného prostoru můžete přidat nový vrchol.",
  addEdge: "Přidat hranu",
  addNode: "Přidat vrchol",
  back: "Zpět",
  close: "Zavřít",
  createEdgeError: "Nelze připojit hranu ke shluku.",
  del: "Smazat výběr",
  deleteClusterError: "Nelze mazat shluky.",
  edgeDescription: "Přetažením z jednoho vrcholu do druhého můžete spojit tyto vrcholy novou hranou.",
  edit: "Upravit",
  editClusterError: "Nelze upravovat shluky.",
  editEdge: "Upravit hranu",
  editEdgeDescription: "Přetažením kontrolního vrcholu hrany ji můžete připojit k jinému vrcholu.",
  editNode: "Upravit vrchol"
};

var locales = /*#__PURE__*/Object.freeze({
	__proto__: null,
	en: en,
	de: de,
	es: es,
	it: it,
	nl: nl,
	pt: pt,
	ru: ru,
	cn: cn,
	uk: uk,
	fr: fr,
	cs: cs
});

/**
 * Normalizes language code into the format used internally.
 *
 * @param locales - All the available locales.
 * @param rawCode - The original code as supplied by the user.
 * @returns Language code in the format language-COUNTRY or language, eventually
 * fallbacks to en.
 */
function normalizeLanguageCode(locales, rawCode) {
  try {
    var _rawCode$split = rawCode.split(/[-_ /]/, 2),
        _rawCode$split2 = _slicedToArray(_rawCode$split, 2),
        rawLanguage = _rawCode$split2[0],
        rawCountry = _rawCode$split2[1];

    var language = rawLanguage != null ? rawLanguage.toLowerCase() : null;
    var country = rawCountry != null ? rawCountry.toUpperCase() : null;

    if (language && country) {
      var code = language + "-" + country;

      if (Object.prototype.hasOwnProperty.call(locales, code)) {
        return code;
      } else {
        var _context;

        console.warn(concat(_context = "Unknown variant ".concat(country, " of language ")).call(_context, language, "."));
      }
    }

    if (language) {
      var _code = language;

      if (Object.prototype.hasOwnProperty.call(locales, _code)) {
        return _code;
      } else {
        console.warn("Unknown language ".concat(language));
      }
    }

    console.warn("Unknown locale ".concat(rawCode, ", falling back to English."));
    return "en";
  } catch (error) {
    console.error(error);
    console.warn("Unexpected error while normalizing locale ".concat(rawCode, ", falling back to English."));
    return "en";
  }
}

/**
 * Associates a canvas to a given image, containing a number of renderings
 * of the image at various sizes.
 *
 * This technique is known as 'mipmapping'.
 *
 * NOTE: Images can also be of type 'data:svg+xml`. This code also works
 *       for svg, but the mipmapping may not be necessary.
 *
 * @param {Image} image
 */
var CachedImage = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function CachedImage() {
    _classCallCheck(this, CachedImage);

    this.NUM_ITERATIONS = 4; // Number of items in the coordinates array

    this.image = new Image();
    this.canvas = document.createElement("canvas");
  }
  /**
   * Called when the image has been successfully loaded.
   */


  _createClass(CachedImage, [{
    key: "init",
    value: function init() {
      if (this.initialized()) return;
      this.src = this.image.src; // For same interface with Image

      var w = this.image.width;
      var h = this.image.height; // Ease external access

      this.width = w;
      this.height = h;
      var h2 = Math.floor(h / 2);
      var h4 = Math.floor(h / 4);
      var h8 = Math.floor(h / 8);
      var h16 = Math.floor(h / 16);
      var w2 = Math.floor(w / 2);
      var w4 = Math.floor(w / 4);
      var w8 = Math.floor(w / 8);
      var w16 = Math.floor(w / 16); // Make canvas as small as possible

      this.canvas.width = 3 * w4;
      this.canvas.height = h2; // Coordinates and sizes of images contained in the canvas
      // Values per row:  [top x, left y, width, height]

      this.coordinates = [[0, 0, w2, h2], [w2, 0, w4, h4], [w2, h4, w8, h8], [5 * w8, h4, w16, h16]];

      this._fillMipMap();
    }
    /**
     * @returns {boolean} true if init() has been called, false otherwise.
     */

  }, {
    key: "initialized",
    value: function initialized() {
      return this.coordinates !== undefined;
    }
    /**
     * Redraw main image in various sizes to the context.
     *
     * The rationale behind this is to reduce artefacts due to interpolation
     * at differing zoom levels.
     *
     * Source: http://stackoverflow.com/q/18761404/1223531
     *
     * This methods takes the resizing out of the drawing loop, in order to
     * reduce performance overhead.
     *
     * TODO: The code assumes that a 2D context can always be gotten. This is
     *       not necessarily true! OTOH, if not true then usage of this class
     *       is senseless.
     *
     * @private
     */

  }, {
    key: "_fillMipMap",
    value: function _fillMipMap() {
      var ctx = this.canvas.getContext("2d"); // First zoom-level comes from the image

      var to = this.coordinates[0];
      ctx.drawImage(this.image, to[0], to[1], to[2], to[3]); // The rest are copy actions internal to the canvas/context

      for (var iterations = 1; iterations < this.NUM_ITERATIONS; iterations++) {
        var from = this.coordinates[iterations - 1];
        var _to = this.coordinates[iterations];
        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], _to[0], _to[1], _to[2], _to[3]);
      }
    }
    /**
     * Draw the image, using the mipmap if necessary.
     *
     * MipMap is only used if param factor > 2; otherwise, original bitmap
     * is resized. This is also used to skip mipmap usage, e.g. by setting factor = 1
     *
     * Credits to 'Alex de Mulder' for original implementation.
     *
     * @param {CanvasRenderingContext2D} ctx  context on which to draw zoomed image
     * @param {Float} factor scale factor at which to draw
     * @param {number} left
     * @param {number} top
     * @param {number} width
     * @param {number} height
     */

  }, {
    key: "drawImageAtPosition",
    value: function drawImageAtPosition(ctx, factor, left, top, width, height) {
      if (!this.initialized()) return; //can't draw image yet not intialized

      if (factor > 2) {
        // Determine which zoomed image to use
        factor *= 0.5;
        var iterations = 0;

        while (factor > 2 && iterations < this.NUM_ITERATIONS) {
          factor *= 0.5;
          iterations += 1;
        }

        if (iterations >= this.NUM_ITERATIONS) {
          iterations = this.NUM_ITERATIONS - 1;
        } //console.log("iterations: " + iterations);


        var from = this.coordinates[iterations];
        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], left, top, width, height);
      } else {
        // Draw image directly
        ctx.drawImage(this.image, left, top, width, height);
      }
    }
  }]);

  return CachedImage;
}();

/**
 * This callback is a callback that accepts an Image.
 *
 * @callback ImageCallback
 * @param {Image} image
 */

/**
 * This class loads images and keeps them stored.
 *
 * @param {ImageCallback} callback
 */

var Images = /*#__PURE__*/function () {
  /**
   * @param {ImageCallback} callback
   */
  function Images(callback) {
    _classCallCheck(this, Images);

    this.images = {};
    this.imageBroken = {};
    this.callback = callback;
  }
  /**
   * @param {string} url                      The original Url that failed to load, if the broken image is successfully loaded it will be added to the cache using this Url as the key so that subsequent requests for this Url will return the broken image
   * @param {string} brokenUrl                Url the broken image to try and load
   * @param {Image} imageToLoadBrokenUrlOn   The image object
   */


  _createClass(Images, [{
    key: "_tryloadBrokenUrl",
    value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {
      //If these parameters aren't specified then exit the function because nothing constructive can be done
      if (url === undefined || imageToLoadBrokenUrlOn === undefined) return;

      if (brokenUrl === undefined) {
        console.warn("No broken url image defined");
        return;
      } //Clear the old subscription to the error event and put a new in place that only handle errors in loading the brokenImageUrl


      imageToLoadBrokenUrlOn.image.onerror = function () {
        console.error("Could not load brokenImage:", brokenUrl); // cache item will contain empty image, this should be OK for default
      }; //Set the source of the image to the brokenUrl, this is actually what kicks off the loading of the broken image


      imageToLoadBrokenUrlOn.image.src = brokenUrl;
    }
    /**
     *
     * @param {vis.Image} imageToRedrawWith
     * @private
     */

  }, {
    key: "_redrawWithImage",
    value: function _redrawWithImage(imageToRedrawWith) {
      if (this.callback) {
        this.callback(imageToRedrawWith);
      }
    }
    /**
     * @param {string} url          Url of the image
     * @param {string} brokenUrl    Url of an image to use if the url image is not found
     * @returns {Image} img          The image object
     */

  }, {
    key: "load",
    value: function load(url, brokenUrl) {
      var _this = this;

      //Try and get the image from the cache, if successful then return the cached image
      var cachedImage = this.images[url];
      if (cachedImage) return cachedImage; //Create a new image

      var img = new CachedImage(); // Need to add to cache here, otherwise final return will spawn different copies of the same image,
      // Also, there will be multiple loads of the same image.

      this.images[url] = img; //Subscribe to the event that is raised if the image loads successfully

      img.image.onload = function () {
        // Properly init the cached item and then request a redraw
        _this._fixImageCoordinates(img.image);

        img.init();

        _this._redrawWithImage(img);
      }; //Subscribe to the event that is raised if the image fails to load


      img.image.onerror = function () {
        console.error("Could not load image:", url); //Try and load the image specified by the brokenUrl using

        _this._tryloadBrokenUrl(url, brokenUrl, img);
      }; //Set the source of the image to the url, this is what actually kicks off the loading of the image


      img.image.src = url; //Return the new image

      return img;
    }
    /**
     * IE11 fix -- thanks dponch!
     *
     * Local helper function
     *
     * @param {vis.Image} imageToCache
     * @private
     */

  }, {
    key: "_fixImageCoordinates",
    value: function _fixImageCoordinates(imageToCache) {
      if (imageToCache.width === 0) {
        document.body.appendChild(imageToCache);
        imageToCache.width = imageToCache.offsetWidth;
        imageToCache.height = imageToCache.offsetHeight;
        document.body.removeChild(imageToCache);
      }
    }
  }]);

  return Images;
}();

var internalMetadata = {exports: {}};

var fails$7 = fails$t;
var arrayBufferNonExtensible = fails$7(function () {
  if (typeof ArrayBuffer == 'function') {
    var buffer = new ArrayBuffer(8); // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe

    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', {
      value: 8
    });
  }
});

var fails$6 = fails$t;
var isObject$6 = isObject$j;
var classof$4 = classofRaw$1;
var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible; // eslint-disable-next-line es/no-object-isextensible -- safe

var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES$1 = fails$6(function () {
  $isExtensible(1);
}); // `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible

var objectIsExtensible = FAILS_ON_PRIMITIVES$1 || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
  if (!isObject$6(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$4(it) == 'ArrayBuffer') return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;

var fails$5 = fails$t;
var freezing = !fails$5(function () {
  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});

var $$e = _export;
var uncurryThis$4 = functionUncurryThis;
var hiddenKeys = hiddenKeys$6;
var isObject$5 = isObject$j;
var hasOwn$5 = hasOwnProperty_1;
var defineProperty$2 = objectDefineProperty.f;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
var isExtensible$1 = objectIsExtensible;
var uid = uid$4;
var FREEZING = freezing;
var REQUIRED = false;
var METADATA = uid('meta');
var id$1 = 0;

var setMetadata = function (it) {
  defineProperty$2(it, METADATA, {
    value: {
      objectID: 'O' + id$1++,
      // object ID
      weakData: {} // weak collections IDs

    }
  });
};

var fastKey$1 = function (it, create) {
  // return a primitive with prefix
  if (!isObject$5(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!hasOwn$5(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible$1(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMetadata(it); // return object ID
  }

  return it[METADATA].objectID;
};

var getWeakData$1 = function (it, create) {
  if (!hasOwn$5(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible$1(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMetadata(it); // return the store of weak collections IDs
  }

  return it[METADATA].weakData;
}; // add metadata on freeze-family methods calling


var onFreeze = function (it) {
  if (FREEZING && REQUIRED && isExtensible$1(it) && !hasOwn$5(it, METADATA)) setMetadata(it);
  return it;
};

var enable = function () {
  meta.enable = function () {
    /* empty */
  };

  REQUIRED = true;
  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
  var splice = uncurryThis$4([].splice);
  var test = {};
  test[METADATA] = 1; // prevent exposing of metadata key

  if (getOwnPropertyNames(test).length) {
    getOwnPropertyNamesModule.f = function (it) {
      var result = getOwnPropertyNames(it);

      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice(result, i, 1);
          break;
        }
      }

      return result;
    };

    $$e({
      target: 'Object',
      stat: true,
      forced: true
    }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};

var meta = internalMetadata.exports = {
  enable: enable,
  fastKey: fastKey$1,
  getWeakData: getWeakData$1,
  onFreeze: onFreeze
};
hiddenKeys[METADATA] = true;

var global$a = global$P;
var bind$3 = functionBindContext;
var call$1 = functionCall;
var anObject$3 = anObject$d;
var tryToString$1 = tryToString$4;
var isArrayIteratorMethod = isArrayIteratorMethod$2;
var lengthOfArrayLike$4 = lengthOfArrayLike$d;
var isPrototypeOf$9 = objectIsPrototypeOf;
var getIterator$5 = getIterator$7;
var getIteratorMethod = getIteratorMethod$8;
var iteratorClose = iteratorClose$2;
var TypeError$5 = global$a.TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

var iterate$3 = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$3(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject$3(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    }

    return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw TypeError$5(tryToString$1(iterable) + ' is not iterable'); // optimisation for array iterators

    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike$4(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf$9(ResultPrototype, result)) return result;
      }

      return new Result(false);
    }

    iterator = getIterator$5(iterable, iterFn);
  }

  next = iterator.next;

  while (!(step = call$1(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }

    if (typeof result == 'object' && result && isPrototypeOf$9(ResultPrototype, result)) return result;
  }

  return new Result(false);
};

var global$9 = global$P;
var isPrototypeOf$8 = objectIsPrototypeOf;
var TypeError$4 = global$9.TypeError;

var anInstance$3 = function (it, Prototype) {
  if (isPrototypeOf$8(Prototype, it)) return it;
  throw TypeError$4('Incorrect invocation');
};

var $$d = _export;
var global$8 = global$P;
var InternalMetadataModule$1 = internalMetadata.exports;
var fails$4 = fails$t;
var createNonEnumerableProperty = createNonEnumerableProperty$6;
var iterate$2 = iterate$3;
var anInstance$2 = anInstance$3;
var isCallable = isCallable$h;
var isObject$4 = isObject$j;
var setToStringTag = setToStringTag$5;
var defineProperty$1 = objectDefineProperty.f;
var forEach = arrayIteration.forEach;
var DESCRIPTORS$2 = descriptors;
var InternalStateModule$2 = internalState;
var setInternalState$2 = InternalStateModule$2.set;
var internalStateGetterFor$2 = InternalStateModule$2.getterFor;

var collection$3 = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global$8[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var exported = {};
  var Constructor;

  if (!DESCRIPTORS$2 || !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$4(function () {
    new NativeConstructor().entries().next();
  }))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule$1.enable();
  } else {
    Constructor = wrapper(function (target, iterable) {
      setInternalState$2(anInstance$2(target, Prototype), {
        type: CONSTRUCTOR_NAME,
        collection: new NativeConstructor()
      });
      if (iterable != undefined) iterate$2(iterable, target[ADDER], {
        that: target,
        AS_ENTRIES: IS_MAP
      });
    });
    var Prototype = Constructor.prototype;
    var getInternalState = internalStateGetterFor$2(CONSTRUCTOR_NAME);
    forEach(['add', 'clear', 'delete', 'forEach', 'get', 'has', 'set', 'keys', 'values', 'entries'], function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';

      if (KEY in NativePrototype && !(IS_WEAK && KEY == 'clear')) {
        createNonEnumerableProperty(Prototype, KEY, function (a, b) {
          var collection = getInternalState(this).collection;
          if (!IS_ADDER && IS_WEAK && !isObject$4(a)) return KEY == 'get' ? undefined : false;
          var result = collection[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      }
    });
    IS_WEAK || defineProperty$1(Prototype, 'size', {
      configurable: true,
      get: function () {
        return getInternalState(this).collection.size;
      }
    });
  }

  setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);
  exported[CONSTRUCTOR_NAME] = Constructor;
  $$d({
    global: true,
    forced: true
  }, exported);
  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};

var redefine = redefine$4;

var redefineAll$3 = function (target, src, options) {
  for (var key in src) {
    if (options && options.unsafe && target[key]) target[key] = src[key];else redefine(target, key, src[key], options);
  }

  return target;
};

var getBuiltIn$1 = getBuiltIn$9;
var definePropertyModule = objectDefineProperty;
var wellKnownSymbol = wellKnownSymbol$j;
var DESCRIPTORS$1 = descriptors;
var SPECIES = wellKnownSymbol('species');

var setSpecies$1 = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$1(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS$1 && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () {
        return this;
      }
    });
  }
};

var defineProperty = objectDefineProperty.f;
var create$4 = objectCreate;
var redefineAll$2 = redefineAll$3;
var bind$2 = functionBindContext;
var anInstance$1 = anInstance$3;
var iterate$1 = iterate$3;
var defineIterator = defineIterator$3;
var setSpecies = setSpecies$1;
var DESCRIPTORS = descriptors;
var fastKey = internalMetadata.exports.fastKey;
var InternalStateModule$1 = internalState;
var setInternalState$1 = InternalStateModule$1.set;
var internalStateGetterFor$1 = InternalStateModule$1.getterFor;
var collectionStrong$2 = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance$1(that, Prototype);
      setInternalState$1(that, {
        type: CONSTRUCTOR_NAME,
        index: create$4(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate$1(iterable, that[ADDER], {
        that: that,
        AS_ENTRIES: IS_MAP
      });
    });
    var Prototype = Constructor.prototype;
    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index; // change existing entry

      if (entry) {
        entry.value = value; // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;else that.size++; // add to index

        if (index !== 'F') state.index[index] = entry;
      }

      return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that); // fast case

      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index]; // frozen object case

      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll$2(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;

        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }

        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;else that.size--;
        }

        return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        var state = getInternalState(this);
        var boundFunction = bind$2(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var entry;

        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this); // revert to the last existing entry

          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });
    redefineAll$2(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(Prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return Constructor;
  },
  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor$1(ITERATOR_NAME); // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
    // https://tc39.es/ecma262/#sec-map.prototype.entries
    // https://tc39.es/ecma262/#sec-map.prototype.keys
    // https://tc39.es/ecma262/#sec-map.prototype.values
    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
    // https://tc39.es/ecma262/#sec-set.prototype.entries
    // https://tc39.es/ecma262/#sec-set.prototype.keys
    // https://tc39.es/ecma262/#sec-set.prototype.values
    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator

    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState$1(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last; // revert to the last existing entry

      while (entry && entry.removed) entry = entry.previous; // get next entry


      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return {
          value: undefined,
          done: true
        };
      } // return step by kind


      if (kind == 'keys') return {
        value: entry.key,
        done: false
      };
      if (kind == 'values') return {
        value: entry.value,
        done: false
      };
      return {
        value: [entry.key, entry.value],
        done: false
      };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // `{ Map, Set }.prototype[@@species]` accessors
    // https://tc39.es/ecma262/#sec-get-map-@@species
    // https://tc39.es/ecma262/#sec-get-set-@@species

    setSpecies(CONSTRUCTOR_NAME);
  }
};

var collection$2 = collection$3;
var collectionStrong$1 = collectionStrong$2; // `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects

collection$2('Map', function (init) {
  return function Map() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong$1);

var path$b = path$y;
var map$2 = path$b.Map;

var parent$v = map$2;
var map$1 = parent$v;

var map = map$1;

/**
 * This class can store groups and options specific for groups.
 */
var Groups = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function Groups() {
    _classCallCheck(this, Groups);

    this.clear();
    this._defaultIndex = 0;
    this._groupIndex = 0;
    this._defaultGroups = [{
      border: "#2B7CE9",
      background: "#97C2FC",
      highlight: {
        border: "#2B7CE9",
        background: "#D2E5FF"
      },
      hover: {
        border: "#2B7CE9",
        background: "#D2E5FF"
      }
    }, // 0: blue
    {
      border: "#FFA500",
      background: "#FFFF00",
      highlight: {
        border: "#FFA500",
        background: "#FFFFA3"
      },
      hover: {
        border: "#FFA500",
        background: "#FFFFA3"
      }
    }, // 1: yellow
    {
      border: "#FA0A10",
      background: "#FB7E81",
      highlight: {
        border: "#FA0A10",
        background: "#FFAFB1"
      },
      hover: {
        border: "#FA0A10",
        background: "#FFAFB1"
      }
    }, // 2: red
    {
      border: "#41A906",
      background: "#7BE141",
      highlight: {
        border: "#41A906",
        background: "#A1EC76"
      },
      hover: {
        border: "#41A906",
        background: "#A1EC76"
      }
    }, // 3: green
    {
      border: "#E129F0",
      background: "#EB7DF4",
      highlight: {
        border: "#E129F0",
        background: "#F0B3F5"
      },
      hover: {
        border: "#E129F0",
        background: "#F0B3F5"
      }
    }, // 4: magenta
    {
      border: "#7C29F0",
      background: "#AD85E4",
      highlight: {
        border: "#7C29F0",
        background: "#D3BDF0"
      },
      hover: {
        border: "#7C29F0",
        background: "#D3BDF0"
      }
    }, // 5: purple
    {
      border: "#C37F00",
      background: "#FFA807",
      highlight: {
        border: "#C37F00",
        background: "#FFCA66"
      },
      hover: {
        border: "#C37F00",
        background: "#FFCA66"
      }
    }, // 6: orange
    {
      border: "#4220FB",
      background: "#6E6EFD",
      highlight: {
        border: "#4220FB",
        background: "#9B9BFD"
      },
      hover: {
        border: "#4220FB",
        background: "#9B9BFD"
      }
    }, // 7: darkblue
    {
      border: "#FD5A77",
      background: "#FFC0CB",
      highlight: {
        border: "#FD5A77",
        background: "#FFD1D9"
      },
      hover: {
        border: "#FD5A77",
        background: "#FFD1D9"
      }
    }, // 8: pink
    {
      border: "#4AD63A",
      background: "#C2FABC",
      highlight: {
        border: "#4AD63A",
        background: "#E6FFE3"
      },
      hover: {
        border: "#4AD63A",
        background: "#E6FFE3"
      }
    }, // 9: mint
    {
      border: "#990000",
      background: "#EE0000",
      highlight: {
        border: "#BB0000",
        background: "#FF3333"
      },
      hover: {
        border: "#BB0000",
        background: "#FF3333"
      }
    }, // 10:bright red
    {
      border: "#FF6000",
      background: "#FF6000",
      highlight: {
        border: "#FF6000",
        background: "#FF6000"
      },
      hover: {
        border: "#FF6000",
        background: "#FF6000"
      }
    }, // 12: real orange
    {
      border: "#97C2FC",
      background: "#2B7CE9",
      highlight: {
        border: "#D2E5FF",
        background: "#2B7CE9"
      },
      hover: {
        border: "#D2E5FF",
        background: "#2B7CE9"
      }
    }, // 13: blue
    {
      border: "#399605",
      background: "#255C03",
      highlight: {
        border: "#399605",
        background: "#255C03"
      },
      hover: {
        border: "#399605",
        background: "#255C03"
      }
    }, // 14: green
    {
      border: "#B70054",
      background: "#FF007E",
      highlight: {
        border: "#B70054",
        background: "#FF007E"
      },
      hover: {
        border: "#B70054",
        background: "#FF007E"
      }
    }, // 15: magenta
    {
      border: "#AD85E4",
      background: "#7C29F0",
      highlight: {
        border: "#D3BDF0",
        background: "#7C29F0"
      },
      hover: {
        border: "#D3BDF0",
        background: "#7C29F0"
      }
    }, // 16: purple
    {
      border: "#4557FA",
      background: "#000EA1",
      highlight: {
        border: "#6E6EFD",
        background: "#000EA1"
      },
      hover: {
        border: "#6E6EFD",
        background: "#000EA1"
      }
    }, // 17: darkblue
    {
      border: "#FFC0CB",
      background: "#FD5A77",
      highlight: {
        border: "#FFD1D9",
        background: "#FD5A77"
      },
      hover: {
        border: "#FFD1D9",
        background: "#FD5A77"
      }
    }, // 18: pink
    {
      border: "#C2FABC",
      background: "#74D66A",
      highlight: {
        border: "#E6FFE3",
        background: "#74D66A"
      },
      hover: {
        border: "#E6FFE3",
        background: "#74D66A"
      }
    }, // 19: mint
    {
      border: "#EE0000",
      background: "#990000",
      highlight: {
        border: "#FF3333",
        background: "#BB0000"
      },
      hover: {
        border: "#FF3333",
        background: "#BB0000"
      }
    } // 20:bright red
    ];
    this.options = {};
    this.defaultOptions = {
      useDefaultGroups: true
    };

    assign$2(this.options, this.defaultOptions);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(Groups, [{
    key: "setOptions",
    value: function setOptions(options) {
      var optionFields = ["useDefaultGroups"];

      if (options !== undefined) {
        for (var groupName in options) {
          if (Object.prototype.hasOwnProperty.call(options, groupName)) {
            if (indexOf(optionFields).call(optionFields, groupName) === -1) {
              var group = options[groupName];
              this.add(groupName, group);
            }
          }
        }
      }
    }
    /**
     * Clear all groups
     */

  }, {
    key: "clear",
    value: function clear() {
      this._groups = new map();
      this._groupNames = [];
    }
    /**
     * Get group options of a groupname.
     * If groupname is not found, a new group may be created.
     *
     * @param {*}       groupname     Can be a number, string, Date, etc.
     * @param {boolean} [shouldCreate=true] If true, create a new group
     * @returns {object} The found or created group
     */

  }, {
    key: "get",
    value: function get(groupname) {
      var shouldCreate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var group = this._groups.get(groupname);

      if (group === undefined && shouldCreate) {
        if (this.options.useDefaultGroups === false && this._groupNames.length > 0) {
          // create new group
          var index = this._groupIndex % this._groupNames.length;
          ++this._groupIndex;
          group = {};
          group.color = this._groups.get(this._groupNames[index]);

          this._groups.set(groupname, group);
        } else {
          // create new group
          var _index = this._defaultIndex % this._defaultGroups.length;

          this._defaultIndex++;
          group = {};
          group.color = this._defaultGroups[_index];

          this._groups.set(groupname, group);
        }
      }

      return group;
    }
    /**
     * Add custom group style.
     *
     * @param {string} groupName - The name of the group, a new group will be
     * created if a group with the same name doesn't exist, otherwise the old
     * groups style will be overwritten.
     * @param {object} style - An object containing borderColor, backgroundColor,
     * etc.
     * @returns {object} The created group object.
     */

  }, {
    key: "add",
    value: function add(groupName, style) {
      // Only push group name once to prevent duplicates which would consume more
      // RAM and also skew the distribution towards more often updated groups,
      // neither of which is desirable.
      if (!this._groups.has(groupName)) {
        this._groupNames.push(groupName);
      }

      this._groups.set(groupName, style);

      return style;
    }
  }]);

  return Groups;
}();

var $$c = _export; // `Number.isNaN` method
// https://tc39.es/ecma262/#sec-number.isnan

$$c({
  target: 'Number',
  stat: true
}, {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare -- NaN check
    return number != number;
  }
});

var path$a = path$y;
var isNan$2 = path$a.Number.isNaN;

var parent$u = isNan$2;
var isNan$1 = parent$u;

var isNan = isNan$1;

var global$7 = global$P;
var globalIsFinite = global$7.isFinite; // `Number.isFinite` method
// https://tc39.es/ecma262/#sec-number.isfinite
// eslint-disable-next-line es/no-number-isfinite -- safe

var numberIsFinite$1 = Number.isFinite || function isFinite(it) {
  return typeof it == 'number' && globalIsFinite(it);
};

var $$b = _export;
var numberIsFinite = numberIsFinite$1; // `Number.isFinite` method
// https://tc39.es/ecma262/#sec-number.isfinite

$$b({
  target: 'Number',
  stat: true
}, {
  isFinite: numberIsFinite
});

var path$9 = path$y;
var _isFinite$2 = path$9.Number.isFinite;

var parent$t = _isFinite$2;
var _isFinite$1 = parent$t;

var _isFinite = _isFinite$1;

var $$a = _export;
var $some = arrayIteration.some;
var arrayMethodIsStrict$3 = arrayMethodIsStrict$6;
var STRICT_METHOD$3 = arrayMethodIsStrict$3('some'); // `Array.prototype.some` method
// https://tc39.es/ecma262/#sec-array.prototype.some

$$a({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD$3
}, {
  some: function some(callbackfn
  /* , thisArg */
  ) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$7 = entryVirtual$l;
var some$3 = entryVirtual$7('Array').some;

var isPrototypeOf$7 = objectIsPrototypeOf;
var method$7 = some$3;
var ArrayPrototype$7 = Array.prototype;

var some$2 = function (it) {
  var own = it.some;
  return it === ArrayPrototype$7 || isPrototypeOf$7(ArrayPrototype$7, it) && own === ArrayPrototype$7.some ? method$7 : own;
};

var parent$s = some$2;
var some$1 = parent$s;

var some = some$1;

var global$6 = global$P;
var isConstructor = isConstructor$4;
var tryToString = tryToString$4;
var TypeError$3 = global$6.TypeError; // `Assert: IsConstructor(argument) is true`

var aConstructor$1 = function (argument) {
  if (isConstructor(argument)) return argument;
  throw TypeError$3(tryToString(argument) + ' is not a constructor');
};

var $$9 = _export;
var getBuiltIn = getBuiltIn$9;
var apply = functionApply;
var bind$1 = functionBind;
var aConstructor = aConstructor$1;
var anObject$2 = anObject$d;
var isObject$3 = isObject$j;
var create$3 = objectCreate;
var fails$3 = fails$t;
var nativeConstruct = getBuiltIn('Reflect', 'construct');
var ObjectPrototype = Object.prototype;
var push$1 = [].push; // `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it

var NEW_TARGET_BUG = fails$3(function () {
  function F() {
    /* empty */
  }

  return !(nativeConstruct(function () {
    /* empty */
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails$3(function () {
  nativeConstruct(function () {
    /* empty */
  });
});
var FORCED$2 = NEW_TARGET_BUG || ARGS_BUG;
$$9({
  target: 'Reflect',
  stat: true,
  forced: FORCED$2,
  sham: FORCED$2
}, {
  construct: function construct(Target, args
  /* , newTarget */
  ) {
    aConstructor(Target);
    anObject$2(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);

    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();

        case 1:
          return new Target(args[0]);

        case 2:
          return new Target(args[0], args[1]);

        case 3:
          return new Target(args[0], args[1], args[2]);

        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      } // w/o altered newTarget, lot of arguments case


      var $args = [null];
      apply(push$1, $args, args);
      return new (apply(bind$1, Target, $args))();
    } // with altered newTarget, not support built-in constructors


    var proto = newTarget.prototype;
    var instance = create$3(isObject$3(proto) ? proto : ObjectPrototype);
    var result = apply(Target, instance, args);
    return isObject$3(result) ? result : instance;
  }
});

var path$8 = path$y;
var construct$2 = path$8.Reflect.construct;

var parent$r = construct$2;
var construct$1 = parent$r;

var construct = construct$1;

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var parent$q = create$6;
var create$2 = parent$q;

var parent$p = create$2;
var create$1 = parent$p;

var create = create$1;

var $$8 = _export;
var setPrototypeOf$5 = objectSetPrototypeOf; // `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof

$$8({
  target: 'Object',
  stat: true
}, {
  setPrototypeOf: setPrototypeOf$5
});

var path$7 = path$y;
var setPrototypeOf$4 = path$7.Object.setPrototypeOf;

var parent$o = setPrototypeOf$4;
var setPrototypeOf$3 = parent$o;

var parent$n = setPrototypeOf$3;
var setPrototypeOf$2 = parent$n;

var parent$m = setPrototypeOf$2;
var setPrototypeOf$1 = parent$m;

var setPrototypeOf = setPrototypeOf$1;

function _setPrototypeOf(o, p) {
  _setPrototypeOf = setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });

  defineProperty$3(subClass, "prototype", {
    writable: false
  });

  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

var parent$l = getPrototypeOf$5;
var getPrototypeOf$3 = parent$l;

var parent$k = getPrototypeOf$3;
var getPrototypeOf$2 = parent$k;

var getPrototypeOf$1 = getPrototypeOf$2;

function _getPrototypeOf(o) {
  _getPrototypeOf = setPrototypeOf ? getPrototypeOf$1 : function _getPrototypeOf(o) {
    return o.__proto__ || getPrototypeOf$1(o);
  };
  return _getPrototypeOf(o);
}

var runtime = {exports: {}};

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(function (module) {
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.

    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.

      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.

    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.


    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    }; // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.


    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).


      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    });
    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          } // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted; // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.

            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    } // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.


    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      } // The delegate iterator is finished, so forget it and continue with
      // the outer generator.


      context.delegate = null;
      return ContinueSentinel;
    } // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.


    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.

    define(Gp, iteratorSymbol, function () {
      return this;
    });
    define(Gp, "toString", function () {
      return "[object Generator]";
    });

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse(); // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.

      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        } // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.


        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      } // Return an iterator with no values.


      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        this.prev = 0;
        this.next = 0; // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.

        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function () {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function (record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        } // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.


        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    }; // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.

    return exports;
  }( // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, in modern engines
    // we can explicitly access globalThis. In older engines we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
})(runtime);

var regenerator = runtime.exports;

var global$5 = global$P;
var aCallable$2 = aCallable$7;
var toObject$2 = toObject$e;
var IndexedObject = indexedObject;
var lengthOfArrayLike$3 = lengthOfArrayLike$d;
var TypeError$2 = global$5.TypeError; // `Array.prototype.{ reduce, reduceRight }` methods implementation

var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aCallable$2(callbackfn);
    var O = toObject$2(that);
    var self = IndexedObject(O);
    var length = lengthOfArrayLike$3(O);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }

      index += i;

      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError$2('Reduce of empty array with no initial value');
      }
    }

    for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }

    return memo;
  };
};

var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};

var classof$3 = classofRaw$1;
var global$4 = global$P;
var engineIsNode = classof$3(global$4.process) == 'process';

var $$7 = _export;
var $reduce = arrayReduce.left;
var arrayMethodIsStrict$2 = arrayMethodIsStrict$6;
var CHROME_VERSION = engineV8Version;
var IS_NODE = engineIsNode;
var STRICT_METHOD$2 = arrayMethodIsStrict$2('reduce'); // Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982

var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83; // `Array.prototype.reduce` method
// https://tc39.es/ecma262/#sec-array.prototype.reduce

$$7({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD$2 || CHROME_BUG
}, {
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    var length = arguments.length;
    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual$6 = entryVirtual$l;
var reduce$3 = entryVirtual$6('Array').reduce;

var isPrototypeOf$6 = objectIsPrototypeOf;
var method$6 = reduce$3;
var ArrayPrototype$6 = Array.prototype;

var reduce$2 = function (it) {
  var own = it.reduce;
  return it === ArrayPrototype$6 || isPrototypeOf$6(ArrayPrototype$6, it) && own === ArrayPrototype$6.reduce ? method$6 : own;
};

var parent$j = reduce$2;
var reduce$1 = parent$j;

var reduce = reduce$1;

var global$3 = global$P;
var isArray = isArray$d;
var lengthOfArrayLike$2 = lengthOfArrayLike$d;
var bind = functionBindContext;
var TypeError$1 = global$3.TypeError; // `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

var flattenIntoArray$1 = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg) : false;
  var element, elementLen;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        elementLen = lengthOfArrayLike$2(element);
        targetIndex = flattenIntoArray$1(target, original, element, elementLen, targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError$1('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }

    sourceIndex++;
  }

  return targetIndex;
};

var flattenIntoArray_1 = flattenIntoArray$1;

var $$6 = _export;
var flattenIntoArray = flattenIntoArray_1;
var aCallable$1 = aCallable$7;
var toObject$1 = toObject$e;
var lengthOfArrayLike$1 = lengthOfArrayLike$d;
var arraySpeciesCreate = arraySpeciesCreate$4; // `Array.prototype.flatMap` method
// https://tc39.es/ecma262/#sec-array.prototype.flatmap

$$6({
  target: 'Array',
  proto: true
}, {
  flatMap: function flatMap(callbackfn
  /* , thisArg */
  ) {
    var O = toObject$1(this);
    var sourceLen = lengthOfArrayLike$1(O);
    var A;
    aCallable$1(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  }
});

var entryVirtual$5 = entryVirtual$l;
var flatMap$3 = entryVirtual$5('Array').flatMap;

var isPrototypeOf$5 = objectIsPrototypeOf;
var method$5 = flatMap$3;
var ArrayPrototype$5 = Array.prototype;

var flatMap$2 = function (it) {
  var own = it.flatMap;
  return it === ArrayPrototype$5 || isPrototypeOf$5(ArrayPrototype$5, it) && own === ArrayPrototype$5.flatMap ? method$5 : own;
};

var parent$i = flatMap$2;
var flatMap$1 = parent$i;

var flatMap = flatMap$1;

var collection$1 = collection$3;
var collectionStrong = collectionStrong$2; // `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects

collection$1('Set', function (init) {
  return function Set() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong);

var path$6 = path$y;
var set$2 = path$6.Set;

var parent$h = set$2;
var set$1 = parent$h;

var set = set$1;

var iterator = iterator$4;

var getIterator$4 = getIterator$7;
var getIterator_1 = getIterator$4;

var parent$g = getIterator_1;
var getIterator$3 = parent$g;

var parent$f = getIterator$3;
var getIterator$2 = parent$f;

var parent$e = getIterator$2;
var getIterator$1 = parent$e;

var getIterator = getIterator$1;

var arraySlice = arraySliceSimple;
var floor = Math.floor;

var mergeSort = function (array, comparefn) {
  var length = array.length;
  var middle = floor(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySlice(array, 0, middle), comparefn), mergeSort(arraySlice(array, middle), comparefn), comparefn);
};

var insertionSort = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;

  while (i < length) {
    j = i;
    element = array[i];

    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }

    if (j !== i++) array[j] = element;
  }

  return array;
};

var merge = function (array, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;

  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
  }

  return array;
};

var arraySort = mergeSort;

var userAgent$1 = engineUserAgent;
var firefox = userAgent$1.match(/firefox\/(\d+)/i);
var engineFfVersion = !!firefox && +firefox[1];

var UA = engineUserAgent;
var engineIsIeOrEdge = /MSIE|Trident/.test(UA);

var userAgent = engineUserAgent;
var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
var engineWebkitVersion = !!webkit && +webkit[1];

var $$5 = _export;
var uncurryThis$3 = functionUncurryThis;
var aCallable = aCallable$7;
var toObject = toObject$e;
var lengthOfArrayLike = lengthOfArrayLike$d;
var toString$1 = toString$8;
var fails$2 = fails$t;
var internalSort = arraySort;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$6;
var FF = engineFfVersion;
var IE_OR_EDGE = engineIsIeOrEdge;
var V8 = engineV8Version;
var WEBKIT = engineWebkitVersion;
var test = [];
var un$Sort = uncurryThis$3(test.sort);
var push = uncurryThis$3(test.push); // IE8-

var FAILS_ON_UNDEFINED = fails$2(function () {
  test.sort(undefined);
}); // V8 bug

var FAILS_ON_NULL = fails$2(function () {
  test.sort(null);
}); // Old WebKit

var STRICT_METHOD$1 = arrayMethodIsStrict$1('sort');
var STABLE_SORT = !fails$2(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 70;
  if (FF && FF > 3) return;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 603;
  var result = '';
  var code, chr, value, index; // generate an array with more 512 elements (Chakra and old V8 fails only in this case)

  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);

    switch (code) {
      case 66:
      case 69:
      case 70:
      case 72:
        value = 3;
        break;

      case 68:
      case 71:
        value = 4;
        break;

      default:
        value = 2;
    }

    for (index = 0; index < 47; index++) {
      test.push({
        k: chr + index,
        v: value
      });
    }
  }

  test.sort(function (a, b) {
    return b.v - a.v;
  });

  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }

  return result !== 'DGBEFHACIJK';
});
var FORCED$1 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$1 || !STABLE_SORT;

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (y === undefined) return -1;
    if (x === undefined) return 1;
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    return toString$1(x) > toString$1(y) ? 1 : -1;
  };
}; // `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort


$$5({
  target: 'Array',
  proto: true,
  forced: FORCED$1
}, {
  sort: function sort(comparefn) {
    if (comparefn !== undefined) aCallable(comparefn);
    var array = toObject(this);
    if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);
    var items = [];
    var arrayLength = lengthOfArrayLike(array);
    var itemsLength, index;

    for (index = 0; index < arrayLength; index++) {
      if (index in array) push(items, array[index]);
    }

    internalSort(items, getSortCompare(comparefn));
    itemsLength = items.length;
    index = 0;

    while (index < itemsLength) array[index] = items[index++];

    while (index < arrayLength) delete array[index++];

    return array;
  }
});

var entryVirtual$4 = entryVirtual$l;
var sort$3 = entryVirtual$4('Array').sort;

var isPrototypeOf$4 = objectIsPrototypeOf;
var method$4 = sort$3;
var ArrayPrototype$4 = Array.prototype;

var sort$2 = function (it) {
  var own = it.sort;
  return it === ArrayPrototype$4 || isPrototypeOf$4(ArrayPrototype$4, it) && own === ArrayPrototype$4.sort ? method$4 : own;
};

var parent$d = sort$2;
var sort$1 = parent$d;

var sort = sort$1;

var entryVirtual$3 = entryVirtual$l;
var keys$3 = entryVirtual$3('Array').keys;

var parent$c = keys$3;
var keys$2 = parent$c;

var classof$2 = classof$e;
var hasOwn$4 = hasOwnProperty_1;
var isPrototypeOf$3 = objectIsPrototypeOf;
var method$3 = keys$2;
var ArrayPrototype$3 = Array.prototype;
var DOMIterables$2 = {
  DOMTokenList: true,
  NodeList: true
};

var keys$1 = function (it) {
  var own = it.keys;
  return it === ArrayPrototype$3 || isPrototypeOf$3(ArrayPrototype$3, it) && own === ArrayPrototype$3.keys || hasOwn$4(DOMIterables$2, classof$2(it)) ? method$3 : own;
};

var keys = keys$1;

var entryVirtual$2 = entryVirtual$l;
var values$3 = entryVirtual$2('Array').values;

var parent$b = values$3;
var values$2 = parent$b;

var classof$1 = classof$e;
var hasOwn$3 = hasOwnProperty_1;
var isPrototypeOf$2 = objectIsPrototypeOf;
var method$2 = values$2;
var ArrayPrototype$2 = Array.prototype;
var DOMIterables$1 = {
  DOMTokenList: true,
  NodeList: true
};

var values$1 = function (it) {
  var own = it.values;
  return it === ArrayPrototype$2 || isPrototypeOf$2(ArrayPrototype$2, it) && own === ArrayPrototype$2.values || hasOwn$3(DOMIterables$1, classof$1(it)) ? method$2 : own;
};

var values = values$1;

var entryVirtual$1 = entryVirtual$l;
var entries$3 = entryVirtual$1('Array').entries;

var parent$a = entries$3;
var entries$2 = parent$a;

var classof = classof$e;
var hasOwn$2 = hasOwnProperty_1;
var isPrototypeOf$1 = objectIsPrototypeOf;
var method$1 = entries$2;
var ArrayPrototype$1 = Array.prototype;
var DOMIterables = {
  DOMTokenList: true,
  NodeList: true
};

var entries$1 = function (it) {
  var own = it.entries;
  return it === ArrayPrototype$1 || isPrototypeOf$1(ArrayPrototype$1, it) && own === ArrayPrototype$1.entries || hasOwn$2(DOMIterables, classof(it)) ? method$1 : own;
};

var entries = entries$1;

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

var _Symbol$iterator;

function ownKeys$4(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var _context32, _context33; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context32 = ownKeys$4(Object(source), !0)).call(_context32, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context33 = ownKeys$4(Object(source))).call(_context33, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }

function _createSuper$t(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$t(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$t() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _createForOfIteratorHelper$7(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$7(o, minLen) { var _context31; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$7(o, minLen); var n = slice(_context31 = Object.prototype.toString.call(o)).call(_context31, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }

function _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Create new data pipe.
 *
 * @param from - The source data set or data view.
 * @remarks
 * Example usage:
 * ```typescript
 * interface AppItem {
 *   whoami: string;
 *   appData: unknown;
 *   visData: VisItem;
 * }
 * interface VisItem {
 *   id: number;
 *   label: string;
 *   color: string;
 *   x: number;
 *   y: number;
 * }
 *
 * const ds1 = new DataSet<AppItem, "whoami">([], { fieldId: "whoami" });
 * const ds2 = new DataSet<VisItem, "id">();
 *
 * const pipe = createNewDataPipeFrom(ds1)
 *   .filter((item): boolean => item.enabled === true)
 *   .map<VisItem, "id">((item): VisItem => item.visData)
 *   .to(ds2);
 *
 * pipe.start();
 * ```
 * @returns A factory whose methods can be used to configure the pipe.
 */

function createNewDataPipeFrom(from) {
  return new DataPipeUnderConstruction(from);
}
/**
 * Internal implementation of the pipe. This should be accessible only through
 * `createNewDataPipeFrom` from the outside.
 *
 * @typeParam SI - Source item type.
 * @typeParam SP - Source item type's id property name.
 * @typeParam TI - Target item type.
 * @typeParam TP - Target item type's id property name.
 */


var SimpleDataPipe = /*#__PURE__*/function () {
  /**
   * Bound listeners for use with `DataInterface['on' | 'off']`.
   */

  /**
   * Create a new data pipe.
   *
   * @param _source - The data set or data view that will be observed.
   * @param _transformers - An array of transforming functions to be used to
   * filter or transform the items in the pipe.
   * @param _target - The data set or data view that will receive the items.
   */
  function SimpleDataPipe(_source, _transformers, _target) {
    var _context, _context2, _context3;

    _classCallCheck(this, SimpleDataPipe);

    _defineProperty(this, "_source", void 0);

    _defineProperty(this, "_transformers", void 0);

    _defineProperty(this, "_target", void 0);

    _defineProperty(this, "_listeners", {
      add: bind$6(_context = this._add).call(_context, this),
      remove: bind$6(_context2 = this._remove).call(_context2, this),
      update: bind$6(_context3 = this._update).call(_context3, this)
    });

    this._source = _source;
    this._transformers = _transformers;
    this._target = _target;
  }
  /** @inheritDoc */


  _createClass(SimpleDataPipe, [{
    key: "all",
    value: function all() {
      this._target.update(this._transformItems(this._source.get()));

      return this;
    }
    /** @inheritDoc */

  }, {
    key: "start",
    value: function start() {
      this._source.on("add", this._listeners.add);

      this._source.on("remove", this._listeners.remove);

      this._source.on("update", this._listeners.update);

      return this;
    }
    /** @inheritDoc */

  }, {
    key: "stop",
    value: function stop() {
      this._source.off("add", this._listeners.add);

      this._source.off("remove", this._listeners.remove);

      this._source.off("update", this._listeners.update);

      return this;
    }
    /**
     * Apply the transformers to the items.
     *
     * @param items - The items to be transformed.
     * @returns The transformed items.
     */

  }, {
    key: "_transformItems",
    value: function _transformItems(items) {
      var _context4;

      return reduce(_context4 = this._transformers).call(_context4, function (items, transform) {
        return transform(items);
      }, items);
    }
    /**
     * Handle an add event.
     *
     * @param _name - Ignored.
     * @param payload - The payload containing the ids of the added items.
     */

  }, {
    key: "_add",
    value: function _add(_name, payload) {
      if (payload == null) {
        return;
      }

      this._target.add(this._transformItems(this._source.get(payload.items)));
    }
    /**
     * Handle an update event.
     *
     * @param _name - Ignored.
     * @param payload - The payload containing the ids of the updated items.
     */

  }, {
    key: "_update",
    value: function _update(_name, payload) {
      if (payload == null) {
        return;
      }

      this._target.update(this._transformItems(this._source.get(payload.items)));
    }
    /**
     * Handle a remove event.
     *
     * @param _name - Ignored.
     * @param payload - The payload containing the data of the removed items.
     */

  }, {
    key: "_remove",
    value: function _remove(_name, payload) {
      if (payload == null) {
        return;
      }

      this._target.remove(this._transformItems(payload.oldData));
    }
  }]);

  return SimpleDataPipe;
}();
/**
 * Internal implementation of the pipe factory. This should be accessible
 * only through `createNewDataPipeFrom` from the outside.
 *
 * @typeParam TI - Target item type.
 * @typeParam TP - Target item type's id property name.
 */


var DataPipeUnderConstruction = /*#__PURE__*/function () {
  /**
   * Array transformers used to transform items within the pipe. This is typed
   * as any for the sake of simplicity.
   */

  /**
   * Create a new data pipe factory. This is an internal constructor that
   * should never be called from outside of this file.
   *
   * @param _source - The source data set or data view for this pipe.
   */
  function DataPipeUnderConstruction(_source) {
    _classCallCheck(this, DataPipeUnderConstruction);

    _defineProperty(this, "_source", void 0);

    _defineProperty(this, "_transformers", []);

    this._source = _source;
  }
  /**
   * Filter the items.
   *
   * @param callback - A filtering function that returns true if given item
   * should be piped and false if not.
   * @returns This factory for further configuration.
   */


  _createClass(DataPipeUnderConstruction, [{
    key: "filter",
    value: function filter$1(callback) {
      this._transformers.push(function (input) {
        return filter(input).call(input, callback);
      });

      return this;
    }
    /**
     * Map each source item to a new type.
     *
     * @param callback - A mapping function that takes a source item and returns
     * corresponding mapped item.
     * @typeParam TI - Target item type.
     * @typeParam TP - Target item type's id property name.
     * @returns This factory for further configuration.
     */

  }, {
    key: "map",
    value: function map(callback) {
      this._transformers.push(function (input) {
        return map$3(input).call(input, callback);
      });

      return this;
    }
    /**
     * Map each source item to zero or more items of a new type.
     *
     * @param callback - A mapping function that takes a source item and returns
     * an array of corresponding mapped items.
     * @typeParam TI - Target item type.
     * @typeParam TP - Target item type's id property name.
     * @returns This factory for further configuration.
     */

  }, {
    key: "flatMap",
    value: function flatMap$1(callback) {
      this._transformers.push(function (input) {
        return flatMap(input).call(input, callback);
      });

      return this;
    }
    /**
     * Connect this pipe to given data set.
     *
     * @param target - The data set that will receive the items from this pipe.
     * @returns The pipe connected between given data sets and performing
     * configured transformation on the processed items.
     */

  }, {
    key: "to",
    value: function to(target) {
      return new SimpleDataPipe(this._source, this._transformers, target);
    }
  }]);

  return DataPipeUnderConstruction;
}();
/**
 * Determine whether a value can be used as an id.
 *
 * @param value - Input value of unknown type.
 * @returns True if the value is valid id, false otherwise.
 */


function isId(value) {
  return typeof value === "string" || typeof value === "number";
}
/**
 * A queue.
 *
 * @typeParam T - The type of method names to be replaced by queued versions.
 */


var Queue = /*#__PURE__*/function () {
  /** Delay in milliseconds. If defined the queue will be periodically flushed. */

  /** Maximum number of entries in the queue before it will be flushed. */

  /**
   * Construct a new Queue.
   *
   * @param options - Queue configuration.
   */
  function Queue(options) {
    _classCallCheck(this, Queue);

    _defineProperty(this, "delay", void 0);

    _defineProperty(this, "max", void 0);

    _defineProperty(this, "_queue", []);

    _defineProperty(this, "_timeout", null);

    _defineProperty(this, "_extended", null);

    // options
    this.delay = null;
    this.max = Infinity;
    this.setOptions(options);
  }
  /**
   * Update the configuration of the queue.
   *
   * @param options - Queue configuration.
   */


  _createClass(Queue, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options && typeof options.delay !== "undefined") {
        this.delay = options.delay;
      }

      if (options && typeof options.max !== "undefined") {
        this.max = options.max;
      }

      this._flushIfNeeded();
    }
    /**
     * Extend an object with queuing functionality.
     * The object will be extended with a function flush, and the methods provided in options.replace will be replaced with queued ones.
     *
     * @param object - The object to be extended.
     * @param options - Additional options.
     * @returns The created queue.
     */

  }, {
    key: "destroy",
    value:
    /**
     * Destroy the queue. The queue will first flush all queued actions, and in case it has extended an object, will restore the original object.
     */
    function destroy() {
      this.flush();

      if (this._extended) {
        var object = this._extended.object;
        var methods = this._extended.methods;

        for (var i = 0; i < methods.length; i++) {
          var method = methods[i];

          if (method.original) {
            // @TODO: better solution?
            object[method.name] = method.original;
          } else {
            // @TODO: better solution?
            delete object[method.name];
          }
        }

        this._extended = null;
      }
    }
    /**
     * Replace a method on an object with a queued version.
     *
     * @param object - Object having the method.
     * @param method - The method name.
     */

  }, {
    key: "replace",
    value: function replace(object, method) {
      /* eslint-disable-next-line @typescript-eslint/no-this-alias -- Function this is necessary in the function bellow, so class this has to be saved into a variable here. */
      var me = this;
      var original = object[method];

      if (!original) {
        throw new Error("Method " + method + " undefined");
      }

      object[method] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        // add this call to the queue
        me.queue({
          args: args,
          fn: original,
          context: this
        });
      };
    }
    /**
     * Queue a call.
     *
     * @param entry - The function or entry to be queued.
     */

  }, {
    key: "queue",
    value: function queue(entry) {
      if (typeof entry === "function") {
        this._queue.push({
          fn: entry
        });
      } else {
        this._queue.push(entry);
      }

      this._flushIfNeeded();
    }
    /**
     * Check whether the queue needs to be flushed.
     */

  }, {
    key: "_flushIfNeeded",
    value: function _flushIfNeeded() {
      var _this = this;

      // flush when the maximum is exceeded.
      if (this._queue.length > this.max) {
        this.flush();
      } // flush after a period of inactivity when a delay is configured


      if (this._timeout != null) {
        clearTimeout(this._timeout);
        this._timeout = null;
      }

      if (this.queue.length > 0 && typeof this.delay === "number") {
        this._timeout = setTimeout$1(function () {
          _this.flush();
        }, this.delay);
      }
    }
    /**
     * Flush all queued calls
     */

  }, {
    key: "flush",
    value: function flush() {
      var _context5, _context6;

      forEach$2(_context5 = splice$1(_context6 = this._queue).call(_context6, 0)).call(_context5, function (entry) {
        entry.fn.apply(entry.context || entry.fn, entry.args || []);
      });
    }
  }], [{
    key: "extend",
    value: function extend(object, options) {
      var queue = new Queue(options);

      if (object.flush !== undefined) {
        throw new Error("Target object already has a property flush");
      }

      object.flush = function () {
        queue.flush();
      };

      var methods = [{
        name: "flush",
        original: undefined
      }];

      if (options && options.replace) {
        for (var i = 0; i < options.replace.length; i++) {
          var name = options.replace[i];
          methods.push({
            name: name,
            // @TODO: better solution?
            original: object[name]
          }); // @TODO: better solution?

          queue.replace(object, name);
        }
      }

      queue._extended = {
        object: object,
        methods: methods
      };
      return queue;
    }
  }]);

  return Queue;
}();
/**
 * [[DataSet]] code that can be reused in [[DataView]] or other similar implementations of [[DataInterface]].
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */


var DataSetPart = /*#__PURE__*/function () {
  function DataSetPart() {
    _classCallCheck(this, DataSetPart);

    _defineProperty(this, "_subscribers", {
      "*": [],
      add: [],
      remove: [],
      update: []
    });

    _defineProperty(this, "subscribe", DataSetPart.prototype.on);

    _defineProperty(this, "unsubscribe", DataSetPart.prototype.off);
  }

  _createClass(DataSetPart, [{
    key: "_trigger",
    value:
    /**
     * Trigger an event
     *
     * @param event - Event name.
     * @param payload - Event payload.
     * @param senderId - Id of the sender.
     */
    function _trigger(event, payload, senderId) {
      var _context7, _context8;

      if (event === "*") {
        throw new Error("Cannot trigger event *");
      }

      forEach$2(_context7 = concat(_context8 = []).call(_context8, _toConsumableArray(this._subscribers[event]), _toConsumableArray(this._subscribers["*"]))).call(_context7, function (subscriber) {
        subscriber(event, payload, senderId != null ? senderId : null);
      });
    }
    /**
     * Subscribe to an event, add an event listener.
     *
     * @remarks Non-function callbacks are ignored.
     * @param event - Event name.
     * @param callback - Callback method.
     */

  }, {
    key: "on",
    value: function on(event, callback) {
      if (typeof callback === "function") {
        this._subscribers[event].push(callback);
      } // @TODO: Maybe throw for invalid callbacks?

    }
    /**
     * Unsubscribe from an event, remove an event listener.
     *
     * @remarks If the same callback was subscribed more than once **all** occurences will be removed.
     * @param event - Event name.
     * @param callback - Callback method.
     */

  }, {
    key: "off",
    value: function off(event, callback) {
      var _context9;

      this._subscribers[event] = filter(_context9 = this._subscribers[event]).call(_context9, function (subscriber) {
        return subscriber !== callback;
      });
    }
    /**
     * @deprecated Use on instead (PS: DataView.subscribe === DataView.on).
     */

  }]);

  return DataSetPart;
}();
/**
 * Data stream
 *
 * @remarks
 * [[DataStream]] offers an always up to date stream of items from a [[DataSet]] or [[DataView]].
 * That means that the stream is evaluated at the time of iteration, conversion to another data type or when [[cache]] is called, not when the [[DataStream]] was created.
 * Multiple invocations of for example [[toItemArray]] may yield different results (if the data source like for example [[DataSet]] gets modified).
 * @typeParam Item - The item type this stream is going to work with.
 */


_Symbol$iterator = iterator;

var DataStream = /*#__PURE__*/function () {
  /**
   * Create a new data stream.
   *
   * @param pairs - The id, item pairs.
   */
  function DataStream(pairs) {
    _classCallCheck(this, DataStream);

    _defineProperty(this, "_pairs", void 0);

    this._pairs = pairs;
  }
  /**
   * Return an iterable of key, value pairs for every entry in the stream.
   */


  _createClass(DataStream, [{
    key: _Symbol$iterator,
    value:
    /*#__PURE__*/
    regenerator.mark(function value() {
      var _iterator, _step, _step$value, id, item;

      return regenerator.wrap(function value$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _iterator = _createForOfIteratorHelper$7(this._pairs);
              _context10.prev = 1;

              _iterator.s();

            case 3:
              if ((_step = _iterator.n()).done) {
                _context10.next = 9;
                break;
              }

              _step$value = _slicedToArray(_step.value, 2), id = _step$value[0], item = _step$value[1];
              _context10.next = 7;
              return [id, item];

            case 7:
              _context10.next = 3;
              break;

            case 9:
              _context10.next = 14;
              break;

            case 11:
              _context10.prev = 11;
              _context10.t0 = _context10["catch"](1);

              _iterator.e(_context10.t0);

            case 14:
              _context10.prev = 14;

              _iterator.f();

              return _context10.finish(14);

            case 17:
            case "end":
              return _context10.stop();
          }
        }
      }, value, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an iterable of key, value pairs for every entry in the stream.
     */

  }, {
    key: "entries",
    value:
    /*#__PURE__*/
    regenerator.mark(function entries() {
      var _iterator2, _step2, _step2$value, id, item;

      return regenerator.wrap(function entries$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _iterator2 = _createForOfIteratorHelper$7(this._pairs);
              _context11.prev = 1;

              _iterator2.s();

            case 3:
              if ((_step2 = _iterator2.n()).done) {
                _context11.next = 9;
                break;
              }

              _step2$value = _slicedToArray(_step2.value, 2), id = _step2$value[0], item = _step2$value[1];
              _context11.next = 7;
              return [id, item];

            case 7:
              _context11.next = 3;
              break;

            case 9:
              _context11.next = 14;
              break;

            case 11:
              _context11.prev = 11;
              _context11.t0 = _context11["catch"](1);

              _iterator2.e(_context11.t0);

            case 14:
              _context11.prev = 14;

              _iterator2.f();

              return _context11.finish(14);

            case 17:
            case "end":
              return _context11.stop();
          }
        }
      }, entries, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an iterable of keys in the stream.
     */

  }, {
    key: "keys",
    value:
    /*#__PURE__*/
    regenerator.mark(function keys() {
      var _iterator3, _step3, _step3$value, id;

      return regenerator.wrap(function keys$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _iterator3 = _createForOfIteratorHelper$7(this._pairs);
              _context12.prev = 1;

              _iterator3.s();

            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context12.next = 9;
                break;
              }

              _step3$value = _slicedToArray(_step3.value, 1), id = _step3$value[0];
              _context12.next = 7;
              return id;

            case 7:
              _context12.next = 3;
              break;

            case 9:
              _context12.next = 14;
              break;

            case 11:
              _context12.prev = 11;
              _context12.t0 = _context12["catch"](1);

              _iterator3.e(_context12.t0);

            case 14:
              _context12.prev = 14;

              _iterator3.f();

              return _context12.finish(14);

            case 17:
            case "end":
              return _context12.stop();
          }
        }
      }, keys, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an iterable of values in the stream.
     */

  }, {
    key: "values",
    value:
    /*#__PURE__*/
    regenerator.mark(function values() {
      var _iterator4, _step4, _step4$value, item;

      return regenerator.wrap(function values$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              _iterator4 = _createForOfIteratorHelper$7(this._pairs);
              _context13.prev = 1;

              _iterator4.s();

            case 3:
              if ((_step4 = _iterator4.n()).done) {
                _context13.next = 9;
                break;
              }

              _step4$value = _slicedToArray(_step4.value, 2), item = _step4$value[1];
              _context13.next = 7;
              return item;

            case 7:
              _context13.next = 3;
              break;

            case 9:
              _context13.next = 14;
              break;

            case 11:
              _context13.prev = 11;
              _context13.t0 = _context13["catch"](1);

              _iterator4.e(_context13.t0);

            case 14:
              _context13.prev = 14;

              _iterator4.f();

              return _context13.finish(14);

            case 17:
            case "end":
              return _context13.stop();
          }
        }
      }, values, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an array containing all the ids in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     * @returns The array with all ids from this stream.
     */

  }, {
    key: "toIdArray",
    value: function toIdArray() {
      var _context14;

      return map$3(_context14 = _toConsumableArray(this._pairs)).call(_context14, function (pair) {
        return pair[0];
      });
    }
    /**
     * Return an array containing all the items in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     * @returns The array with all items from this stream.
     */

  }, {
    key: "toItemArray",
    value: function toItemArray() {
      var _context15;

      return map$3(_context15 = _toConsumableArray(this._pairs)).call(_context15, function (pair) {
        return pair[1];
      });
    }
    /**
     * Return an array containing all the entries in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     * @returns The array with all entries from this stream.
     */

  }, {
    key: "toEntryArray",
    value: function toEntryArray() {
      return _toConsumableArray(this._pairs);
    }
    /**
     * Return an object map containing all the items in this stream accessible by ids.
     *
     * @remarks
     * In case of duplicate ids (coerced to string so `7 == '7'`) the last encoutered appears in the returned object.
     * @returns The object map of all id → item pairs from this stream.
     */

  }, {
    key: "toObjectMap",
    value: function toObjectMap() {
      var map = create$5(null);

      var _iterator5 = _createForOfIteratorHelper$7(this._pairs),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _step5$value = _slicedToArray(_step5.value, 2),
              id = _step5$value[0],
              item = _step5$value[1];

          map[id] = item;
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return map;
    }
    /**
     * Return a map containing all the items in this stream accessible by ids.
     *
     * @returns The map of all id → item pairs from this stream.
     */

  }, {
    key: "toMap",
    value: function toMap() {
      return new map(this._pairs);
    }
    /**
     * Return a set containing all the (unique) ids in this stream.
     *
     * @returns The set of all ids from this stream.
     */

  }, {
    key: "toIdSet",
    value: function toIdSet() {
      return new set(this.toIdArray());
    }
    /**
     * Return a set containing all the (unique) items in this stream.
     *
     * @returns The set of all items from this stream.
     */

  }, {
    key: "toItemSet",
    value: function toItemSet() {
      return new set(this.toItemArray());
    }
    /**
     * Cache the items from this stream.
     *
     * @remarks
     * This method allows for items to be fetched immediatelly and used (possibly multiple times) later.
     * It can also be used to optimize performance as [[DataStream]] would otherwise reevaluate everything upon each iteration.
     *
     * ## Example
     * ```javascript
     * const ds = new DataSet([…])
     *
     * const cachedStream = ds.stream()
     *   .filter(…)
     *   .sort(…)
     *   .map(…)
     *   .cached(…) // Data are fetched, processed and cached here.
     *
     * ds.clear()
     * chachedStream // Still has all the items.
     * ```
     * @returns A new [[DataStream]] with cached items (detached from the original [[DataSet]]).
     */

  }, {
    key: "cache",
    value: function cache() {
      return new DataStream(_toConsumableArray(this._pairs));
    }
    /**
     * Get the distinct values of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     * @typeParam T - The type of the distinct value.
     * @returns A set of all distinct properties.
     */

  }, {
    key: "distinct",
    value: function distinct(callback) {
      var set$1 = new set();

      var _iterator6 = _createForOfIteratorHelper$7(this._pairs),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _step6$value = _slicedToArray(_step6.value, 2),
              id = _step6$value[0],
              item = _step6$value[1];

          set$1.add(callback(item, id));
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      return set$1;
    }
    /**
     * Filter the items of the stream.
     *
     * @param callback - The function that decides whether an item will be included.
     * @returns A new data stream with the filtered items.
     */

  }, {
    key: "filter",
    value: function filter(callback) {
      var pairs = this._pairs;
      return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee() {
        var _iterator7, _step7, _step7$value, id, item;

        return regenerator.wrap(function _callee$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _iterator7 = _createForOfIteratorHelper$7(pairs);
                _context16.prev = 1;

                _iterator7.s();

              case 3:
                if ((_step7 = _iterator7.n()).done) {
                  _context16.next = 10;
                  break;
                }

                _step7$value = _slicedToArray(_step7.value, 2), id = _step7$value[0], item = _step7$value[1];

                if (!callback(item, id)) {
                  _context16.next = 8;
                  break;
                }

                _context16.next = 8;
                return [id, item];

              case 8:
                _context16.next = 3;
                break;

              case 10:
                _context16.next = 15;
                break;

              case 12:
                _context16.prev = 12;
                _context16.t0 = _context16["catch"](1);

                _iterator7.e(_context16.t0);

              case 15:
                _context16.prev = 15;

                _iterator7.f();

                return _context16.finish(15);

              case 18:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee, null, [[1, 12, 15, 18]]);
      })));
    }
    /**
     * Execute a callback for each item of the stream.
     *
     * @param callback - The function that will be invoked for each item.
     */

  }, {
    key: "forEach",
    value: function forEach(callback) {
      var _iterator8 = _createForOfIteratorHelper$7(this._pairs),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var _step8$value = _slicedToArray(_step8.value, 2),
              id = _step8$value[0],
              item = _step8$value[1];

          callback(item, id);
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
    /**
     * Map the items into a different type.
     *
     * @param callback - The function that does the conversion.
     * @typeParam Mapped - The type of the item after mapping.
     * @returns A new data stream with the mapped items.
     */

  }, {
    key: "map",
    value: function map(callback) {
      var pairs = this._pairs;
      return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee2() {
        var _iterator9, _step9, _step9$value, id, item;

        return regenerator.wrap(function _callee2$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _iterator9 = _createForOfIteratorHelper$7(pairs);
                _context17.prev = 1;

                _iterator9.s();

              case 3:
                if ((_step9 = _iterator9.n()).done) {
                  _context17.next = 9;
                  break;
                }

                _step9$value = _slicedToArray(_step9.value, 2), id = _step9$value[0], item = _step9$value[1];
                _context17.next = 7;
                return [id, callback(item, id)];

              case 7:
                _context17.next = 3;
                break;

              case 9:
                _context17.next = 14;
                break;

              case 11:
                _context17.prev = 11;
                _context17.t0 = _context17["catch"](1);

                _iterator9.e(_context17.t0);

              case 14:
                _context17.prev = 14;

                _iterator9.f();

                return _context17.finish(14);

              case 17:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee2, null, [[1, 11, 14, 17]]);
      })));
    }
    /**
     * Get the item with the maximum value of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     * @returns The item with the maximum if found otherwise null.
     */

  }, {
    key: "max",
    value: function max(callback) {
      var iter = getIterator(this._pairs);

      var curr = iter.next();

      if (curr.done) {
        return null;
      }

      var maxItem = curr.value[1];
      var maxValue = callback(curr.value[1], curr.value[0]);

      while (!(curr = iter.next()).done) {
        var _curr$value = _slicedToArray(curr.value, 2),
            id = _curr$value[0],
            item = _curr$value[1];

        var _value = callback(item, id);

        if (_value > maxValue) {
          maxValue = _value;
          maxItem = item;
        }
      }

      return maxItem;
    }
    /**
     * Get the item with the minimum value of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     * @returns The item with the minimum if found otherwise null.
     */

  }, {
    key: "min",
    value: function min(callback) {
      var iter = getIterator(this._pairs);

      var curr = iter.next();

      if (curr.done) {
        return null;
      }

      var minItem = curr.value[1];
      var minValue = callback(curr.value[1], curr.value[0]);

      while (!(curr = iter.next()).done) {
        var _curr$value2 = _slicedToArray(curr.value, 2),
            id = _curr$value2[0],
            item = _curr$value2[1];

        var _value2 = callback(item, id);

        if (_value2 < minValue) {
          minValue = _value2;
          minItem = item;
        }
      }

      return minItem;
    }
    /**
     * Reduce the items into a single value.
     *
     * @param callback - The function that does the reduction.
     * @param accumulator - The initial value of the accumulator.
     * @typeParam T - The type of the accumulated value.
     * @returns The reduced value.
     */

  }, {
    key: "reduce",
    value: function reduce(callback, accumulator) {
      var _iterator10 = _createForOfIteratorHelper$7(this._pairs),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var _step10$value = _slicedToArray(_step10.value, 2),
              id = _step10$value[0],
              item = _step10$value[1];

          accumulator = callback(accumulator, item, id);
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }

      return accumulator;
    }
    /**
     * Sort the items.
     *
     * @param callback - Item comparator.
     * @returns A new stream with sorted items.
     */

  }, {
    key: "sort",
    value: function sort$1(callback) {
      var _this2 = this;

      return new DataStream(_defineProperty({}, iterator, function () {
        var _context18;

        return getIterator(sort(_context18 = _toConsumableArray(_this2._pairs)).call(_context18, function (_ref, _ref2) {
          var _ref3 = _slicedToArray(_ref, 2),
              idA = _ref3[0],
              itemA = _ref3[1];

          var _ref4 = _slicedToArray(_ref2, 2),
              idB = _ref4[0],
              itemB = _ref4[1];

          return callback(itemA, itemB, idA, idB);
        }));
      }));
    }
  }]);

  return DataStream;
}();
/**
 * Add an id to given item if it doesn't have one already.
 *
 * @remarks
 * The item will be modified.
 * @param item - The item that will have an id after a call to this function.
 * @param idProp - The key of the id property.
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 * @returns true
 */


function ensureFullItem(item, idProp) {
  if (item[idProp] == null) {
    // generate an id
    item[idProp] = v4();
  }

  return item;
}
/**
 * # DataSet
 *
 * Vis.js comes with a flexible DataSet, which can be used to hold and
 * manipulate unstructured data and listen for changes in the data. The DataSet
 * is key/value based. Data items can be added, updated and removed from the
 * DataSet, and one can subscribe to changes in the DataSet. The data in the
 * DataSet can be filtered and ordered. Data can be normalized when appending it
 * to the DataSet as well.
 *
 * ## Example
 *
 * The following example shows how to use a DataSet.
 *
 * ```javascript
 * // create a DataSet
 * var options = {};
 * var data = new vis.DataSet(options);
 *
 * // add items
 * // note that the data items can contain different properties and data formats
 * data.add([
 *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
 *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
 *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
 *   {id: 4, text: 'item 4'}
 * ]);
 *
 * // subscribe to any change in the DataSet
 * data.on('*', function (event, properties, senderId) {
 *   console.log('event', event, properties);
 * });
 *
 * // update an existing item
 * data.update({id: 2, group: 1});
 *
 * // remove an item
 * data.remove(4);
 *
 * // get all ids
 * var ids = data.getIds();
 * console.log('ids', ids);
 *
 * // get a specific item
 * var item1 = data.get(1);
 * console.log('item1', item1);
 *
 * // retrieve a filtered subset of the data
 * var items = data.get({
 *   filter: function (item) {
 *     return item.group == 1;
 *   }
 * });
 * console.log('filtered items', items);
 * ```
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */


var DataSet = /*#__PURE__*/function (_DataSetPart) {
  _inherits(DataSet, _DataSetPart);

  var _super = _createSuper$t(DataSet);

  /**
   * Construct a new DataSet.
   *
   * @param data - Initial data or options.
   * @param options - Options (type error if data is also options).
   */
  function DataSet(data, options) {
    var _this3;

    _classCallCheck(this, DataSet);

    _this3 = _super.call(this); // correctly read optional arguments

    _defineProperty(_assertThisInitialized(_this3), "flush", void 0);

    _defineProperty(_assertThisInitialized(_this3), "length", void 0);

    _defineProperty(_assertThisInitialized(_this3), "_options", void 0);

    _defineProperty(_assertThisInitialized(_this3), "_data", void 0);

    _defineProperty(_assertThisInitialized(_this3), "_idProp", void 0);

    _defineProperty(_assertThisInitialized(_this3), "_queue", null);

    if (data && !isArray$2(data)) {
      options = data;
      data = [];
    }

    _this3._options = options || {};
    _this3._data = new map(); // map with data indexed by id

    _this3.length = 0; // number of items in the DataSet

    _this3._idProp = _this3._options.fieldId || "id"; // name of the field containing id
    // add initial data when provided

    if (data && data.length) {
      _this3.add(data);
    }

    _this3.setOptions(options);

    return _this3;
  }
  /**
   * Set new options.
   *
   * @param options - The new options.
   */


  _createClass(DataSet, [{
    key: "idProp",
    get:
    /** Flush all queued calls. */

    /** @inheritDoc */

    /** @inheritDoc */
    function get() {
      return this._idProp;
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options && options.queue !== undefined) {
        if (options.queue === false) {
          // delete queue if loaded
          if (this._queue) {
            this._queue.destroy();

            this._queue = null;
          }
        } else {
          // create queue and update its options
          if (!this._queue) {
            this._queue = Queue.extend(this, {
              replace: ["add", "update", "remove"]
            });
          }

          if (options.queue && _typeof(options.queue) === "object") {
            this._queue.setOptions(options.queue);
          }
        }
      }
    }
    /**
     * Add a data item or an array with items.
     *
     * After the items are added to the DataSet, the DataSet will trigger an event `add`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet()
     *
     * // add items
     * const ids = data.add([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { text: 'item without an id' }
     * ])
     *
     * console.log(ids) // [1, 2, '<UUIDv4>']
     * ```
     *
     * @param data - Items to be added (ids will be generated if missing).
     * @param senderId - Sender id.
     * @returns addedIds - Array with the ids (generated if not present) of the added items.
     * @throws When an item with the same id as any of the added items already exists.
     */

  }, {
    key: "add",
    value: function add(data, senderId) {
      var _this4 = this;

      var addedIds = [];
      var id;

      if (isArray$2(data)) {
        // Array
        var idsToAdd = map$3(data).call(data, function (d) {
          return d[_this4._idProp];
        });

        if (some(idsToAdd).call(idsToAdd, function (id) {
          return _this4._data.has(id);
        })) {
          throw new Error("A duplicate id was found in the parameter array.");
        }

        for (var i = 0, len = data.length; i < len; i++) {
          id = this._addItem(data[i]);
          addedIds.push(id);
        }
      } else if (data && _typeof(data) === "object") {
        // Single item
        id = this._addItem(data);
        addedIds.push(id);
      } else {
        throw new Error("Unknown dataType");
      }

      if (addedIds.length) {
        this._trigger("add", {
          items: addedIds
        }, senderId);
      }

      return addedIds;
    }
    /**
     * Update existing items. When an item does not exist, it will be created.
     *
     * @remarks
     * The provided properties will be merged in the existing item. When an item does not exist, it will be created.
     *
     * After the items are updated, the DataSet will trigger an event `add` for the added items, and an event `update`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' }
     * ])
     *
     * // update items
     * const ids = data.update([
     *   { id: 2, text: 'item 2 (updated)' },
     *   { id: 4, text: 'item 4 (new)' }
     * ])
     *
     * console.log(ids) // [2, 4]
     * ```
     *
     * ## Warning for TypeScript users
     * This method may introduce partial items into the data set. Use add or updateOnly instead for better type safety.
     * @param data - Items to be updated (if the id is already present) or added (if the id is missing).
     * @param senderId - Sender id.
     * @returns updatedIds - The ids of the added (these may be newly generated if there was no id in the item from the data) or updated items.
     * @throws When the supplied data is neither an item nor an array of items.
     */

  }, {
    key: "update",
    value: function update(data, senderId) {
      var _this5 = this;

      var addedIds = [];
      var updatedIds = [];
      var oldData = [];
      var updatedData = [];
      var idProp = this._idProp;

      var addOrUpdate = function addOrUpdate(item) {
        var origId = item[idProp];

        if (origId != null && _this5._data.has(origId)) {
          var fullItem = item; // it has an id, therefore it is a fullitem

          var oldItem = assign$2({}, _this5._data.get(origId)); // update item


          var id = _this5._updateItem(fullItem);

          updatedIds.push(id);
          updatedData.push(fullItem);
          oldData.push(oldItem);
        } else {
          // add new item
          var _id = _this5._addItem(item);

          addedIds.push(_id);
        }
      };

      if (isArray$2(data)) {
        // Array
        for (var i = 0, len = data.length; i < len; i++) {
          if (data[i] && _typeof(data[i]) === "object") {
            addOrUpdate(data[i]);
          } else {
            console.warn("Ignoring input item, which is not an object at index " + i);
          }
        }
      } else if (data && _typeof(data) === "object") {
        // Single item
        addOrUpdate(data);
      } else {
        throw new Error("Unknown dataType");
      }

      if (addedIds.length) {
        this._trigger("add", {
          items: addedIds
        }, senderId);
      }

      if (updatedIds.length) {
        var props = {
          items: updatedIds,
          oldData: oldData,
          data: updatedData
        }; // TODO: remove deprecated property 'data' some day
        //Object.defineProperty(props, 'data', {
        //  'get': (function() {
        //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
        //    return updatedData;
        //  }).bind(this)
        //});

        this._trigger("update", props, senderId);
      }

      return concat(addedIds).call(addedIds, updatedIds);
    }
    /**
     * Update existing items. When an item does not exist, an error will be thrown.
     *
     * @remarks
     * The provided properties will be deeply merged into the existing item.
     * When an item does not exist (id not present in the data set or absent), an error will be thrown and nothing will be changed.
     *
     * After the items are updated, the DataSet will trigger an event `update`.
     * When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' },
     * ])
     *
     * // update items
     * const ids = data.update([
     *   { id: 2, text: 'item 2 (updated)' }, // works
     *   // { id: 4, text: 'item 4 (new)' }, // would throw
     *   // { text: 'item 4 (new)' }, // would also throw
     * ])
     *
     * console.log(ids) // [2]
     * ```
     * @param data - Updates (the id and optionally other props) to the items in this data set.
     * @param senderId - Sender id.
     * @returns updatedIds - The ids of the updated items.
     * @throws When the supplied data is neither an item nor an array of items, when the ids are missing.
     */

  }, {
    key: "updateOnly",
    value: function updateOnly(data, senderId) {
      var _context19,
          _this6 = this;

      if (!isArray$2(data)) {
        data = [data];
      }

      var updateEventData = map$3(_context19 = map$3(data).call(data, function (update) {
        var oldData = _this6._data.get(update[_this6._idProp]);

        if (oldData == null) {
          throw new Error("Updating non-existent items is not allowed.");
        }

        return {
          oldData: oldData,
          update: update
        };
      })).call(_context19, function (_ref5) {
        var oldData = _ref5.oldData,
            update = _ref5.update;
        var id = oldData[_this6._idProp];
        var updatedData = pureDeepObjectAssign(oldData, update);

        _this6._data.set(id, updatedData);

        return {
          id: id,
          oldData: oldData,
          updatedData: updatedData
        };
      });

      if (updateEventData.length) {
        var props = {
          items: map$3(updateEventData).call(updateEventData, function (value) {
            return value.id;
          }),
          oldData: map$3(updateEventData).call(updateEventData, function (value) {
            return value.oldData;
          }),
          data: map$3(updateEventData).call(updateEventData, function (value) {
            return value.updatedData;
          })
        }; // TODO: remove deprecated property 'data' some day
        //Object.defineProperty(props, 'data', {
        //  'get': (function() {
        //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
        //    return updatedData;
        //  }).bind(this)
        //});

        this._trigger("update", props, senderId);

        return props.items;
      } else {
        return [];
      }
    }
    /** @inheritDoc */

  }, {
    key: "get",
    value: function get(first, second) {
      // @TODO: Woudn't it be better to split this into multiple methods?
      // parse the arguments
      var id = undefined;
      var ids = undefined;
      var options = undefined;

      if (isId(first)) {
        // get(id [, options])
        id = first;
        options = second;
      } else if (isArray$2(first)) {
        // get(ids [, options])
        ids = first;
        options = second;
      } else {
        // get([, options])
        options = first;
      } // determine the return type


      var returnType = options && options.returnType === "Object" ? "Object" : "Array"; // @TODO: WTF is this? Or am I missing something?
      // var returnType
      // if (options && options.returnType) {
      //   var allowedValues = ['Array', 'Object']
      //   returnType =
      //     allowedValues.indexOf(options.returnType) == -1
      //       ? 'Array'
      //       : options.returnType
      // } else {
      //   returnType = 'Array'
      // }
      // build options

      var filter$1 = options && filter(options);

      var items = [];
      var item = undefined;
      var itemIds = undefined;
      var itemId = undefined; // convert items

      if (id != null) {
        // return a single item
        item = this._data.get(id);

        if (item && filter$1 && !filter$1(item)) {
          item = undefined;
        }
      } else if (ids != null) {
        // return a subset of items
        for (var i = 0, len = ids.length; i < len; i++) {
          item = this._data.get(ids[i]);

          if (item != null && (!filter$1 || filter$1(item))) {
            items.push(item);
          }
        }
      } else {
        var _context20;

        // return all items
        itemIds = _toConsumableArray(keys(_context20 = this._data).call(_context20));

        for (var _i = 0, _len2 = itemIds.length; _i < _len2; _i++) {
          itemId = itemIds[_i];
          item = this._data.get(itemId);

          if (item != null && (!filter$1 || filter$1(item))) {
            items.push(item);
          }
        }
      } // order the results


      if (options && options.order && id == undefined) {
        this._sort(items, options.order);
      } // filter fields of the items


      if (options && options.fields) {
        var fields = options.fields;

        if (id != undefined && item != null) {
          item = this._filterFields(item, fields);
        } else {
          for (var _i2 = 0, _len3 = items.length; _i2 < _len3; _i2++) {
            items[_i2] = this._filterFields(items[_i2], fields);
          }
        }
      } // return the results


      if (returnType == "Object") {
        var result = {};

        for (var _i3 = 0, _len4 = items.length; _i3 < _len4; _i3++) {
          var resultant = items[_i3]; // @TODO: Shoudn't this be this._fieldId?
          // result[resultant.id] = resultant

          var _id2 = resultant[this._idProp];
          result[_id2] = resultant;
        }

        return result;
      } else {
        if (id != null) {
          var _item;

          // a single item
          return (_item = item) !== null && _item !== void 0 ? _item : null;
        } else {
          // just return our array
          return items;
        }
      }
    }
    /** @inheritDoc */

  }, {
    key: "getIds",
    value: function getIds(options) {
      var data = this._data;

      var filter$1 = options && filter(options);

      var order = options && options.order;

      var itemIds = _toConsumableArray(keys(data).call(data));

      var ids = [];

      if (filter$1) {
        // get filtered items
        if (order) {
          // create ordered list
          var items = [];

          for (var i = 0, len = itemIds.length; i < len; i++) {
            var id = itemIds[i];

            var item = this._data.get(id);

            if (item != null && filter$1(item)) {
              items.push(item);
            }
          }

          this._sort(items, order);

          for (var _i4 = 0, _len5 = items.length; _i4 < _len5; _i4++) {
            ids.push(items[_i4][this._idProp]);
          }
        } else {
          // create unordered list
          for (var _i5 = 0, _len6 = itemIds.length; _i5 < _len6; _i5++) {
            var _id3 = itemIds[_i5];

            var _item2 = this._data.get(_id3);

            if (_item2 != null && filter$1(_item2)) {
              ids.push(_item2[this._idProp]);
            }
          }
        }
      } else {
        // get all items
        if (order) {
          // create an ordered list
          var _items = [];

          for (var _i6 = 0, _len7 = itemIds.length; _i6 < _len7; _i6++) {
            var _id4 = itemIds[_i6];

            _items.push(data.get(_id4));
          }

          this._sort(_items, order);

          for (var _i7 = 0, _len8 = _items.length; _i7 < _len8; _i7++) {
            ids.push(_items[_i7][this._idProp]);
          }
        } else {
          // create unordered list
          for (var _i8 = 0, _len9 = itemIds.length; _i8 < _len9; _i8++) {
            var _id5 = itemIds[_i8];

            var _item3 = data.get(_id5);

            if (_item3 != null) {
              ids.push(_item3[this._idProp]);
            }
          }
        }
      }

      return ids;
    }
    /** @inheritDoc */

  }, {
    key: "getDataSet",
    value: function getDataSet() {
      return this;
    }
    /** @inheritDoc */

  }, {
    key: "forEach",
    value: function forEach(callback, options) {
      var filter$1 = options && filter(options);

      var data = this._data;

      var itemIds = _toConsumableArray(keys(data).call(data));

      if (options && options.order) {
        // execute forEach on ordered list
        var items = this.get(options);

        for (var i = 0, len = items.length; i < len; i++) {
          var item = items[i];
          var id = item[this._idProp];
          callback(item, id);
        }
      } else {
        // unordered
        for (var _i9 = 0, _len10 = itemIds.length; _i9 < _len10; _i9++) {
          var _id6 = itemIds[_i9];

          var _item4 = this._data.get(_id6);

          if (_item4 != null && (!filter$1 || filter$1(_item4))) {
            callback(_item4, _id6);
          }
        }
      }
    }
    /** @inheritDoc */

  }, {
    key: "map",
    value: function map(callback, options) {
      var filter$1 = options && filter(options);

      var mappedItems = [];
      var data = this._data;

      var itemIds = _toConsumableArray(keys(data).call(data)); // convert and filter items


      for (var i = 0, len = itemIds.length; i < len; i++) {
        var id = itemIds[i];

        var item = this._data.get(id);

        if (item != null && (!filter$1 || filter$1(item))) {
          mappedItems.push(callback(item, id));
        }
      } // order items


      if (options && options.order) {
        this._sort(mappedItems, options.order);
      }

      return mappedItems;
    }
    /**
     * Filter the fields of an item.
     *
     * @param item - The item whose fields should be filtered.
     * @param fields - The names of the fields that will be kept.
     * @typeParam K - Field name type.
     * @returns The item without any additional fields.
     */

  }, {
    key: "_filterFields",
    value: function _filterFields(item, fields) {
      var _context21;

      if (!item) {
        // item is null
        return item;
      }

      return reduce(_context21 = isArray$2(fields) ? // Use the supplied array
      fields : // Use the keys of the supplied object
      keys$4(fields)).call(_context21, function (filteredItem, field) {
        filteredItem[field] = item[field];
        return filteredItem;
      }, {});
    }
    /**
     * Sort the provided array with items.
     *
     * @param items - Items to be sorted in place.
     * @param order - A field name or custom sort function.
     * @typeParam T - The type of the items in the items array.
     */

  }, {
    key: "_sort",
    value: function _sort(items, order) {
      if (typeof order === "string") {
        // order by provided field name
        var name = order; // field name

        sort(items).call(items, function (a, b) {
          // @TODO: How to treat missing properties?
          var av = a[name];
          var bv = b[name];
          return av > bv ? 1 : av < bv ? -1 : 0;
        });
      } else if (typeof order === "function") {
        // order by sort function
        sort(items).call(items, order);
      } else {
        // TODO: extend order by an Object {field:string, direction:string}
        //       where direction can be 'asc' or 'desc'
        throw new TypeError("Order must be a function or a string");
      }
    }
    /**
     * Remove an item or multiple items by “reference” (only the id is used) or by id.
     *
     * The method ignores removal of non-existing items, and returns an array containing the ids of the items which are actually removed from the DataSet.
     *
     * After the items are removed, the DataSet will trigger an event `remove` for the removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' }
     * ])
     *
     * // remove items
     * const ids = data.remove([2, { id: 3 }, 4])
     *
     * console.log(ids) // [2, 3]
     * ```
     *
     * @param id - One or more items or ids of items to be removed.
     * @param senderId - Sender id.
     * @returns The ids of the removed items.
     */

  }, {
    key: "remove",
    value: function remove(id, senderId) {
      var removedIds = [];
      var removedItems = []; // force everything to be an array for simplicity

      var ids = isArray$2(id) ? id : [id];

      for (var i = 0, len = ids.length; i < len; i++) {
        var item = this._remove(ids[i]);

        if (item) {
          var itemId = item[this._idProp];

          if (itemId != null) {
            removedIds.push(itemId);
            removedItems.push(item);
          }
        }
      }

      if (removedIds.length) {
        this._trigger("remove", {
          items: removedIds,
          oldData: removedItems
        }, senderId);
      }

      return removedIds;
    }
    /**
     * Remove an item by its id or reference.
     *
     * @param id - Id of an item or the item itself.
     * @returns The removed item if removed, null otherwise.
     */

  }, {
    key: "_remove",
    value: function _remove(id) {
      // @TODO: It origianlly returned the item although the docs say id.
      // The code expects the item, so probably an error in the docs.
      var ident; // confirm the id to use based on the args type

      if (isId(id)) {
        ident = id;
      } else if (id && _typeof(id) === "object") {
        ident = id[this._idProp]; // look for the identifier field using ._idProp
      } // do the removing if the item is found


      if (ident != null && this._data.has(ident)) {
        var item = this._data.get(ident) || null;

        this._data.delete(ident);

        --this.length;
        return item;
      }

      return null;
    }
    /**
     * Clear the entire data set.
     *
     * After the items are removed, the [[DataSet]] will trigger an event `remove` for all removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * @param senderId - Sender id.
     * @returns removedIds - The ids of all removed items.
     */

  }, {
    key: "clear",
    value: function clear(senderId) {
      var _context22;

      var ids = _toConsumableArray(keys(_context22 = this._data).call(_context22));

      var items = [];

      for (var i = 0, len = ids.length; i < len; i++) {
        items.push(this._data.get(ids[i]));
      }

      this._data.clear();

      this.length = 0;

      this._trigger("remove", {
        items: ids,
        oldData: items
      }, senderId);

      return ids;
    }
    /**
     * Find the item with maximum value of a specified field.
     *
     * @param field - Name of the property that should be searched for max value.
     * @returns Item containing max value, or null if no items.
     */

  }, {
    key: "max",
    value: function max(field) {
      var _context23;

      var max = null;
      var maxField = null;

      var _iterator11 = _createForOfIteratorHelper$7(values(_context23 = this._data).call(_context23)),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var item = _step11.value;
          var itemField = item[field];

          if (typeof itemField === "number" && (maxField == null || itemField > maxField)) {
            max = item;
            maxField = itemField;
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }

      return max || null;
    }
    /**
     * Find the item with minimum value of a specified field.
     *
     * @param field - Name of the property that should be searched for min value.
     * @returns Item containing min value, or null if no items.
     */

  }, {
    key: "min",
    value: function min(field) {
      var _context24;

      var min = null;
      var minField = null;

      var _iterator12 = _createForOfIteratorHelper$7(values(_context24 = this._data).call(_context24)),
          _step12;

      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var item = _step12.value;
          var itemField = item[field];

          if (typeof itemField === "number" && (minField == null || itemField < minField)) {
            min = item;
            minField = itemField;
          }
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }

      return min || null;
    }
    /**
     * Find all distinct values of a specified field
     *
     * @param prop - The property name whose distinct values should be returned.
     * @returns Unordered array containing all distinct values. Items without specified property are ignored.
     */

  }, {
    key: "distinct",
    value: function distinct(prop) {
      var data = this._data;

      var itemIds = _toConsumableArray(keys(data).call(data));

      var values = [];
      var count = 0;

      for (var i = 0, len = itemIds.length; i < len; i++) {
        var id = itemIds[i];
        var item = data.get(id);
        var _value3 = item[prop];
        var exists = false;

        for (var j = 0; j < count; j++) {
          if (values[j] == _value3) {
            exists = true;
            break;
          }
        }

        if (!exists && _value3 !== undefined) {
          values[count] = _value3;
          count++;
        }
      }

      return values;
    }
    /**
     * Add a single item. Will fail when an item with the same id already exists.
     *
     * @param item - A new item to be added.
     * @returns Added item's id. An id is generated when it is not present in the item.
     */

  }, {
    key: "_addItem",
    value: function _addItem(item) {
      var fullItem = ensureFullItem(item, this._idProp);
      var id = fullItem[this._idProp]; // check whether this id is already taken

      if (this._data.has(id)) {
        // item already exists
        throw new Error("Cannot add item: item with id " + id + " already exists");
      }

      this._data.set(id, fullItem);

      ++this.length;
      return id;
    }
    /**
     * Update a single item: merge with existing item.
     * Will fail when the item has no id, or when there does not exist an item with the same id.
     *
     * @param update - The new item
     * @returns The id of the updated item.
     */

  }, {
    key: "_updateItem",
    value: function _updateItem(update) {
      var id = update[this._idProp];

      if (id == null) {
        throw new Error("Cannot update item: item has no id (item: " + stringify$1(update) + ")");
      }

      var item = this._data.get(id);

      if (!item) {
        // item doesn't exist
        throw new Error("Cannot update item: no item with id " + id + " found");
      }

      this._data.set(id, _objectSpread$4(_objectSpread$4({}, item), update));

      return id;
    }
    /** @inheritDoc */

  }, {
    key: "stream",
    value: function stream(ids) {
      if (ids) {
        var data = this._data;
        return new DataStream(_defineProperty({}, iterator, /*#__PURE__*/regenerator.mark(function _callee3() {
          var _iterator13, _step13, id, item;

          return regenerator.wrap(function _callee3$(_context25) {
            while (1) {
              switch (_context25.prev = _context25.next) {
                case 0:
                  _iterator13 = _createForOfIteratorHelper$7(ids);
                  _context25.prev = 1;

                  _iterator13.s();

                case 3:
                  if ((_step13 = _iterator13.n()).done) {
                    _context25.next = 11;
                    break;
                  }

                  id = _step13.value;
                  item = data.get(id);

                  if (!(item != null)) {
                    _context25.next = 9;
                    break;
                  }

                  _context25.next = 9;
                  return [id, item];

                case 9:
                  _context25.next = 3;
                  break;

                case 11:
                  _context25.next = 16;
                  break;

                case 13:
                  _context25.prev = 13;
                  _context25.t0 = _context25["catch"](1);

                  _iterator13.e(_context25.t0);

                case 16:
                  _context25.prev = 16;

                  _iterator13.f();

                  return _context25.finish(16);

                case 19:
                case "end":
                  return _context25.stop();
              }
            }
          }, _callee3, null, [[1, 13, 16, 19]]);
        })));
      } else {
        var _context26;

        return new DataStream(_defineProperty({}, iterator, bind$6(_context26 = entries(this._data)).call(_context26, this._data)));
      }
    }
  }]);

  return DataSet;
}(DataSetPart);
/**
 * DataView
 *
 * A DataView offers a filtered and/or formatted view on a DataSet. One can subscribe to changes in a DataView, and easily get filtered or formatted data without having to specify filters and field types all the time.
 *
 * ## Example
 * ```javascript
 * // create a DataSet
 * var data = new vis.DataSet();
 * data.add([
 *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
 *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
 *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
 *   {id: 4, text: 'item 4'}
 * ]);
 *
 * // create a DataView
 * // the view will only contain items having a property group with value 1,
 * // and will only output fields id, text, and date.
 * var view = new vis.DataView(data, {
 *   filter: function (item) {
 *     return (item.group == 1);
 *   },
 *   fields: ['id', 'text', 'date']
 * });
 *
 * // subscribe to any change in the DataView
 * view.on('*', function (event, properties, senderId) {
 *   console.log('event', event, properties);
 * });
 *
 * // update an item in the data set
 * data.update({id: 2, group: 1});
 *
 * // get all ids in the view
 * var ids = view.getIds();
 * console.log('ids', ids); // will output [1, 2]
 *
 * // get all items in the view
 * var items = view.get();
 * ```
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */


var DataView = /*#__PURE__*/function (_DataSetPart2) {
  _inherits(DataView, _DataSetPart2);

  var _super2 = _createSuper$t(DataView);

  /**
   * Create a DataView.
   *
   * @param data - The instance containing data (directly or indirectly).
   * @param options - Options to configure this data view.
   */
  function DataView(data, options) {
    var _context27;

    var _this7;

    _classCallCheck(this, DataView);

    _this7 = _super2.call(this);

    _defineProperty(_assertThisInitialized(_this7), "length", 0);

    _defineProperty(_assertThisInitialized(_this7), "_listener", void 0);

    _defineProperty(_assertThisInitialized(_this7), "_data", void 0);

    _defineProperty(_assertThisInitialized(_this7), "_ids", new set());

    _defineProperty(_assertThisInitialized(_this7), "_options", void 0);

    _this7._options = options || {};
    _this7._listener = bind$6(_context27 = _this7._onEvent).call(_context27, _assertThisInitialized(_this7));

    _this7.setData(data);

    return _this7;
  } // TODO: implement a function .config() to dynamically update things like configured filter
  // and trigger changes accordingly

  /**
   * Set a data source for the view.
   *
   * @param data - The instance containing data (directly or indirectly).
   * @remarks
   * Note that when the data view is bound to a data set it won't be garbage
   * collected unless the data set is too. Use `dataView.setData(null)` or
   * `dataView.dispose()` to enable garbage collection before you lose the last
   * reference.
   */


  _createClass(DataView, [{
    key: "idProp",
    get:
    /** @inheritDoc */

    /** @inheritDoc */
    function get() {
      return this.getDataSet().idProp;
    }
  }, {
    key: "setData",
    value: function setData(data) {
      if (this._data) {
        // unsubscribe from current dataset
        if (this._data.off) {
          this._data.off("*", this._listener);
        } // trigger a remove of all items in memory


        var ids = this._data.getIds({
          filter: filter(this._options)
        });

        var items = this._data.get(ids);

        this._ids.clear();

        this.length = 0;

        this._trigger("remove", {
          items: ids,
          oldData: items
        });
      }

      if (data != null) {
        this._data = data; // trigger an add of all added items

        var _ids = this._data.getIds({
          filter: filter(this._options)
        });

        for (var i = 0, len = _ids.length; i < len; i++) {
          var id = _ids[i];

          this._ids.add(id);
        }

        this.length = _ids.length;

        this._trigger("add", {
          items: _ids
        });
      } else {
        this._data = new DataSet();
      } // subscribe to new dataset


      if (this._data.on) {
        this._data.on("*", this._listener);
      }
    }
    /**
     * Refresh the DataView.
     * Useful when the DataView has a filter function containing a variable parameter.
     */

  }, {
    key: "refresh",
    value: function refresh() {
      var ids = this._data.getIds({
        filter: filter(this._options)
      });

      var oldIds = _toConsumableArray(this._ids);

      var newIds = {};
      var addedIds = [];
      var removedIds = [];
      var removedItems = []; // check for additions

      for (var i = 0, len = ids.length; i < len; i++) {
        var id = ids[i];
        newIds[id] = true;

        if (!this._ids.has(id)) {
          addedIds.push(id);

          this._ids.add(id);
        }
      } // check for removals


      for (var _i10 = 0, _len11 = oldIds.length; _i10 < _len11; _i10++) {
        var _id7 = oldIds[_i10];

        var item = this._data.get(_id7);

        if (item == null) {
          // @TODO: Investigate.
          // Doesn't happen during tests or examples.
          // Is it really impossible or could it eventually happen?
          // How to handle it if it does? The types guarantee non-nullable items.
          console.error("If you see this, report it please.");
        } else if (!newIds[_id7]) {
          removedIds.push(_id7);
          removedItems.push(item);

          this._ids.delete(_id7);
        }
      }

      this.length += addedIds.length - removedIds.length; // trigger events

      if (addedIds.length) {
        this._trigger("add", {
          items: addedIds
        });
      }

      if (removedIds.length) {
        this._trigger("remove", {
          items: removedIds,
          oldData: removedItems
        });
      }
    }
    /** @inheritDoc */

  }, {
    key: "get",
    value: function get(first, second) {
      if (this._data == null) {
        return null;
      } // parse the arguments


      var ids = null;
      var options;

      if (isId(first) || isArray$2(first)) {
        ids = first;
        options = second;
      } else {
        options = first;
      } // extend the options with the default options and provided options


      var viewOptions = assign$2({}, this._options, options); // create a combined filter method when needed


      var thisFilter = filter(this._options);

      var optionsFilter = options && filter(options);

      if (thisFilter && optionsFilter) {
        viewOptions.filter = function (item) {
          return thisFilter(item) && optionsFilter(item);
        };
      }

      if (ids == null) {
        return this._data.get(viewOptions);
      } else {
        return this._data.get(ids, viewOptions);
      }
    }
    /** @inheritDoc */

  }, {
    key: "getIds",
    value: function getIds(options) {
      if (this._data.length) {
        var defaultFilter = filter(this._options);

        var optionsFilter = options != null ? filter(options) : null;
        var filter$1;

        if (optionsFilter) {
          if (defaultFilter) {
            filter$1 = function filter(item) {
              return defaultFilter(item) && optionsFilter(item);
            };
          } else {
            filter$1 = optionsFilter;
          }
        } else {
          filter$1 = defaultFilter;
        }

        return this._data.getIds({
          filter: filter$1,
          order: options && options.order
        });
      } else {
        return [];
      }
    }
    /** @inheritDoc */

  }, {
    key: "forEach",
    value: function forEach(callback, options) {
      if (this._data) {
        var _context28;

        var defaultFilter = filter(this._options);

        var optionsFilter = options && filter(options);

        var filter$1;

        if (optionsFilter) {
          if (defaultFilter) {
            filter$1 = function filter(item) {
              return defaultFilter(item) && optionsFilter(item);
            };
          } else {
            filter$1 = optionsFilter;
          }
        } else {
          filter$1 = defaultFilter;
        }

        forEach$2(_context28 = this._data).call(_context28, callback, {
          filter: filter$1,
          order: options && options.order
        });
      }
    }
    /** @inheritDoc */

  }, {
    key: "map",
    value: function map(callback, options) {
      if (this._data) {
        var _context29;

        var defaultFilter = filter(this._options);

        var optionsFilter = options && filter(options);

        var filter$1;

        if (optionsFilter) {
          if (defaultFilter) {
            filter$1 = function filter(item) {
              return defaultFilter(item) && optionsFilter(item);
            };
          } else {
            filter$1 = optionsFilter;
          }
        } else {
          filter$1 = defaultFilter;
        }

        return map$3(_context29 = this._data).call(_context29, callback, {
          filter: filter$1,
          order: options && options.order
        });
      } else {
        return [];
      }
    }
    /** @inheritDoc */

  }, {
    key: "getDataSet",
    value: function getDataSet() {
      return this._data.getDataSet();
    }
    /** @inheritDoc */

  }, {
    key: "stream",
    value: function stream(ids) {
      var _context30;

      return this._data.stream(ids || _defineProperty({}, iterator, bind$6(_context30 = keys(this._ids)).call(_context30, this._ids)));
    }
    /**
     * Render the instance unusable prior to garbage collection.
     *
     * @remarks
     * The intention of this method is to help discover scenarios where the data
     * view is being used when the programmer thinks it has been garbage collected
     * already. It's stricter version of `dataView.setData(null)`.
     */

  }, {
    key: "dispose",
    value: function dispose() {
      var _this$_data;

      if ((_this$_data = this._data) !== null && _this$_data !== void 0 && _this$_data.off) {
        this._data.off("*", this._listener);
      }

      var message = "This data view has already been disposed of.";
      var replacement = {
        get: function get() {
          throw new Error(message);
        },
        set: function set() {
          throw new Error(message);
        },
        configurable: false
      };

      var _iterator14 = _createForOfIteratorHelper$7(ownKeys$5(DataView.prototype)),
          _step14;

      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var key = _step14.value;

          defineProperty$6(this, key, replacement);
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
    }
    /**
     * Event listener. Will propagate all events from the connected data set to the subscribers of the DataView, but will filter the items and only trigger when there are changes in the filtered data set.
     *
     * @param event - The name of the event.
     * @param params - Parameters of the event.
     * @param senderId - Id supplied by the sender.
     */

  }, {
    key: "_onEvent",
    value: function _onEvent(event, params, senderId) {
      if (!params || !params.items || !this._data) {
        return;
      }

      var ids = params.items;
      var addedIds = [];
      var updatedIds = [];
      var removedIds = [];
      var oldItems = [];
      var updatedItems = [];
      var removedItems = [];

      switch (event) {
        case "add":
          // filter the ids of the added items
          for (var i = 0, len = ids.length; i < len; i++) {
            var id = ids[i];
            var item = this.get(id);

            if (item) {
              this._ids.add(id);

              addedIds.push(id);
            }
          }

          break;

        case "update":
          // determine the event from the views viewpoint: an updated
          // item can be added, updated, or removed from this view.
          for (var _i11 = 0, _len12 = ids.length; _i11 < _len12; _i11++) {
            var _id8 = ids[_i11];

            var _item5 = this.get(_id8);

            if (_item5) {
              if (this._ids.has(_id8)) {
                updatedIds.push(_id8);
                updatedItems.push(params.data[_i11]);
                oldItems.push(params.oldData[_i11]);
              } else {
                this._ids.add(_id8);

                addedIds.push(_id8);
              }
            } else {
              if (this._ids.has(_id8)) {
                this._ids.delete(_id8);

                removedIds.push(_id8);
                removedItems.push(params.oldData[_i11]);
              }
            }
          }

          break;

        case "remove":
          // filter the ids of the removed items
          for (var _i12 = 0, _len13 = ids.length; _i12 < _len13; _i12++) {
            var _id9 = ids[_i12];

            if (this._ids.has(_id9)) {
              this._ids.delete(_id9);

              removedIds.push(_id9);
              removedItems.push(params.oldData[_i12]);
            }
          }

          break;
      }

      this.length += addedIds.length - removedIds.length;

      if (addedIds.length) {
        this._trigger("add", {
          items: addedIds
        }, senderId);
      }

      if (updatedIds.length) {
        this._trigger("update", {
          items: updatedIds,
          oldData: oldItems,
          data: updatedItems
        }, senderId);
      }

      if (removedIds.length) {
        this._trigger("remove", {
          items: removedIds,
          oldData: removedItems
        }, senderId);
      }
    }
  }]);

  return DataView;
}(DataSetPart);
/**
 * Check that given value is compatible with Vis Data Set interface.
 *
 * @param idProp - The expected property to contain item id.
 * @param v - The value to be tested.
 * @returns True if all expected values and methods match, false otherwise.
 */


function isDataSetLike(idProp, v) {
  return _typeof(v) === "object" && v !== null && idProp === v.idProp && typeof v.add === "function" && typeof v.clear === "function" && typeof v.distinct === "function" && typeof forEach$2(v) === "function" && typeof v.get === "function" && typeof v.getDataSet === "function" && typeof v.getIds === "function" && typeof v.length === "number" && typeof map$3(v) === "function" && typeof v.max === "function" && typeof v.min === "function" && typeof v.off === "function" && typeof v.on === "function" && typeof v.remove === "function" && typeof v.setOptions === "function" && typeof v.stream === "function" && typeof v.update === "function" && typeof v.updateOnly === "function";
}
/**
 * Check that given value is compatible with Vis Data View interface.
 *
 * @param idProp - The expected property to contain item id.
 * @param v - The value to be tested.
 * @returns True if all expected values and methods match, false otherwise.
 */


function isDataViewLike(idProp, v) {
  return _typeof(v) === "object" && v !== null && idProp === v.idProp && typeof forEach$2(v) === "function" && typeof v.get === "function" && typeof v.getDataSet === "function" && typeof v.getIds === "function" && typeof v.length === "number" && typeof map$3(v) === "function" && typeof v.off === "function" && typeof v.on === "function" && typeof v.stream === "function" && isDataSetLike(idProp, v.getDataSet());
}

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DELETE: DELETE,
	DataSet: DataSet,
	DataStream: DataStream,
	DataView: DataView,
	Queue: Queue,
	createNewDataPipeFrom: createNewDataPipeFrom,
	isDataSetLike: isDataSetLike,
	isDataViewLike: isDataViewLike
});

var global$2 = global$P;
var fails$1 = fails$t;
var uncurryThis$2 = functionUncurryThis;
var toString = toString$8;
var trim = stringTrim.trim;
var whitespaces = whitespaces$4;
var charAt = uncurryThis$2(''.charAt);
var n$ParseFloat = global$2.parseFloat;
var Symbol$1 = global$2.Symbol;
var ITERATOR = Symbol$1 && Symbol$1.iterator;
var FORCED = 1 / n$ParseFloat(whitespaces + '-0') !== -Infinity // MS Edge 18- broken with boxed symbols
|| ITERATOR && !fails$1(function () {
  n$ParseFloat(Object(ITERATOR));
}); // `parseFloat` method
// https://tc39.es/ecma262/#sec-parsefloat-string

var numberParseFloat = FORCED ? function parseFloat(string) {
  var trimmedString = trim(toString(string));
  var result = n$ParseFloat(trimmedString);
  return result === 0 && charAt(trimmedString, 0) == '-' ? -0 : result;
} : n$ParseFloat;

var $$4 = _export;
var $parseFloat = numberParseFloat; // `parseFloat` method
// https://tc39.es/ecma262/#sec-parsefloat-string

$$4({
  global: true,
  forced: parseFloat != $parseFloat
}, {
  parseFloat: $parseFloat
});

var path$5 = path$y;
var _parseFloat$2 = path$5.parseFloat;

var parent$9 = _parseFloat$2;
var _parseFloat$1 = parent$9;

var _parseFloat = _parseFloat$1;

var $$3 = _export;
var fails = fails$t;
var getOwnPropertyNames$3 = objectGetOwnPropertyNamesExternal.f; // eslint-disable-next-line es/no-object-getownpropertynames -- required for testing

var FAILS_ON_PRIMITIVES = fails(function () {
  return !Object.getOwnPropertyNames(1);
}); // `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames

$$3({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES
}, {
  getOwnPropertyNames: getOwnPropertyNames$3
});

var path$4 = path$y;
var Object$1 = path$4.Object;

var getOwnPropertyNames$2 = function getOwnPropertyNames(it) {
  return Object$1.getOwnPropertyNames(it);
};

var parent$8 = getOwnPropertyNames$2;
var getOwnPropertyNames$1 = parent$8;

var getOwnPropertyNames = getOwnPropertyNames$1;

/**
 * Helper functions for components
 */

/**
 * Determine values to use for (sub)options of 'chosen'.
 *
 * This option is either a boolean or an object whose values should be examined further.
 * The relevant structures are:
 *
 * - chosen: <boolean value>
 * - chosen: { subOption: <boolean or function> }
 *
 * Where subOption is 'node', 'edge' or 'label'.
 *
 * The intention of this method appears to be to set a specific priority to the options;
 * Since most properties are either bridged or merged into the local options objects, there
 * is not much point in handling them separately.
 * TODO: examine if 'most' in previous sentence can be replaced with 'all'. In that case, we
 *       should be able to get rid of this method.
 *
 * @param {string}  subOption  option within object 'chosen' to consider; either 'node', 'edge' or 'label'
 * @param {object}  pile       array of options objects to consider
 * @returns {boolean | Function}  value for passed subOption of 'chosen' to use
 */

function choosify(subOption, pile) {
  // allowed values for subOption
  var allowed = ["node", "edge", "label"];
  var value = true;
  var chosen = topMost(pile, "chosen");

  if (typeof chosen === "boolean") {
    value = chosen;
  } else if (_typeof(chosen) === "object") {
    if (indexOf(allowed).call(allowed, subOption) === -1) {
      throw new Error("choosify: subOption '" + subOption + "' should be one of " + "'" + allowed.join("', '") + "'");
    }

    var chosenEdge = topMost(pile, ["chosen", subOption]);

    if (typeof chosenEdge === "boolean" || typeof chosenEdge === "function") {
      value = chosenEdge;
    }
  }

  return value;
}
/**
 * Check if the point falls within the given rectangle.
 *
 * @param {rect} rect
 * @param {point} point
 * @param {rotationPoint} [rotationPoint] if specified, the rotation that applies to the rectangle.
 * @returns {boolean}  true if point within rectangle, false otherwise
 */

function pointInRect(rect, point, rotationPoint) {
  if (rect.width <= 0 || rect.height <= 0) {
    return false; // early out
  }

  if (rotationPoint !== undefined) {
    // Rotate the point the same amount as the rectangle
    var tmp = {
      x: point.x - rotationPoint.x,
      y: point.y - rotationPoint.y
    };

    if (rotationPoint.angle !== 0) {
      // In order to get the coordinates the same, you need to
      // rotate in the reverse direction
      var angle = -rotationPoint.angle;
      var tmp2 = {
        x: Math.cos(angle) * tmp.x - Math.sin(angle) * tmp.y,
        y: Math.sin(angle) * tmp.x + Math.cos(angle) * tmp.y
      };
      point = tmp2;
    } else {
      point = tmp;
    } // Note that if a rotation is specified, the rectangle coordinates
    // are **not* the full canvas coordinates. They are relative to the
    // rotationPoint. Hence, the point coordinates need not be translated
    // back in this case.

  }

  var right = rect.x + rect.width;
  var bottom = rect.y + rect.width;
  return rect.left < point.x && right > point.x && rect.top < point.y && bottom > point.y;
}
/**
 * Check if given value is acceptable as a label text.
 *
 * @param {*} text value to check; can be anything at this point
 * @returns {boolean} true if valid label value, false otherwise
 */

function isValidLabel(text) {
  // Note that this is quite strict: types that *might* be converted to string are disallowed
  return typeof text === "string" && text !== "";
}
/**
 * Returns x, y of self reference circle based on provided angle
 *
 * @param {object} ctx
 * @param {number} angle
 * @param {number} radius
 * @param {VisNode} node
 * @returns {object} x and y coordinates
 */

function getSelfRefCoordinates(ctx, angle, radius, node) {
  var x = node.x;
  var y = node.y;

  if (typeof node.distanceToBorder === "function") {
    //calculating opposite and adjacent
    //distaneToBorder becomes Hypotenuse.
    //Formulas sin(a) = Opposite / Hypotenuse and cos(a) = Adjacent / Hypotenuse
    var toBorderDist = node.distanceToBorder(ctx, angle);
    var yFromNodeCenter = Math.sin(angle) * toBorderDist;
    var xFromNodeCenter = Math.cos(angle) * toBorderDist; //xFromNodeCenter is basically x and if xFromNodeCenter equals to the distance to border then it means
    //that y does not need calculation because it is equal node.height / 2 or node.y
    //same thing with yFromNodeCenter and if yFromNodeCenter equals to the distance to border then it means
    //that x is equal node.width / 2 or node.x

    if (xFromNodeCenter === toBorderDist) {
      x += toBorderDist;
      y = node.y;
    } else if (yFromNodeCenter === toBorderDist) {
      x = node.x;
      y -= toBorderDist;
    } else {
      x += xFromNodeCenter;
      y -= yFromNodeCenter;
    }
  } else if (node.shape.width > node.shape.height) {
    x = node.x + node.shape.width * 0.5;
    y = node.y - radius;
  } else {
    x = node.x + radius;
    y = node.y - node.shape.height * 0.5;
  }

  return {
    x: x,
    y: y
  };
}

/**
 * Callback to determine text dimensions, using the parent label settings.
 *
 * @callback MeasureText
 * @param {text} text
 * @param {text} mod
 * @returns {object} { width, values} width in pixels and font attributes
 */

/**
 * Helper class for Label which collects results of splitting labels into lines and blocks.
 *
 * @private
 */
var LabelAccumulator = /*#__PURE__*/function () {
  /**
   * @param {MeasureText} measureText
   */
  function LabelAccumulator(measureText) {
    _classCallCheck(this, LabelAccumulator);

    this.measureText = measureText;
    this.current = 0;
    this.width = 0;
    this.height = 0;
    this.lines = [];
  }
  /**
   * Append given text to the given line.
   *
   * @param {number}  l    index of line to add to
   * @param {string}  text string to append to line
   * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
   * @private
   */


  _createClass(LabelAccumulator, [{
    key: "_add",
    value: function _add(l, text) {
      var mod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "normal";

      if (this.lines[l] === undefined) {
        this.lines[l] = {
          width: 0,
          height: 0,
          blocks: []
        };
      } // We still need to set a block for undefined and empty texts, hence return at this point
      // This is necessary because we don't know at this point if we're at the
      // start of an empty line or not.
      // To compensate, empty blocks are removed in `finalize()`.
      //
      // Empty strings should still have a height


      var tmpText = text;
      if (text === undefined || text === "") tmpText = " "; // Determine width and get the font properties

      var result = this.measureText(tmpText, mod);

      var block = assign$2({}, values(result));

      block.text = text;
      block.width = result.width;
      block.mod = mod;

      if (text === undefined || text === "") {
        block.width = 0;
      }

      this.lines[l].blocks.push(block); // Update the line width. We need this for determining if a string goes over max width

      this.lines[l].width += block.width;
    }
    /**
     * Returns the width in pixels of the current line.
     *
     * @returns {number}
     */

  }, {
    key: "curWidth",
    value: function curWidth() {
      var line = this.lines[this.current];
      if (line === undefined) return 0;
      return line.width;
    }
    /**
     * Add text in block to current line
     *
     * @param {string} text
     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
     */

  }, {
    key: "append",
    value: function append(text) {
      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "normal";

      this._add(this.current, text, mod);
    }
    /**
     * Add text in block to current line and start a new line
     *
     * @param {string} text
     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
     */

  }, {
    key: "newLine",
    value: function newLine(text) {
      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "normal";

      this._add(this.current, text, mod);

      this.current++;
    }
    /**
     * Determine and set the heights of all the lines currently contained in this instance
     *
     * Note that width has already been set.
     *
     * @private
     */

  }, {
    key: "determineLineHeights",
    value: function determineLineHeights() {
      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k]; // Looking for max height of blocks in line

        var height = 0;

        if (line.blocks !== undefined) {
          // Can happen if text contains e.g. '\n '
          for (var l = 0; l < line.blocks.length; l++) {
            var block = line.blocks[l];

            if (height < block.height) {
              height = block.height;
            }
          }
        }

        line.height = height;
      }
    }
    /**
     * Determine the full size of the label text, as determined by current lines and blocks
     *
     * @private
     */

  }, {
    key: "determineLabelSize",
    value: function determineLabelSize() {
      var width = 0;
      var height = 0;

      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k];

        if (line.width > width) {
          width = line.width;
        }

        height += line.height;
      }

      this.width = width;
      this.height = height;
    }
    /**
     * Remove all empty blocks and empty lines we don't need
     *
     * This must be done after the width/height determination,
     * so that these are set properly for processing here.
     *
     * @returns {Array<Line>} Lines with empty blocks (and some empty lines) removed
     * @private
     */

  }, {
    key: "removeEmptyBlocks",
    value: function removeEmptyBlocks() {
      var tmpLines = [];

      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k]; // Note: an empty line in between text has width zero but is still relevant to layout.
        // So we can't use width for testing empty line here

        if (line.blocks.length === 0) continue; // Discard final empty line always

        if (k === this.lines.length - 1) {
          if (line.width === 0) continue;
        }

        var tmpLine = {};

        assign$2(tmpLine, line);

        tmpLine.blocks = [];
        var firstEmptyBlock = void 0;
        var tmpBlocks = [];

        for (var l = 0; l < line.blocks.length; l++) {
          var block = line.blocks[l];

          if (block.width !== 0) {
            tmpBlocks.push(block);
          } else {
            if (firstEmptyBlock === undefined) {
              firstEmptyBlock = block;
            }
          }
        } // Ensure that there is *some* text present


        if (tmpBlocks.length === 0 && firstEmptyBlock !== undefined) {
          tmpBlocks.push(firstEmptyBlock);
        }

        tmpLine.blocks = tmpBlocks;
        tmpLines.push(tmpLine);
      }

      return tmpLines;
    }
    /**
     * Set the sizes for all lines and the whole thing.
     *
     * @returns {{width: (number|*), height: (number|*), lines: Array}}
     */

  }, {
    key: "finalize",
    value: function finalize() {
      //console.log(JSON.stringify(this.lines, null, 2));
      this.determineLineHeights();
      this.determineLabelSize();
      var tmpLines = this.removeEmptyBlocks(); // Return a simple hash object for further processing.

      return {
        width: this.width,
        height: this.height,
        lines: tmpLines
      };
    }
  }]);

  return LabelAccumulator;
}();

var tagPattern = {
  // HTML
  "<b>": /<b>/,
  "<i>": /<i>/,
  "<code>": /<code>/,
  "</b>": /<\/b>/,
  "</i>": /<\/i>/,
  "</code>": /<\/code>/,
  // Markdown
  "*": /\*/,
  // bold
  _: /_/,
  // ital
  "`": /`/,
  // mono
  afterBold: /[^*]/,
  afterItal: /[^_]/,
  afterMono: /[^`]/
};
/**
 * Internal helper class for parsing the markup tags for HTML and Markdown.
 *
 * NOTE: Sequences of tabs and spaces are reduced to single space.
 *       Scan usage of `this.spacing` within method
 */

var MarkupAccumulator = /*#__PURE__*/function () {
  /**
   * Create an instance
   *
   * @param {string} text  text to parse for markup
   */
  function MarkupAccumulator(text) {
    _classCallCheck(this, MarkupAccumulator);

    this.text = text;
    this.bold = false;
    this.ital = false;
    this.mono = false;
    this.spacing = false;
    this.position = 0;
    this.buffer = "";
    this.modStack = [];
    this.blocks = [];
  }
  /**
   * Return the mod label currently on the top of the stack
   *
   * @returns {string}  label of topmost mod
   * @private
   */


  _createClass(MarkupAccumulator, [{
    key: "mod",
    value: function mod() {
      return this.modStack.length === 0 ? "normal" : this.modStack[0];
    }
    /**
     * Return the mod label currently active
     *
     * @returns {string}  label of active mod
     * @private
     */

  }, {
    key: "modName",
    value: function modName() {
      if (this.modStack.length === 0) return "normal";else if (this.modStack[0] === "mono") return "mono";else {
        if (this.bold && this.ital) {
          return "boldital";
        } else if (this.bold) {
          return "bold";
        } else if (this.ital) {
          return "ital";
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "emitBlock",
    value: function emitBlock() {
      if (this.spacing) {
        this.add(" ");
        this.spacing = false;
      }

      if (this.buffer.length > 0) {
        this.blocks.push({
          text: this.buffer,
          mod: this.modName()
        });
        this.buffer = "";
      }
    }
    /**
     * Output text to buffer
     *
     * @param {string} text  text to add
     * @private
     */

  }, {
    key: "add",
    value: function add(text) {
      if (text === " ") {
        this.spacing = true;
      }

      if (this.spacing) {
        this.buffer += " ";
        this.spacing = false;
      }

      if (text != " ") {
        this.buffer += text;
      }
    }
    /**
     * Handle parsing of whitespace
     *
     * @param {string} ch  the character to check
     * @returns {boolean} true if the character was processed as whitespace, false otherwise
     */

  }, {
    key: "parseWS",
    value: function parseWS(ch) {
      if (/[ \t]/.test(ch)) {
        if (!this.mono) {
          this.spacing = true;
        } else {
          this.add(ch);
        }

        return true;
      }

      return false;
    }
    /**
     * @param {string} tagName  label for block type to set
     * @private
     */

  }, {
    key: "setTag",
    value: function setTag(tagName) {
      this.emitBlock();
      this[tagName] = true;
      this.modStack.unshift(tagName);
    }
    /**
     * @param {string} tagName  label for block type to unset
     * @private
     */

  }, {
    key: "unsetTag",
    value: function unsetTag(tagName) {
      this.emitBlock();
      this[tagName] = false;
      this.modStack.shift();
    }
    /**
     * @param {string} tagName label for block type we are currently processing
     * @param {string|RegExp} tag string to match in text
     * @returns {boolean} true if the tag was processed, false otherwise
     */

  }, {
    key: "parseStartTag",
    value: function parseStartTag(tagName, tag) {
      // Note: if 'mono' passed as tagName, there is a double check here. This is OK
      if (!this.mono && !this[tagName] && this.match(tag)) {
        this.setTag(tagName);
        return true;
      }

      return false;
    }
    /**
     * @param {string|RegExp} tag
     * @param {number} [advance=true] if set, advance current position in text
     * @returns {boolean} true if match at given position, false otherwise
     * @private
     */

  }, {
    key: "match",
    value: function match(tag) {
      var advance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var _this$prepareRegExp = this.prepareRegExp(tag),
          _this$prepareRegExp2 = _slicedToArray(_this$prepareRegExp, 2),
          regExp = _this$prepareRegExp2[0],
          length = _this$prepareRegExp2[1];

      var matched = regExp.test(this.text.substr(this.position, length));

      if (matched && advance) {
        this.position += length - 1;
      }

      return matched;
    }
    /**
     * @param {string} tagName label for block type we are currently processing
     * @param {string|RegExp} tag string to match in text
     * @param {RegExp} [nextTag] regular expression to match for characters *following* the current tag
     * @returns {boolean} true if the tag was processed, false otherwise
     */

  }, {
    key: "parseEndTag",
    value: function parseEndTag(tagName, tag, nextTag) {
      var checkTag = this.mod() === tagName;

      if (tagName === "mono") {
        // special handling for 'mono'
        checkTag = checkTag && this.mono;
      } else {
        checkTag = checkTag && !this.mono;
      }

      if (checkTag && this.match(tag)) {
        if (nextTag !== undefined) {
          // Purpose of the following match is to prevent a direct unset/set of a given tag
          // E.g. '*bold **still bold*' => '*bold still bold*'
          if (this.position === this.text.length - 1 || this.match(nextTag, false)) {
            this.unsetTag(tagName);
          }
        } else {
          this.unsetTag(tagName);
        }

        return true;
      }

      return false;
    }
    /**
     * @param {string|RegExp} tag  string to match in text
     * @param {value} value  string to replace tag with, if found at current position
     * @returns {boolean} true if the tag was processed, false otherwise
     */

  }, {
    key: "replace",
    value: function replace(tag, value) {
      if (this.match(tag)) {
        this.add(value);
        this.position += length - 1;
        return true;
      }

      return false;
    }
    /**
     * Create a regular expression for the tag if it isn't already one.
     *
     * The return value is an array `[RegExp, number]`, with exactly two value, where:
     *  - RegExp is the regular expression to use
     *  - number is the lenth of the input string to match
     *
     * @param {string|RegExp} tag  string to match in text
     * @returns {Array}  regular expression to use and length of input string to match
     * @private
     */

  }, {
    key: "prepareRegExp",
    value: function prepareRegExp(tag) {
      var length;
      var regExp;

      if (tag instanceof RegExp) {
        regExp = tag;
        length = 1; // ASSUMPTION: regexp only tests one character
      } else {
        // use prepared regexp if present
        var prepared = tagPattern[tag];

        if (prepared !== undefined) {
          regExp = prepared;
        } else {
          regExp = new RegExp(tag);
        }

        length = tag.length;
      }

      return [regExp, length];
    }
  }]);

  return MarkupAccumulator;
}();
/**
 * Helper class for Label which explodes the label text into lines and blocks within lines
 *
 * @private
 */


var LabelSplitter = /*#__PURE__*/function () {
  /**
   * @param {CanvasRenderingContext2D} ctx Canvas rendering context
   * @param {Label} parent reference to the Label instance using current instance
   * @param {boolean} selected
   * @param {boolean} hover
   */
  function LabelSplitter(ctx, parent, selected, hover) {
    var _this = this;

    _classCallCheck(this, LabelSplitter);

    this.ctx = ctx;
    this.parent = parent;
    this.selected = selected;
    this.hover = hover;
    /**
     * Callback to determine text width; passed to LabelAccumulator instance
     *
     * @param  {string} text string to determine width of
     * @param  {string} mod  font type to use for this text
     * @returns {object} { width, values} width in pixels and font attributes
     */

    var textWidth = function textWidth(text, mod) {
      if (text === undefined) return 0; // TODO: This can be done more efficiently with caching
      // This will set the ctx.font correctly, depending on selected/hover and mod - so that ctx.measureText() will be accurate.

      var values = _this.parent.getFormattingValues(ctx, selected, hover, mod);

      var width = 0;

      if (text !== "") {
        var measure = _this.ctx.measureText(text);

        width = measure.width;
      }

      return {
        width: width,
        values: values
      };
    };

    this.lines = new LabelAccumulator(textWidth);
  }
  /**
   * Split passed text of a label into lines and blocks.
   *
   * # NOTE
   *
   * The handling of spacing is option dependent:
   *
   * - if `font.multi : false`, all spaces are retained
   * - if `font.multi : true`, every sequence of spaces is compressed to a single space
   *
   * This might not be the best way to do it, but this is as it has been working till now.
   * In order not to break existing functionality, for the time being this behaviour will
   * be retained in any code changes.
   *
   * @param {string} text  text to split
   * @returns {Array<line>}
   */


  _createClass(LabelSplitter, [{
    key: "process",
    value: function process(text) {
      if (!isValidLabel(text)) {
        return this.lines.finalize();
      }

      var font = this.parent.fontOptions; // Normalize the end-of-line's to a single representation - order important

      text = text.replace(/\r\n/g, "\n"); // Dos EOL's

      text = text.replace(/\r/g, "\n"); // Mac EOL's
      // Note that at this point, there can be no \r's in the text.
      // This is used later on splitStringIntoLines() to split multifont texts.

      var nlLines = String(text).split("\n");
      var lineCount = nlLines.length;

      if (font.multi) {
        // Multi-font case: styling tags active
        for (var i = 0; i < lineCount; i++) {
          var blocks = this.splitBlocks(nlLines[i], font.multi); // Post: Sequences of tabs and spaces are reduced to single space

          if (blocks === undefined) continue;

          if (blocks.length === 0) {
            this.lines.newLine("");
            continue;
          }

          if (font.maxWdt > 0) {
            // widthConstraint.maximum defined
            //console.log('Running widthConstraint multi, max: ' + this.fontOptions.maxWdt);
            for (var j = 0; j < blocks.length; j++) {
              var mod = blocks[j].mod;
              var _text = blocks[j].text;
              this.splitStringIntoLines(_text, mod, true);
            }
          } else {
            // widthConstraint.maximum NOT defined
            for (var _j = 0; _j < blocks.length; _j++) {
              var _mod = blocks[_j].mod;
              var _text2 = blocks[_j].text;
              this.lines.append(_text2, _mod);
            }
          }

          this.lines.newLine();
        }
      } else {
        // Single-font case
        if (font.maxWdt > 0) {
          // widthConstraint.maximum defined
          // console.log('Running widthConstraint normal, max: ' + this.fontOptions.maxWdt);
          for (var _i = 0; _i < lineCount; _i++) {
            this.splitStringIntoLines(nlLines[_i]);
          }
        } else {
          // widthConstraint.maximum NOT defined
          for (var _i2 = 0; _i2 < lineCount; _i2++) {
            this.lines.newLine(nlLines[_i2]);
          }
        }
      }

      return this.lines.finalize();
    }
    /**
     * normalize the markup system
     *
     * @param {boolean|'md'|'markdown'|'html'} markupSystem
     * @returns {string}
     */

  }, {
    key: "decodeMarkupSystem",
    value: function decodeMarkupSystem(markupSystem) {
      var system = "none";

      if (markupSystem === "markdown" || markupSystem === "md") {
        system = "markdown";
      } else if (markupSystem === true || markupSystem === "html") {
        system = "html";
      }

      return system;
    }
    /**
     *
     * @param {string} text
     * @returns {Array}
     */

  }, {
    key: "splitHtmlBlocks",
    value: function splitHtmlBlocks(text) {
      var s = new MarkupAccumulator(text);

      var parseEntities = function parseEntities(ch) {
        if (/&/.test(ch)) {
          var parsed = s.replace(s.text, "&lt;", "<") || s.replace(s.text, "&amp;", "&");

          if (!parsed) {
            s.add("&");
          }

          return true;
        }

        return false;
      };

      while (s.position < s.text.length) {
        var ch = s.text.charAt(s.position);
        var parsed = s.parseWS(ch) || /</.test(ch) && (s.parseStartTag("bold", "<b>") || s.parseStartTag("ital", "<i>") || s.parseStartTag("mono", "<code>") || s.parseEndTag("bold", "</b>") || s.parseEndTag("ital", "</i>") || s.parseEndTag("mono", "</code>")) || parseEntities(ch);

        if (!parsed) {
          s.add(ch);
        }

        s.position++;
      }

      s.emitBlock();
      return s.blocks;
    }
    /**
     *
     * @param {string} text
     * @returns {Array}
     */

  }, {
    key: "splitMarkdownBlocks",
    value: function splitMarkdownBlocks(text) {
      var _this2 = this;

      var s = new MarkupAccumulator(text);
      var beginable = true;

      var parseOverride = function parseOverride(ch) {
        if (/\\/.test(ch)) {
          if (s.position < _this2.text.length + 1) {
            s.position++;
            ch = _this2.text.charAt(s.position);

            if (/ \t/.test(ch)) {
              s.spacing = true;
            } else {
              s.add(ch);
              beginable = false;
            }
          }

          return true;
        }

        return false;
      };

      while (s.position < s.text.length) {
        var ch = s.text.charAt(s.position);
        var parsed = s.parseWS(ch) || parseOverride(ch) || (beginable || s.spacing) && (s.parseStartTag("bold", "*") || s.parseStartTag("ital", "_") || s.parseStartTag("mono", "`")) || s.parseEndTag("bold", "*", "afterBold") || s.parseEndTag("ital", "_", "afterItal") || s.parseEndTag("mono", "`", "afterMono");

        if (!parsed) {
          s.add(ch);
          beginable = false;
        }

        s.position++;
      }

      s.emitBlock();
      return s.blocks;
    }
    /**
     * Explodes a piece of text into single-font blocks using a given markup
     *
     * @param {string} text
     * @param {boolean|'md'|'markdown'|'html'} markupSystem
     * @returns {Array.<{text: string, mod: string}>}
     * @private
     */

  }, {
    key: "splitBlocks",
    value: function splitBlocks(text, markupSystem) {
      var system = this.decodeMarkupSystem(markupSystem);

      if (system === "none") {
        return [{
          text: text,
          mod: "normal"
        }];
      } else if (system === "markdown") {
        return this.splitMarkdownBlocks(text);
      } else if (system === "html") {
        return this.splitHtmlBlocks(text);
      }
    }
    /**
     * @param {string} text
     * @returns {boolean} true if text length over the current max with
     * @private
     */

  }, {
    key: "overMaxWidth",
    value: function overMaxWidth(text) {
      var width = this.ctx.measureText(text).width;
      return this.lines.curWidth() + width > this.parent.fontOptions.maxWdt;
    }
    /**
     * Determine the longest part of the sentence which still fits in the
     * current max width.
     *
     * @param {Array} words  Array of strings signifying a text lines
     * @returns {number}      index of first item in string making string go over max
     * @private
     */

  }, {
    key: "getLongestFit",
    value: function getLongestFit(words) {
      var text = "";
      var w = 0;

      while (w < words.length) {
        var pre = text === "" ? "" : " ";
        var newText = text + pre + words[w];
        if (this.overMaxWidth(newText)) break;
        text = newText;
        w++;
      }

      return w;
    }
    /**
     * Determine the longest part of the string which still fits in the
     * current max width.
     *
     * @param {Array} words Array of strings signifying a text lines
     * @returns {number} index of first item in string making string go over max
     */

  }, {
    key: "getLongestFitWord",
    value: function getLongestFitWord(words) {
      var w = 0;

      while (w < words.length) {
        if (this.overMaxWidth(slice(words).call(words, 0, w))) break;
        w++;
      }

      return w;
    }
    /**
     * Split the passed text into lines, according to width constraint (if any).
     *
     * The method assumes that the input string is a single line, i.e. without lines break.
     *
     * This method retains spaces, if still present (case `font.multi: false`).
     * A space which falls on an internal line break, will be replaced by a newline.
     * There is no special handling of tabs; these go along with the flow.
     *
     * @param {string} str
     * @param {string} [mod='normal']
     * @param {boolean} [appendLast=false]
     * @private
     */

  }, {
    key: "splitStringIntoLines",
    value: function splitStringIntoLines(str) {
      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "normal";
      var appendLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // Set the canvas context font, based upon the current selected/hover state
      // and the provided mod, so the text measurement performed by getLongestFit
      // will be accurate - and not just use the font of whoever last used the canvas.
      this.parent.getFormattingValues(this.ctx, this.selected, this.hover, mod); // Still-present spaces are relevant, retain them

      str = str.replace(/^( +)/g, "$1\r");
      str = str.replace(/([^\r][^ ]*)( +)/g, "$1\r$2\r");
      var words = str.split("\r");

      while (words.length > 0) {
        var w = this.getLongestFit(words);

        if (w === 0) {
          // Special case: the first word is already larger than the max width.
          var word = words[0]; // Break the word to the largest part that fits the line

          var x = this.getLongestFitWord(word);
          this.lines.newLine(slice(word).call(word, 0, x), mod); // Adjust the word, so that the rest will be done next iteration

          words[0] = slice(word).call(word, x);
        } else {
          // skip any space that is replaced by a newline
          var newW = w;

          if (words[w - 1] === " ") {
            w--;
          } else if (words[newW] === " ") {
            newW++;
          }

          var text = slice(words).call(words, 0, w).join("");

          if (w == words.length && appendLast) {
            this.lines.append(text, mod);
          } else {
            this.lines.newLine(text, mod);
          } // Adjust the word, so that the rest will be done next iteration


          words = slice(words).call(words, newW);
        }
      }
    }
  }]);

  return LabelSplitter;
}();

/**
 * List of special styles for multi-fonts
 *
 * @private
 */

var multiFontStyle = ["bold", "ital", "boldital", "mono"];
/**
 * A Label to be used for Nodes or Edges.
 */

var Label = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {object} options
   * @param {boolean} [edgelabel=false]
   */
  function Label(body, options) {
    var edgelabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    _classCallCheck(this, Label);

    this.body = body;
    this.pointToSelf = false;
    this.baseSize = undefined;
    this.fontOptions = {}; // instance variable containing the *instance-local* font options

    this.setOptions(options);
    this.size = {
      top: 0,
      left: 0,
      width: 0,
      height: 0,
      yLine: 0
    };
    this.isEdgeLabel = edgelabel;
  }
  /**
   * @param {object} options the options of the parent Node-instance
   */


  _createClass(Label, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.elementOptions = options; // Reference to the options of the parent Node-instance

      this.initFontOptions(options.font);

      if (isValidLabel(options.label)) {
        this.labelDirty = true;
      } else {
        // Bad label! Change the option value to prevent bad stuff happening
        options.label = undefined;
      }

      if (options.font !== undefined && options.font !== null) {
        // font options can be deleted at various levels
        if (typeof options.font === "string") {
          this.baseSize = this.fontOptions.size;
        } else if (_typeof(options.font) === "object") {
          var size = options.font.size;

          if (size !== undefined) {
            this.baseSize = size;
          }
        }
      }
    }
    /**
     * Init the font Options structure.
     *
     * Member fontOptions serves as an accumulator for the current font options.
     * As such, it needs to be completely separated from the node options.
     *
     * @param {object} newFontOptions the new font options to process
     * @private
     */

  }, {
    key: "initFontOptions",
    value: function initFontOptions(newFontOptions) {
      var _this = this;

      // Prepare the multi-font option objects.
      // These will be filled in propagateFonts(), if required
      forEach$1(multiFontStyle, function (style) {
        _this.fontOptions[style] = {};
      }); // Handle shorthand option, if present

      if (Label.parseFontString(this.fontOptions, newFontOptions)) {
        this.fontOptions.vadjust = 0;
        return;
      } // Copy over the non-multifont options, if specified


      forEach$1(newFontOptions, function (prop, n) {
        if (prop !== undefined && prop !== null && _typeof(prop) !== "object") {
          _this.fontOptions[n] = prop;
        }
      });
    }
    /**
     * If in-variable is a string, parse it as a font specifier.
     *
     * Note that following is not done here and have to be done after the call:
     * - Not all font options are set (vadjust, mod)
     *
     * @param {object} outOptions  out-parameter, object in which to store the parse results (if any)
     * @param {object} inOptions  font options to parse
     * @returns {boolean} true if font parsed as string, false otherwise
     * @static
     */

  }, {
    key: "constrain",
    value:
    /**
     * Set the width and height constraints based on 'nearest' value
     *
     * @param {Array} pile array of option objects to consider
     * @returns {object} the actual constraint values to use
     * @private
     */
    function constrain(pile) {
      // NOTE: constrainWidth and  constrainHeight never set!
      // NOTE: for edge labels, only 'maxWdt' set
      // Node labels can set all the fields
      var fontOptions = {
        constrainWidth: false,
        maxWdt: -1,
        minWdt: -1,
        constrainHeight: false,
        minHgt: -1,
        valign: "middle"
      };
      var widthConstraint = topMost(pile, "widthConstraint");

      if (typeof widthConstraint === "number") {
        fontOptions.maxWdt = Number(widthConstraint);
        fontOptions.minWdt = Number(widthConstraint);
      } else if (_typeof(widthConstraint) === "object") {
        var widthConstraintMaximum = topMost(pile, ["widthConstraint", "maximum"]);

        if (typeof widthConstraintMaximum === "number") {
          fontOptions.maxWdt = Number(widthConstraintMaximum);
        }

        var widthConstraintMinimum = topMost(pile, ["widthConstraint", "minimum"]);

        if (typeof widthConstraintMinimum === "number") {
          fontOptions.minWdt = Number(widthConstraintMinimum);
        }
      }

      var heightConstraint = topMost(pile, "heightConstraint");

      if (typeof heightConstraint === "number") {
        fontOptions.minHgt = Number(heightConstraint);
      } else if (_typeof(heightConstraint) === "object") {
        var heightConstraintMinimum = topMost(pile, ["heightConstraint", "minimum"]);

        if (typeof heightConstraintMinimum === "number") {
          fontOptions.minHgt = Number(heightConstraintMinimum);
        }

        var heightConstraintValign = topMost(pile, ["heightConstraint", "valign"]);

        if (typeof heightConstraintValign === "string") {
          if (heightConstraintValign === "top" || heightConstraintValign === "bottom") {
            fontOptions.valign = heightConstraintValign;
          }
        }
      }

      return fontOptions;
    }
    /**
     * Set options and update internal state
     *
     * @param {object} options  options to set
     * @param {Array}  pile     array of option objects to consider for option 'chosen'
     */

  }, {
    key: "update",
    value: function update(options, pile) {
      this.setOptions(options, true);
      this.propagateFonts(pile);
      deepExtend(this.fontOptions, this.constrain(pile));
      this.fontOptions.chooser = choosify("label", pile);
    }
    /**
     * When margins are set in an element, adjust sizes is called to remove them
     * from the width/height constraints. This must be done prior to label sizing.
     *
     * @param {{top: number, right: number, bottom: number, left: number}} margins
     */

  }, {
    key: "adjustSizes",
    value: function adjustSizes(margins) {
      var widthBias = margins ? margins.right + margins.left : 0;

      if (this.fontOptions.constrainWidth) {
        this.fontOptions.maxWdt -= widthBias;
        this.fontOptions.minWdt -= widthBias;
      }

      var heightBias = margins ? margins.top + margins.bottom : 0;

      if (this.fontOptions.constrainHeight) {
        this.fontOptions.minHgt -= heightBias;
      }
    } /////////////////////////////////////////////////////////
    // Methods for handling options piles
    // Eventually, these will be moved to a separate class
    /////////////////////////////////////////////////////////

    /**
     * Add the font members of the passed list of option objects to the pile.
     *
     * @param {Pile} dstPile  pile of option objects add to
     * @param {Pile} srcPile  pile of option objects to take font options from
     * @private
     */

  }, {
    key: "addFontOptionsToPile",
    value: function addFontOptionsToPile(dstPile, srcPile) {
      for (var i = 0; i < srcPile.length; ++i) {
        this.addFontToPile(dstPile, srcPile[i]);
      }
    }
    /**
     * Add given font option object to the list of objects (the 'pile') to consider for determining
     * multi-font option values.
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {object} options  instance to add to pile
     * @private
     */

  }, {
    key: "addFontToPile",
    value: function addFontToPile(pile, options) {
      if (options === undefined) return;
      if (options.font === undefined || options.font === null) return;
      var item = options.font;
      pile.push(item);
    }
    /**
     * Collect all own-property values from the font pile that aren't multi-font option objectss.
     *
     * @param {Pile} pile  pile of option objects to use
     * @returns {object} object with all current own basic font properties
     * @private
     */

  }, {
    key: "getBasicOptions",
    value: function getBasicOptions(pile) {
      var ret = {}; // Scans the whole pile to get all options present

      for (var n = 0; n < pile.length; ++n) {
        var fontOptions = pile[n]; // Convert shorthand if necessary

        var tmpShorthand = {};

        if (Label.parseFontString(tmpShorthand, fontOptions)) {
          fontOptions = tmpShorthand;
        }

        forEach$1(fontOptions, function (opt, name) {
          if (opt === undefined) return; // multi-font option need not be present

          if (Object.prototype.hasOwnProperty.call(ret, name)) return; // Keep first value we encounter

          if (indexOf(multiFontStyle).call(multiFontStyle, name) !== -1) {
            // Skip multi-font properties but we do need the structure
            ret[name] = {};
          } else {
            ret[name] = opt;
          }
        });
      }

      return ret;
    }
    /**
     * Return the value for given option for the given multi-font.
     *
     * All available option objects are trawled in the set order to construct the option values.
     *
     * ---------------------------------------------------------------------
     * ## Traversal of pile for multi-fonts
     *
     * The determination of multi-font option values is a special case, because any values not
     * present in the multi-font options should by definition be taken from the main font options,
     * i.e. from the current 'parent' object of the multi-font option.
     *
     * ### Search order for multi-fonts
     *
     * 'bold' used as example:
     *
     *   - search in option group 'bold' in local properties
     *   - search in main font option group in local properties
     *
     * ---------------------------------------------------------------------
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {MultiFontStyle} multiName sub path for the multi-font
     * @param {string} option  the option to search for, for the given multi-font
     * @returns {string|number} the value for the given option
     * @private
     */

  }, {
    key: "getFontOption",
    value: function getFontOption(pile, multiName, option) {
      var multiFont; // Search multi font in local properties

      for (var n = 0; n < pile.length; ++n) {
        var fontOptions = pile[n];

        if (Object.prototype.hasOwnProperty.call(fontOptions, multiName)) {
          multiFont = fontOptions[multiName];
          if (multiFont === undefined || multiFont === null) continue; // Convert shorthand if necessary
          // TODO: inefficient to do this conversion every time; find a better way.

          var tmpShorthand = {};

          if (Label.parseFontString(tmpShorthand, multiFont)) {
            multiFont = tmpShorthand;
          }

          if (Object.prototype.hasOwnProperty.call(multiFont, option)) {
            return multiFont[option];
          }
        }
      } // Option is not mentioned in the multi font options; take it from the parent font options.
      // These have already been converted with getBasicOptions(), so use the converted values.


      if (Object.prototype.hasOwnProperty.call(this.fontOptions, option)) {
        return this.fontOptions[option];
      } // A value **must** be found; you should never get here.


      throw new Error("Did not find value for multi-font for property: '" + option + "'");
    }
    /**
     * Return all options values for the given multi-font.
     *
     * All available option objects are trawled in the set order to construct the option values.
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {MultiFontStyle} multiName sub path for the mod-font
     * @returns {MultiFontOptions}
     * @private
     */

  }, {
    key: "getFontOptions",
    value: function getFontOptions(pile, multiName) {
      var result = {};
      var optionNames = ["color", "size", "face", "mod", "vadjust"]; // List of allowed options per multi-font

      for (var i = 0; i < optionNames.length; ++i) {
        var mod = optionNames[i];
        result[mod] = this.getFontOption(pile, multiName, mod);
      }

      return result;
    } /////////////////////////////////////////////////////////
    // End methods for handling options piles
    /////////////////////////////////////////////////////////

    /**
     * Collapse the font options for the multi-font to single objects, from
     * the chain of option objects passed (the 'pile').
     *
     * @param {Pile} pile  sequence of option objects to consider.
     *                     First item in list assumed to be the newly set options.
     */

  }, {
    key: "propagateFonts",
    value: function propagateFonts(pile) {
      var _this2 = this;

      var fontPile = []; // sequence of font objects to consider, order important
      // Note that this.elementOptions is not used here.

      this.addFontOptionsToPile(fontPile, pile);
      this.fontOptions = this.getBasicOptions(fontPile); // We set multifont values even if multi === false, for consistency (things break otherwise)

      var _loop = function _loop(i) {
        var mod = multiFontStyle[i];
        var modOptions = _this2.fontOptions[mod];

        var tmpMultiFontOptions = _this2.getFontOptions(fontPile, mod); // Copy over found values


        forEach$1(tmpMultiFontOptions, function (option, n) {
          modOptions[n] = option;
        });
        modOptions.size = Number(modOptions.size);
        modOptions.vadjust = Number(modOptions.vadjust);
      };

      for (var i = 0; i < multiFontStyle.length; ++i) {
        _loop(i);
      }
    }
    /**
     * Main function. This is called from anything that wants to draw a label.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} [baseline='middle']
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover) {
      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "middle";
      // if no label, return
      if (this.elementOptions.label === undefined) return; // check if we have to render the label

      var viewFontSize = this.fontOptions.size * this.body.view.scale;
      if (this.elementOptions.label && viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) return; // This ensures that there will not be HUGE letters on screen
      // by setting an upper limit on the visible text size (regardless of zoomLevel)

      if (viewFontSize >= this.elementOptions.scaling.label.maxVisible) {
        viewFontSize = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale;
      } // update the size cache if required


      this.calculateLabelSize(ctx, selected, hover, x, y, baseline);

      this._drawBackground(ctx);

      this._drawText(ctx, x, this.size.yLine, baseline, viewFontSize);
    }
    /**
     * Draws the label background
     *
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */

  }, {
    key: "_drawBackground",
    value: function _drawBackground(ctx) {
      if (this.fontOptions.background !== undefined && this.fontOptions.background !== "none") {
        ctx.fillStyle = this.fontOptions.background;
        var size = this.getSize();
        ctx.fillRect(size.left, size.top, size.width, size.height);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {string} [baseline='middle']
     * @param {number} viewFontSize
     * @private
     */

  }, {
    key: "_drawText",
    value: function _drawText(ctx, x, y) {
      var baseline = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "middle";
      var viewFontSize = arguments.length > 4 ? arguments[4] : undefined;

      var _this$_setAlignment = this._setAlignment(ctx, x, y, baseline);

      var _this$_setAlignment2 = _slicedToArray(_this$_setAlignment, 2);

      x = _this$_setAlignment2[0];
      y = _this$_setAlignment2[1];
      ctx.textAlign = "left";
      x = x - this.size.width / 2; // Shift label 1/2-distance to the left

      if (this.fontOptions.valign && this.size.height > this.size.labelHeight) {
        if (this.fontOptions.valign === "top") {
          y -= (this.size.height - this.size.labelHeight) / 2;
        }

        if (this.fontOptions.valign === "bottom") {
          y += (this.size.height - this.size.labelHeight) / 2;
        }
      } // draw the text


      for (var i = 0; i < this.lineCount; i++) {
        var line = this.lines[i];

        if (line && line.blocks) {
          var width = 0;

          if (this.isEdgeLabel || this.fontOptions.align === "center") {
            width += (this.size.width - line.width) / 2;
          } else if (this.fontOptions.align === "right") {
            width += this.size.width - line.width;
          }

          for (var j = 0; j < line.blocks.length; j++) {
            var block = line.blocks[j];
            ctx.font = block.font;

            var _this$_getColor = this._getColor(block.color, viewFontSize, block.strokeColor),
                _this$_getColor2 = _slicedToArray(_this$_getColor, 2),
                fontColor = _this$_getColor2[0],
                strokeColor = _this$_getColor2[1];

            if (block.strokeWidth > 0) {
              ctx.lineWidth = block.strokeWidth;
              ctx.strokeStyle = strokeColor;
              ctx.lineJoin = "round";
            }

            ctx.fillStyle = fontColor;

            if (block.strokeWidth > 0) {
              ctx.strokeText(block.text, x + width, y + block.vadjust);
            }

            ctx.fillText(block.text, x + width, y + block.vadjust);
            width += block.width;
          }

          y += line.height;
        }
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {string} baseline
     * @returns {Array.<number>}
     * @private
     */

  }, {
    key: "_setAlignment",
    value: function _setAlignment(ctx, x, y, baseline) {
      // check for label alignment (for edges)
      // TODO: make alignment for nodes
      if (this.isEdgeLabel && this.fontOptions.align !== "horizontal" && this.pointToSelf === false) {
        x = 0;
        y = 0;
        var lineMargin = 2;

        if (this.fontOptions.align === "top") {
          ctx.textBaseline = "alphabetic";
          y -= 2 * lineMargin; // distance from edge, required because we use alphabetic. Alphabetic has less difference between browsers
        } else if (this.fontOptions.align === "bottom") {
          ctx.textBaseline = "hanging";
          y += 2 * lineMargin; // distance from edge, required because we use hanging. Hanging has less difference between browsers
        } else {
          ctx.textBaseline = "middle";
        }
      } else {
        ctx.textBaseline = baseline;
      }

      return [x, y];
    }
    /**
     * fade in when relative scale is between threshold and threshold - 1.
     * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.
     *
     * @param {string} color  The font color to use
     * @param {number} viewFontSize
     * @param {string} initialStrokeColor
     * @returns {Array.<string>} An array containing the font color and stroke color
     * @private
     */

  }, {
    key: "_getColor",
    value: function _getColor(color, viewFontSize, initialStrokeColor) {
      var fontColor = color || "#000000";
      var strokeColor = initialStrokeColor || "#ffffff";

      if (viewFontSize <= this.elementOptions.scaling.label.drawThreshold) {
        var opacity = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - viewFontSize)));
        fontColor = overrideOpacity(fontColor, opacity);
        strokeColor = overrideOpacity(strokeColor, opacity);
      }

      return [fontColor, strokeColor];
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {{width: number, height: number}}
     */

  }, {
    key: "getTextSize",
    value: function getTextSize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      this._processLabel(ctx, selected, hover);

      return {
        width: this.size.width,
        height: this.size.height,
        lineCount: this.lineCount
      };
    }
    /**
     * Get the current dimensions of the label
     *
     * @returns {rect}
     */

  }, {
    key: "getSize",
    value: function getSize() {
      var lineMargin = 2;
      var x = this.size.left; // default values which might be overridden below

      var y = this.size.top - 0.5 * lineMargin; // idem

      if (this.isEdgeLabel) {
        var x2 = -this.size.width * 0.5;

        switch (this.fontOptions.align) {
          case "middle":
            x = x2;
            y = -this.size.height * 0.5;
            break;

          case "top":
            x = x2;
            y = -(this.size.height + lineMargin);
            break;

          case "bottom":
            x = x2;
            y = lineMargin;
            break;
        }
      }

      var ret = {
        left: x,
        top: y,
        width: this.size.width,
        height: this.size.height
      };
      return ret;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {number} [x=0]
     * @param {number} [y=0]
     * @param {'middle'|'hanging'} [baseline='middle']
     */

  }, {
    key: "calculateLabelSize",
    value: function calculateLabelSize(ctx, selected, hover) {
      var x = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var y = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "middle";

      this._processLabel(ctx, selected, hover);

      this.size.left = x - this.size.width * 0.5;
      this.size.top = y - this.size.height * 0.5;
      this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;

      if (baseline === "hanging") {
        this.size.top += 0.5 * this.fontOptions.size;
        this.size.top += 4; // distance from node, required because we use hanging. Hanging has less difference between browsers

        this.size.yLine += 4; // distance from node
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} mod
     * @returns {{color, size, face, mod, vadjust, strokeWidth: *, strokeColor: (*|string|allOptions.edges.font.strokeColor|{string}|allOptions.nodes.font.strokeColor|Array)}}
     */

  }, {
    key: "getFormattingValues",
    value: function getFormattingValues(ctx, selected, hover, mod) {
      var getValue = function getValue(fontOptions, mod, option) {
        if (mod === "normal") {
          if (option === "mod") return "";
          return fontOptions[option];
        }

        if (fontOptions[mod][option] !== undefined) {
          // Grumbl leaving out test on undefined equals false for ""
          return fontOptions[mod][option];
        } else {
          // Take from parent font option
          return fontOptions[option];
        }
      };

      var values = {
        color: getValue(this.fontOptions, mod, "color"),
        size: getValue(this.fontOptions, mod, "size"),
        face: getValue(this.fontOptions, mod, "face"),
        mod: getValue(this.fontOptions, mod, "mod"),
        vadjust: getValue(this.fontOptions, mod, "vadjust"),
        strokeWidth: this.fontOptions.strokeWidth,
        strokeColor: this.fontOptions.strokeColor
      };

      if (selected || hover) {
        if (mod === "normal" && this.fontOptions.chooser === true && this.elementOptions.labelHighlightBold) {
          values.mod = "bold";
        } else {
          if (typeof this.fontOptions.chooser === "function") {
            this.fontOptions.chooser(values, this.elementOptions.id, selected, hover);
          }
        }
      }

      var fontString = "";

      if (values.mod !== undefined && values.mod !== "") {
        // safeguard for undefined - this happened
        fontString += values.mod + " ";
      }

      fontString += values.size + "px " + values.face;
      ctx.font = fontString.replace(/"/g, "");
      values.font = ctx.font;
      values.height = values.size;
      return values;
    }
    /**
     *
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {boolean}
     */

  }, {
    key: "differentState",
    value: function differentState(selected, hover) {
      return selected !== this.selectedState || hover !== this.hoverState;
    }
    /**
     * This explodes the passed text into lines and determines the width, height and number of lines.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} inText  the text to explode
     * @returns {{width, height, lines}|*}
     * @private
     */

  }, {
    key: "_processLabelText",
    value: function _processLabelText(ctx, selected, hover, inText) {
      var splitter = new LabelSplitter(ctx, this, selected, hover);
      return splitter.process(inText);
    }
    /**
     * This explodes the label string into lines and sets the width, height and number of lines.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */

  }, {
    key: "_processLabel",
    value: function _processLabel(ctx, selected, hover) {
      if (this.labelDirty === false && !this.differentState(selected, hover)) return;

      var state = this._processLabelText(ctx, selected, hover, this.elementOptions.label);

      if (this.fontOptions.minWdt > 0 && state.width < this.fontOptions.minWdt) {
        state.width = this.fontOptions.minWdt;
      }

      this.size.labelHeight = state.height;

      if (this.fontOptions.minHgt > 0 && state.height < this.fontOptions.minHgt) {
        state.height = this.fontOptions.minHgt;
      }

      this.lines = state.lines;
      this.lineCount = state.lines.length;
      this.size.width = state.width;
      this.size.height = state.height;
      this.selectedState = selected;
      this.hoverState = hover;
      this.labelDirty = false;
    }
    /**
     * Check if this label is visible
     *
     * @returns {boolean} true if this label will be show, false otherwise
     */

  }, {
    key: "visible",
    value: function visible() {
      if (this.size.width === 0 || this.size.height === 0 || this.elementOptions.label === undefined) {
        return false; // nothing to display
      }

      var viewFontSize = this.fontOptions.size * this.body.view.scale;

      if (viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) {
        return false; // Too small or too far away to show
      }

      return true;
    }
  }], [{
    key: "parseFontString",
    value: function parseFontString(outOptions, inOptions) {
      if (!inOptions || typeof inOptions !== "string") return false;
      var newOptionsArray = inOptions.split(" ");
      outOptions.size = +newOptionsArray[0].replace("px", "");
      outOptions.face = newOptionsArray[1];
      outOptions.color = newOptionsArray[2];
      return true;
    }
  }]);

  return Label;
}();

/**
 * The Base class for all Nodes.
 */
var NodeBase = /*#__PURE__*/function () {
  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function NodeBase(options, body, labelModule) {
    _classCallCheck(this, NodeBase);

    this.body = body;
    this.labelModule = labelModule;
    this.setOptions(options);
    this.top = undefined;
    this.left = undefined;
    this.height = undefined;
    this.width = undefined;
    this.radius = undefined;
    this.margin = undefined;
    this.refreshNeeded = true;
    this.boundingBox = {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    };
  }
  /**
   *
   * @param {object} options
   */


  _createClass(NodeBase, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     *
     * @param {Label} labelModule
     * @private
     */

  }, {
    key: "_setMargins",
    value: function _setMargins(labelModule) {
      this.margin = {};

      if (this.options.margin) {
        if (_typeof(this.options.margin) == "object") {
          this.margin.top = this.options.margin.top;
          this.margin.right = this.options.margin.right;
          this.margin.bottom = this.options.margin.bottom;
          this.margin.left = this.options.margin.left;
        } else {
          this.margin.top = this.options.margin;
          this.margin.right = this.options.margin;
          this.margin.bottom = this.options.margin;
          this.margin.left = this.options.margin;
        }
      }

      labelModule.adjustSizes(this.margin);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     * @private
     */

  }, {
    key: "_distanceToBorder",
    value: function _distanceToBorder(ctx, angle) {
      var borderWidth = this.options.borderWidth;

      if (ctx) {
        this.resize(ctx);
      }

      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "enableShadow",
    value: function enableShadow(ctx, values) {
      if (values.shadow) {
        ctx.shadowColor = values.shadowColor;
        ctx.shadowBlur = values.shadowSize;
        ctx.shadowOffsetX = values.shadowX;
        ctx.shadowOffsetY = values.shadowY;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "disableShadow",
    value: function disableShadow(ctx, values) {
      if (values.shadow) {
        ctx.shadowColor = "rgba(0,0,0,0)";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "enableBorderDashes",
    value: function enableBorderDashes(ctx, values) {
      if (values.borderDashes !== false) {
        if (ctx.setLineDash !== undefined) {
          var dashes = values.borderDashes;

          if (dashes === true) {
            dashes = [5, 15];
          }

          ctx.setLineDash(dashes);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
          this.options.shapeProperties.borderDashes = false;
          values.borderDashes = false;
        }
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "disableBorderDashes",
    value: function disableBorderDashes(ctx, values) {
      if (values.borderDashes !== false) {
        if (ctx.setLineDash !== undefined) {
          ctx.setLineDash([0]);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
          this.options.shapeProperties.borderDashes = false;
          values.borderDashes = false;
        }
      }
    }
    /**
     * Determine if the shape of a node needs to be recalculated.
     *
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {boolean}
     * @protected
     */

  }, {
    key: "needsRefresh",
    value: function needsRefresh(selected, hover) {
      if (this.refreshNeeded === true) {
        // This is probably not the best location to reset this member.
        // However, in the current logic, it is the most convenient one.
        this.refreshNeeded = false;
        return true;
      }

      return this.width === undefined || this.labelModule.differentState(selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "initContextForDraw",
    value: function initContextForDraw(ctx, values) {
      var borderWidth = values.borderWidth / this.body.view.scale;
      ctx.lineWidth = Math.min(this.width, borderWidth);
      ctx.strokeStyle = values.borderColor;
      ctx.fillStyle = values.color;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "performStroke",
    value: function performStroke(ctx, values) {
      var borderWidth = values.borderWidth / this.body.view.scale; //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.

      ctx.save(); // if borders are zero width, they will be drawn with width 1 by default. This prevents that

      if (borderWidth > 0) {
        this.enableBorderDashes(ctx, values); //draw the border

        ctx.stroke(); //disable dashed border for other elements

        this.disableBorderDashes(ctx, values);
      }

      ctx.restore();
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: "performFill",
    value: function performFill(ctx, values) {
      ctx.save();
      ctx.fillStyle = values.color; // draw shadow if enabled

      this.enableShadow(ctx, values); // draw the background

      fill(ctx).call(ctx); // disable shadows for other elements.


      this.disableShadow(ctx, values);
      ctx.restore();
      this.performStroke(ctx, values);
    }
    /**
     *
     * @param {number} margin
     * @private
     */

  }, {
    key: "_addBoundingBoxMargin",
    value: function _addBoundingBoxMargin(margin) {
      this.boundingBox.left -= margin;
      this.boundingBox.top -= margin;
      this.boundingBox.bottom += margin;
      this.boundingBox.right += margin;
    }
    /**
     * Actual implementation of this method call.
     *
     * Doing it like this makes it easier to override
     * in the child classes.
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */

  }, {
    key: "_updateBoundingBox",
    value: function _updateBoundingBox(x, y, ctx, selected, hover) {
      if (ctx !== undefined) {
        this.resize(ctx, selected, hover);
      }

      this.left = x - this.width / 2;
      this.top = y - this.height / 2;
      this.boundingBox.left = this.left;
      this.boundingBox.top = this.top;
      this.boundingBox.bottom = this.top + this.height;
      this.boundingBox.right = this.left + this.width;
    }
    /**
     * Default implementation of this method call.
     * This acts as a stub which can be overridden.
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y, ctx, selected, hover) {
      this._updateBoundingBox(x, y, ctx, selected, hover);
    }
    /**
     * Determine the dimensions to use for nodes with an internal label
     *
     * Currently, these are: Circle, Ellipse, Database, Box
     * The other nodes have external labels, and will not call this method
     *
     * If there is no label, decent default values are supplied.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} [selected]
     * @param {boolean} [hover]
     * @returns {{width:number, height:number}}
     */

  }, {
    key: "getDimensionsFromLabel",
    value: function getDimensionsFromLabel(ctx, selected, hover) {
      // NOTE: previously 'textSize' was not put in 'this' for Ellipse
      // TODO: examine the consequences.
      this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
      var width = this.textSize.width;
      var height = this.textSize.height;
      var DEFAULT_SIZE = 14;

      if (width === 0) {
        // This happens when there is no label text set
        width = DEFAULT_SIZE; // use a decent default

        height = DEFAULT_SIZE; // if width zero, then height also always zero
      }

      return {
        width: width,
        height: height
      };
    }
  }]);

  return NodeBase;
}();

function _createSuper$s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$s(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$s() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Box Node/Cluster shape.
 *
 * @augments NodeBase
 */

var Box$1 = /*#__PURE__*/function (_NodeBase) {
  _inherits(Box, _NodeBase);

  var _super = _createSuper$s(Box);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Box(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Box);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Box, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;

      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        this.width = dimensions.width + this.margin.right + this.margin.left;
        this.height = dimensions.height + this.margin.top + this.margin.bottom;
        this.radius = this.width / 2;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;
      this.initContextForDraw(ctx, values);
      drawRoundRect(ctx, this.left, this.top, this.width, this.height, values.borderRadius);
      this.performFill(ctx, values);
      this.updateBoundingBox(x, y, ctx, selected, hover);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
    }
    /**
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y, ctx, selected, hover) {
      this._updateBoundingBox(x, y, ctx, selected, hover);

      var borderRadius = this.options.shapeProperties.borderRadius; // only effective for box

      this._addBoundingBoxMargin(borderRadius);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      if (ctx) {
        this.resize(ctx);
      }

      var borderWidth = this.options.borderWidth;
      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
    }
  }]);

  return Box;
}(NodeBase);

function _createSuper$r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$r(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$r() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * NOTE: This is a bad base class
 *
 * Child classes are:
 *
 *   Image       - uses *only* image methods
 *   Circle      - uses *only* _drawRawCircle
 *   CircleImage - uses all
 *
 * TODO: Refactor, move _drawRawCircle to different module, derive Circle from NodeBase
 *       Rename this to ImageBase
 *       Consolidate common code in Image and CircleImage to base class
 *
 * @augments NodeBase
 */

var CircleImageBase = /*#__PURE__*/function (_NodeBase) {
  _inherits(CircleImageBase, _NodeBase);

  var _super = _createSuper$r(CircleImageBase);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function CircleImageBase(options, body, labelModule) {
    var _this;

    _classCallCheck(this, CircleImageBase);

    _this = _super.call(this, options, body, labelModule);
    _this.labelOffset = 0;
    _this.selected = false;
    return _this;
  }
  /**
   *
   * @param {object} options
   * @param {object} [imageObj]
   * @param {object} [imageObjAlt]
   */


  _createClass(CircleImageBase, [{
    key: "setOptions",
    value: function setOptions(options, imageObj, imageObjAlt) {
      this.options = options;

      if (!(imageObj === undefined && imageObjAlt === undefined)) {
        this.setImages(imageObj, imageObjAlt);
      }
    }
    /**
     * Set the images for this node.
     *
     * The images can be updated after the initial setting of options;
     * therefore, this method needs to be reentrant.
     *
     * For correct working in error cases, it is necessary to properly set
     * field 'nodes.brokenImage' in the options.
     *
     * @param {Image} imageObj  required; main image to show for this node
     * @param {Image|undefined} imageObjAlt optional; image to show when node is selected
     */

  }, {
    key: "setImages",
    value: function setImages(imageObj, imageObjAlt) {
      if (imageObjAlt && this.selected) {
        this.imageObj = imageObjAlt;
        this.imageObjAlt = imageObj;
      } else {
        this.imageObj = imageObj;
        this.imageObjAlt = imageObjAlt;
      }
    }
    /**
     * Set selection and switch between the base and the selected image.
     *
     * Do the switch only if imageObjAlt exists.
     *
     * @param {boolean} selected value of new selected state for current node
     */

  }, {
    key: "switchImages",
    value: function switchImages(selected) {
      var selection_changed = selected && !this.selected || !selected && this.selected;
      this.selected = selected; // Remember new selection

      if (this.imageObjAlt !== undefined && selection_changed) {
        var imageTmp = this.imageObj;
        this.imageObj = this.imageObjAlt;
        this.imageObjAlt = imageTmp;
      }
    }
    /**
     * Returns Image Padding from node options
     *
     * @returns {{top: number,left: number,bottom: number,right: number}} image padding inside this shape
     * @private
     */

  }, {
    key: "_getImagePadding",
    value: function _getImagePadding() {
      var imgPadding = {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };

      if (this.options.imagePadding) {
        var optImgPadding = this.options.imagePadding;

        if (_typeof(optImgPadding) == "object") {
          imgPadding.top = optImgPadding.top;
          imgPadding.right = optImgPadding.right;
          imgPadding.bottom = optImgPadding.bottom;
          imgPadding.left = optImgPadding.left;
        } else {
          imgPadding.top = optImgPadding;
          imgPadding.right = optImgPadding;
          imgPadding.bottom = optImgPadding;
          imgPadding.left = optImgPadding;
        }
      }

      return imgPadding;
    }
    /**
     * Adjust the node dimensions for a loaded image.
     *
     * Pre: this.imageObj is valid
     */

  }, {
    key: "_resizeImage",
    value: function _resizeImage() {
      var width, height;

      if (this.options.shapeProperties.useImageSize === false) {
        // Use the size property
        var ratio_width = 1;
        var ratio_height = 1; // Only calculate the proper ratio if both width and height not zero

        if (this.imageObj.width && this.imageObj.height) {
          if (this.imageObj.width > this.imageObj.height) {
            ratio_width = this.imageObj.width / this.imageObj.height;
          } else {
            ratio_height = this.imageObj.height / this.imageObj.width;
          }
        }

        width = this.options.size * 2 * ratio_width;
        height = this.options.size * 2 * ratio_height;
      } else {
        // Use the image size with image padding
        var imgPadding = this._getImagePadding();

        width = this.imageObj.width + imgPadding.left + imgPadding.right;
        height = this.imageObj.height + imgPadding.top + imgPadding.bottom;
      }

      this.width = width;
      this.height = height;
      this.radius = 0.5 * this.width;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {ArrowOptions} values
     * @private
     */

  }, {
    key: "_drawRawCircle",
    value: function _drawRawCircle(ctx, x, y, values) {
      this.initContextForDraw(ctx, values);
      drawCircle(ctx, x, y, values.size);
      this.performFill(ctx, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     * @private
     */

  }, {
    key: "_drawImageAtPosition",
    value: function _drawImageAtPosition(ctx, values) {
      if (this.imageObj.width != 0) {
        // draw the image
        ctx.globalAlpha = values.opacity !== undefined ? values.opacity : 1; // draw shadow if enabled

        this.enableShadow(ctx, values);
        var factor = 1;

        if (this.options.shapeProperties.interpolation === true) {
          factor = this.imageObj.width / this.width / this.body.view.scale;
        }

        var imgPadding = this._getImagePadding();

        var imgPosLeft = this.left + imgPadding.left;
        var imgPosTop = this.top + imgPadding.top;
        var imgWidth = this.width - imgPadding.left - imgPadding.right;
        var imgHeight = this.height - imgPadding.top - imgPadding.bottom;
        this.imageObj.drawImageAtPosition(ctx, factor, imgPosLeft, imgPosTop, imgWidth, imgHeight); // disable shadows for other elements.

        this.disableShadow(ctx, values);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */

  }, {
    key: "_drawImageLabel",
    value: function _drawImageLabel(ctx, x, y, selected, hover) {
      var offset = 0;

      if (this.height !== undefined) {
        offset = this.height * 0.5;
        var labelDimensions = this.labelModule.getTextSize(ctx, selected, hover);

        if (labelDimensions.lineCount >= 1) {
          offset += labelDimensions.height / 2;
        }
      }

      var yLabel = y + offset;

      if (this.options.label) {
        this.labelOffset = offset;
      }

      this.labelModule.draw(ctx, x, yLabel, selected, hover, "hanging");
    }
  }]);

  return CircleImageBase;
}(NodeBase);

function _createSuper$q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$q(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$q() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Circle Node/Cluster shape.
 *
 * @augments CircleImageBase
 */

var Circle$1 = /*#__PURE__*/function (_CircleImageBase) {
  _inherits(Circle, _CircleImageBase);

  var _super = _createSuper$q(Circle);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Circle(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Circle);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Circle, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;

      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        var diameter = Math.max(dimensions.width + this.margin.right + this.margin.left, dimensions.height + this.margin.top + this.margin.bottom);
        this.options.size = diameter / 2; // NOTE: this size field only set here, not in Ellipse, Database, Box

        this.width = diameter;
        this.height = diameter;
        this.radius = this.width / 2;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;

      this._drawRawCircle(ctx, x, y, values);

      this.updateBoundingBox(x, y);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, y, selected, hover);
    }
    /**
     *
     * @param {number} x width
     * @param {number} y height
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      this.boundingBox.top = y - this.options.size;
      this.boundingBox.left = x - this.options.size;
      this.boundingBox.right = x + this.options.size;
      this.boundingBox.bottom = y + this.options.size;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx) {
      if (ctx) {
        this.resize(ctx);
      }

      return this.width * 0.5;
    }
  }]);

  return Circle;
}(CircleImageBase);

function _createSuper$p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$p(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$p() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A CircularImage Node/Cluster shape.
 *
 * @augments CircleImageBase
 */

var CircularImage = /*#__PURE__*/function (_CircleImageBase) {
  _inherits(CircularImage, _CircleImageBase);

  var _super = _createSuper$p(CircularImage);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   * @param {Image} imageObj
   * @param {Image} imageObjAlt
   */
  function CircularImage(options, body, labelModule, imageObj, imageObjAlt) {
    var _this;

    _classCallCheck(this, CircularImage);

    _this = _super.call(this, options, body, labelModule);

    _this.setImages(imageObj, imageObjAlt);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(CircularImage, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;
      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;

      if (imageAbsent) {
        var diameter = this.options.size * 2;
        this.width = diameter;
        this.height = diameter;
        this.radius = 0.5 * this.width;
        return;
      } // At this point, an image is present, i.e. this.imageObj is valid.


      if (this.needsRefresh(selected, hover)) {
        this._resizeImage();
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.switchImages(selected);
      this.resize();
      var labelX = x,
          labelY = y;

      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.left = x;
        this.top = y;
        labelX += this.width / 2;
        labelY += this.height / 2;
      } else {
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;
      } // draw the background circle. IMPORTANT: the stroke in this method is used by the clip method below.


      this._drawRawCircle(ctx, labelX, labelY, values); // now we draw in the circle, we save so we can revert the clip operation after drawing.


      ctx.save(); // clip is used to use the stroke in drawRawCircle as an area that we can draw in.

      ctx.clip(); // draw the image

      this._drawImageAtPosition(ctx, values); // restore so we can again draw on the full canvas


      ctx.restore();

      this._drawImageLabel(ctx, labelX, labelY, selected, hover);

      this.updateBoundingBox(x, y);
    } // TODO: compare with Circle.updateBoundingBox(), consolidate? More stuff is happening here

    /**
     *
     * @param {number} x width
     * @param {number} y height
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.boundingBox.top = y;
        this.boundingBox.left = x;
        this.boundingBox.right = x + this.options.size * 2;
        this.boundingBox.bottom = y + this.options.size * 2;
      } else {
        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;
      } // TODO: compare with Image.updateBoundingBox(), consolidate?


      this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
      this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
      this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx) {
      if (ctx) {
        this.resize(ctx);
      }

      return this.width * 0.5;
    }
  }]);

  return CircularImage;
}(CircleImageBase);

function _createSuper$o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$o(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$o() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Base class for constructing Node/Cluster Shapes.
 *
 * @augments NodeBase
 */

var ShapeBase = /*#__PURE__*/function (_NodeBase) {
  _inherits(ShapeBase, _NodeBase);

  var _super = _createSuper$o(ShapeBase);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function ShapeBase(options, body, labelModule) {
    _classCallCheck(this, ShapeBase);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   * @param {object} [values={size: this.options.size}]
   */


  _createClass(ShapeBase, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;
      var values = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        size: this.options.size
      };

      if (this.needsRefresh(selected, hover)) {
        var _this$customSizeWidth, _this$customSizeHeigh;

        this.labelModule.getTextSize(ctx, selected, hover);
        var size = 2 * values.size;
        this.width = (_this$customSizeWidth = this.customSizeWidth) !== null && _this$customSizeWidth !== void 0 ? _this$customSizeWidth : size;
        this.height = (_this$customSizeHeigh = this.customSizeHeight) !== null && _this$customSizeHeigh !== void 0 ? _this$customSizeHeigh : size;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} shape
     * @param {number} sizeMultiplier - Unused! TODO: Remove next major release
     * @param {number} x
     * @param {number} y
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     * @private
     * @returns {object} Callbacks to draw later on higher layers.
     */

  }, {
    key: "_drawShape",
    value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover, values) {
      var _this = this;

      this.resize(ctx, selected, hover, values);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;
      this.initContextForDraw(ctx, values);
      getShape(shape)(ctx, x, y, values.size);
      this.performFill(ctx, values);

      if (this.options.icon !== undefined) {
        if (this.options.icon.code !== undefined) {
          ctx.font = (selected ? "bold " : "") + this.height / 2 + "px " + (this.options.icon.face || "FontAwesome");
          ctx.fillStyle = this.options.icon.color || "black";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(this.options.icon.code, x, y);
        }
      }

      return {
        drawExternalLabel: function drawExternalLabel() {
          if (_this.options.label !== undefined) {
            // Need to call following here in order to ensure value for
            // `this.labelModule.size.height`.
            _this.labelModule.calculateLabelSize(ctx, selected, hover, x, y, "hanging");

            var yLabel = y + 0.5 * _this.height + 0.5 * _this.labelModule.size.height;

            _this.labelModule.draw(ctx, x, yLabel, selected, hover, "hanging");
          }

          _this.updateBoundingBox(x, y);
        }
      };
    }
    /**
     *
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      this.boundingBox.top = y - this.options.size;
      this.boundingBox.left = x - this.options.size;
      this.boundingBox.right = x + this.options.size;
      this.boundingBox.bottom = y + this.options.size;

      if (this.options.label !== undefined && this.labelModule.size.width > 0) {
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height);
      }
    }
  }]);

  return ShapeBase;
}(NodeBase);

function ownKeys$3(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context = ownKeys$3(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context2 = ownKeys$3(Object(source))).call(_context2, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }

function _createSuper$n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$n(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$n() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A CustomShape Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var CustomShape = /*#__PURE__*/function (_ShapeBase) {
  _inherits(CustomShape, _ShapeBase);

  var _super = _createSuper$n(CustomShape);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   * @param {Function} ctxRenderer
   */
  function CustomShape(options, body, labelModule, ctxRenderer) {
    var _this;

    _classCallCheck(this, CustomShape);

    _this = _super.call(this, options, body, labelModule, ctxRenderer);
    _this.ctxRenderer = ctxRenderer;
    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on different layers.
   */


  _createClass(CustomShape, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover, values);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2; // Guard right away because someone may just draw in the function itself.

      ctx.save();
      var drawLater = this.ctxRenderer({
        ctx: ctx,
        id: this.options.id,
        x: x,
        y: y,
        state: {
          selected: selected,
          hover: hover
        },
        style: _objectSpread$3({}, values),
        label: this.options.label
      }); // Render the node shape bellow arrows.

      if (drawLater.drawNode != null) {
        drawLater.drawNode();
      }

      ctx.restore();

      if (drawLater.drawExternalLabel) {
        // Guard the external label (above arrows) drawing function.
        var drawExternalLabel = drawLater.drawExternalLabel;

        drawLater.drawExternalLabel = function () {
          ctx.save();
          drawExternalLabel();
          ctx.restore();
        };
      }

      if (drawLater.nodeDimensions) {
        this.customSizeWidth = drawLater.nodeDimensions.width;
        this.customSizeHeight = drawLater.nodeDimensions.height;
      }

      return drawLater;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return CustomShape;
}(ShapeBase);

function _createSuper$m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$m(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$m() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Database Node/Cluster shape.
 *
 * @augments NodeBase
 */

var Database = /*#__PURE__*/function (_NodeBase) {
  _inherits(Database, _NodeBase);

  var _super = _createSuper$m(Database);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Database(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Database);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} selected
   * @param {boolean} hover
   */


  _createClass(Database, [{
    key: "resize",
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        var size = dimensions.width + this.margin.right + this.margin.left;
        this.width = size;
        this.height = size;
        this.radius = this.width / 2;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;
      this.initContextForDraw(ctx, values);
      drawDatabase(ctx, x - this.width / 2, y - this.height / 2, this.width, this.height);
      this.performFill(ctx, values);
      this.updateBoundingBox(x, y, ctx, selected, hover);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Database;
}(NodeBase);

function _createSuper$l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$l(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$l() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Diamond Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Diamond$1 = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Diamond, _ShapeBase);

  var _super = _createSuper$l(Diamond);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Diamond(options, body, labelModule) {
    _classCallCheck(this, Diamond);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Diamond, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "diamond", 4, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Diamond;
}(ShapeBase);

function _createSuper$k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$k(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$k() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Dot Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Dot = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Dot, _ShapeBase);

  var _super = _createSuper$k(Dot);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Dot(options, body, labelModule) {
    _classCallCheck(this, Dot);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Dot, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "circle", 2, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx) {
      if (ctx) {
        this.resize(ctx);
      }

      return this.options.size;
    }
  }]);

  return Dot;
}(ShapeBase);

function _createSuper$j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$j(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$j() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Am Ellipse Node/Cluster shape.
 *
 * @augments NodeBase
 */

var Ellipse = /*#__PURE__*/function (_NodeBase) {
  _inherits(Ellipse, _NodeBase);

  var _super = _createSuper$j(Ellipse);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Ellipse(options, body, labelModule) {
    _classCallCheck(this, Ellipse);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Ellipse, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;

      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        this.height = dimensions.height * 2;
        this.width = dimensions.width + dimensions.height;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width * 0.5;
      this.top = y - this.height * 0.5;
      this.initContextForDraw(ctx, values);
      drawEllipse(ctx, this.left, this.top, this.width, this.height);
      this.performFill(ctx, values);
      this.updateBoundingBox(x, y, ctx, selected, hover);
      this.labelModule.draw(ctx, x, y, selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      if (ctx) {
        this.resize(ctx);
      }

      var a = this.width * 0.5;
      var b = this.height * 0.5;
      var w = Math.sin(angle) * a;
      var h = Math.cos(angle) * b;
      return a * b / Math.sqrt(w * w + h * h);
    }
  }]);

  return Ellipse;
}(NodeBase);

function _createSuper$i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$i(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$i() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * An icon replacement for the default Node shape.
 *
 * @augments NodeBase
 */

var Icon = /*#__PURE__*/function (_NodeBase) {
  _inherits(Icon, _NodeBase);

  var _super = _createSuper$i(Icon);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Icon(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Icon);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx - Unused.
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Icon, [{
    key: "resize",
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        this.iconSize = {
          width: Number(this.options.icon.size),
          height: Number(this.options.icon.size)
        };
        this.width = this.iconSize.width + this.margin.right + this.margin.left;
        this.height = this.iconSize.height + this.margin.top + this.margin.bottom;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     * @returns {object} Callbacks to draw later on higher layers.
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      var _this2 = this;

      this.resize(ctx, selected, hover);
      this.options.icon.size = this.options.icon.size || 50;
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;

      this._icon(ctx, x, y, selected, hover, values);

      return {
        drawExternalLabel: function drawExternalLabel() {
          if (_this2.options.label !== undefined) {
            var iconTextSpacing = 5;

            _this2.labelModule.draw(ctx, _this2.left + _this2.iconSize.width / 2 + _this2.margin.left, y + _this2.height / 2 + iconTextSpacing, selected);
          }

          _this2.updateBoundingBox(x, y);
        }
      };
    }
    /**
     *
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      this.boundingBox.top = y - this.options.icon.size * 0.5;
      this.boundingBox.left = x - this.options.icon.size * 0.5;
      this.boundingBox.right = x + this.options.icon.size * 0.5;
      this.boundingBox.bottom = y + this.options.icon.size * 0.5;

      if (this.options.label !== undefined && this.labelModule.size.width > 0) {
        var iconTextSpacing = 5;
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover - Unused
     * @param {ArrowOptions} values
     */

  }, {
    key: "_icon",
    value: function _icon(ctx, x, y, selected, hover, values) {
      var iconSize = Number(this.options.icon.size);

      if (this.options.icon.code !== undefined) {
        ctx.font = [this.options.icon.weight != null ? this.options.icon.weight : selected ? "bold" : "", // If the weight is forced (for example to make Font Awesome 5 work
        // properly) substitute slightly bigger size for bold font face.
        (this.options.icon.weight != null && selected ? 5 : 0) + iconSize + "px", this.options.icon.face].join(" "); // draw icon

        ctx.fillStyle = this.options.icon.color || "black";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle"; // draw shadow if enabled

        this.enableShadow(ctx, values);
        ctx.fillText(this.options.icon.code, x, y); // disable shadows for other elements.

        this.disableShadow(ctx, values);
      } else {
        console.error("When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.");
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Icon;
}(NodeBase);

function _createSuper$h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$h(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$h() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * An image-based replacement for the default Node shape.
 *
 * @augments CircleImageBase
 */

var Image$2 = /*#__PURE__*/function (_CircleImageBase) {
  _inherits(Image, _CircleImageBase);

  var _super = _createSuper$h(Image);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   * @param {Image} imageObj
   * @param {Image} imageObjAlt
   */
  function Image(options, body, labelModule, imageObj, imageObjAlt) {
    var _this;

    _classCallCheck(this, Image);

    _this = _super.call(this, options, body, labelModule);

    _this.setImages(imageObj, imageObjAlt);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx - Unused.
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  _createClass(Image, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;
      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;

      if (imageAbsent) {
        var side = this.options.size * 2;
        this.width = side;
        this.height = side;
        return;
      }

      if (this.needsRefresh(selected, hover)) {
        this._resizeImage();
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      ctx.save();
      this.switchImages(selected);
      this.resize();
      var labelX = x,
          labelY = y;

      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.left = x;
        this.top = y;
        labelX += this.width / 2;
        labelY += this.height / 2;
      } else {
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;
      }

      if (this.options.shapeProperties.useBorderWithImage === true) {
        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);
        ctx.beginPath();
        var strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
        var fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;

        if (values.opacity !== undefined) {
          strokeStyle = overrideOpacity(strokeStyle, values.opacity);
          fillStyle = overrideOpacity(fillStyle, values.opacity);
        } // setup the line properties.


        ctx.strokeStyle = strokeStyle; // set a fillstyle

        ctx.fillStyle = fillStyle; // draw a rectangle to form the border around. This rectangle is filled so the opacity of a picture (in future vis releases?) can be used to tint the image

        ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);

        fill(ctx).call(ctx);

        this.performStroke(ctx, values);
        ctx.closePath();
      }

      this._drawImageAtPosition(ctx, values);

      this._drawImageLabel(ctx, labelX, labelY, selected, hover);

      this.updateBoundingBox(x, y);
      ctx.restore();
    }
    /**
     *
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x, y) {
      this.resize();

      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.left = x;
        this.top = y;
      } else {
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;
      }

      this.boundingBox.left = this.left;
      this.boundingBox.top = this.top;
      this.boundingBox.bottom = this.top + this.height;
      this.boundingBox.right = this.left + this.width;

      if (this.options.label !== undefined && this.labelModule.size.width > 0) {
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Image;
}(CircleImageBase);

function _createSuper$g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$g(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$g() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Square Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Square = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Square, _ShapeBase);

  var _super = _createSuper$g(Square);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Square(options, body, labelModule) {
    _classCallCheck(this, Square);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Square, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "square", 2, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Square;
}(ShapeBase);

function _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$f() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Hexagon Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Hexagon = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Hexagon, _ShapeBase);

  var _super = _createSuper$f(Hexagon);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Hexagon(options, body, labelModule) {
    _classCallCheck(this, Hexagon);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Hexagon, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "hexagon", 4, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Hexagon;
}(ShapeBase);

function _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$e() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Star Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Star = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Star, _ShapeBase);

  var _super = _createSuper$e(Star);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Star(options, body, labelModule) {
    _classCallCheck(this, Star);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Star, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "star", 4, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Star;
}(ShapeBase);

function _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$d() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A text-based replacement for the default Node shape.
 *
 * @augments NodeBase
 */

var Text = /*#__PURE__*/function (_NodeBase) {
  _inherits(Text, _NodeBase);

  var _super = _createSuper$d(Text);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Text(options, body, labelModule) {
    var _this;

    _classCallCheck(this, Text);

    _this = _super.call(this, options, body, labelModule);

    _this._setMargins(labelModule);

    return _this;
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} selected
   * @param {boolean} hover
   */


  _createClass(Text, [{
    key: "resize",
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
        this.width = this.textSize.width + this.margin.right + this.margin.left;
        this.height = this.textSize.height + this.margin.top + this.margin.bottom;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2; // draw shadow if enabled

      this.enableShadow(ctx, values);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover); // disable shadows for other elements.

      this.disableShadow(ctx, values);
      this.updateBoundingBox(x, y, ctx, selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Text;
}(NodeBase);

function _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Triangle Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var Triangle$1 = /*#__PURE__*/function (_ShapeBase) {
  _inherits(Triangle, _ShapeBase);

  var _super = _createSuper$c(Triangle);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function Triangle(options, body, labelModule) {
    _classCallCheck(this, Triangle);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x
   * @param {number} y
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(Triangle, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "triangle", 3, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return Triangle;
}(ShapeBase);

function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A downward facing Triangle Node/Cluster shape.
 *
 * @augments ShapeBase
 */

var TriangleDown = /*#__PURE__*/function (_ShapeBase) {
  _inherits(TriangleDown, _ShapeBase);

  var _super = _createSuper$b(TriangleDown);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */
  function TriangleDown(options, body, labelModule) {
    _classCallCheck(this, TriangleDown);

    return _super.call(this, options, body, labelModule);
  }
  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x
   * @param {number} y
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   * @returns {object} Callbacks to draw later on higher layers.
   */


  _createClass(TriangleDown, [{
    key: "draw",
    value: function draw(ctx, x, y, selected, hover, values) {
      return this._drawShape(ctx, "triangleDown", 3, x, y, selected, hover, values);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);

  return TriangleDown;
}(ShapeBase);

function ownKeys$2(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var _context5, _context6; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context5 = ownKeys$2(Object(source), !0)).call(_context5, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context6 = ownKeys$2(Object(source))).call(_context6, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }
/**
 * A node. A node can be connected to other nodes via one or multiple edges.
 */

var Node = /*#__PURE__*/function () {
  /**
   *
   * @param {object} options An object containing options for the node. All
   *                            options are optional, except for the id.
   *                              {number} id     Id of the node. Required
   *                              {string} label  Text label for the node
   *                              {number} x      Horizontal position of the node
   *                              {number} y      Vertical position of the node
   *                              {string} shape  Node shape
   *                              {string} image  An image url
   *                              {string} title  A title text, can be HTML
   *                              {anytype} group A group name or number
   * @param {object} body               Shared state of current network instance
   * @param {Network.Images} imagelist  A list with images. Only needed when the node has an image
   * @param {Groups} grouplist          A list with groups. Needed for retrieving group options
   * @param {object} globalOptions      Current global node options; these serve as defaults for the node instance
   * @param {object} defaultOptions     Global default options for nodes; note that this is also the prototype
   *                                    for parameter `globalOptions`.
   */
  function Node(options, body, imagelist, grouplist, globalOptions, defaultOptions) {
    _classCallCheck(this, Node);

    this.options = bridgeObject(globalOptions);
    this.globalOptions = globalOptions;
    this.defaultOptions = defaultOptions;
    this.body = body;
    this.edges = []; // all edges connected to this node
    // set defaults for the options

    this.id = undefined;
    this.imagelist = imagelist;
    this.grouplist = grouplist; // state options

    this.x = undefined;
    this.y = undefined;
    this.baseSize = this.options.size;
    this.baseFontSize = this.options.font.size;
    this.predefinedPosition = false; // used to check if initial fit should just take the range or approximate

    this.selected = false;
    this.hover = false;
    this.labelModule = new Label(this.body, this.options, false
    /* Not edge label */
    );
    this.setOptions(options);
  }
  /**
   * Attach a edge to the node
   *
   * @param {Edge} edge
   */


  _createClass(Node, [{
    key: "attachEdge",
    value: function attachEdge(edge) {
      var _context;

      if (indexOf(_context = this.edges).call(_context, edge) === -1) {
        this.edges.push(edge);
      }
    }
    /**
     * Detach a edge from the node
     *
     * @param {Edge} edge
     */

  }, {
    key: "detachEdge",
    value: function detachEdge(edge) {
      var _context2;

      var index = indexOf(_context2 = this.edges).call(_context2, edge);

      if (index != -1) {
        var _context3;

        splice$1(_context3 = this.edges).call(_context3, index, 1);
      }
    }
    /**
     * Set or overwrite options for the node
     *
     * @param {object} options an object with options
     * @returns {null|boolean}
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var currentShape = this.options.shape;

      if (!options) {
        return; // Note that the return value will be 'undefined'! This is OK.
      } // Save the color for later.
      // This is necessary in order to prevent local color from being overwritten by group color.
      // TODO: To prevent such workarounds the way options are handled should be rewritten from scratch.
      // This is not the only problem with current options handling.


      if (typeof options.color !== "undefined") {
        this._localColor = options.color;
      } // basic options


      if (options.id !== undefined) {
        this.id = options.id;
      }

      if (this.id === undefined) {
        throw new Error("Node must have an id");
      }

      Node.checkMass(options, this.id); // set these options locally
      // clear x and y positions

      if (options.x !== undefined) {
        if (options.x === null) {
          this.x = undefined;
          this.predefinedPosition = false;
        } else {
          this.x = _parseInt(options.x);
          this.predefinedPosition = true;
        }
      }

      if (options.y !== undefined) {
        if (options.y === null) {
          this.y = undefined;
          this.predefinedPosition = false;
        } else {
          this.y = _parseInt(options.y);
          this.predefinedPosition = true;
        }
      }

      if (options.size !== undefined) {
        this.baseSize = options.size;
      }

      if (options.value !== undefined) {
        options.value = _parseFloat(options.value);
      } // this transforms all shorthands into fully defined options


      Node.parseOptions(this.options, options, true, this.globalOptions, this.grouplist);
      var pile = [options, this.options, this.defaultOptions];
      this.chooser = choosify("node", pile);

      this._load_images();

      this.updateLabelModule(options); // Need to set local opacity after `this.updateLabelModule(options);` because `this.updateLabelModule(options);` overrites local opacity with group opacity

      if (options.opacity !== undefined && Node.checkOpacity(options.opacity)) {
        this.options.opacity = options.opacity;
      }

      this.updateShape(currentShape);
      return options.hidden !== undefined || options.physics !== undefined;
    }
    /**
     * Load the images from the options, for the nodes that need them.
     *
     * Images are always loaded, even if they are not used in the current shape.
     * The user may switch to an image shape later on.
     *
     * @private
     */

  }, {
    key: "_load_images",
    value: function _load_images() {
      if (this.options.shape === "circularImage" || this.options.shape === "image") {
        if (this.options.image === undefined) {
          throw new Error("Option image must be defined for node type '" + this.options.shape + "'");
        }
      }

      if (this.options.image === undefined) {
        return;
      }

      if (this.imagelist === undefined) {
        throw new Error("Internal Error: No images provided");
      }

      if (typeof this.options.image === "string") {
        this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);
      } else {
        if (this.options.image.unselected === undefined) {
          throw new Error("No unselected image provided");
        }

        this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id);

        if (this.options.image.selected !== undefined) {
          this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id);
        } else {
          this.imageObjAlt = undefined;
        }
      }
    }
    /**
     * Check that opacity is only between 0 and 1
     *
     * @param {number} opacity
     * @returns {boolean}
     */

  }, {
    key: "getFormattingValues",
    value:
    /**
     *
     * @returns {{color: *, borderWidth: *, borderColor: *, size: *, borderDashes: (boolean|Array|allOptions.nodes.shapeProperties.borderDashes|{boolean, array}), borderRadius: (number|allOptions.nodes.shapeProperties.borderRadius|{number}|Array), shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *}}
     */
    function getFormattingValues() {
      var values = {
        color: this.options.color.background,
        opacity: this.options.opacity,
        borderWidth: this.options.borderWidth,
        borderColor: this.options.color.border,
        size: this.options.size,
        borderDashes: this.options.shapeProperties.borderDashes,
        borderRadius: this.options.shapeProperties.borderRadius,
        shadow: this.options.shadow.enabled,
        shadowColor: this.options.shadow.color,
        shadowSize: this.options.shadow.size,
        shadowX: this.options.shadow.x,
        shadowY: this.options.shadow.y
      };

      if (this.selected || this.hover) {
        if (this.chooser === true) {
          if (this.selected) {
            if (this.options.borderWidthSelected != null) {
              values.borderWidth = this.options.borderWidthSelected;
            } else {
              values.borderWidth *= 2;
            }

            values.color = this.options.color.highlight.background;
            values.borderColor = this.options.color.highlight.border;
            values.shadow = this.options.shadow.enabled;
          } else if (this.hover) {
            values.color = this.options.color.hover.background;
            values.borderColor = this.options.color.hover.border;
            values.shadow = this.options.shadow.enabled;
          }
        } else if (typeof this.chooser === "function") {
          this.chooser(values, this.options.id, this.selected, this.hover);

          if (values.shadow === false) {
            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {
              values.shadow = true;
            }
          }
        }
      } else {
        values.shadow = this.options.shadow.enabled;
      }

      if (this.options.opacity !== undefined) {
        var opacity = this.options.opacity;
        values.borderColor = overrideOpacity(values.borderColor, opacity);
        values.color = overrideOpacity(values.color, opacity);
        values.shadowColor = overrideOpacity(values.shadowColor, opacity);
      }

      return values;
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "updateLabelModule",
    value: function updateLabelModule(options) {
      if (this.options.label === undefined || this.options.label === null) {
        this.options.label = "";
      }

      Node.updateGroupOptions(this.options, _objectSpread$2(_objectSpread$2({}, options), {}, {
        color: options && options.color || this._localColor || undefined
      }), this.grouplist); //
      // Note:The prototype chain for this.options is:
      //
      // this.options ->    NodesHandler.options    -> NodesHandler.defaultOptions
      //                 (also: this.globalOptions)
      //
      // Note that the prototypes are mentioned explicitly in the pile list below;
      // WE DON'T WANT THE ORDER OF THE PROTOTYPES!!!! At least, not for font handling of labels.
      // This is a good indication that the prototype usage of options is deficient.
      //

      var currentGroup = this.grouplist.get(this.options.group, false);
      var pile = [options, // new options
      this.options, // current node options, see comment above for prototype
      currentGroup, // group options, if any
      this.globalOptions, // Currently set global node options
      this.defaultOptions // Default global node options
      ];
      this.labelModule.update(this.options, pile);

      if (this.labelModule.baseSize !== undefined) {
        this.baseFontSize = this.labelModule.baseSize;
      }
    }
    /**
     *
     * @param {string} currentShape
     */

  }, {
    key: "updateShape",
    value: function updateShape(currentShape) {
      if (currentShape === this.options.shape && this.shape) {
        this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);
      } else {
        // choose draw method depending on the shape
        switch (this.options.shape) {
          case "box":
            this.shape = new Box$1(this.options, this.body, this.labelModule);
            break;

          case "circle":
            this.shape = new Circle$1(this.options, this.body, this.labelModule);
            break;

          case "circularImage":
            this.shape = new CircularImage(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
            break;

          case "custom":
            this.shape = new CustomShape(this.options, this.body, this.labelModule, this.options.ctxRenderer);
            break;

          case "database":
            this.shape = new Database(this.options, this.body, this.labelModule);
            break;

          case "diamond":
            this.shape = new Diamond$1(this.options, this.body, this.labelModule);
            break;

          case "dot":
            this.shape = new Dot(this.options, this.body, this.labelModule);
            break;

          case "ellipse":
            this.shape = new Ellipse(this.options, this.body, this.labelModule);
            break;

          case "icon":
            this.shape = new Icon(this.options, this.body, this.labelModule);
            break;

          case "image":
            this.shape = new Image$2(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
            break;

          case "square":
            this.shape = new Square(this.options, this.body, this.labelModule);
            break;

          case "hexagon":
            this.shape = new Hexagon(this.options, this.body, this.labelModule);
            break;

          case "star":
            this.shape = new Star(this.options, this.body, this.labelModule);
            break;

          case "text":
            this.shape = new Text(this.options, this.body, this.labelModule);
            break;

          case "triangle":
            this.shape = new Triangle$1(this.options, this.body, this.labelModule);
            break;

          case "triangleDown":
            this.shape = new TriangleDown(this.options, this.body, this.labelModule);
            break;

          default:
            this.shape = new Ellipse(this.options, this.body, this.labelModule);
            break;
        }
      }

      this.needsRefresh();
    }
    /**
     * select this node
     */

  }, {
    key: "select",
    value: function select() {
      this.selected = true;
      this.needsRefresh();
    }
    /**
     * unselect this node
     */

  }, {
    key: "unselect",
    value: function unselect() {
      this.selected = false;
      this.needsRefresh();
    }
    /**
     * Reset the calculated size of the node, forces it to recalculate its size
     */

  }, {
    key: "needsRefresh",
    value: function needsRefresh() {
      this.shape.refreshNeeded = true;
    }
    /**
     * get the title of this node.
     *
     * @returns {string} title    The title of the node, or undefined when no title
     *                           has been set.
     */

  }, {
    key: "getTitle",
    value: function getTitle() {
      return this.options.title;
    }
    /**
     * Calculate the distance to the border of the Node
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @param {number} angle        Angle in radians
     * @returns {number} distance   Distance to the border in pixels
     */

  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this.shape.distanceToBorder(ctx, angle);
    }
    /**
     * Check if this node has a fixed x and y position
     *
     * @returns {boolean}      true if fixed, false if not
     */

  }, {
    key: "isFixed",
    value: function isFixed() {
      return this.options.fixed.x && this.options.fixed.y;
    }
    /**
     * check if this node is selecte
     *
     * @returns {boolean} selected   True if node is selected, else false
     */

  }, {
    key: "isSelected",
    value: function isSelected() {
      return this.selected;
    }
    /**
     * Retrieve the value of the node. Can be undefined
     *
     * @returns {number} value
     */

  }, {
    key: "getValue",
    value: function getValue() {
      return this.options.value;
    }
    /**
     * Get the current dimensions of the label
     *
     * @returns {rect}
     */

  }, {
    key: "getLabelSize",
    value: function getLabelSize() {
      return this.labelModule.size();
    }
    /**
     * Adjust the value range of the node. The node will adjust it's size
     * based on its value.
     *
     * @param {number} min
     * @param {number} max
     * @param {number} total
     */

  }, {
    key: "setValueRange",
    value: function setValueRange(min, max, total) {
      if (this.options.value !== undefined) {
        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
        var sizeDiff = this.options.scaling.max - this.options.scaling.min;

        if (this.options.scaling.label.enabled === true) {
          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
        }

        this.options.size = this.options.scaling.min + scale * sizeDiff;
      } else {
        this.options.size = this.baseSize;
        this.options.font.size = this.baseFontSize;
      }

      this.updateLabelModule();
    }
    /**
     * Draw this node in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @returns {object} Callbacks to draw later on higher layers.
     */

  }, {
    key: "draw",
    value: function draw(ctx) {
      var values = this.getFormattingValues();
      return this.shape.draw(ctx, this.x, this.y, this.selected, this.hover, values) || {};
    }
    /**
     * Update the bounding box of the shape
     *
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(ctx) {
      this.shape.updateBoundingBox(this.x, this.y, ctx);
    }
    /**
     * Recalculate the size of this node in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: "resize",
    value: function resize(ctx) {
      var values = this.getFormattingValues();
      this.shape.resize(ctx, this.selected, this.hover, values);
    }
    /**
     * Determine all visual elements of this node instance, in which the given
     * point falls within the bounding shape.
     *
     * @param {point} point
     * @returns {Array.<nodeClickItem|nodeLabelClickItem>} list with the items which are on the point
     */

  }, {
    key: "getItemsOnPoint",
    value: function getItemsOnPoint(point) {
      var ret = [];

      if (this.labelModule.visible()) {
        if (pointInRect(this.labelModule.getSize(), point)) {
          ret.push({
            nodeId: this.id,
            labelId: 0
          });
        }
      }

      if (pointInRect(this.shape.boundingBox, point)) {
        ret.push({
          nodeId: this.id
        });
      }

      return ret;
    }
    /**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top, right, bottom
     * @returns {boolean}     True if location is located on node
     */

  }, {
    key: "isOverlappingWith",
    value: function isOverlappingWith(obj) {
      return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;
    }
    /**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top, right, bottom
     * @returns {boolean}     True if location is located on node
     */

  }, {
    key: "isBoundingBoxOverlappingWith",
    value: function isBoundingBoxOverlappingWith(obj) {
      return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;
    }
    /**
     * Check valid values for mass
     *
     * The mass may not be negative or zero. If it is, reset to 1
     *
     * @param {object} options
     * @param {Node.id} id
     * @static
     */

  }], [{
    key: "checkOpacity",
    value: function checkOpacity(opacity) {
      return 0 <= opacity && opacity <= 1;
    }
    /**
     * Check that origin is 'center' or 'top-left'
     *
     * @param {string} origin
     * @returns {boolean}
     */

  }, {
    key: "checkCoordinateOrigin",
    value: function checkCoordinateOrigin(origin) {
      return origin === undefined || origin === "center" || origin === "top-left";
    }
    /**
     * Copy group option values into the node options.
     *
     * The group options override the global node options, so the copy of group options
     *  must happen *after* the global node options have been set.
     *
     * This method must also be called also if the global node options have changed and the group options did not.
     *
     * @param {object} parentOptions
     * @param {object} newOptions  new values for the options, currently only passed in for check
     * @param {object} groupList
     */

  }, {
    key: "updateGroupOptions",
    value: function updateGroupOptions(parentOptions, newOptions, groupList) {
      var _context4;

      if (groupList === undefined) return; // No groups, nothing to do

      var group = parentOptions.group; // paranoia: the selected group is already merged into node options, check.

      if (newOptions !== undefined && newOptions.group !== undefined && group !== newOptions.group) {
        throw new Error("updateGroupOptions: group values in options don't match.");
      }

      var hasGroup = typeof group === "number" || typeof group === "string" && group != "";
      if (!hasGroup) return; // current node has no group, no need to merge

      var groupObj = groupList.get(group);

      if (groupObj.opacity !== undefined && newOptions.opacity === undefined) {
        if (!Node.checkOpacity(groupObj.opacity)) {
          console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + groupObj.opacity);
          groupObj.opacity = undefined;
        }
      } // Skip any new option to avoid them being overridden by the group options.


      var skipProperties = filter(_context4 = getOwnPropertyNames(newOptions)).call(_context4, function (p) {
        return newOptions[p] != null;
      }); // Always skip merging group font options into parent; these are required to be distinct for labels


      skipProperties.push("font");
      selectiveNotDeepExtend(skipProperties, parentOptions, groupObj); // the color object needs to be completely defined.
      // Since groups can partially overwrite the colors, we parse it again, just in case.

      parentOptions.color = parseColor(parentOptions.color);
    }
    /**
     * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.
     * Static so it can also be used by the handler.
     *
     * @param {object} parentOptions
     * @param {object} newOptions
     * @param {boolean} [allowDeletion=false]
     * @param {object} [globalOptions={}]
     * @param {object} [groupList]
     * @static
     */

  }, {
    key: "parseOptions",
    value: function parseOptions(parentOptions, newOptions) {
      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var groupList = arguments.length > 4 ? arguments[4] : undefined;
      var fields = ["color", "fixed", "shadow"];
      selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);
      Node.checkMass(newOptions);

      if (parentOptions.opacity !== undefined) {
        if (!Node.checkOpacity(parentOptions.opacity)) {
          console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + parentOptions.opacity);
          parentOptions.opacity = undefined;
        }
      }

      if (newOptions.opacity !== undefined) {
        if (!Node.checkOpacity(newOptions.opacity)) {
          console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + newOptions.opacity);
          newOptions.opacity = undefined;
        }
      }

      if (newOptions.shapeProperties && !Node.checkCoordinateOrigin(newOptions.shapeProperties.coordinateOrigin)) {
        console.error("Invalid option for node coordinateOrigin, found: " + newOptions.shapeProperties.coordinateOrigin);
      } // merge the shadow options into the parent.


      mergeOptions(parentOptions, newOptions, "shadow", globalOptions); // individual shape newOptions

      if (newOptions.color !== undefined && newOptions.color !== null) {
        var parsedColor = parseColor(newOptions.color);
        fillIfDefined(parentOptions.color, parsedColor);
      } else if (allowDeletion === true && newOptions.color === null) {
        parentOptions.color = bridgeObject(globalOptions.color); // set the object back to the global options
      } // handle the fixed options


      if (newOptions.fixed !== undefined && newOptions.fixed !== null) {
        if (typeof newOptions.fixed === "boolean") {
          parentOptions.fixed.x = newOptions.fixed;
          parentOptions.fixed.y = newOptions.fixed;
        } else {
          if (newOptions.fixed.x !== undefined && typeof newOptions.fixed.x === "boolean") {
            parentOptions.fixed.x = newOptions.fixed.x;
          }

          if (newOptions.fixed.y !== undefined && typeof newOptions.fixed.y === "boolean") {
            parentOptions.fixed.y = newOptions.fixed.y;
          }
        }
      }

      if (allowDeletion === true && newOptions.font === null) {
        parentOptions.font = bridgeObject(globalOptions.font); // set the object back to the global options
      }

      Node.updateGroupOptions(parentOptions, newOptions, groupList); // handle the scaling options, specifically the label part

      if (newOptions.scaling !== undefined) {
        mergeOptions(parentOptions.scaling, newOptions.scaling, "label", globalOptions.scaling);
      }
    }
  }, {
    key: "checkMass",
    value: function checkMass(options, id) {
      if (options.mass !== undefined && options.mass <= 0) {
        var strId = "";

        if (id !== undefined) {
          strId = " in node id: " + id;
        }

        console.error("%cNegative or zero mass disallowed" + strId + ", setting mass to 1.", VALIDATOR_PRINT_STYLE);
        options.mass = 1;
      }
    }
  }]);

  return Node;
}();

function _createForOfIteratorHelper$6(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$6(o, minLen) { var _context4; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$6(o, minLen); var n = slice(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }

function _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Handler for Nodes
 */

var NodesHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Images} images
   * @param {Array.<Group>} groups
   * @param {LayoutEngine} layoutEngine
   */
  function NodesHandler(body, images, groups, layoutEngine) {
    var _context,
        _this = this;

    _classCallCheck(this, NodesHandler);

    this.body = body;
    this.images = images;
    this.groups = groups;
    this.layoutEngine = layoutEngine; // create the node API in the body container

    this.body.functions.createNode = bind$6(_context = this.create).call(_context, this);
    this.nodesListeners = {
      add: function add(event, params) {
        _this.add(params.items);
      },
      update: function update(event, params) {
        _this.update(params.items, params.data, params.oldData);
      },
      remove: function remove(event, params) {
        _this.remove(params.items);
      }
    };
    this.defaultOptions = {
      borderWidth: 1,
      borderWidthSelected: undefined,
      brokenImage: undefined,
      color: {
        border: "#2B7CE9",
        background: "#97C2FC",
        highlight: {
          border: "#2B7CE9",
          background: "#D2E5FF"
        },
        hover: {
          border: "#2B7CE9",
          background: "#D2E5FF"
        }
      },
      opacity: undefined,
      // number between 0 and 1
      fixed: {
        x: false,
        y: false
      },
      font: {
        color: "#343434",
        size: 14,
        // px
        face: "arial",
        background: "none",
        strokeWidth: 0,
        // px
        strokeColor: "#ffffff",
        align: "center",
        vadjust: 0,
        multi: false,
        bold: {
          mod: "bold"
        },
        boldital: {
          mod: "bold italic"
        },
        ital: {
          mod: "italic"
        },
        mono: {
          mod: "",
          size: 15,
          // px
          face: "monospace",
          vadjust: 2
        }
      },
      group: undefined,
      hidden: false,
      icon: {
        face: "FontAwesome",
        //'FontAwesome',
        code: undefined,
        //'\uf007',
        size: 50,
        //50,
        color: "#2B7CE9" //'#aa00ff'

      },
      image: undefined,
      // --> URL
      imagePadding: {
        // only for image shape
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      },
      label: undefined,
      labelHighlightBold: true,
      level: undefined,
      margin: {
        top: 5,
        right: 5,
        bottom: 5,
        left: 5
      },
      mass: 1,
      physics: true,
      scaling: {
        min: 10,
        max: 30,
        label: {
          enabled: false,
          min: 14,
          max: 30,
          maxVisible: 30,
          drawThreshold: 5
        },
        customScalingFunction: function customScalingFunction(min, max, total, value) {
          if (max === min) {
            return 0.5;
          } else {
            var scale = 1 / (max - min);
            return Math.max(0, (value - min) * scale);
          }
        }
      },
      shadow: {
        enabled: false,
        color: "rgba(0,0,0,0.5)",
        size: 10,
        x: 5,
        y: 5
      },
      shape: "ellipse",
      shapeProperties: {
        borderDashes: false,
        // only for borders
        borderRadius: 6,
        // only for box shape
        interpolation: true,
        // only for image and circularImage shapes
        useImageSize: false,
        // only for image and circularImage shapes
        useBorderWithImage: false,
        // only for image shape
        coordinateOrigin: "center" // only for image and circularImage shapes

      },
      size: 25,
      title: undefined,
      value: undefined,
      x: undefined,
      y: undefined
    }; // Protect from idiocy

    if (this.defaultOptions.mass <= 0) {
      throw "Internal error: mass in defaultOptions of NodesHandler may not be zero or negative";
    }

    this.options = bridgeObject(this.defaultOptions);
    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(NodesHandler, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _context2,
          _context3,
          _this2 = this;

      // refresh the nodes. Used when reverting from hierarchical layout
      this.body.emitter.on("refreshNodes", bind$6(_context2 = this.refresh).call(_context2, this));
      this.body.emitter.on("refresh", bind$6(_context3 = this.refresh).call(_context3, this));
      this.body.emitter.on("destroy", function () {
        forEach$1(_this2.nodesListeners, function (callback, event) {
          if (_this2.body.data.nodes) _this2.body.data.nodes.off(event, callback);
        });
        delete _this2.body.functions.createNode;
        delete _this2.nodesListeners.add;
        delete _this2.nodesListeners.update;
        delete _this2.nodesListeners.remove;
        delete _this2.nodesListeners;
      });
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        Node.parseOptions(this.options, options); // Need to set opacity here because Node.parseOptions is also used for groups,
        // if you set opacity in Node.parseOptions it overwrites group opacity.

        if (options.opacity !== undefined) {
          if (isNan(options.opacity) || !_isFinite(options.opacity) || options.opacity < 0 || options.opacity > 1) {
            console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + options.opacity);
          } else {
            this.options.opacity = options.opacity;
          }
        } // update the shape in all nodes


        if (options.shape !== undefined) {
          for (var nodeId in this.body.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
              this.body.nodes[nodeId].updateShape();
            }
          }
        } // Update the labels of nodes if any relevant options changed.


        if (typeof options.font !== "undefined" || typeof options.widthConstraint !== "undefined" || typeof options.heightConstraint !== "undefined") {
          for (var _i = 0, _Object$keys = keys$4(this.body.nodes); _i < _Object$keys.length; _i++) {
            var _nodeId = _Object$keys[_i];

            this.body.nodes[_nodeId].updateLabelModule();

            this.body.nodes[_nodeId].needsRefresh();
          }
        } // update the shape size in all nodes


        if (options.size !== undefined) {
          for (var _nodeId2 in this.body.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {
              this.body.nodes[_nodeId2].needsRefresh();
            }
          }
        } // update the state of the variables if needed


        if (options.hidden !== undefined || options.physics !== undefined) {
          this.body.emitter.emit("_dataChanged");
        }
      }
    }
    /**
     * Set a data set with nodes for the network
     *
     * @param {Array | DataSet | DataView} nodes         The data containing the nodes.
     * @param {boolean} [doNotEmit=false] - Suppress data changed event.
     * @private
     */

  }, {
    key: "setData",
    value: function setData(nodes) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var oldNodesData = this.body.data.nodes;

      if (isDataViewLike("id", nodes)) {
        this.body.data.nodes = nodes;
      } else if (isArray$2(nodes)) {
        this.body.data.nodes = new DataSet();
        this.body.data.nodes.add(nodes);
      } else if (!nodes) {
        this.body.data.nodes = new DataSet();
      } else {
        throw new TypeError("Array or DataSet expected");
      }

      if (oldNodesData) {
        // unsubscribe from old dataset
        forEach$1(this.nodesListeners, function (callback, event) {
          oldNodesData.off(event, callback);
        });
      } // remove drawn nodes


      this.body.nodes = {};

      if (this.body.data.nodes) {
        // subscribe to new dataset
        var me = this;
        forEach$1(this.nodesListeners, function (callback, event) {
          me.body.data.nodes.on(event, callback);
        }); // draw all new nodes

        var ids = this.body.data.nodes.getIds();
        this.add(ids, true);
      }

      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Add nodes
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [doNotEmit=false]
     * @private
     */

  }, {
    key: "add",
    value: function add(ids) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var id;
      var newNodes = [];

      for (var i = 0; i < ids.length; i++) {
        id = ids[i];
        var properties = this.body.data.nodes.get(id);
        var node = this.create(properties);
        newNodes.push(node);
        this.body.nodes[id] = node; // note: this may replace an existing node
      }

      this.layoutEngine.positionInitially(newNodes);

      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Update existing nodes, or create them when not yet existing
     *
     * @param {number[] | string[]} ids id's of changed nodes
     * @param {Array} changedData array with changed data
     * @param {Array|undefined} oldData optional; array with previous data
     * @private
     */

  }, {
    key: "update",
    value: function update(ids, changedData, oldData) {
      var nodes = this.body.nodes;
      var dataChanged = false;

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var node = nodes[id];
        var data = changedData[i];

        if (node !== undefined) {
          // update node
          if (node.setOptions(data)) {
            dataChanged = true;
          }
        } else {
          dataChanged = true; // create node

          node = this.create(data);
          nodes[id] = node;
        }
      }

      if (!dataChanged && oldData !== undefined) {
        // Check for any changes which should trigger a layout recalculation
        // For now, this is just 'level' for hierarchical layout
        // Assumption: old and new data arranged in same order; at time of writing, this holds.
        dataChanged = some(changedData).call(changedData, function (newValue, index) {
          var oldValue = oldData[index];
          return oldValue && oldValue.level !== newValue.level;
        });
      }

      if (dataChanged === true) {
        this.body.emitter.emit("_dataChanged");
      } else {
        this.body.emitter.emit("_dataUpdated");
      }
    }
    /**
     * Remove existing nodes. If nodes do not exist, the method will just ignore it.
     *
     * @param {number[] | string[]} ids
     * @private
     */

  }, {
    key: "remove",
    value: function remove(ids) {
      var nodes = this.body.nodes;

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        delete nodes[id];
      }

      this.body.emitter.emit("_dataChanged");
    }
    /**
     * create a node
     *
     * @param {object} properties
     * @param {class} [constructorClass=Node.default]
     * @returns {*}
     */

  }, {
    key: "create",
    value: function create(properties) {
      var constructorClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Node;
      return new constructorClass(properties, this.body, this.images, this.groups, this.options, this.defaultOptions);
    }
    /**
     *
     * @param {boolean} [clearPositions=false]
     */

  }, {
    key: "refresh",
    value: function refresh() {
      var _this3 = this;

      var clearPositions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      forEach$1(this.body.nodes, function (node, nodeId) {
        var data = _this3.body.data.nodes.get(nodeId);

        if (data !== undefined) {
          if (clearPositions === true) {
            node.setOptions({
              x: null,
              y: null
            });
          }

          node.setOptions({
            fixed: false
          });
          node.setOptions(data);
        }
      });
    }
    /**
     * Returns the positions of the nodes.
     *
     * @param {Array.<Node.id> | string} [ids]  --> optional, can be array of nodeIds, can be string
     * @returns {{}}
     */

  }, {
    key: "getPositions",
    value: function getPositions(ids) {
      var dataArray = {};

      if (ids !== undefined) {
        if (isArray$2(ids) === true) {
          for (var i = 0; i < ids.length; i++) {
            if (this.body.nodes[ids[i]] !== undefined) {
              var node = this.body.nodes[ids[i]];
              dataArray[ids[i]] = {
                x: Math.round(node.x),
                y: Math.round(node.y)
              };
            }
          }
        } else {
          if (this.body.nodes[ids] !== undefined) {
            var _node = this.body.nodes[ids];
            dataArray[ids] = {
              x: Math.round(_node.x),
              y: Math.round(_node.y)
            };
          }
        }
      } else {
        for (var _i2 = 0; _i2 < this.body.nodeIndices.length; _i2++) {
          var _node2 = this.body.nodes[this.body.nodeIndices[_i2]];
          dataArray[this.body.nodeIndices[_i2]] = {
            x: Math.round(_node2.x),
            y: Math.round(_node2.y)
          };
        }
      }

      return dataArray;
    }
    /**
     * Retrieves the x y position of a specific id.
     *
     * @param {string} id The id to retrieve.
     * @throws {TypeError} If no id is included.
     * @throws {ReferenceError} If an invalid id is provided.
     * @returns {{ x: number, y: number }} Returns X, Y canvas position of the node with given id.
     */

  }, {
    key: "getPosition",
    value: function getPosition(id) {
      if (id == undefined) {
        throw new TypeError("No id was specified for getPosition method.");
      } else if (this.body.nodes[id] == undefined) {
        throw new ReferenceError("NodeId provided for getPosition does not exist. Provided: ".concat(id));
      } else {
        return {
          x: Math.round(this.body.nodes[id].x),
          y: Math.round(this.body.nodes[id].y)
        };
      }
    }
    /**
     * Load the XY positions of the nodes into the dataset.
     */

  }, {
    key: "storePositions",
    value: function storePositions() {
      // todo: add support for clusters and hierarchical.
      var dataArray = [];
      var dataset = this.body.data.nodes.getDataSet();

      var _iterator = _createForOfIteratorHelper$6(dataset.get()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var dsNode = _step.value;
          var id = dsNode.id;
          var bodyNode = this.body.nodes[id];
          var x = Math.round(bodyNode.x);
          var y = Math.round(bodyNode.y);

          if (dsNode.x !== x || dsNode.y !== y) {
            dataArray.push({
              id: id,
              x: x,
              y: y
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      dataset.update(dataArray);
    }
    /**
     * get the bounding box of a node.
     *
     * @param {Node.id} nodeId
     * @returns {j|*}
     */

  }, {
    key: "getBoundingBox",
    value: function getBoundingBox(nodeId) {
      if (this.body.nodes[nodeId] !== undefined) {
        return this.body.nodes[nodeId].shape.boundingBox;
      }
    }
    /**
     * Get the Ids of nodes connected to this node.
     *
     * @param {Node.id} nodeId
     * @param {'to'|'from'|undefined} direction values 'from' and 'to' select respectively parent and child nodes only.
     *                                          Any other value returns both parent and child nodes.
     * @returns {Array}
     */

  }, {
    key: "getConnectedNodes",
    value: function getConnectedNodes(nodeId, direction) {
      var nodeList = [];

      if (this.body.nodes[nodeId] !== undefined) {
        var node = this.body.nodes[nodeId];
        var nodeObj = {}; // used to quickly check if node already exists

        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];

          if (direction !== "to" && edge.toId == node.id) {
            // these are double equals since ids can be numeric or string
            if (nodeObj[edge.fromId] === undefined) {
              nodeList.push(edge.fromId);
              nodeObj[edge.fromId] = true;
            }
          } else if (direction !== "from" && edge.fromId == node.id) {
            // these are double equals since ids can be numeric or string
            if (nodeObj[edge.toId] === undefined) {
              nodeList.push(edge.toId);
              nodeObj[edge.toId] = true;
            }
          }
        }
      }

      return nodeList;
    }
    /**
     * Get the ids of the edges connected to this node.
     *
     * @param {Node.id} nodeId
     * @returns {*}
     */

  }, {
    key: "getConnectedEdges",
    value: function getConnectedEdges(nodeId) {
      var edgeList = [];

      if (this.body.nodes[nodeId] !== undefined) {
        var node = this.body.nodes[nodeId];

        for (var i = 0; i < node.edges.length; i++) {
          edgeList.push(node.edges[i].id);
        }
      } else {
        console.error("NodeId provided for getConnectedEdges does not exist. Provided: ", nodeId);
      }

      return edgeList;
    }
    /**
     * Move a node.
     *
     * @param {Node.id} nodeId
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: "moveNode",
    value: function moveNode(nodeId, x, y) {
      var _this4 = this;

      if (this.body.nodes[nodeId] !== undefined) {
        this.body.nodes[nodeId].x = Number(x);
        this.body.nodes[nodeId].y = Number(y);

        setTimeout$1(function () {
          _this4.body.emitter.emit("startSimulation");
        }, 0);
      } else {
        console.error("Node id supplied to moveNode does not exist. Provided: ", nodeId);
      }
    }
  }]);

  return NodesHandler;
}();

var hasOwn$1 = hasOwnProperty_1;

var isDataDescriptor$1 = function (descriptor) {
  return descriptor !== undefined && (hasOwn$1(descriptor, 'value') || hasOwn$1(descriptor, 'writable'));
};

var $$2 = _export;
var call = functionCall;
var isObject$2 = isObject$j;
var anObject$1 = anObject$d;
var isDataDescriptor = isDataDescriptor$1;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var getPrototypeOf = objectGetPrototypeOf; // `Reflect.get` method
// https://tc39.es/ecma262/#sec-reflect.get

function get$5(target, propertyKey
/* , receiver */
) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject$1(target) === receiver) return target[propertyKey];
  descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
  if (descriptor) return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === undefined ? undefined : call(descriptor.get, receiver);
  if (isObject$2(prototype = getPrototypeOf(target))) return get$5(prototype, propertyKey, receiver);
}

$$2({
  target: 'Reflect',
  stat: true
}, {
  get: get$5
});

var path$3 = path$y;
var get$4 = path$3.Reflect.get;

var parent$7 = get$4;
var get$3 = parent$7;

var parent$6 = get$3;
var get$2 = parent$6;

var parent$5 = get$2;
var get$1 = parent$5;

var get = get$1;

var parent$4 = getOwnPropertyDescriptor$4;
var getOwnPropertyDescriptor$2 = parent$4;

var parent$3 = getOwnPropertyDescriptor$2;
var getOwnPropertyDescriptor$1 = parent$3;

var getOwnPropertyDescriptor = getOwnPropertyDescriptor$1;

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get() {
  if (typeof Reflect !== "undefined" && get) {
    _get = get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;

      var desc = getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    };
  }

  return _get.apply(this, arguments);
}

var $$1 = _export; // eslint-disable-next-line es/no-math-hypot -- required for testing

var $hypot = Math.hypot;
var abs = Math.abs;
var sqrt = Math.sqrt; // Chrome 77 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=9546

var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity; // `Math.hypot` method
// https://tc39.es/ecma262/#sec-math.hypot

$$1({
  target: 'Math',
  stat: true,
  forced: BUGGY
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  hypot: function hypot(value1, value2) {
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;

    while (i < aLen) {
      arg = abs(arguments[i++]);

      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }

    return larg === Infinity ? Infinity : larg * sqrt(sum);
  }
});

var path$2 = path$y;
var hypot$2 = path$2.Math.hypot;

var parent$2 = hypot$2;
var hypot$1 = parent$2;

var hypot = hypot$1;

function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Common methods for endpoints
 *
 * @class
 */

var EndPoint = /*#__PURE__*/function () {
  function EndPoint() {
    _classCallCheck(this, EndPoint);
  }

  _createClass(EndPoint, null, [{
    key: "transform",
    value:
    /**
     * Apply transformation on points for display.
     *
     * The following is done:
     * - rotate by the specified angle
     * - multiply the (normalized) coordinates by the passed length
     * - offset by the target coordinates
     *
     * @param points - The point(s) to be transformed.
     * @param arrowData - The data determining the result of the transformation.
     */
    function transform(points, arrowData) {
      if (!isArray$2(points)) {
        points = [points];
      }

      var x = arrowData.point.x;
      var y = arrowData.point.y;
      var angle = arrowData.angle;
      var length = arrowData.length;

      for (var i = 0; i < points.length; ++i) {
        var p = points[i];
        var xt = p.x * Math.cos(angle) - p.y * Math.sin(angle);
        var yt = p.x * Math.sin(angle) + p.y * Math.cos(angle);
        p.x = x + length * xt;
        p.y = y + length * yt;
      }
    }
    /**
     * Draw a closed path using the given real coordinates.
     *
     * @param ctx - The path will be rendered into this context.
     * @param points - The points of the path.
     */

  }, {
    key: "drawPath",
    value: function drawPath(ctx, points) {
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);

      for (var i = 1; i < points.length; ++i) {
        ctx.lineTo(points[i].x, points[i].y);
      }

      ctx.closePath();
    }
  }]);

  return EndPoint;
}();
/**
 * Drawing methods for the arrow endpoint.
 */


var Image$1 = /*#__PURE__*/function (_EndPoint) {
  _inherits(Image, _EndPoint);

  var _super = _createSuper$a(Image);

  function Image() {
    _classCallCheck(this, Image);

    return _super.apply(this, arguments);
  }

  _createClass(Image, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns False as there is no way to fill an image.
     */
    function draw(ctx, arrowData) {
      if (arrowData.image) {
        ctx.save();
        ctx.translate(arrowData.point.x, arrowData.point.y);
        ctx.rotate(Math.PI / 2 + arrowData.angle);
        var width = arrowData.imageWidth != null ? arrowData.imageWidth : arrowData.image.width;
        var height = arrowData.imageHeight != null ? arrowData.imageHeight : arrowData.image.height;
        arrowData.image.drawImageAtPosition(ctx, 1, // scale
        -width / 2, // x
        0, // y
        width, height);
        ctx.restore();
      }

      return false;
    }
  }]);

  return Image;
}(EndPoint);
/**
 * Drawing methods for the arrow endpoint.
 */


var Arrow = /*#__PURE__*/function (_EndPoint2) {
  _inherits(Arrow, _EndPoint2);

  var _super2 = _createSuper$a(Arrow);

  function Arrow() {
    _classCallCheck(this, Arrow);

    return _super2.apply(this, arguments);
  }

  _createClass(Arrow, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: 0,
        y: 0
      }, {
        x: -1,
        y: 0.3
      }, {
        x: -0.9,
        y: 0
      }, {
        x: -1,
        y: -0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Arrow;
}(EndPoint);
/**
 * Drawing methods for the crow endpoint.
 */


var Crow = /*#__PURE__*/function () {
  function Crow() {
    _classCallCheck(this, Crow);
  }

  _createClass(Crow, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: -1,
        y: 0
      }, {
        x: 0,
        y: 0.3
      }, {
        x: -0.4,
        y: 0
      }, {
        x: 0,
        y: -0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Crow;
}();
/**
 * Drawing methods for the curve endpoint.
 */


var Curve = /*#__PURE__*/function () {
  function Curve() {
    _classCallCheck(this, Curve);
  }

  _createClass(Curve, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var point = {
        x: -0.4,
        y: 0
      };
      EndPoint.transform(point, arrowData); // Update endpoint style for drawing transparent arc.

      ctx.strokeStyle = ctx.fillStyle;
      ctx.fillStyle = "rgba(0, 0, 0, 0)"; // Define curve endpoint as semicircle.

      var pi = Math.PI;
      var startAngle = arrowData.angle - pi / 2;
      var endAngle = arrowData.angle + pi / 2;
      ctx.beginPath();
      ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);
      ctx.stroke();
      return true;
    }
  }]);

  return Curve;
}();
/**
 * Drawing methods for the inverted curve endpoint.
 */


var InvertedCurve = /*#__PURE__*/function () {
  function InvertedCurve() {
    _classCallCheck(this, InvertedCurve);
  }

  _createClass(InvertedCurve, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var point = {
        x: -0.3,
        y: 0
      };
      EndPoint.transform(point, arrowData); // Update endpoint style for drawing transparent arc.

      ctx.strokeStyle = ctx.fillStyle;
      ctx.fillStyle = "rgba(0, 0, 0, 0)"; // Define inverted curve endpoint as semicircle.

      var pi = Math.PI;
      var startAngle = arrowData.angle + pi / 2;
      var endAngle = arrowData.angle + 3 * pi / 2;
      ctx.beginPath();
      ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);
      ctx.stroke();
      return true;
    }
  }]);

  return InvertedCurve;
}();
/**
 * Drawing methods for the trinagle endpoint.
 */


var Triangle = /*#__PURE__*/function () {
  function Triangle() {
    _classCallCheck(this, Triangle);
  }

  _createClass(Triangle, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: 0.02,
        y: 0
      }, {
        x: -1,
        y: 0.3
      }, {
        x: -1,
        y: -0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Triangle;
}();
/**
 * Drawing methods for the inverted trinagle endpoint.
 */


var InvertedTriangle = /*#__PURE__*/function () {
  function InvertedTriangle() {
    _classCallCheck(this, InvertedTriangle);
  }

  _createClass(InvertedTriangle, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: 0,
        y: 0.3
      }, {
        x: 0,
        y: -0.3
      }, {
        x: -1,
        y: 0
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return InvertedTriangle;
}();
/**
 * Drawing methods for the circle endpoint.
 */


var Circle = /*#__PURE__*/function () {
  function Circle() {
    _classCallCheck(this, Circle);
  }

  _createClass(Circle, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      var point = {
        x: -0.4,
        y: 0
      };
      EndPoint.transform(point, arrowData);
      drawCircle(ctx, point.x, point.y, arrowData.length * 0.4);
      return true;
    }
  }]);

  return Circle;
}();
/**
 * Drawing methods for the bar endpoint.
 */


var Bar = /*#__PURE__*/function () {
  function Bar() {
    _classCallCheck(this, Bar);
  }

  _createClass(Bar, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      /*
      var points = [
        {x:0, y:0.5},
        {x:0, y:-0.5}
      ];
           EndPoint.transform(points, arrowData);
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      ctx.lineTo(points[1].x, points[1].y);
      ctx.stroke();
      */
      var points = [{
        x: 0,
        y: 0.5
      }, {
        x: 0,
        y: -0.5
      }, {
        x: -0.15,
        y: -0.5
      }, {
        x: -0.15,
        y: 0.5
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Bar;
}();
/**
 * Drawing methods for the box endpoint.
 */


var Box = /*#__PURE__*/function () {
  function Box() {
    _classCallCheck(this, Box);
  }

  _createClass(Box, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      var points = [{
        x: 0,
        y: 0.3
      }, {
        x: 0,
        y: -0.3
      }, {
        x: -0.6,
        y: -0.3
      }, {
        x: -0.6,
        y: 0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Box;
}();
/**
 * Drawing methods for the diamond endpoint.
 */


var Diamond = /*#__PURE__*/function () {
  function Diamond() {
    _classCallCheck(this, Diamond);
  }

  _createClass(Diamond, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      var points = [{
        x: 0,
        y: 0
      }, {
        x: -0.5,
        y: -0.3
      }, {
        x: -1,
        y: 0
      }, {
        x: -0.5,
        y: 0.3
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Diamond;
}();
/**
 * Drawing methods for the vee endpoint.
 */


var Vee = /*#__PURE__*/function () {
  function Vee() {
    _classCallCheck(this, Vee);
  }

  _createClass(Vee, null, [{
    key: "draw",
    value:
    /**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True because ctx.fill() can be used to fill the arrow.
     */
    function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{
        x: -1,
        y: 0.3
      }, {
        x: -0.5,
        y: 0
      }, {
        x: -1,
        y: -0.3
      }, {
        x: 0,
        y: 0
      }];
      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
      return true;
    }
  }]);

  return Vee;
}();
/**
 * Drawing methods for the endpoints.
 */


var EndPoints = /*#__PURE__*/function () {
  function EndPoints() {
    _classCallCheck(this, EndPoints);
  }

  _createClass(EndPoints, null, [{
    key: "draw",
    value:
    /**
     * Draw an endpoint.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     * @returns True if ctx.fill() can be used to fill the arrow, false otherwise.
     */
    function draw(ctx, arrowData) {
      var type;

      if (arrowData.type) {
        type = arrowData.type.toLowerCase();
      }

      switch (type) {
        case "image":
          return Image$1.draw(ctx, arrowData);

        case "circle":
          return Circle.draw(ctx, arrowData);

        case "box":
          return Box.draw(ctx, arrowData);

        case "crow":
          return Crow.draw(ctx, arrowData);

        case "curve":
          return Curve.draw(ctx, arrowData);

        case "diamond":
          return Diamond.draw(ctx, arrowData);

        case "inv_curve":
          return InvertedCurve.draw(ctx, arrowData);

        case "triangle":
          return Triangle.draw(ctx, arrowData);

        case "inv_triangle":
          return InvertedTriangle.draw(ctx, arrowData);

        case "bar":
          return Bar.draw(ctx, arrowData);

        case "vee":
          return Vee.draw(ctx, arrowData);

        case "arrow": // fall-through

        default:
          return Arrow.draw(ctx, arrowData);
      }
    }
  }]);

  return EndPoints;
}();

function ownKeys$1(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var _context2, _context3; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context2 = ownKeys$1(Object(source), !0)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context3 = ownKeys$1(Object(source))).call(_context3, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }
/**
 * The Base Class for all edges.
 */

var EdgeBase = /*#__PURE__*/function () {
  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param _body - The body of the network.
   * @param _labelModule - Label module.
   */
  function EdgeBase(options, _body, _labelModule) {
    _classCallCheck(this, EdgeBase);

    this._body = _body;
    this._labelModule = _labelModule;
    this.color = {};
    this.colorDirty = true;
    this.hoverWidth = 1.5;
    this.selectionWidth = 2;
    this.setOptions(options);
    this.fromPoint = this.from;
    this.toPoint = this.to;
  }
  /** @inheritDoc */


  _createClass(EdgeBase, [{
    key: "connect",
    value: function connect() {
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to];
    }
    /** @inheritDoc */

  }, {
    key: "cleanup",
    value: function cleanup() {
      return false;
    }
    /**
     * Set new edge options.
     *
     * @param options - The new edge options object.
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to];
      this.id = this.options.id;
    }
    /** @inheritDoc */

  }, {
    key: "drawLine",
    value: function drawLine(ctx, values, _selected, _hover) {
      var viaNode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.getViaNode();
      // set style
      ctx.strokeStyle = this.getColor(ctx, values);
      ctx.lineWidth = values.width;

      if (values.dashes !== false) {
        this._drawDashedLine(ctx, values, viaNode);
      } else {
        this._drawLine(ctx, values, viaNode);
      }
    }
    /**
     * Draw a line with given style between two nodes through supplied node(s).
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param viaNode - Additional control point(s) for the edge.
     * @param fromPoint - TODO: Seems ignored, remove?
     * @param toPoint - TODO: Seems ignored, remove?
     */

  }, {
    key: "_drawLine",
    value: function _drawLine(ctx, values, viaNode, fromPoint, toPoint) {
      if (this.from != this.to) {
        // draw line
        this._line(ctx, values, viaNode, fromPoint, toPoint);
      } else {
        var _this$_getCircleData = this._getCircleData(ctx),
            _this$_getCircleData2 = _slicedToArray(_this$_getCircleData, 3),
            x = _this$_getCircleData2[0],
            y = _this$_getCircleData2[1],
            radius = _this$_getCircleData2[2];

        this._circle(ctx, values, x, y, radius);
      }
    }
    /**
     * Draw a dashed line with given style between two nodes through supplied node(s).
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param viaNode - Additional control point(s) for the edge.
     * @param _fromPoint - Ignored (TODO: remove in the future).
     * @param _toPoint - Ignored (TODO: remove in the future).
     */

  }, {
    key: "_drawDashedLine",
    value: function _drawDashedLine(ctx, values, viaNode, _fromPoint, _toPoint) {
      ctx.lineCap = "round";
      var pattern = isArray$2(values.dashes) ? values.dashes : [5, 5]; // only firefox and chrome support this method, else we use the legacy one.

      if (ctx.setLineDash !== undefined) {
        ctx.save(); // set dash settings for chrome or firefox

        ctx.setLineDash(pattern);
        ctx.lineDashOffset = 0; // draw the line

        if (this.from != this.to) {
          // draw line
          this._line(ctx, values, viaNode);
        } else {
          var _this$_getCircleData3 = this._getCircleData(ctx),
              _this$_getCircleData4 = _slicedToArray(_this$_getCircleData3, 3),
              x = _this$_getCircleData4[0],
              y = _this$_getCircleData4[1],
              radius = _this$_getCircleData4[2];

          this._circle(ctx, values, x, y, radius);
        } // restore the dash settings.


        ctx.setLineDash([0]);
        ctx.lineDashOffset = 0;
        ctx.restore();
      } else {
        // unsupporting smooth lines
        if (this.from != this.to) {
          // draw line
          drawDashedLine(ctx, this.from.x, this.from.y, this.to.x, this.to.y, pattern);
        } else {
          var _this$_getCircleData5 = this._getCircleData(ctx),
              _this$_getCircleData6 = _slicedToArray(_this$_getCircleData5, 3),
              _x = _this$_getCircleData6[0],
              _y = _this$_getCircleData6[1],
              _radius = _this$_getCircleData6[2];

          this._circle(ctx, values, _x, _y, _radius);
        } // draw shadow if enabled


        this.enableShadow(ctx, values);
        ctx.stroke(); // disable shadows for other elements.

        this.disableShadow(ctx, values);
      }
    }
    /**
     * Find the intersection between the border of the node and the edge.
     *
     * @param node - The node (either from or to node of the edge).
     * @param ctx - The context that will be used for rendering.
     * @param options - Additional options.
     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
     */

  }, {
    key: "findBorderPosition",
    value: function findBorderPosition(node, ctx, options) {
      if (this.from != this.to) {
        return this._findBorderPosition(node, ctx, options);
      } else {
        return this._findBorderPositionCircle(node, ctx, options);
      }
    }
    /** @inheritDoc */

  }, {
    key: "findBorderPositions",
    value: function findBorderPositions(ctx) {
      if (this.from != this.to) {
        return {
          from: this._findBorderPosition(this.from, ctx),
          to: this._findBorderPosition(this.to, ctx)
        };
      } else {
        var _context;

        var _this$_getCircleData$ = slice(_context = this._getCircleData(ctx)).call(_context, 0, 2),
            _this$_getCircleData$2 = _slicedToArray(_this$_getCircleData$, 2),
            x = _this$_getCircleData$2[0],
            y = _this$_getCircleData$2[1];

        return {
          from: this._findBorderPositionCircle(this.from, ctx, {
            x: x,
            y: y,
            low: 0.25,
            high: 0.6,
            direction: -1
          }),
          to: this._findBorderPositionCircle(this.from, ctx, {
            x: x,
            y: y,
            low: 0.6,
            high: 0.8,
            direction: 1
          })
        };
      }
    }
    /**
     * Compute the center point and radius of an edge connected to the same node at both ends.
     *
     * @param ctx - The context that will be used for rendering.
     * @returns `[x, y, radius]`
     */

  }, {
    key: "_getCircleData",
    value: function _getCircleData(ctx) {
      var radius = this.options.selfReference.size;

      if (ctx !== undefined) {
        if (this.from.shape.width === undefined) {
          this.from.shape.resize(ctx);
        }
      } // get circle coordinates


      var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, radius, this.from);
      return [coordinates.x, coordinates.y, radius];
    }
    /**
     * Get a point on a circle.
     *
     * @param x - Center of the circle on the x axis.
     * @param y - Center of the circle on the y axis.
     * @param radius - Radius of the circle.
     * @param position - Value between 0 (line start) and 1 (line end).
     * @returns Cartesian coordinates of requested point on the circle.
     */

  }, {
    key: "_pointOnCircle",
    value: function _pointOnCircle(x, y, radius, position) {
      var angle = position * 2 * Math.PI;
      return {
        x: x + radius * Math.cos(angle),
        y: y - radius * Math.sin(angle)
      };
    }
    /**
     * Find the intersection between the border of the node and the edge.
     *
     * @remarks
     * This function uses binary search to look for the point where the circle crosses the border of the node.
     * @param nearNode - The node (either from or to node of the edge).
     * @param ctx - The context that will be used for rendering.
     * @param options - Additional options.
     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
     */

  }, {
    key: "_findBorderPositionCircle",
    value: function _findBorderPositionCircle(nearNode, ctx, options) {
      var x = options.x;
      var y = options.y;
      var low = options.low;
      var high = options.high;
      var direction = options.direction;
      var maxIterations = 10;
      var radius = this.options.selfReference.size;
      var threshold = 0.05;
      var pos;
      var middle = (low + high) * 0.5;
      var endPointOffset = 0;

      if (this.options.arrowStrikethrough === true) {
        if (direction === -1) {
          endPointOffset = this.options.endPointOffset.from;
        } else if (direction === 1) {
          endPointOffset = this.options.endPointOffset.to;
        }
      }

      var iteration = 0;

      do {
        middle = (low + high) * 0.5;
        pos = this._pointOnCircle(x, y, radius, middle);
        var angle = Math.atan2(nearNode.y - pos.y, nearNode.x - pos.x);
        var distanceToBorder = nearNode.distanceToBorder(ctx, angle) + endPointOffset;
        var distanceToPoint = Math.sqrt(Math.pow(pos.x - nearNode.x, 2) + Math.pow(pos.y - nearNode.y, 2));
        var difference = distanceToBorder - distanceToPoint;

        if (Math.abs(difference) < threshold) {
          break; // found
        } else if (difference > 0) {
          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
          if (direction > 0) {
            low = middle;
          } else {
            high = middle;
          }
        } else {
          if (direction > 0) {
            high = middle;
          } else {
            low = middle;
          }
        }

        ++iteration;
      } while (low <= high && iteration < maxIterations);

      return _objectSpread$1(_objectSpread$1({}, pos), {}, {
        t: middle
      });
    }
    /**
     * Get the line width of the edge. Depends on width and whether one of the connected nodes is selected.
     *
     * @param selected - Determines wheter the line is selected.
     * @param hover - Determines wheter the line is being hovered, only applies if selected is false.
     * @returns The width of the line.
     */

  }, {
    key: "getLineWidth",
    value: function getLineWidth(selected, hover) {
      if (selected === true) {
        return Math.max(this.selectionWidth, 0.3 / this._body.view.scale);
      } else if (hover === true) {
        return Math.max(this.hoverWidth, 0.3 / this._body.view.scale);
      } else {
        return Math.max(this.options.width, 0.3 / this._body.view.scale);
      }
    }
    /**
     * Compute the color or gradient for given edge.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param _selected - Ignored (TODO: remove in the future).
     * @param _hover - Ignored (TODO: remove in the future).
     * @returns Color string if single color is inherited or gradient if two.
     */

  }, {
    key: "getColor",
    value: function getColor(ctx, values) {
      if (values.inheritsColor !== false) {
        // when this is a loop edge, just use the 'from' method
        if (values.inheritsColor === "both" && this.from.id !== this.to.id) {
          var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);
          var fromColor = this.from.options.color.highlight.border;
          var toColor = this.to.options.color.highlight.border;

          if (this.from.selected === false && this.to.selected === false) {
            fromColor = overrideOpacity(this.from.options.color.border, values.opacity);
            toColor = overrideOpacity(this.to.options.color.border, values.opacity);
          } else if (this.from.selected === true && this.to.selected === false) {
            toColor = this.to.options.color.border;
          } else if (this.from.selected === false && this.to.selected === true) {
            fromColor = this.from.options.color.border;
          }

          grd.addColorStop(0, fromColor);
          grd.addColorStop(1, toColor); // -------------------- this returns -------------------- //

          return grd;
        }

        if (values.inheritsColor === "to") {
          return overrideOpacity(this.to.options.color.border, values.opacity);
        } else {
          // "from"
          return overrideOpacity(this.from.options.color.border, values.opacity);
        }
      } else {
        return overrideOpacity(values.color, values.opacity);
      }
    }
    /**
     * Draw a line from a node to itself, a circle.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param x - Center of the circle on the x axis.
     * @param y - Center of the circle on the y axis.
     * @param radius - Radius of the circle.
     */

  }, {
    key: "_circle",
    value: function _circle(ctx, values, x, y, radius) {
      // draw shadow if enabled
      this.enableShadow(ctx, values); //full circle

      var angleFrom = 0;
      var angleTo = Math.PI * 2;

      if (!this.options.selfReference.renderBehindTheNode) {
        //render only parts which are not overlaping with parent node
        //need to find x,y of from point and x,y to point
        //calculating radians
        var low = this.options.selfReference.angle;
        var high = this.options.selfReference.angle + Math.PI;

        var pointTFrom = this._findBorderPositionCircle(this.from, ctx, {
          x: x,
          y: y,
          low: low,
          high: high,
          direction: -1
        });

        var pointTTo = this._findBorderPositionCircle(this.from, ctx, {
          x: x,
          y: y,
          low: low,
          high: high,
          direction: 1
        });

        angleFrom = Math.atan2(pointTFrom.y - y, pointTFrom.x - x);
        angleTo = Math.atan2(pointTTo.y - y, pointTTo.x - x);
      } // draw a circle


      ctx.beginPath();
      ctx.arc(x, y, radius, angleFrom, angleTo, false);
      ctx.stroke(); // disable shadows for other elements.

      this.disableShadow(ctx, values);
    }
    /**
     * @inheritDoc
     * @remarks
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     */

  }, {
    key: "getDistanceToEdge",
    value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      if (this.from != this.to) {
        return this._getDistanceToEdge(x1, y1, x2, y2, x3, y3);
      } else {
        var _this$_getCircleData7 = this._getCircleData(undefined),
            _this$_getCircleData8 = _slicedToArray(_this$_getCircleData7, 3),
            x = _this$_getCircleData8[0],
            y = _this$_getCircleData8[1],
            radius = _this$_getCircleData8[2];

        var dx = x - x3;
        var dy = y - y3;
        return Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);
      }
    }
    /**
     * Calculate the distance between a point (x3, y3) and a line segment from (x1, y1) to (x2, y2).
     *
     * @param x1 - First end of the line segment on the x axis.
     * @param y1 - First end of the line segment on the y axis.
     * @param x2 - Second end of the line segment on the x axis.
     * @param y2 - Second end of the line segment on the y axis.
     * @param x3 - Position of the point on the x axis.
     * @param y3 - Position of the point on the y axis.
     * @returns The distance between the line segment and the point.
     */

  }, {
    key: "_getDistanceToLine",
    value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {
      var px = x2 - x1;
      var py = y2 - y1;
      var something = px * px + py * py;
      var u = ((x3 - x1) * px + (y3 - y1) * py) / something;

      if (u > 1) {
        u = 1;
      } else if (u < 0) {
        u = 0;
      }

      var x = x1 + u * px;
      var y = y1 + u * py;
      var dx = x - x3;
      var dy = y - y3; //# Note: If the actual distance does not matter,
      //# if you only want to compare what this function
      //# returns to other results of this function, you
      //# can just return the squared distance instead
      //# (i.e. remove the sqrt) to gain a little performance

      return Math.sqrt(dx * dx + dy * dy);
    }
    /** @inheritDoc */

  }, {
    key: "getArrowData",
    value: function getArrowData(ctx, position, viaNode, _selected, _hover, values) {
      // set lets
      var angle;
      var arrowPoint;
      var node1;
      var node2;
      var reversed;
      var scaleFactor;
      var type;
      var lineWidth = values.width;

      if (position === "from") {
        node1 = this.from;
        node2 = this.to;
        reversed = values.fromArrowScale < 0;
        scaleFactor = Math.abs(values.fromArrowScale);
        type = values.fromArrowType;
      } else if (position === "to") {
        node1 = this.to;
        node2 = this.from;
        reversed = values.toArrowScale < 0;
        scaleFactor = Math.abs(values.toArrowScale);
        type = values.toArrowType;
      } else {
        node1 = this.to;
        node2 = this.from;
        reversed = values.middleArrowScale < 0;
        scaleFactor = Math.abs(values.middleArrowScale);
        type = values.middleArrowType;
      }

      var length = 15 * scaleFactor + 3 * lineWidth; // 3* lineWidth is the width of the edge.
      // if not connected to itself

      if (node1 != node2) {
        var approximateEdgeLength = hypot(node1.x - node2.x, node1.y - node2.y);

        var relativeLength = length / approximateEdgeLength;

        if (position !== "middle") {
          // draw arrow head
          if (this.options.smooth.enabled === true) {
            var pointT = this._findBorderPosition(node1, ctx, {
              via: viaNode
            });

            var guidePos = this.getPoint(pointT.t + relativeLength * (position === "from" ? 1 : -1), viaNode);
            angle = Math.atan2(pointT.y - guidePos.y, pointT.x - guidePos.x);
            arrowPoint = pointT;
          } else {
            angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
            arrowPoint = this._findBorderPosition(node1, ctx);
          }
        } else {
          // Negative half length reverses arrow direction.
          var halfLength = (reversed ? -relativeLength : relativeLength) / 2;
          var guidePos1 = this.getPoint(0.5 + halfLength, viaNode);
          var guidePos2 = this.getPoint(0.5 - halfLength, viaNode);
          angle = Math.atan2(guidePos1.y - guidePos2.y, guidePos1.x - guidePos2.x);
          arrowPoint = this.getPoint(0.5, viaNode);
        }
      } else {
        // draw circle
        var _this$_getCircleData9 = this._getCircleData(ctx),
            _this$_getCircleData10 = _slicedToArray(_this$_getCircleData9, 3),
            x = _this$_getCircleData10[0],
            y = _this$_getCircleData10[1],
            radius = _this$_getCircleData10[2];

        if (position === "from") {
          var low = this.options.selfReference.angle;
          var high = this.options.selfReference.angle + Math.PI;

          var _pointT = this._findBorderPositionCircle(this.from, ctx, {
            x: x,
            y: y,
            low: low,
            high: high,
            direction: -1
          });

          angle = _pointT.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
          arrowPoint = _pointT;
        } else if (position === "to") {
          var _low = this.options.selfReference.angle;

          var _high = this.options.selfReference.angle + Math.PI;

          var _pointT2 = this._findBorderPositionCircle(this.from, ctx, {
            x: x,
            y: y,
            low: _low,
            high: _high,
            direction: 1
          });

          angle = _pointT2.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;
          arrowPoint = _pointT2;
        } else {
          var pos = this.options.selfReference.angle / (2 * Math.PI);
          arrowPoint = this._pointOnCircle(x, y, radius, pos);
          angle = pos * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
        }
      }

      var xi = arrowPoint.x - length * 0.9 * Math.cos(angle);
      var yi = arrowPoint.y - length * 0.9 * Math.sin(angle);
      var arrowCore = {
        x: xi,
        y: yi
      };
      return {
        point: arrowPoint,
        core: arrowCore,
        angle: angle,
        length: length,
        type: type
      };
    }
    /** @inheritDoc */

  }, {
    key: "drawArrowHead",
    value: function drawArrowHead(ctx, values, _selected, _hover, arrowData) {
      // set style
      ctx.strokeStyle = this.getColor(ctx, values);
      ctx.fillStyle = ctx.strokeStyle;
      ctx.lineWidth = values.width;
      var canFill = EndPoints.draw(ctx, arrowData);

      if (canFill) {
        // draw shadow if enabled
        this.enableShadow(ctx, values);

        fill(ctx).call(ctx); // disable shadows for other elements.


        this.disableShadow(ctx, values);
      }
    }
    /**
     * Set the shadow formatting values in the context if enabled, do nothing otherwise.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the shadow.
     */

  }, {
    key: "enableShadow",
    value: function enableShadow(ctx, values) {
      if (values.shadow === true) {
        ctx.shadowColor = values.shadowColor;
        ctx.shadowBlur = values.shadowSize;
        ctx.shadowOffsetX = values.shadowX;
        ctx.shadowOffsetY = values.shadowY;
      }
    }
    /**
     * Reset the shadow formatting values in the context if enabled, do nothing otherwise.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the shadow.
     */

  }, {
    key: "disableShadow",
    value: function disableShadow(ctx, values) {
      if (values.shadow === true) {
        ctx.shadowColor = "rgba(0,0,0,0)";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      }
    }
    /**
     * Render the background according to the formatting values.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the background.
     */

  }, {
    key: "drawBackground",
    value: function drawBackground(ctx, values) {
      if (values.background !== false) {
        // save original line attrs
        var origCtxAttr = {
          strokeStyle: ctx.strokeStyle,
          lineWidth: ctx.lineWidth,
          dashes: ctx.dashes
        };
        ctx.strokeStyle = values.backgroundColor;
        ctx.lineWidth = values.backgroundSize;
        this.setStrokeDashed(ctx, values.backgroundDashes);
        ctx.stroke(); // restore original line attrs

        ctx.strokeStyle = origCtxAttr.strokeStyle;
        ctx.lineWidth = origCtxAttr.lineWidth;
        ctx.dashes = origCtxAttr.dashes;
        this.setStrokeDashed(ctx, values.dashes);
      }
    }
    /**
     * Set the line dash pattern if supported. Logs a warning to the console if it isn't supported.
     *
     * @param ctx - The context that will be used for rendering.
     * @param dashes - The pattern [line, space, line…], true for default dashed line or false for normal line.
     */

  }, {
    key: "setStrokeDashed",
    value: function setStrokeDashed(ctx, dashes) {
      if (dashes !== false) {
        if (ctx.setLineDash !== undefined) {
          var pattern = isArray$2(dashes) ? dashes : [5, 5];
          ctx.setLineDash(pattern);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");
        }
      } else {
        if (ctx.setLineDash !== undefined) {
          ctx.setLineDash([]);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");
        }
      }
    }
  }]);

  return EdgeBase;
}();

function ownKeys(object, enumerableOnly) { var keys = keys$4(object); if (getOwnPropertySymbols) { var symbols = getOwnPropertySymbols(object); enumerableOnly && (symbols = filter(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$3(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? forEach$2(_context = ownKeys(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : getOwnPropertyDescriptors ? defineProperties(target, getOwnPropertyDescriptors(source)) : forEach$2(_context2 = ownKeys(Object(source))).call(_context2, function (key) { defineProperty$6(target, key, getOwnPropertyDescriptor$3(source, key)); }); } return target; }

function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * The Base Class for all Bezier edges.
 * Bezier curves are used to model smooth gradual curves in paths between nodes.
 */

var BezierEdgeBase = /*#__PURE__*/function (_EdgeBase) {
  _inherits(BezierEdgeBase, _EdgeBase);

  var _super = _createSuper$9(BezierEdgeBase);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function BezierEdgeBase(options, body, labelModule) {
    _classCallCheck(this, BezierEdgeBase);

    return _super.call(this, options, body, labelModule);
  }
  /**
   * Find the intersection between the border of the node and the edge.
   *
   * @remarks
   * This function uses binary search to look for the point where the bezier curve crosses the border of the node.
   * @param nearNode - The node (either from or to node of the edge).
   * @param ctx - The context that will be used for rendering.
   * @param viaNode - Additional node(s) the edge passes through.
   * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
   */


  _createClass(BezierEdgeBase, [{
    key: "_findBorderPositionBezier",
    value: function _findBorderPositionBezier(nearNode, ctx) {
      var viaNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._getViaCoordinates();
      var maxIterations = 10;
      var threshold = 0.2;
      var from = false;
      var high = 1;
      var low = 0;
      var node = this.to;
      var pos;
      var middle;
      var endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.to : 0;

      if (nearNode.id === this.from.id) {
        node = this.from;
        from = true;
        endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.from : 0;
      }

      if (this.options.arrowStrikethrough === false) {
        endPointOffset = 0;
      }

      var iteration = 0;

      do {
        middle = (low + high) * 0.5;
        pos = this.getPoint(middle, viaNode);
        var angle = Math.atan2(node.y - pos.y, node.x - pos.x);
        var distanceToBorder = node.distanceToBorder(ctx, angle) + endPointOffset;
        var distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
        var difference = distanceToBorder - distanceToPoint;

        if (Math.abs(difference) < threshold) {
          break; // found
        } else if (difference < 0) {
          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
          if (from === false) {
            low = middle;
          } else {
            high = middle;
          }
        } else {
          if (from === false) {
            high = middle;
          } else {
            low = middle;
          }
        }

        ++iteration;
      } while (low <= high && iteration < maxIterations);

      return _objectSpread(_objectSpread({}, pos), {}, {
        t: middle
      });
    }
    /**
     * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).
     *
     * @remarks
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     * @param x1 - First end of the line segment on the x axis.
     * @param y1 - First end of the line segment on the y axis.
     * @param x2 - Second end of the line segment on the x axis.
     * @param y2 - Second end of the line segment on the y axis.
     * @param x3 - Position of the point on the x axis.
     * @param y3 - Position of the point on the y axis.
     * @param via - The control point for the edge.
     * @returns The distance between the line segment and the point.
     */

  }, {
    key: "_getDistanceToBezierEdge",
    value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {
      // x3,y3 is the point
      var minDistance = 1e9;
      var distance;
      var i, t, x, y;
      var lastX = x1;
      var lastY = y1;

      for (i = 1; i < 10; i++) {
        t = 0.1 * i;
        x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;
        y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;

        if (i > 0) {
          distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
          minDistance = distance < minDistance ? distance : minDistance;
        }

        lastX = x;
        lastY = y;
      }

      return minDistance;
    }
    /**
     * Render a bezier curve between two nodes.
     *
     * @remarks
     * The method accepts zero, one or two control points.
     * Passing zero control points just draws a straight line.
     * @param ctx - The context that will be used for rendering.
     * @param values - Style options for edge drawing.
     * @param viaNode1 - First control point for curve drawing.
     * @param viaNode2 - Second control point for curve drawing.
     */

  }, {
    key: "_bezierCurve",
    value: function _bezierCurve(ctx, values, viaNode1, viaNode2) {
      ctx.beginPath();
      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);

      if (viaNode1 != null && viaNode1.x != null) {
        if (viaNode2 != null && viaNode2.x != null) {
          ctx.bezierCurveTo(viaNode1.x, viaNode1.y, viaNode2.x, viaNode2.y, this.toPoint.x, this.toPoint.y);
        } else {
          ctx.quadraticCurveTo(viaNode1.x, viaNode1.y, this.toPoint.x, this.toPoint.y);
        }
      } else {
        // fallback to normal straight edge
        ctx.lineTo(this.toPoint.x, this.toPoint.y);
      } // draw a background


      this.drawBackground(ctx, values); // draw shadow if enabled

      this.enableShadow(ctx, values);
      ctx.stroke();
      this.disableShadow(ctx, values);
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this._getViaCoordinates();
    }
  }]);

  return BezierEdgeBase;
}(EdgeBase);

function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Dynamic Bezier Edge. Bezier curves are used to model smooth gradual
 * curves in paths between nodes. The Dynamic piece refers to how the curve
 * reacts to physics changes.
 *
 * @augments BezierEdgeBase
 */

var BezierEdgeDynamic = /*#__PURE__*/function (_BezierEdgeBase) {
  _inherits(BezierEdgeDynamic, _BezierEdgeBase);

  var _super = _createSuper$8(BezierEdgeDynamic);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function BezierEdgeDynamic(options, body, labelModule) {
    var _this;

    _classCallCheck(this, BezierEdgeDynamic);

    //this.via = undefined; // Here for completeness but not allowed to defined before super() is invoked.
    _this = _super.call(this, options, body, labelModule); // --> this calls the setOptions below

    _this.via = _this.via; // constructor → super → super → setOptions → setupSupportNode

    _this._boundFunction = function () {
      _this.positionBezierNode();
    };

    _this._body.emitter.on("_repositionBezierNodes", _this._boundFunction);

    return _this;
  }
  /** @inheritDoc */


  _createClass(BezierEdgeDynamic, [{
    key: "setOptions",
    value: function setOptions(options) {
      _get(_getPrototypeOf(BezierEdgeDynamic.prototype), "setOptions", this).call(this, options); // check if the physics has changed.


      var physicsChange = false;

      if (this.options.physics !== options.physics) {
        physicsChange = true;
      } // set the options and the to and from nodes


      this.options = options;
      this.id = this.options.id;
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to]; // setup the support node and connect

      this.setupSupportNode();
      this.connect(); // when we change the physics state of the edge, we reposition the support node.

      if (physicsChange === true) {
        this.via.setOptions({
          physics: this.options.physics
        });
        this.positionBezierNode();
      }
    }
    /** @inheritDoc */

  }, {
    key: "connect",
    value: function connect() {
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to];

      if (this.from === undefined || this.to === undefined || this.options.physics === false) {
        this.via.setOptions({
          physics: false
        });
      } else {
        // fix weird behaviour where a self referencing node has physics enabled
        if (this.from.id === this.to.id) {
          this.via.setOptions({
            physics: false
          });
        } else {
          this.via.setOptions({
            physics: true
          });
        }
      }
    }
    /** @inheritDoc */

  }, {
    key: "cleanup",
    value: function cleanup() {
      this._body.emitter.off("_repositionBezierNodes", this._boundFunction);

      if (this.via !== undefined) {
        delete this._body.nodes[this.via.id];
        this.via = undefined;
        return true;
      }

      return false;
    }
    /**
     * Create and add a support node if not already present.
     *
     * @remarks
     * Bezier curves require an anchor point to calculate the smooth flow.
     * These points are nodes.
     * These nodes are invisible but are used for the force calculation.
     *
     * The changed data is not called, if needed, it is returned by the main edge constructor.
     */

  }, {
    key: "setupSupportNode",
    value: function setupSupportNode() {
      if (this.via === undefined) {
        var nodeId = "edgeId:" + this.id;

        var node = this._body.functions.createNode({
          id: nodeId,
          shape: "circle",
          physics: true,
          hidden: true
        });

        this._body.nodes[nodeId] = node;
        this.via = node;
        this.via.parentEdgeId = this.id;
        this.positionBezierNode();
      }
    }
    /**
     * Position bezier node.
     */

  }, {
    key: "positionBezierNode",
    value: function positionBezierNode() {
      if (this.via !== undefined && this.from !== undefined && this.to !== undefined) {
        this.via.x = 0.5 * (this.from.x + this.to.x);
        this.via.y = 0.5 * (this.from.y + this.to.y);
      } else if (this.via !== undefined) {
        this.via.x = 0;
        this.via.y = 0;
      }
    }
    /** @inheritDoc */

  }, {
    key: "_line",
    value: function _line(ctx, values, viaNode) {
      this._bezierCurve(ctx, values, viaNode);
    }
    /** @inheritDoc */

  }, {
    key: "_getViaCoordinates",
    value: function _getViaCoordinates() {
      return this.via;
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this.via;
    }
    /** @inheritDoc */

  }, {
    key: "getPoint",
    value: function getPoint(position) {
      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.via;

      if (this.from === this.to) {
        var _this$_getCircleData = this._getCircleData(),
            _this$_getCircleData2 = _slicedToArray(_this$_getCircleData, 3),
            cx = _this$_getCircleData2[0],
            cy = _this$_getCircleData2[1],
            cr = _this$_getCircleData2[2];

        var a = 2 * Math.PI * (1 - position);
        return {
          x: cx + cr * Math.sin(a),
          y: cy + cr - cr * (1 - Math.cos(a))
        };
      } else {
        return {
          x: Math.pow(1 - position, 2) * this.fromPoint.x + 2 * position * (1 - position) * viaNode.x + Math.pow(position, 2) * this.toPoint.x,
          y: Math.pow(1 - position, 2) * this.fromPoint.y + 2 * position * (1 - position) * viaNode.y + Math.pow(position, 2) * this.toPoint.y
        };
      }
    }
    /** @inheritDoc */

  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      return this._findBorderPositionBezier(nearNode, ctx, this.via);
    }
    /** @inheritDoc */

  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      // x3,y3 is the point
      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);
    }
  }]);

  return BezierEdgeDynamic;
}(BezierEdgeBase);

function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Static Bezier Edge. Bezier curves are used to model smooth gradual curves in paths between nodes.
 */

var BezierEdgeStatic = /*#__PURE__*/function (_BezierEdgeBase) {
  _inherits(BezierEdgeStatic, _BezierEdgeBase);

  var _super = _createSuper$7(BezierEdgeStatic);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function BezierEdgeStatic(options, body, labelModule) {
    _classCallCheck(this, BezierEdgeStatic);

    return _super.call(this, options, body, labelModule);
  }
  /** @inheritDoc */


  _createClass(BezierEdgeStatic, [{
    key: "_line",
    value: function _line(ctx, values, viaNode) {
      this._bezierCurve(ctx, values, viaNode);
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this._getViaCoordinates();
    }
    /**
     * Compute the coordinates of the via node.
     *
     * @remarks
     * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.
     * @returns Cartesian coordinates of the via node.
     */

  }, {
    key: "_getViaCoordinates",
    value: function _getViaCoordinates() {
      // Assumption: x/y coordinates in from/to always defined
      var factor = this.options.smooth.roundness;
      var type = this.options.smooth.type;
      var dx = Math.abs(this.from.x - this.to.x);
      var dy = Math.abs(this.from.y - this.to.y);

      if (type === "discrete" || type === "diagonalCross") {
        var stepX;
        var stepY;

        if (dx <= dy) {
          stepX = stepY = factor * dy;
        } else {
          stepX = stepY = factor * dx;
        }

        if (this.from.x > this.to.x) {
          stepX = -stepX;
        }

        if (this.from.y >= this.to.y) {
          stepY = -stepY;
        }

        var xVia = this.from.x + stepX;
        var yVia = this.from.y + stepY;

        if (type === "discrete") {
          if (dx <= dy) {
            xVia = dx < factor * dy ? this.from.x : xVia;
          } else {
            yVia = dy < factor * dx ? this.from.y : yVia;
          }
        }

        return {
          x: xVia,
          y: yVia
        };
      } else if (type === "straightCross") {
        var _stepX = (1 - factor) * dx;

        var _stepY = (1 - factor) * dy;

        if (dx <= dy) {
          // up - down
          _stepX = 0;

          if (this.from.y < this.to.y) {
            _stepY = -_stepY;
          }
        } else {
          // left - right
          if (this.from.x < this.to.x) {
            _stepX = -_stepX;
          }

          _stepY = 0;
        }

        return {
          x: this.to.x + _stepX,
          y: this.to.y + _stepY
        };
      } else if (type === "horizontal") {
        var _stepX2 = (1 - factor) * dx;

        if (this.from.x < this.to.x) {
          _stepX2 = -_stepX2;
        }

        return {
          x: this.to.x + _stepX2,
          y: this.from.y
        };
      } else if (type === "vertical") {
        var _stepY2 = (1 - factor) * dy;

        if (this.from.y < this.to.y) {
          _stepY2 = -_stepY2;
        }

        return {
          x: this.from.x,
          y: this.to.y + _stepY2
        };
      } else if (type === "curvedCW") {
        dx = this.to.x - this.from.x;
        dy = this.from.y - this.to.y;
        var radius = Math.sqrt(dx * dx + dy * dy);
        var pi = Math.PI;
        var originalAngle = Math.atan2(dy, dx);
        var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);
        return {
          x: this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle),
          y: this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle)
        };
      } else if (type === "curvedCCW") {
        dx = this.to.x - this.from.x;
        dy = this.from.y - this.to.y;

        var _radius = Math.sqrt(dx * dx + dy * dy);

        var _pi = Math.PI;

        var _originalAngle = Math.atan2(dy, dx);

        var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);

        return {
          x: this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle),
          y: this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle)
        };
      } else {
        // continuous
        var _stepX3;

        var _stepY3;

        if (dx <= dy) {
          _stepX3 = _stepY3 = factor * dy;
        } else {
          _stepX3 = _stepY3 = factor * dx;
        }

        if (this.from.x > this.to.x) {
          _stepX3 = -_stepX3;
        }

        if (this.from.y >= this.to.y) {
          _stepY3 = -_stepY3;
        }

        var _xVia = this.from.x + _stepX3;

        var _yVia = this.from.y + _stepY3;

        if (dx <= dy) {
          if (this.from.x <= this.to.x) {
            _xVia = this.to.x < _xVia ? this.to.x : _xVia;
          } else {
            _xVia = this.to.x > _xVia ? this.to.x : _xVia;
          }
        } else {
          if (this.from.y >= this.to.y) {
            _yVia = this.to.y > _yVia ? this.to.y : _yVia;
          } else {
            _yVia = this.to.y < _yVia ? this.to.y : _yVia;
          }
        }

        return {
          x: _xVia,
          y: _yVia
        };
      }
    }
    /** @inheritDoc */

  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this._findBorderPositionBezier(nearNode, ctx, options.via);
    }
    /** @inheritDoc */

  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      var viaNode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates();
      // x3,y3 is the point
      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);
    }
    /** @inheritDoc */

  }, {
    key: "getPoint",
    value: function getPoint(position) {
      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates();
      var t = position;
      var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
      var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;
      return {
        x: x,
        y: y
      };
    }
  }]);

  return BezierEdgeStatic;
}(BezierEdgeBase);

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Base Class for all Cubic Bezier Edges. Bezier curves are used to model
 * smooth gradual curves in paths between nodes.
 *
 * @augments BezierEdgeBase
 */

var CubicBezierEdgeBase = /*#__PURE__*/function (_BezierEdgeBase) {
  _inherits(CubicBezierEdgeBase, _BezierEdgeBase);

  var _super = _createSuper$6(CubicBezierEdgeBase);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function CubicBezierEdgeBase(options, body, labelModule) {
    _classCallCheck(this, CubicBezierEdgeBase);

    return _super.call(this, options, body, labelModule);
  }
  /**
   * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).
   *
   * @remarks
   * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
   * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
   * @param x1 - First end of the line segment on the x axis.
   * @param y1 - First end of the line segment on the y axis.
   * @param x2 - Second end of the line segment on the x axis.
   * @param y2 - Second end of the line segment on the y axis.
   * @param x3 - Position of the point on the x axis.
   * @param y3 - Position of the point on the y axis.
   * @param via1 - The first point this edge passes through.
   * @param via2 - The second point this edge passes through.
   * @returns The distance between the line segment and the point.
   */


  _createClass(CubicBezierEdgeBase, [{
    key: "_getDistanceToBezierEdge2",
    value: function _getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2) {
      // x3,y3 is the point
      var minDistance = 1e9;
      var lastX = x1;
      var lastY = y1;
      var vec = [0, 0, 0, 0];

      for (var i = 1; i < 10; i++) {
        var t = 0.1 * i;
        vec[0] = Math.pow(1 - t, 3);
        vec[1] = 3 * t * Math.pow(1 - t, 2);
        vec[2] = 3 * Math.pow(t, 2) * (1 - t);
        vec[3] = Math.pow(t, 3);
        var x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;
        var y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;

        if (i > 0) {
          var distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);

          minDistance = distance < minDistance ? distance : minDistance;
        }

        lastX = x;
        lastY = y;
      }

      return minDistance;
    }
  }]);

  return CubicBezierEdgeBase;
}(BezierEdgeBase);

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Cubic Bezier Edge. Bezier curves are used to model smooth gradual curves in paths between nodes.
 */

var CubicBezierEdge = /*#__PURE__*/function (_CubicBezierEdgeBase) {
  _inherits(CubicBezierEdge, _CubicBezierEdgeBase);

  var _super = _createSuper$5(CubicBezierEdge);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function CubicBezierEdge(options, body, labelModule) {
    _classCallCheck(this, CubicBezierEdge);

    return _super.call(this, options, body, labelModule);
  }
  /** @inheritDoc */


  _createClass(CubicBezierEdge, [{
    key: "_line",
    value: function _line(ctx, values, viaNodes) {
      // get the coordinates of the support points.
      var via1 = viaNodes[0];
      var via2 = viaNodes[1];

      this._bezierCurve(ctx, values, via1, via2);
    }
    /**
     * Compute the additional points the edge passes through.
     *
     * @returns Cartesian coordinates of the points the edge passes through.
     */

  }, {
    key: "_getViaCoordinates",
    value: function _getViaCoordinates() {
      var dx = this.from.x - this.to.x;
      var dy = this.from.y - this.to.y;
      var x1;
      var y1;
      var x2;
      var y2;
      var roundness = this.options.smooth.roundness; // horizontal if x > y or if direction is forced or if direction is horizontal

      if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === "horizontal") && this.options.smooth.forceDirection !== "vertical") {
        y1 = this.from.y;
        y2 = this.to.y;
        x1 = this.from.x - roundness * dx;
        x2 = this.to.x + roundness * dx;
      } else {
        y1 = this.from.y - roundness * dy;
        y2 = this.to.y + roundness * dy;
        x1 = this.from.x;
        x2 = this.to.x;
      }

      return [{
        x: x1,
        y: y1
      }, {
        x: x2,
        y: y2
      }];
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this._getViaCoordinates();
    }
    /** @inheritDoc */

  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      return this._findBorderPositionBezier(nearNode, ctx);
    }
    /** @inheritDoc */

  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      var _ref = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates(),
          _ref2 = _slicedToArray(_ref, 2),
          via1 = _ref2[0],
          via2 = _ref2[1];

      // x3,y3 is the point
      return this._getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2);
    }
    /** @inheritDoc */

  }, {
    key: "getPoint",
    value: function getPoint(position) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates(),
          _ref4 = _slicedToArray(_ref3, 2),
          via1 = _ref4[0],
          via2 = _ref4[1];

      var t = position;
      var vec = [Math.pow(1 - t, 3), 3 * t * Math.pow(1 - t, 2), 3 * Math.pow(t, 2) * (1 - t), Math.pow(t, 3)];
      var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;
      var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;
      return {
        x: x,
        y: y
      };
    }
  }]);

  return CubicBezierEdge;
}(CubicBezierEdgeBase);

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Straight Edge.
 */

var StraightEdge = /*#__PURE__*/function (_EdgeBase) {
  _inherits(StraightEdge, _EdgeBase);

  var _super = _createSuper$4(StraightEdge);

  /**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */
  function StraightEdge(options, body, labelModule) {
    _classCallCheck(this, StraightEdge);

    return _super.call(this, options, body, labelModule);
  }
  /** @inheritDoc */


  _createClass(StraightEdge, [{
    key: "_line",
    value: function _line(ctx, values) {
      // draw a straight line
      ctx.beginPath();
      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
      ctx.lineTo(this.toPoint.x, this.toPoint.y); // draw shadow if enabled

      this.enableShadow(ctx, values);
      ctx.stroke();
      this.disableShadow(ctx, values);
    }
    /** @inheritDoc */

  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return undefined;
    }
    /** @inheritDoc */

  }, {
    key: "getPoint",
    value: function getPoint(position) {
      return {
        x: (1 - position) * this.fromPoint.x + position * this.toPoint.x,
        y: (1 - position) * this.fromPoint.y + position * this.toPoint.y
      };
    }
    /** @inheritDoc */

  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      var node1 = this.to;
      var node2 = this.from;

      if (nearNode.id === this.from.id) {
        node1 = this.from;
        node2 = this.to;
      }

      var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
      var dx = node1.x - node2.x;
      var dy = node1.y - node2.y;
      var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);
      var toBorderDist = nearNode.distanceToBorder(ctx, angle);
      var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;
      return {
        x: (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x,
        y: (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y,
        t: 0
      };
    }
    /** @inheritDoc */

  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      // x3,y3 is the point
      return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);
    }
  }]);

  return StraightEdge;
}(EdgeBase);

/**
 * An edge connects two nodes and has a specific direction.
 */

var Edge = /*#__PURE__*/function () {
  /**
   * @param {object} options        values specific to this edge, must contain at least 'from' and 'to'
   * @param {object} body           shared state from Network instance
   * @param {Network.Images} imagelist  A list with images. Only needed when the edge has image arrows.
   * @param {object} globalOptions  options from the EdgesHandler instance
   * @param {object} defaultOptions default options from the EdgeHandler instance. Value and reference are constant
   */
  function Edge(options, body, imagelist, globalOptions, defaultOptions) {
    _classCallCheck(this, Edge);

    if (body === undefined) {
      throw new Error("No body provided");
    } // Since globalOptions is constant in values as well as reference,
    // Following needs to be done only once.


    this.options = bridgeObject(globalOptions);
    this.globalOptions = globalOptions;
    this.defaultOptions = defaultOptions;
    this.body = body;
    this.imagelist = imagelist; // initialize variables

    this.id = undefined;
    this.fromId = undefined;
    this.toId = undefined;
    this.selected = false;
    this.hover = false;
    this.labelDirty = true;
    this.baseWidth = this.options.width;
    this.baseFontSize = this.options.font.size;
    this.from = undefined; // a node

    this.to = undefined; // a node

    this.edgeType = undefined;
    this.connected = false;
    this.labelModule = new Label(this.body, this.options, true
    /* It's an edge label */
    );
    this.setOptions(options);
  }
  /**
   * Set or overwrite options for the edge
   *
   * @param {object} options  an object with options
   * @returns {undefined|boolean} undefined if no options, true if layout affecting data changed, false otherwise.
   */


  _createClass(Edge, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (!options) {
        return;
      } // Following options if changed affect the layout.


      var affectsLayout = typeof options.physics !== "undefined" && this.options.physics !== options.physics || typeof options.hidden !== "undefined" && (this.options.hidden || false) !== (options.hidden || false) || typeof options.from !== "undefined" && this.options.from !== options.from || typeof options.to !== "undefined" && this.options.to !== options.to;
      Edge.parseOptions(this.options, options, true, this.globalOptions);

      if (options.id !== undefined) {
        this.id = options.id;
      }

      if (options.from !== undefined) {
        this.fromId = options.from;
      }

      if (options.to !== undefined) {
        this.toId = options.to;
      }

      if (options.title !== undefined) {
        this.title = options.title;
      }

      if (options.value !== undefined) {
        options.value = _parseFloat(options.value);
      }

      var pile = [options, this.options, this.defaultOptions];
      this.chooser = choosify("edge", pile); // update label Module

      this.updateLabelModule(options); // Update edge type, this if changed affects the layout.

      affectsLayout = this.updateEdgeType() || affectsLayout; // if anything has been updates, reset the selection width and the hover width

      this._setInteractionWidths(); // A node is connected when it has a from and to node that both exist in the network.body.nodes.


      this.connect();
      return affectsLayout;
    }
    /**
     *
     * @param {object} parentOptions
     * @param {object} newOptions
     * @param {boolean} [allowDeletion=false]
     * @param {object} [globalOptions={}]
     * @param {boolean} [copyFromGlobals=false]
     */

  }, {
    key: "getFormattingValues",
    value:
    /**
     *
     * @returns {ArrowOptions}
     */
    function getFormattingValues() {
      var toArrow = this.options.arrows.to === true || this.options.arrows.to.enabled === true;
      var fromArrow = this.options.arrows.from === true || this.options.arrows.from.enabled === true;
      var middleArrow = this.options.arrows.middle === true || this.options.arrows.middle.enabled === true;
      var inheritsColor = this.options.color.inherit;
      var values = {
        toArrow: toArrow,
        toArrowScale: this.options.arrows.to.scaleFactor,
        toArrowType: this.options.arrows.to.type,
        toArrowSrc: this.options.arrows.to.src,
        toArrowImageWidth: this.options.arrows.to.imageWidth,
        toArrowImageHeight: this.options.arrows.to.imageHeight,
        middleArrow: middleArrow,
        middleArrowScale: this.options.arrows.middle.scaleFactor,
        middleArrowType: this.options.arrows.middle.type,
        middleArrowSrc: this.options.arrows.middle.src,
        middleArrowImageWidth: this.options.arrows.middle.imageWidth,
        middleArrowImageHeight: this.options.arrows.middle.imageHeight,
        fromArrow: fromArrow,
        fromArrowScale: this.options.arrows.from.scaleFactor,
        fromArrowType: this.options.arrows.from.type,
        fromArrowSrc: this.options.arrows.from.src,
        fromArrowImageWidth: this.options.arrows.from.imageWidth,
        fromArrowImageHeight: this.options.arrows.from.imageHeight,
        arrowStrikethrough: this.options.arrowStrikethrough,
        color: inheritsColor ? undefined : this.options.color.color,
        inheritsColor: inheritsColor,
        opacity: this.options.color.opacity,
        hidden: this.options.hidden,
        length: this.options.length,
        shadow: this.options.shadow.enabled,
        shadowColor: this.options.shadow.color,
        shadowSize: this.options.shadow.size,
        shadowX: this.options.shadow.x,
        shadowY: this.options.shadow.y,
        dashes: this.options.dashes,
        width: this.options.width,
        background: this.options.background.enabled,
        backgroundColor: this.options.background.color,
        backgroundSize: this.options.background.size,
        backgroundDashes: this.options.background.dashes
      };

      if (this.selected || this.hover) {
        if (this.chooser === true) {
          if (this.selected) {
            var selectedWidth = this.options.selectionWidth;

            if (typeof selectedWidth === "function") {
              values.width = selectedWidth(values.width);
            } else if (typeof selectedWidth === "number") {
              values.width += selectedWidth;
            }

            values.width = Math.max(values.width, 0.3 / this.body.view.scale);
            values.color = this.options.color.highlight;
            values.shadow = this.options.shadow.enabled;
          } else if (this.hover) {
            var hoverWidth = this.options.hoverWidth;

            if (typeof hoverWidth === "function") {
              values.width = hoverWidth(values.width);
            } else if (typeof hoverWidth === "number") {
              values.width += hoverWidth;
            }

            values.width = Math.max(values.width, 0.3 / this.body.view.scale);
            values.color = this.options.color.hover;
            values.shadow = this.options.shadow.enabled;
          }
        } else if (typeof this.chooser === "function") {
          this.chooser(values, this.options.id, this.selected, this.hover);

          if (values.color !== undefined) {
            values.inheritsColor = false;
          }

          if (values.shadow === false) {
            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {
              values.shadow = true;
            }
          }
        }
      } else {
        values.shadow = this.options.shadow.enabled;
        values.width = Math.max(values.width, 0.3 / this.body.view.scale);
      }

      return values;
    }
    /**
     * update the options in the label module
     *
     * @param {object} options
     */

  }, {
    key: "updateLabelModule",
    value: function updateLabelModule(options) {
      var pile = [options, this.options, this.globalOptions, // Currently set global edge options
      this.defaultOptions];
      this.labelModule.update(this.options, pile);

      if (this.labelModule.baseSize !== undefined) {
        this.baseFontSize = this.labelModule.baseSize;
      }
    }
    /**
     * update the edge type, set the options
     *
     * @returns {boolean}
     */

  }, {
    key: "updateEdgeType",
    value: function updateEdgeType() {
      var smooth = this.options.smooth;
      var dataChanged = false;
      var changeInType = true;

      if (this.edgeType !== undefined) {
        if (this.edgeType instanceof BezierEdgeDynamic && smooth.enabled === true && smooth.type === "dynamic" || this.edgeType instanceof CubicBezierEdge && smooth.enabled === true && smooth.type === "cubicBezier" || this.edgeType instanceof BezierEdgeStatic && smooth.enabled === true && smooth.type !== "dynamic" && smooth.type !== "cubicBezier" || this.edgeType instanceof StraightEdge && smooth.type.enabled === false) {
          changeInType = false;
        }

        if (changeInType === true) {
          dataChanged = this.cleanup();
        }
      }

      if (changeInType === true) {
        if (smooth.enabled === true) {
          if (smooth.type === "dynamic") {
            dataChanged = true;
            this.edgeType = new BezierEdgeDynamic(this.options, this.body, this.labelModule);
          } else if (smooth.type === "cubicBezier") {
            this.edgeType = new CubicBezierEdge(this.options, this.body, this.labelModule);
          } else {
            this.edgeType = new BezierEdgeStatic(this.options, this.body, this.labelModule);
          }
        } else {
          this.edgeType = new StraightEdge(this.options, this.body, this.labelModule);
        }
      } else {
        // if nothing changes, we just set the options.
        this.edgeType.setOptions(this.options);
      }

      return dataChanged;
    }
    /**
     * Connect an edge to its nodes
     */

  }, {
    key: "connect",
    value: function connect() {
      this.disconnect();
      this.from = this.body.nodes[this.fromId] || undefined;
      this.to = this.body.nodes[this.toId] || undefined;
      this.connected = this.from !== undefined && this.to !== undefined;

      if (this.connected === true) {
        this.from.attachEdge(this);
        this.to.attachEdge(this);
      } else {
        if (this.from) {
          this.from.detachEdge(this);
        }

        if (this.to) {
          this.to.detachEdge(this);
        }
      }

      this.edgeType.connect();
    }
    /**
     * Disconnect an edge from its nodes
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this.from) {
        this.from.detachEdge(this);
        this.from = undefined;
      }

      if (this.to) {
        this.to.detachEdge(this);
        this.to = undefined;
      }

      this.connected = false;
    }
    /**
     * get the title of this edge.
     *
     * @returns {string} title    The title of the edge, or undefined when no title
     *                           has been set.
     */

  }, {
    key: "getTitle",
    value: function getTitle() {
      return this.title;
    }
    /**
     * check if this node is selecte
     *
     * @returns {boolean} selected   True if node is selected, else false
     */

  }, {
    key: "isSelected",
    value: function isSelected() {
      return this.selected;
    }
    /**
     * Retrieve the value of the edge. Can be undefined
     *
     * @returns {number} value
     */

  }, {
    key: "getValue",
    value: function getValue() {
      return this.options.value;
    }
    /**
     * Adjust the value range of the edge. The edge will adjust it's width
     * based on its value.
     *
     * @param {number} min
     * @param {number} max
     * @param {number} total
     */

  }, {
    key: "setValueRange",
    value: function setValueRange(min, max, total) {
      if (this.options.value !== undefined) {
        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
        var widthDiff = this.options.scaling.max - this.options.scaling.min;

        if (this.options.scaling.label.enabled === true) {
          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
        }

        this.options.width = this.options.scaling.min + scale * widthDiff;
      } else {
        this.options.width = this.baseWidth;
        this.options.font.size = this.baseFontSize;
      }

      this._setInteractionWidths();

      this.updateLabelModule();
    }
    /**
     *
     * @private
     */

  }, {
    key: "_setInteractionWidths",
    value: function _setInteractionWidths() {
      if (typeof this.options.hoverWidth === "function") {
        this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);
      } else {
        this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;
      }

      if (typeof this.options.selectionWidth === "function") {
        this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);
      } else {
        this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;
      }
    }
    /**
     * Redraw a edge
     * Draw this edge in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: "draw",
    value: function draw(ctx) {
      var values = this.getFormattingValues();

      if (values.hidden) {
        return;
      } // get the via node from the edge type


      var viaNode = this.edgeType.getViaNode(); // draw line and label

      this.edgeType.drawLine(ctx, values, this.selected, this.hover, viaNode);
      this.drawLabel(ctx, viaNode);
    }
    /**
     * Redraw arrows
     * Draw this arrows in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: "drawArrows",
    value: function drawArrows(ctx) {
      var values = this.getFormattingValues();

      if (values.hidden) {
        return;
      } // get the via node from the edge type


      var viaNode = this.edgeType.getViaNode();
      var arrowData = {}; // restore edge targets to defaults

      this.edgeType.fromPoint = this.edgeType.from;
      this.edgeType.toPoint = this.edgeType.to; // from and to arrows give a different end point for edges. we set them here

      if (values.fromArrow) {
        arrowData.from = this.edgeType.getArrowData(ctx, "from", viaNode, this.selected, this.hover, values);
        if (values.arrowStrikethrough === false) this.edgeType.fromPoint = arrowData.from.core;

        if (values.fromArrowSrc) {
          arrowData.from.image = this.imagelist.load(values.fromArrowSrc);
        }

        if (values.fromArrowImageWidth) {
          arrowData.from.imageWidth = values.fromArrowImageWidth;
        }

        if (values.fromArrowImageHeight) {
          arrowData.from.imageHeight = values.fromArrowImageHeight;
        }
      }

      if (values.toArrow) {
        arrowData.to = this.edgeType.getArrowData(ctx, "to", viaNode, this.selected, this.hover, values);
        if (values.arrowStrikethrough === false) this.edgeType.toPoint = arrowData.to.core;

        if (values.toArrowSrc) {
          arrowData.to.image = this.imagelist.load(values.toArrowSrc);
        }

        if (values.toArrowImageWidth) {
          arrowData.to.imageWidth = values.toArrowImageWidth;
        }

        if (values.toArrowImageHeight) {
          arrowData.to.imageHeight = values.toArrowImageHeight;
        }
      } // the middle arrow depends on the line, which can depend on the to and from arrows so we do this one lastly.


      if (values.middleArrow) {
        arrowData.middle = this.edgeType.getArrowData(ctx, "middle", viaNode, this.selected, this.hover, values);

        if (values.middleArrowSrc) {
          arrowData.middle.image = this.imagelist.load(values.middleArrowSrc);
        }

        if (values.middleArrowImageWidth) {
          arrowData.middle.imageWidth = values.middleArrowImageWidth;
        }

        if (values.middleArrowImageHeight) {
          arrowData.middle.imageHeight = values.middleArrowImageHeight;
        }
      }

      if (values.fromArrow) {
        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.from);
      }

      if (values.middleArrow) {
        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.middle);
      }

      if (values.toArrow) {
        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.to);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Node} viaNode
     */

  }, {
    key: "drawLabel",
    value: function drawLabel(ctx, viaNode) {
      if (this.options.label !== undefined) {
        // set style
        var node1 = this.from;
        var node2 = this.to;

        if (this.labelModule.differentState(this.selected, this.hover)) {
          this.labelModule.getTextSize(ctx, this.selected, this.hover);
        }

        var point;

        if (node1.id != node2.id) {
          this.labelModule.pointToSelf = false;
          point = this.edgeType.getPoint(0.5, viaNode);
          ctx.save();

          var rotationPoint = this._getRotation(ctx);

          if (rotationPoint.angle != 0) {
            ctx.translate(rotationPoint.x, rotationPoint.y);
            ctx.rotate(rotationPoint.angle);
          } // draw the label


          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
          /*
          // Useful debug code: draw a border around the label
          // This should **not** be enabled in production!
          var size = this.labelModule.getSize();; // ;; intentional so lint catches it
          ctx.strokeStyle = "#ff0000";
          ctx.strokeRect(size.left, size.top, size.width, size.height);
          // End  debug code
          */

          ctx.restore();
        } else {
          // Ignore the orientations.
          this.labelModule.pointToSelf = true; // get circle coordinates

          var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, this.options.selfReference.size, node1);
          point = this._pointOnCircle(coordinates.x, coordinates.y, this.options.selfReference.size, this.options.selfReference.angle);
          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
        }
      }
    }
    /**
     * Determine all visual elements of this edge instance, in which the given
     * point falls within the bounding shape.
     *
     * @param {point} point
     * @returns {Array.<edgeClickItem|edgeLabelClickItem>} list with the items which are on the point
     */

  }, {
    key: "getItemsOnPoint",
    value: function getItemsOnPoint(point) {
      var ret = [];

      if (this.labelModule.visible()) {
        var rotationPoint = this._getRotation();

        if (pointInRect(this.labelModule.getSize(), point, rotationPoint)) {
          ret.push({
            edgeId: this.id,
            labelId: 0
          });
        }
      }

      var obj = {
        left: point.x,
        top: point.y
      };

      if (this.isOverlappingWith(obj)) {
        ret.push({
          edgeId: this.id
        });
      }

      return ret;
    }
    /**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top
     * @returns {boolean}     True if location is located on the edge
     */

  }, {
    key: "isOverlappingWith",
    value: function isOverlappingWith(obj) {
      if (this.connected) {
        var distMax = 10;
        var xFrom = this.from.x;
        var yFrom = this.from.y;
        var xTo = this.to.x;
        var yTo = this.to.y;
        var xObj = obj.left;
        var yObj = obj.top;
        var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);
        return dist < distMax;
      } else {
        return false;
      }
    }
    /**
     * Determine the rotation point, if any.
     *
     * @param {CanvasRenderingContext2D} [ctx] if passed, do a recalculation of the label size
     * @returns {rotationPoint} the point to rotate around and the angle in radians to rotate
     * @private
     */

  }, {
    key: "_getRotation",
    value: function _getRotation(ctx) {
      var viaNode = this.edgeType.getViaNode();
      var point = this.edgeType.getPoint(0.5, viaNode);

      if (ctx !== undefined) {
        this.labelModule.calculateLabelSize(ctx, this.selected, this.hover, point.x, point.y);
      }

      var ret = {
        x: point.x,
        y: this.labelModule.size.yLine,
        angle: 0
      };

      if (!this.labelModule.visible()) {
        return ret; // Don't even bother doing the atan2, there's nothing to draw
      }

      if (this.options.font.align === "horizontal") {
        return ret; // No need to calculate angle
      }

      var dy = this.from.y - this.to.y;
      var dx = this.from.x - this.to.x;
      var angle = Math.atan2(dy, dx); // radians
      // rotate so that label is readable

      if (angle < -1 && dx < 0 || angle > 0 && dx < 0) {
        angle += Math.PI;
      }

      ret.angle = angle;
      return ret;
    }
    /**
     * Get a point on a circle
     *
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {number} angle
     * @returns {object} point
     * @private
     */

  }, {
    key: "_pointOnCircle",
    value: function _pointOnCircle(x, y, radius, angle) {
      return {
        x: x + radius * Math.cos(angle),
        y: y - radius * Math.sin(angle)
      };
    }
    /**
     * Sets selected state to true
     */

  }, {
    key: "select",
    value: function select() {
      this.selected = true;
    }
    /**
     * Sets selected state to false
     */

  }, {
    key: "unselect",
    value: function unselect() {
      this.selected = false;
    }
    /**
     * cleans all required things on delete
     *
     * @returns {*}
     */

  }, {
    key: "cleanup",
    value: function cleanup() {
      return this.edgeType.cleanup();
    }
    /**
     * Remove edge from the list and perform necessary cleanup.
     */

  }, {
    key: "remove",
    value: function remove() {
      this.cleanup();
      this.disconnect();
      delete this.body.edges[this.id];
    }
    /**
     * Check if both connecting nodes exist
     *
     * @returns {boolean}
     */

  }, {
    key: "endPointsValid",
    value: function endPointsValid() {
      return this.body.nodes[this.fromId] !== undefined && this.body.nodes[this.toId] !== undefined;
    }
  }], [{
    key: "parseOptions",
    value: function parseOptions(parentOptions, newOptions) {
      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var copyFromGlobals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var fields = ["endPointOffset", "arrowStrikethrough", "id", "from", "hidden", "hoverWidth", "labelHighlightBold", "length", "line", "opacity", "physics", "scaling", "selectionWidth", "selfReferenceSize", "selfReference", "to", "title", "value", "width", "font", "chosen", "widthConstraint"]; // only deep extend the items in the field array. These do not have shorthand.

      selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion); // Only use endPointOffset values (from and to) if it's valid values

      if (newOptions.endPointOffset !== undefined && newOptions.endPointOffset.from !== undefined) {
        if (_isFinite(newOptions.endPointOffset.from)) {
          parentOptions.endPointOffset.from = newOptions.endPointOffset.from;
        } else {
          parentOptions.endPointOffset.from = globalOptions.endPointOffset.from !== undefined ? globalOptions.endPointOffset.from : 0;
          console.error("endPointOffset.from is not a valid number");
        }
      }

      if (newOptions.endPointOffset !== undefined && newOptions.endPointOffset.to !== undefined) {
        if (_isFinite(newOptions.endPointOffset.to)) {
          parentOptions.endPointOffset.to = newOptions.endPointOffset.to;
        } else {
          parentOptions.endPointOffset.to = globalOptions.endPointOffset.to !== undefined ? globalOptions.endPointOffset.to : 0;
          console.error("endPointOffset.to is not a valid number");
        }
      } // Only copy label if it's a legal value.


      if (isValidLabel(newOptions.label)) {
        parentOptions.label = newOptions.label;
      } else if (!isValidLabel(parentOptions.label)) {
        parentOptions.label = undefined;
      }

      mergeOptions(parentOptions, newOptions, "smooth", globalOptions);
      mergeOptions(parentOptions, newOptions, "shadow", globalOptions);
      mergeOptions(parentOptions, newOptions, "background", globalOptions);

      if (newOptions.dashes !== undefined && newOptions.dashes !== null) {
        parentOptions.dashes = newOptions.dashes;
      } else if (allowDeletion === true && newOptions.dashes === null) {
        parentOptions.dashes = create$5(globalOptions.dashes); // this sets the pointer of the option back to the global option.
      } // set the scaling newOptions


      if (newOptions.scaling !== undefined && newOptions.scaling !== null) {
        if (newOptions.scaling.min !== undefined) {
          parentOptions.scaling.min = newOptions.scaling.min;
        }

        if (newOptions.scaling.max !== undefined) {
          parentOptions.scaling.max = newOptions.scaling.max;
        }

        mergeOptions(parentOptions.scaling, newOptions.scaling, "label", globalOptions.scaling);
      } else if (allowDeletion === true && newOptions.scaling === null) {
        parentOptions.scaling = create$5(globalOptions.scaling); // this sets the pointer of the option back to the global option.
      } // handle multiple input cases for arrows


      if (newOptions.arrows !== undefined && newOptions.arrows !== null) {
        if (typeof newOptions.arrows === "string") {
          var arrows = newOptions.arrows.toLowerCase();
          parentOptions.arrows.to.enabled = indexOf(arrows).call(arrows, "to") != -1;
          parentOptions.arrows.middle.enabled = indexOf(arrows).call(arrows, "middle") != -1;
          parentOptions.arrows.from.enabled = indexOf(arrows).call(arrows, "from") != -1;
        } else if (_typeof(newOptions.arrows) === "object") {
          mergeOptions(parentOptions.arrows, newOptions.arrows, "to", globalOptions.arrows);
          mergeOptions(parentOptions.arrows, newOptions.arrows, "middle", globalOptions.arrows);
          mergeOptions(parentOptions.arrows, newOptions.arrows, "from", globalOptions.arrows);
        } else {
          throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:" + stringify$1(newOptions.arrows));
        }
      } else if (allowDeletion === true && newOptions.arrows === null) {
        parentOptions.arrows = create$5(globalOptions.arrows); // this sets the pointer of the option back to the global option.
      } // handle multiple input cases for color


      if (newOptions.color !== undefined && newOptions.color !== null) {
        var fromColor = isString(newOptions.color) ? {
          color: newOptions.color,
          highlight: newOptions.color,
          hover: newOptions.color,
          inherit: false,
          opacity: 1
        } : newOptions.color;
        var toColor = parentOptions.color; // If passed, fill in values from default options - required in the case of no prototype bridging

        if (copyFromGlobals) {
          deepExtend(toColor, globalOptions.color, false, allowDeletion);
        } else {
          // Clear local properties - need to do it like this in order to retain prototype bridges
          for (var i in toColor) {
            if (Object.prototype.hasOwnProperty.call(toColor, i)) {
              delete toColor[i];
            }
          }
        }

        if (isString(toColor)) {
          toColor.color = toColor;
          toColor.highlight = toColor;
          toColor.hover = toColor;
          toColor.inherit = false;

          if (fromColor.opacity === undefined) {
            toColor.opacity = 1.0; // set default
          }
        } else {
          var colorsDefined = false;

          if (fromColor.color !== undefined) {
            toColor.color = fromColor.color;
            colorsDefined = true;
          }

          if (fromColor.highlight !== undefined) {
            toColor.highlight = fromColor.highlight;
            colorsDefined = true;
          }

          if (fromColor.hover !== undefined) {
            toColor.hover = fromColor.hover;
            colorsDefined = true;
          }

          if (fromColor.inherit !== undefined) {
            toColor.inherit = fromColor.inherit;
          }

          if (fromColor.opacity !== undefined) {
            toColor.opacity = Math.min(1, Math.max(0, fromColor.opacity));
          }

          if (colorsDefined === true) {
            toColor.inherit = false;
          } else {
            if (toColor.inherit === undefined) {
              toColor.inherit = "from"; // Set default
            }
          }
        }
      } else if (allowDeletion === true && newOptions.color === null) {
        parentOptions.color = bridgeObject(globalOptions.color); // set the object back to the global options
      }

      if (allowDeletion === true && newOptions.font === null) {
        parentOptions.font = bridgeObject(globalOptions.font); // set the object back to the global options
      }

      if (Object.prototype.hasOwnProperty.call(newOptions, "selfReferenceSize")) {
        console.warn("The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}");
        parentOptions.selfReference.size = newOptions.selfReferenceSize;
      }
    }
  }]);

  return Edge;
}();

/**
 * Handler for Edges
 */

var EdgesHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Array.<Image>} images
   * @param {Array.<Group>} groups
   */
  function EdgesHandler(body, images, groups) {
    var _context,
        _this = this;

    _classCallCheck(this, EdgesHandler);

    this.body = body;
    this.images = images;
    this.groups = groups; // create the edge API in the body container

    this.body.functions.createEdge = bind$6(_context = this.create).call(_context, this);
    this.edgesListeners = {
      add: function add(event, params) {
        _this.add(params.items);
      },
      update: function update(event, params) {
        _this.update(params.items);
      },
      remove: function remove(event, params) {
        _this.remove(params.items);
      }
    };
    this.options = {};
    this.defaultOptions = {
      arrows: {
        to: {
          enabled: false,
          scaleFactor: 1,
          type: "arrow"
        },
        // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}
        middle: {
          enabled: false,
          scaleFactor: 1,
          type: "arrow"
        },
        from: {
          enabled: false,
          scaleFactor: 1,
          type: "arrow"
        }
      },
      endPointOffset: {
        from: 0,
        to: 0
      },
      arrowStrikethrough: true,
      color: {
        color: "#848484",
        highlight: "#848484",
        hover: "#848484",
        inherit: "from",
        opacity: 1.0
      },
      dashes: false,
      font: {
        color: "#343434",
        size: 14,
        // px
        face: "arial",
        background: "none",
        strokeWidth: 2,
        // px
        strokeColor: "#ffffff",
        align: "horizontal",
        multi: false,
        vadjust: 0,
        bold: {
          mod: "bold"
        },
        boldital: {
          mod: "bold italic"
        },
        ital: {
          mod: "italic"
        },
        mono: {
          mod: "",
          size: 15,
          // px
          face: "courier new",
          vadjust: 2
        }
      },
      hidden: false,
      hoverWidth: 1.5,
      label: undefined,
      labelHighlightBold: true,
      length: undefined,
      physics: true,
      scaling: {
        min: 1,
        max: 15,
        label: {
          enabled: true,
          min: 14,
          max: 30,
          maxVisible: 30,
          drawThreshold: 5
        },
        customScalingFunction: function customScalingFunction(min, max, total, value) {
          if (max === min) {
            return 0.5;
          } else {
            var scale = 1 / (max - min);
            return Math.max(0, (value - min) * scale);
          }
        }
      },
      selectionWidth: 1.5,
      selfReference: {
        size: 20,
        angle: Math.PI / 4,
        renderBehindTheNode: true
      },
      shadow: {
        enabled: false,
        color: "rgba(0,0,0,0.5)",
        size: 10,
        x: 5,
        y: 5
      },
      background: {
        enabled: false,
        color: "rgba(111,111,111,1)",
        size: 10,
        dashes: false
      },
      smooth: {
        enabled: true,
        type: "dynamic",
        forceDirection: "none",
        roundness: 0.5
      },
      title: undefined,
      width: 1,
      value: undefined
    };
    deepExtend(this.options, this.defaultOptions);
    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(EdgesHandler, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this2 = this,
          _context2,
          _context3;

      // this allows external modules to force all dynamic curves to turn static.
      this.body.emitter.on("_forceDisableDynamicCurves", function (type) {
        var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (type === "dynamic") {
          type = "continuous";
        }

        var dataChanged = false;

        for (var edgeId in _this2.body.edges) {
          if (Object.prototype.hasOwnProperty.call(_this2.body.edges, edgeId)) {
            var edge = _this2.body.edges[edgeId];

            var edgeData = _this2.body.data.edges.get(edgeId); // only forcibly remove the smooth curve if the data has been set of the edge has the smooth curves defined.
            // this is because a change in the global would not affect these curves.


            if (edgeData != null) {
              var smoothOptions = edgeData.smooth;

              if (smoothOptions !== undefined) {
                if (smoothOptions.enabled === true && smoothOptions.type === "dynamic") {
                  if (type === undefined) {
                    edge.setOptions({
                      smooth: false
                    });
                  } else {
                    edge.setOptions({
                      smooth: {
                        type: type
                      }
                    });
                  }

                  dataChanged = true;
                }
              }
            }
          }
        }

        if (emit === true && dataChanged === true) {
          _this2.body.emitter.emit("_dataChanged");
        }
      }); // this is called when options of EXISTING nodes or edges have changed.
      //
      // NOTE: Not true, called when options have NOT changed, for both existing as well as new nodes.
      //       See update() for logic.
      // TODO: Verify and examine the consequences of this. It might still trigger when
      //       non-option fields have changed, but then reconnecting edges is still useless.
      //       Alternatively, it might also be called when edges are removed.
      //

      this.body.emitter.on("_dataUpdated", function () {
        _this2.reconnectEdges();
      }); // refresh the edges. Used when reverting from hierarchical layout

      this.body.emitter.on("refreshEdges", bind$6(_context2 = this.refresh).call(_context2, this));
      this.body.emitter.on("refresh", bind$6(_context3 = this.refresh).call(_context3, this));
      this.body.emitter.on("destroy", function () {
        forEach$1(_this2.edgesListeners, function (callback, event) {
          if (_this2.body.data.edges) _this2.body.data.edges.off(event, callback);
        });
        delete _this2.body.functions.createEdge;
        delete _this2.edgesListeners.add;
        delete _this2.edgesListeners.update;
        delete _this2.edgesListeners.remove;
        delete _this2.edgesListeners;
      });
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        // use the parser from the Edge class to fill in all shorthand notations
        Edge.parseOptions(this.options, options, true, this.defaultOptions, true); // update smooth settings in all edges

        var dataChanged = false;

        if (options.smooth !== undefined) {
          for (var edgeId in this.body.edges) {
            if (Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) {
              dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;
            }
          }
        } // update fonts in all edges


        if (options.font !== undefined) {
          for (var _edgeId in this.body.edges) {
            if (Object.prototype.hasOwnProperty.call(this.body.edges, _edgeId)) {
              this.body.edges[_edgeId].updateLabelModule();
            }
          }
        } // update the state of the variables if needed


        if (options.hidden !== undefined || options.physics !== undefined || dataChanged === true) {
          this.body.emitter.emit("_dataChanged");
        }
      }
    }
    /**
     * Load edges by reading the data table
     *
     * @param {Array | DataSet | DataView} edges    The data containing the edges.
     * @param {boolean} [doNotEmit=false] - Suppress data changed event.
     * @private
     */

  }, {
    key: "setData",
    value: function setData(edges) {
      var _this3 = this;

      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var oldEdgesData = this.body.data.edges;

      if (isDataViewLike("id", edges)) {
        this.body.data.edges = edges;
      } else if (isArray$2(edges)) {
        this.body.data.edges = new DataSet();
        this.body.data.edges.add(edges);
      } else if (!edges) {
        this.body.data.edges = new DataSet();
      } else {
        throw new TypeError("Array or DataSet expected");
      } // TODO: is this null or undefined or false?


      if (oldEdgesData) {
        // unsubscribe from old dataset
        forEach$1(this.edgesListeners, function (callback, event) {
          oldEdgesData.off(event, callback);
        });
      } // remove drawn edges


      this.body.edges = {}; // TODO: is this null or undefined or false?

      if (this.body.data.edges) {
        // subscribe to new dataset
        forEach$1(this.edgesListeners, function (callback, event) {
          _this3.body.data.edges.on(event, callback);
        }); // draw all new nodes

        var ids = this.body.data.edges.getIds();
        this.add(ids, true);
      }

      this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");

      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Add edges
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [doNotEmit=false]
     * @private
     */

  }, {
    key: "add",
    value: function add(ids) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var edges = this.body.edges;
      var edgesData = this.body.data.edges;

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var oldEdge = edges[id];

        if (oldEdge) {
          oldEdge.disconnect();
        }

        var data = edgesData.get(id, {
          showInternalIds: true
        });
        edges[id] = this.create(data);
      }

      this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");

      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Update existing edges, or create them when not yet existing
     *
     * @param {number[] | string[]} ids
     * @private
     */

  }, {
    key: "update",
    value: function update(ids) {
      var edges = this.body.edges;
      var edgesData = this.body.data.edges;
      var dataChanged = false;

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var data = edgesData.get(id);
        var edge = edges[id];

        if (edge !== undefined) {
          // update edge
          edge.disconnect();
          dataChanged = edge.setOptions(data) || dataChanged; // if a support node is added, data can be changed.

          edge.connect();
        } else {
          // create edge
          this.body.edges[id] = this.create(data);
          dataChanged = true;
        }
      }

      if (dataChanged === true) {
        this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
        this.body.emitter.emit("_dataChanged");
      } else {
        this.body.emitter.emit("_dataUpdated");
      }
    }
    /**
     * Remove existing edges. Non existing ids will be ignored
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [emit=true]
     * @private
     */

  }, {
    key: "remove",
    value: function remove(ids) {
      var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (ids.length === 0) return; // early out

      var edges = this.body.edges;
      forEach$1(ids, function (id) {
        var edge = edges[id];

        if (edge !== undefined) {
          edge.remove();
        }
      });

      if (emit) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Refreshes Edge Handler
     */

  }, {
    key: "refresh",
    value: function refresh() {
      var _this4 = this;

      forEach$1(this.body.edges, function (edge, edgeId) {
        var data = _this4.body.data.edges.get(edgeId);

        if (data !== undefined) {
          edge.setOptions(data);
        }
      });
    }
    /**
     *
     * @param {object} properties
     * @returns {Edge}
     */

  }, {
    key: "create",
    value: function create(properties) {
      return new Edge(properties, this.body, this.images, this.options, this.defaultOptions);
    }
    /**
     * Reconnect all edges
     *
     * @private
     */

  }, {
    key: "reconnectEdges",
    value: function reconnectEdges() {
      var id;
      var nodes = this.body.nodes;
      var edges = this.body.edges;

      for (id in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, id)) {
          nodes[id].edges = [];
        }
      }

      for (id in edges) {
        if (Object.prototype.hasOwnProperty.call(edges, id)) {
          var edge = edges[id];
          edge.from = null;
          edge.to = null;
          edge.connect();
        }
      }
    }
    /**
     *
     * @param {Edge.id} edgeId
     * @returns {Array}
     */

  }, {
    key: "getConnectedNodes",
    value: function getConnectedNodes(edgeId) {
      var nodeList = [];

      if (this.body.edges[edgeId] !== undefined) {
        var edge = this.body.edges[edgeId];

        if (edge.fromId !== undefined) {
          nodeList.push(edge.fromId);
        }

        if (edge.toId !== undefined) {
          nodeList.push(edge.toId);
        }
      }

      return nodeList;
    }
    /**
     * There is no direct relation between the nodes and the edges DataSet,
     * so the right place to do call this is in the handler for event `_dataUpdated`.
     */

  }, {
    key: "_updateState",
    value: function _updateState() {
      this._addMissingEdges();

      this._removeInvalidEdges();
    }
    /**
     * Scan for missing nodes and remove corresponding edges, if any.
     *
     * @private
     */

  }, {
    key: "_removeInvalidEdges",
    value: function _removeInvalidEdges() {
      var _this5 = this;

      var edgesToDelete = [];
      forEach$1(this.body.edges, function (edge, id) {
        var toNode = _this5.body.nodes[edge.toId];
        var fromNode = _this5.body.nodes[edge.fromId]; // Skip clustering edges here, let the Clustering module handle those

        if (toNode !== undefined && toNode.isCluster === true || fromNode !== undefined && fromNode.isCluster === true) {
          return;
        }

        if (toNode === undefined || fromNode === undefined) {
          edgesToDelete.push(id);
        }
      });
      this.remove(edgesToDelete, false);
    }
    /**
     * add all edges from dataset that are not in the cached state
     *
     * @private
     */

  }, {
    key: "_addMissingEdges",
    value: function _addMissingEdges() {
      var edgesData = this.body.data.edges;

      if (edgesData === undefined || edgesData === null) {
        return; // No edges DataSet yet; can happen on startup
      }

      var edges = this.body.edges;
      var addIds = [];

      forEach$2(edgesData).call(edgesData, function (edgeData, edgeId) {
        var edge = edges[edgeId];

        if (edge === undefined) {
          addIds.push(edgeId);
        }
      });

      this.add(addIds, true);
    }
  }]);

  return EdgesHandler;
}();

/**
 * Barnes Hut Solver
 */

var BarnesHutSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function BarnesHutSolver(body, physicsBody, options) {
    _classCallCheck(this, BarnesHutSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.barnesHutTree;
    this.setOptions(options);
    this._rng = Alea("BARNES HUT SOLVER"); // debug: show grid
    // this.body.emitter.on("afterDrawing", (ctx) => {this._debug(ctx,'#ff0000')})
  }
  /**
   *
   * @param {object} options
   */


  _createClass(BarnesHutSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
      this.thetaInversed = 1 / this.options.theta; // if 1 then min distance = 0.5, if 0.5 then min distance = 0.5 + 0.5*node.shape.radius

      this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));
    }
    /**
     * This function calculates the forces the nodes apply on each other based on a gravitational model.
     * The Barnes Hut method is used to speed up this N-body simulation.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {
        var node;
        var nodes = this.body.nodes;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var nodeCount = nodeIndices.length; // create the tree

        var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices); // for debugging


        this.barnesHutTree = barnesHutTree; // place the nodes one by one recursively

        for (var i = 0; i < nodeCount; i++) {
          node = nodes[nodeIndices[i]];

          if (node.options.mass > 0) {
            // starting with root is irrelevant, it never passes the BarnesHutSolver condition
            this._getForceContributions(barnesHutTree.root, node);
          }
        }
      }
    }
    /**
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */

  }, {
    key: "_getForceContributions",
    value: function _getForceContributions(parentBranch, node) {
      this._getForceContribution(parentBranch.children.NW, node);

      this._getForceContribution(parentBranch.children.NE, node);

      this._getForceContribution(parentBranch.children.SW, node);

      this._getForceContribution(parentBranch.children.SE, node);
    }
    /**
     * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.
     * If a region contains a single node, we check if it is not itself, then we apply the force.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */

  }, {
    key: "_getForceContribution",
    value: function _getForceContribution(parentBranch, node) {
      // we get no force contribution from an empty region
      if (parentBranch.childrenCount > 0) {
        // get the distance from the center of mass to the node.
        var dx = parentBranch.centerOfMass.x - node.x;
        var dy = parentBranch.centerOfMass.y - node.y;
        var distance = Math.sqrt(dx * dx + dy * dy); // BarnesHutSolver condition
        // original condition : s/d < theta = passed  ===  d/s > 1/theta = passed
        // calcSize = 1/s --> d * 1/s > 1/theta = passed

        if (distance * parentBranch.calcSize > this.thetaInversed) {
          this._calculateForces(distance, dx, dy, node, parentBranch);
        } else {
          // Did not pass the condition, go into children if available
          if (parentBranch.childrenCount === 4) {
            this._getForceContributions(parentBranch, node);
          } else {
            // parentBranch must have only one node, if it was empty we wouldnt be here
            if (parentBranch.children.data.id != node.id) {
              // if it is not self
              this._calculateForces(distance, dx, dy, node, parentBranch);
            }
          }
        }
      }
    }
    /**
     * Calculate the forces based on the distance.
     *
     * @param {number} distance
     * @param {number} dx
     * @param {number} dy
     * @param {Node} node
     * @param {object} parentBranch
     * @private
     */

  }, {
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, node, parentBranch) {
      if (distance === 0) {
        distance = 0.1;
        dx = distance;
      }

      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
      } // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce


      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);
      var fx = dx * gravityForce;
      var fy = dy * gravityForce;
      this.physicsBody.forces[node.id].x += fx;
      this.physicsBody.forces[node.id].y += fy;
    }
    /**
     * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.
     *
     * @param {Array.<Node>} nodes
     * @param {Array.<number>} nodeIndices
     * @returns {{root: {centerOfMass: {x: number, y: number}, mass: number, range: {minX: number, maxX: number, minY: number, maxY: number}, size: number, calcSize: number, children: {data: null}, maxWidth: number, level: number, childrenCount: number}}} BarnesHutTree
     * @private
     */

  }, {
    key: "_formBarnesHutTree",
    value: function _formBarnesHutTree(nodes, nodeIndices) {
      var node;
      var nodeCount = nodeIndices.length;
      var minX = nodes[nodeIndices[0]].x;
      var minY = nodes[nodeIndices[0]].y;
      var maxX = nodes[nodeIndices[0]].x;
      var maxY = nodes[nodeIndices[0]].y; // get the range of the nodes

      for (var i = 1; i < nodeCount; i++) {
        var _node = nodes[nodeIndices[i]];
        var x = _node.x;
        var y = _node.y;

        if (_node.options.mass > 0) {
          if (x < minX) {
            minX = x;
          }

          if (x > maxX) {
            maxX = x;
          }

          if (y < minY) {
            minY = y;
          }

          if (y > maxY) {
            maxY = y;
          }
        }
      } // make the range a square


      var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY); // difference between X and Y

      if (sizeDiff > 0) {
        minY -= 0.5 * sizeDiff;
        maxY += 0.5 * sizeDiff;
      } // xSize > ySize
      else {
        minX += 0.5 * sizeDiff;
        maxX -= 0.5 * sizeDiff;
      } // xSize < ySize


      var minimumTreeSize = 1e-5;
      var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));
      var halfRootSize = 0.5 * rootSize;
      var centerX = 0.5 * (minX + maxX),
          centerY = 0.5 * (minY + maxY); // construct the barnesHutTree

      var barnesHutTree = {
        root: {
          centerOfMass: {
            x: 0,
            y: 0
          },
          mass: 0,
          range: {
            minX: centerX - halfRootSize,
            maxX: centerX + halfRootSize,
            minY: centerY - halfRootSize,
            maxY: centerY + halfRootSize
          },
          size: rootSize,
          calcSize: 1 / rootSize,
          children: {
            data: null
          },
          maxWidth: 0,
          level: 0,
          childrenCount: 4
        }
      };

      this._splitBranch(barnesHutTree.root); // place the nodes one by one recursively


      for (var _i = 0; _i < nodeCount; _i++) {
        node = nodes[nodeIndices[_i]];

        if (node.options.mass > 0) {
          this._placeInTree(barnesHutTree.root, node);
        }
      } // make global


      return barnesHutTree;
    }
    /**
     * this updates the mass of a branch. this is increased by adding a node.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */

  }, {
    key: "_updateBranchMass",
    value: function _updateBranchMass(parentBranch, node) {
      var centerOfMass = parentBranch.centerOfMass;
      var totalMass = parentBranch.mass + node.options.mass;
      var totalMassInv = 1 / totalMass;
      centerOfMass.x = centerOfMass.x * parentBranch.mass + node.x * node.options.mass;
      centerOfMass.x *= totalMassInv;
      centerOfMass.y = centerOfMass.y * parentBranch.mass + node.y * node.options.mass;
      centerOfMass.y *= totalMassInv;
      parentBranch.mass = totalMass;
      var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);
      parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;
    }
    /**
     * determine in which branch the node will be placed.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @param {boolean} skipMassUpdate
     * @private
     */

  }, {
    key: "_placeInTree",
    value: function _placeInTree(parentBranch, node, skipMassUpdate) {
      if (skipMassUpdate != true || skipMassUpdate === undefined) {
        // update the mass of the branch.
        this._updateBranchMass(parentBranch, node);
      }

      var range = parentBranch.children.NW.range;
      var region;

      if (range.maxX > node.x) {
        // in NW or SW
        if (range.maxY > node.y) {
          region = "NW";
        } else {
          region = "SW";
        }
      } else {
        // in NE or SE
        if (range.maxY > node.y) {
          region = "NE";
        } else {
          region = "SE";
        }
      }

      this._placeInRegion(parentBranch, node, region);
    }
    /**
     * actually place the node in a region (or branch)
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @param {'NW'| 'NE' | 'SW' | 'SE'} region
     * @private
     */

  }, {
    key: "_placeInRegion",
    value: function _placeInRegion(parentBranch, node, region) {
      var children = parentBranch.children[region];

      switch (children.childrenCount) {
        case 0:
          // place node here
          children.children.data = node;
          children.childrenCount = 1;

          this._updateBranchMass(children, node);

          break;

        case 1:
          // convert into children
          // if there are two nodes exactly overlapping (on init, on opening of cluster etc.)
          // we move one node a little bit and we do not put it in the tree.
          if (children.children.data.x === node.x && children.children.data.y === node.y) {
            node.x += this._rng();
            node.y += this._rng();
          } else {
            this._splitBranch(children);

            this._placeInTree(children, node);
          }

          break;

        case 4:
          // place in branch
          this._placeInTree(children, node);

          break;
      }
    }
    /**
     * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch
     * after the split is complete.
     *
     * @param {object} parentBranch
     * @private
     */

  }, {
    key: "_splitBranch",
    value: function _splitBranch(parentBranch) {
      // if the branch is shaded with a node, replace the node in the new subset.
      var containedNode = null;

      if (parentBranch.childrenCount === 1) {
        containedNode = parentBranch.children.data;
        parentBranch.mass = 0;
        parentBranch.centerOfMass.x = 0;
        parentBranch.centerOfMass.y = 0;
      }

      parentBranch.childrenCount = 4;
      parentBranch.children.data = null;

      this._insertRegion(parentBranch, "NW");

      this._insertRegion(parentBranch, "NE");

      this._insertRegion(parentBranch, "SW");

      this._insertRegion(parentBranch, "SE");

      if (containedNode != null) {
        this._placeInTree(parentBranch, containedNode);
      }
    }
    /**
     * This function subdivides the region into four new segments.
     * Specifically, this inserts a single new segment.
     * It fills the children section of the parentBranch
     *
     * @param {object} parentBranch
     * @param {'NW'| 'NE' | 'SW' | 'SE'} region
     * @private
     */

  }, {
    key: "_insertRegion",
    value: function _insertRegion(parentBranch, region) {
      var minX, maxX, minY, maxY;
      var childSize = 0.5 * parentBranch.size;

      switch (region) {
        case "NW":
          minX = parentBranch.range.minX;
          maxX = parentBranch.range.minX + childSize;
          minY = parentBranch.range.minY;
          maxY = parentBranch.range.minY + childSize;
          break;

        case "NE":
          minX = parentBranch.range.minX + childSize;
          maxX = parentBranch.range.maxX;
          minY = parentBranch.range.minY;
          maxY = parentBranch.range.minY + childSize;
          break;

        case "SW":
          minX = parentBranch.range.minX;
          maxX = parentBranch.range.minX + childSize;
          minY = parentBranch.range.minY + childSize;
          maxY = parentBranch.range.maxY;
          break;

        case "SE":
          minX = parentBranch.range.minX + childSize;
          maxX = parentBranch.range.maxX;
          minY = parentBranch.range.minY + childSize;
          maxY = parentBranch.range.maxY;
          break;
      }

      parentBranch.children[region] = {
        centerOfMass: {
          x: 0,
          y: 0
        },
        mass: 0,
        range: {
          minX: minX,
          maxX: maxX,
          minY: minY,
          maxY: maxY
        },
        size: 0.5 * parentBranch.size,
        calcSize: 2 * parentBranch.calcSize,
        children: {
          data: null
        },
        maxWidth: 0,
        level: parentBranch.level + 1,
        childrenCount: 0
      };
    } //---------------------------  DEBUGGING BELOW  ---------------------------//

    /**
     * This function is for debugging purposed, it draws the tree.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} color
     * @private
     */

  }, {
    key: "_debug",
    value: function _debug(ctx, color) {
      if (this.barnesHutTree !== undefined) {
        ctx.lineWidth = 1;

        this._drawBranch(this.barnesHutTree.root, ctx, color);
      }
    }
    /**
     * This function is for debugging purposes. It draws the branches recursively.
     *
     * @param {object} branch
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} color
     * @private
     */

  }, {
    key: "_drawBranch",
    value: function _drawBranch(branch, ctx, color) {
      if (color === undefined) {
        color = "#FF0000";
      }

      if (branch.childrenCount === 4) {
        this._drawBranch(branch.children.NW, ctx);

        this._drawBranch(branch.children.NE, ctx);

        this._drawBranch(branch.children.SE, ctx);

        this._drawBranch(branch.children.SW, ctx);
      }

      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(branch.range.minX, branch.range.minY);
      ctx.lineTo(branch.range.maxX, branch.range.minY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(branch.range.maxX, branch.range.minY);
      ctx.lineTo(branch.range.maxX, branch.range.maxY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(branch.range.maxX, branch.range.maxY);
      ctx.lineTo(branch.range.minX, branch.range.maxY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(branch.range.minX, branch.range.maxY);
      ctx.lineTo(branch.range.minX, branch.range.minY);
      ctx.stroke();
      /*
       if (branch.mass > 0) {
       ctx.circle(branch.centerOfMass.x, branch.centerOfMass.y, 3*branch.mass);
       ctx.stroke();
       }
       */
    }
  }]);

  return BarnesHutSolver;
}();

/**
 * Repulsion Solver
 */

var RepulsionSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function RepulsionSolver(body, physicsBody, options) {
    _classCallCheck(this, RepulsionSolver);

    this._rng = Alea("REPULSION SOLVER");
    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(RepulsionSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * Calculate the forces the nodes apply on each other based on a repulsion field.
     * This field is linearly approximated.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var dx, dy, distance, fx, fy, repulsingForce, node1, node2;
      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces; // repulsing forces between nodes

      var nodeDistance = this.options.nodeDistance; // approximation constants

      var a = -2 / 3 / nodeDistance;
      var b = 4 / 3; // we loop from i over all but the last entree in the array
      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j

      for (var i = 0; i < nodeIndices.length - 1; i++) {
        node1 = nodes[nodeIndices[i]];

        for (var j = i + 1; j < nodeIndices.length; j++) {
          node2 = nodes[nodeIndices[j]];
          dx = node2.x - node1.x;
          dy = node2.y - node1.y;
          distance = Math.sqrt(dx * dx + dy * dy); // same condition as BarnesHutSolver, making sure nodes are never 100% overlapping.

          if (distance === 0) {
            distance = 0.1 * this._rng();
            dx = distance;
          }

          if (distance < 2 * nodeDistance) {
            if (distance < 0.5 * nodeDistance) {
              repulsingForce = 1.0;
            } else {
              repulsingForce = a * distance + b; // linear approx of  1 / (1 + Math.exp((distance / nodeDistance - 1) * steepness))
            }

            repulsingForce = repulsingForce / distance;
            fx = dx * repulsingForce;
            fy = dy * repulsingForce;
            forces[node1.id].x -= fx;
            forces[node1.id].y -= fy;
            forces[node2.id].x += fx;
            forces[node2.id].y += fy;
          }
        }
      }
    }
  }]);

  return RepulsionSolver;
}();

/**
 * Hierarchical Repulsion Solver
 */
var HierarchicalRepulsionSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function HierarchicalRepulsionSolver(body, physicsBody, options) {
    _classCallCheck(this, HierarchicalRepulsionSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(HierarchicalRepulsionSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
      this.overlapAvoidanceFactor = Math.max(0, Math.min(1, this.options.avoidOverlap || 0));
    }
    /**
     * Calculate the forces the nodes apply on each other based on a repulsion field.
     * This field is linearly approximated.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces; // repulsing forces between nodes

      var nodeDistance = this.options.nodeDistance; // we loop from i over all but the last entree in the array
      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j

      for (var i = 0; i < nodeIndices.length - 1; i++) {
        var node1 = nodes[nodeIndices[i]];

        for (var j = i + 1; j < nodeIndices.length; j++) {
          var node2 = nodes[nodeIndices[j]]; // nodes only affect nodes on their level

          if (node1.level === node2.level) {
            var theseNodesDistance = nodeDistance + this.overlapAvoidanceFactor * ((node1.shape.radius || 0) / 2 + (node2.shape.radius || 0) / 2);
            var dx = node2.x - node1.x;
            var dy = node2.y - node1.y;
            var distance = Math.sqrt(dx * dx + dy * dy);
            var steepness = 0.05;
            var repulsingForce = void 0;

            if (distance < theseNodesDistance) {
              repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * theseNodesDistance, 2);
            } else {
              repulsingForce = 0;
            } // normalize force with


            if (distance !== 0) {
              repulsingForce = repulsingForce / distance;
            }

            var fx = dx * repulsingForce;
            var fy = dy * repulsingForce;
            forces[node1.id].x -= fx;
            forces[node1.id].y -= fy;
            forces[node2.id].x += fx;
            forces[node2.id].y += fy;
          }
        }
      }
    }
  }]);

  return HierarchicalRepulsionSolver;
}();

/**
 * Spring Solver
 */
var SpringSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function SpringSolver(body, physicsBody, options) {
    _classCallCheck(this, SpringSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(SpringSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * This function calculates the springforces on the nodes, accounting for the support nodes.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var edgeLength, edge;
      var edgeIndices = this.physicsBody.physicsEdgeIndices;
      var edges = this.body.edges;
      var node1, node2, node3; // forces caused by the edges, modelled as springs

      for (var i = 0; i < edgeIndices.length; i++) {
        edge = edges[edgeIndices[i]];

        if (edge.connected === true && edge.toId !== edge.fromId) {
          // only calculate forces if nodes are in the same sector
          if (this.body.nodes[edge.toId] !== undefined && this.body.nodes[edge.fromId] !== undefined) {
            if (edge.edgeType.via !== undefined) {
              edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;
              node1 = edge.to;
              node2 = edge.edgeType.via;
              node3 = edge.from;

              this._calculateSpringForce(node1, node2, 0.5 * edgeLength);

              this._calculateSpringForce(node2, node3, 0.5 * edgeLength);
            } else {
              // the * 1.5 is here so the edge looks as large as a smooth edge. It does not initially because the smooth edges use
              // the support nodes which exert a repulsive force on the to and from nodes, making the edge appear larger.
              edgeLength = edge.options.length === undefined ? this.options.springLength * 1.5 : edge.options.length;

              this._calculateSpringForce(edge.from, edge.to, edgeLength);
            }
          }
        }
      }
    }
    /**
     * This is the code actually performing the calculation for the function above.
     *
     * @param {Node} node1
     * @param {Node} node2
     * @param {number} edgeLength
     * @private
     */

  }, {
    key: "_calculateSpringForce",
    value: function _calculateSpringForce(node1, node2, edgeLength) {
      var dx = node1.x - node2.x;
      var dy = node1.y - node2.y;
      var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01); // the 1/distance is so the fx and fy can be calculated without sine or cosine.

      var springForce = this.options.springConstant * (edgeLength - distance) / distance;
      var fx = dx * springForce;
      var fy = dy * springForce; // handle the case where one node is not part of the physcis

      if (this.physicsBody.forces[node1.id] !== undefined) {
        this.physicsBody.forces[node1.id].x += fx;
        this.physicsBody.forces[node1.id].y += fy;
      }

      if (this.physicsBody.forces[node2.id] !== undefined) {
        this.physicsBody.forces[node2.id].x -= fx;
        this.physicsBody.forces[node2.id].y -= fy;
      }
    }
  }]);

  return SpringSolver;
}();

/**
 * Hierarchical Spring Solver
 */
var HierarchicalSpringSolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function HierarchicalSpringSolver(body, physicsBody, options) {
    _classCallCheck(this, HierarchicalSpringSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(HierarchicalSpringSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * This function calculates the springforces on the nodes, accounting for the support nodes.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var edgeLength, edge;
      var dx, dy, fx, fy, springForce, distance;
      var edges = this.body.edges;
      var factor = 0.5;
      var edgeIndices = this.physicsBody.physicsEdgeIndices;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces; // initialize the spring force counters

      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];
        forces[nodeId].springFx = 0;
        forces[nodeId].springFy = 0;
      } // forces caused by the edges, modelled as springs


      for (var _i = 0; _i < edgeIndices.length; _i++) {
        edge = edges[edgeIndices[_i]];

        if (edge.connected === true) {
          edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;
          dx = edge.from.x - edge.to.x;
          dy = edge.from.y - edge.to.y;
          distance = Math.sqrt(dx * dx + dy * dy);
          distance = distance === 0 ? 0.01 : distance; // the 1/distance is so the fx and fy can be calculated without sine or cosine.

          springForce = this.options.springConstant * (edgeLength - distance) / distance;
          fx = dx * springForce;
          fy = dy * springForce;

          if (edge.to.level != edge.from.level) {
            if (forces[edge.toId] !== undefined) {
              forces[edge.toId].springFx -= fx;
              forces[edge.toId].springFy -= fy;
            }

            if (forces[edge.fromId] !== undefined) {
              forces[edge.fromId].springFx += fx;
              forces[edge.fromId].springFy += fy;
            }
          } else {
            if (forces[edge.toId] !== undefined) {
              forces[edge.toId].x -= factor * fx;
              forces[edge.toId].y -= factor * fy;
            }

            if (forces[edge.fromId] !== undefined) {
              forces[edge.fromId].x += factor * fx;
              forces[edge.fromId].y += factor * fy;
            }
          }
        }
      } // normalize spring forces


      springForce = 1;
      var springFx, springFy;

      for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {
        var _nodeId = nodeIndices[_i2];
        springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));
        springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));
        forces[_nodeId].x += springFx;
        forces[_nodeId].y += springFy;
      } // retain energy balance


      var totalFx = 0;
      var totalFy = 0;

      for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {
        var _nodeId2 = nodeIndices[_i3];
        totalFx += forces[_nodeId2].x;
        totalFy += forces[_nodeId2].y;
      }

      var correctionFx = totalFx / nodeIndices.length;
      var correctionFy = totalFy / nodeIndices.length;

      for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {
        var _nodeId3 = nodeIndices[_i4];
        forces[_nodeId3].x -= correctionFx;
        forces[_nodeId3].y -= correctionFy;
      }
    }
  }]);

  return HierarchicalSpringSolver;
}();

/**
 * Central Gravity Solver
 */
var CentralGravitySolver = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function CentralGravitySolver(body, physicsBody, options) {
    _classCallCheck(this, CentralGravitySolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  /**
   *
   * @param {object} options
   */


  _createClass(CentralGravitySolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * Calculates forces for each node
     */

  }, {
    key: "solve",
    value: function solve() {
      var dx, dy, distance, node;
      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces;

      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];
        node = nodes[nodeId];
        dx = -node.x;
        dy = -node.y;
        distance = Math.sqrt(dx * dx + dy * dy);

        this._calculateForces(distance, dx, dy, forces, node);
      }
    }
    /**
     * Calculate the forces based on the distance.
     *
     * @param {number} distance
     * @param {number} dx
     * @param {number} dy
     * @param {object<Node.id, vis.Node>} forces
     * @param {Node} node
     * @private
     */

  }, {
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, forces, node) {
      var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;
      forces[node.id].x = dx * gravityForce;
      forces[node.id].y = dy * gravityForce;
    }
  }]);

  return CentralGravitySolver;
}();

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * @augments BarnesHutSolver
 */

var ForceAtlas2BasedRepulsionSolver = /*#__PURE__*/function (_BarnesHutSolver) {
  _inherits(ForceAtlas2BasedRepulsionSolver, _BarnesHutSolver);

  var _super = _createSuper$3(ForceAtlas2BasedRepulsionSolver);

  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function ForceAtlas2BasedRepulsionSolver(body, physicsBody, options) {
    var _this;

    _classCallCheck(this, ForceAtlas2BasedRepulsionSolver);

    _this = _super.call(this, body, physicsBody, options);
    _this._rng = Alea("FORCE ATLAS 2 BASED REPULSION SOLVER");
    return _this;
  }
  /**
   * Calculate the forces based on the distance.
   *
   * @param {number} distance
   * @param {number} dx
   * @param {number} dy
   * @param {Node} node
   * @param {object} parentBranch
   * @private
   */


  _createClass(ForceAtlas2BasedRepulsionSolver, [{
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, node, parentBranch) {
      if (distance === 0) {
        distance = 0.1 * this._rng();
        dx = distance;
      }

      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
      }

      var degree = node.edges.length + 1; // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce

      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);
      var fx = dx * gravityForce;
      var fy = dy * gravityForce;
      this.physicsBody.forces[node.id].x += fx;
      this.physicsBody.forces[node.id].y += fy;
    }
  }]);

  return ForceAtlas2BasedRepulsionSolver;
}(BarnesHutSolver);

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * @augments CentralGravitySolver
 */

var ForceAtlas2BasedCentralGravitySolver = /*#__PURE__*/function (_CentralGravitySolver) {
  _inherits(ForceAtlas2BasedCentralGravitySolver, _CentralGravitySolver);

  var _super = _createSuper$2(ForceAtlas2BasedCentralGravitySolver);

  /**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */
  function ForceAtlas2BasedCentralGravitySolver(body, physicsBody, options) {
    _classCallCheck(this, ForceAtlas2BasedCentralGravitySolver);

    return _super.call(this, body, physicsBody, options);
  }
  /**
   * Calculate the forces based on the distance.
   *
   * @param {number} distance
   * @param {number} dx
   * @param {number} dy
   * @param {object<Node.id, Node>} forces
   * @param {Node} node
   * @private
   */


  _createClass(ForceAtlas2BasedCentralGravitySolver, [{
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, forces, node) {
      if (distance > 0) {
        var degree = node.edges.length + 1;
        var gravityForce = this.options.centralGravity * degree * node.options.mass;
        forces[node.id].x = dx * gravityForce;
        forces[node.id].y = dy * gravityForce;
      }
    }
  }]);

  return ForceAtlas2BasedCentralGravitySolver;
}(CentralGravitySolver);

/**
 * The physics engine
 */

var PhysicsEngine = /*#__PURE__*/function () {
  /**
   * @param {object} body
   */
  function PhysicsEngine(body) {
    _classCallCheck(this, PhysicsEngine);

    this.body = body;
    this.physicsBody = {
      physicsNodeIndices: [],
      physicsEdgeIndices: [],
      forces: {},
      velocities: {}
    };
    this.physicsEnabled = true;
    this.simulationInterval = 1000 / 60;
    this.requiresTimeout = true;
    this.previousStates = {};
    this.referenceState = {};
    this.freezeCache = {};
    this.renderTimer = undefined; // parameters for the adaptive timestep

    this.adaptiveTimestep = false;
    this.adaptiveTimestepEnabled = false;
    this.adaptiveCounter = 0;
    this.adaptiveInterval = 3;
    this.stabilized = false;
    this.startedStabilization = false;
    this.stabilizationIterations = 0;
    this.ready = false; // will be set to true if the stabilize
    // default options

    this.options = {};
    this.defaultOptions = {
      enabled: true,
      barnesHut: {
        theta: 0.5,
        gravitationalConstant: -2000,
        centralGravity: 0.3,
        springLength: 95,
        springConstant: 0.04,
        damping: 0.09,
        avoidOverlap: 0
      },
      forceAtlas2Based: {
        theta: 0.5,
        gravitationalConstant: -50,
        centralGravity: 0.01,
        springConstant: 0.08,
        springLength: 100,
        damping: 0.4,
        avoidOverlap: 0
      },
      repulsion: {
        centralGravity: 0.2,
        springLength: 200,
        springConstant: 0.05,
        nodeDistance: 100,
        damping: 0.09,
        avoidOverlap: 0
      },
      hierarchicalRepulsion: {
        centralGravity: 0.0,
        springLength: 100,
        springConstant: 0.01,
        nodeDistance: 120,
        damping: 0.09
      },
      maxVelocity: 50,
      minVelocity: 0.75,
      // px/s
      solver: "barnesHut",
      stabilization: {
        enabled: true,
        iterations: 1000,
        // maximum number of iteration to stabilize
        updateInterval: 50,
        onlyDynamicEdges: false,
        fit: true
      },
      timestep: 0.5,
      adaptiveTimestep: true,
      wind: {
        x: 0,
        y: 0
      }
    };

    assign$2(this.options, this.defaultOptions);

    this.timestep = 0.5;
    this.layoutFailed = false;
    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(PhysicsEngine, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this;

      this.body.emitter.on("initPhysics", function () {
        _this.initPhysics();
      });
      this.body.emitter.on("_layoutFailed", function () {
        _this.layoutFailed = true;
      });
      this.body.emitter.on("resetPhysics", function () {
        _this.stopSimulation();

        _this.ready = false;
      });
      this.body.emitter.on("disablePhysics", function () {
        _this.physicsEnabled = false;

        _this.stopSimulation();
      });
      this.body.emitter.on("restorePhysics", function () {
        _this.setOptions(_this.options);

        if (_this.ready === true) {
          _this.startSimulation();
        }
      });
      this.body.emitter.on("startSimulation", function () {
        if (_this.ready === true) {
          _this.startSimulation();
        }
      });
      this.body.emitter.on("stopSimulation", function () {
        _this.stopSimulation();
      });
      this.body.emitter.on("destroy", function () {
        _this.stopSimulation(false);

        _this.body.emitter.off();
      });
      this.body.emitter.on("_dataChanged", function () {
        // Nodes and/or edges have been added or removed, update shortcut lists.
        _this.updatePhysicsData();
      }); // debug: show forces
      // this.body.emitter.on("afterDrawing", (ctx) => {this._drawForces(ctx);});
    }
    /**
     * set the physics options
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        if (options === false) {
          this.options.enabled = false;
          this.physicsEnabled = false;
          this.stopSimulation();
        } else if (options === true) {
          this.options.enabled = true;
          this.physicsEnabled = true;
          this.startSimulation();
        } else {
          this.physicsEnabled = true;
          selectiveNotDeepExtend(["stabilization"], this.options, options);
          mergeOptions(this.options, options, "stabilization");

          if (options.enabled === undefined) {
            this.options.enabled = true;
          }

          if (this.options.enabled === false) {
            this.physicsEnabled = false;
            this.stopSimulation();
          }

          var wind = this.options.wind;

          if (wind) {
            if (typeof wind.x !== "number" || isNan(wind.x)) {
              wind.x = 0;
            }

            if (typeof wind.y !== "number" || isNan(wind.y)) {
              wind.y = 0;
            }
          } // set the timestep


          this.timestep = this.options.timestep;
        }
      }

      this.init();
    }
    /**
     * configure the engine.
     */

  }, {
    key: "init",
    value: function init() {
      var options;

      if (this.options.solver === "forceAtlas2Based") {
        options = this.options.forceAtlas2Based;
        this.nodesSolver = new ForceAtlas2BasedRepulsionSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new ForceAtlas2BasedCentralGravitySolver(this.body, this.physicsBody, options);
      } else if (this.options.solver === "repulsion") {
        options = this.options.repulsion;
        this.nodesSolver = new RepulsionSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      } else if (this.options.solver === "hierarchicalRepulsion") {
        options = this.options.hierarchicalRepulsion;
        this.nodesSolver = new HierarchicalRepulsionSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new HierarchicalSpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      } else {
        // barnesHut
        options = this.options.barnesHut;
        this.nodesSolver = new BarnesHutSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      }

      this.modelOptions = options;
    }
    /**
     * initialize the engine
     */

  }, {
    key: "initPhysics",
    value: function initPhysics() {
      if (this.physicsEnabled === true && this.options.enabled === true) {
        if (this.options.stabilization.enabled === true) {
          this.stabilize();
        } else {
          this.stabilized = false;
          this.ready = true;
          this.body.emitter.emit("fit", {}, this.layoutFailed); // if the layout failed, we use the approximation for the zoom

          this.startSimulation();
        }
      } else {
        this.ready = true;
        this.body.emitter.emit("fit");
      }
    }
    /**
     * Start the simulation
     */

  }, {
    key: "startSimulation",
    value: function startSimulation() {
      if (this.physicsEnabled === true && this.options.enabled === true) {
        this.stabilized = false; // when visible, adaptivity is disabled.

        this.adaptiveTimestep = false; // this sets the width of all nodes initially which could be required for the avoidOverlap

        this.body.emitter.emit("_resizeNodes");

        if (this.viewFunction === undefined) {
          var _context;

          this.viewFunction = bind$6(_context = this.simulationStep).call(_context, this);
          this.body.emitter.on("initRedraw", this.viewFunction);
          this.body.emitter.emit("_startRendering");
        }
      } else {
        this.body.emitter.emit("_redraw");
      }
    }
    /**
     * Stop the simulation, force stabilization.
     *
     * @param {boolean} [emit=true]
     */

  }, {
    key: "stopSimulation",
    value: function stopSimulation() {
      var emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.stabilized = true;

      if (emit === true) {
        this._emitStabilized();
      }

      if (this.viewFunction !== undefined) {
        this.body.emitter.off("initRedraw", this.viewFunction);
        this.viewFunction = undefined;

        if (emit === true) {
          this.body.emitter.emit("_stopRendering");
        }
      }
    }
    /**
     * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.
     *
     */

  }, {
    key: "simulationStep",
    value: function simulationStep() {
      // check if the physics have settled
      var startTime = now$1();

      this.physicsTick();
      var physicsTime = now$1() - startTime; // run double speed if it is a little graph

      if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {
        this.physicsTick(); // this makes sure there is no jitter. The decision is taken once to run it at double speed.

        this.runDoubleSpeed = true;
      }

      if (this.stabilized === true) {
        this.stopSimulation();
      }
    }
    /**
     * trigger the stabilized event.
     *
     * @param {number} [amountOfIterations=this.stabilizationIterations]
     * @private
     */

  }, {
    key: "_emitStabilized",
    value: function _emitStabilized() {
      var _this2 = this;

      var amountOfIterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.stabilizationIterations;

      if (this.stabilizationIterations > 1 || this.startedStabilization === true) {
        setTimeout$1(function () {
          _this2.body.emitter.emit("stabilized", {
            iterations: amountOfIterations
          });

          _this2.startedStabilization = false;
          _this2.stabilizationIterations = 0;
        }, 0);
      }
    }
    /**
     * Calculate the forces for one physics iteration and move the nodes.
     *
     * @private
     */

  }, {
    key: "physicsStep",
    value: function physicsStep() {
      this.gravitySolver.solve();
      this.nodesSolver.solve();
      this.edgesSolver.solve();
      this.moveNodes();
    }
    /**
     * Make dynamic adjustments to the timestep, based on current state.
     *
     * Helper function for physicsTick().
     *
     * @private
     */

  }, {
    key: "adjustTimeStep",
    value: function adjustTimeStep() {
      var factor = 1.2; // Factor for increasing the timestep on success.
      // we compare the two steps. if it is acceptable we double the step.

      if (this._evaluateStepQuality() === true) {
        this.timestep = factor * this.timestep;
      } else {
        // if not, we decrease the step to a minimum of the options timestep.
        // if the decreased timestep is smaller than the options step, we do not reset the counter
        // we assume that the options timestep is stable enough.
        if (this.timestep / factor < this.options.timestep) {
          this.timestep = this.options.timestep;
        } else {
          // if the timestep was larger than 2 times the option one we check the adaptivity again to ensure
          // that large instabilities do not form.
          this.adaptiveCounter = -1; // check again next iteration

          this.timestep = Math.max(this.options.timestep, this.timestep / factor);
        }
      }
    }
    /**
     * A single simulation step (or 'tick') in the physics simulation
     *
     * @private
     */

  }, {
    key: "physicsTick",
    value: function physicsTick() {
      this._startStabilizing(); // this ensures that there is no start event when the network is already stable.


      if (this.stabilized === true) return; // adaptivity means the timestep adapts to the situation, only applicable for stabilization

      if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {
        // timestep remains stable for "interval" iterations.
        var doAdaptive = this.adaptiveCounter % this.adaptiveInterval === 0;

        if (doAdaptive) {
          // first the big step and revert.
          this.timestep = 2 * this.timestep;
          this.physicsStep();
          this.revert(); // saves the reference state
          // now the normal step. Since this is the last step, it is the more stable one and we will take this.

          this.timestep = 0.5 * this.timestep; // since it's half the step, we do it twice.

          this.physicsStep();
          this.physicsStep();
          this.adjustTimeStep();
        } else {
          this.physicsStep(); // normal step, keeping timestep constant
        }

        this.adaptiveCounter += 1;
      } else {
        // case for the static timestep, we reset it to the one in options and take a normal step.
        this.timestep = this.options.timestep;
        this.physicsStep();
      }

      if (this.stabilized === true) this.revert();
      this.stabilizationIterations++;
    }
    /**
     * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.
     *
     * @private
     */

  }, {
    key: "updatePhysicsData",
    value: function updatePhysicsData() {
      this.physicsBody.forces = {};
      this.physicsBody.physicsNodeIndices = [];
      this.physicsBody.physicsEdgeIndices = [];
      var nodes = this.body.nodes;
      var edges = this.body.edges; // get node indices for physics

      for (var nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
          if (nodes[nodeId].options.physics === true) {
            this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);
          }
        }
      } // get edge indices for physics


      for (var edgeId in edges) {
        if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {
          if (edges[edgeId].options.physics === true) {
            this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);
          }
        }
      } // get the velocity and the forces vector


      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
        var _nodeId = this.physicsBody.physicsNodeIndices[i];
        this.physicsBody.forces[_nodeId] = {
          x: 0,
          y: 0
        }; // forces can be reset because they are recalculated. Velocities have to persist.

        if (this.physicsBody.velocities[_nodeId] === undefined) {
          this.physicsBody.velocities[_nodeId] = {
            x: 0,
            y: 0
          };
        }
      } // clean deleted nodes from the velocity vector


      for (var _nodeId2 in this.physicsBody.velocities) {
        if (nodes[_nodeId2] === undefined) {
          delete this.physicsBody.velocities[_nodeId2];
        }
      }
    }
    /**
     * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.
     */

  }, {
    key: "revert",
    value: function revert() {
      var nodeIds = keys$4(this.previousStates);

      var nodes = this.body.nodes;
      var velocities = this.physicsBody.velocities;
      this.referenceState = {};

      for (var i = 0; i < nodeIds.length; i++) {
        var nodeId = nodeIds[i];

        if (nodes[nodeId] !== undefined) {
          if (nodes[nodeId].options.physics === true) {
            this.referenceState[nodeId] = {
              positions: {
                x: nodes[nodeId].x,
                y: nodes[nodeId].y
              }
            };
            velocities[nodeId].x = this.previousStates[nodeId].vx;
            velocities[nodeId].y = this.previousStates[nodeId].vy;
            nodes[nodeId].x = this.previousStates[nodeId].x;
            nodes[nodeId].y = this.previousStates[nodeId].y;
          }
        } else {
          delete this.previousStates[nodeId];
        }
      }
    }
    /**
     * This compares the reference state to the current state
     *
     * @returns {boolean}
     * @private
     */

  }, {
    key: "_evaluateStepQuality",
    value: function _evaluateStepQuality() {
      var dx, dy, dpos;
      var nodes = this.body.nodes;
      var reference = this.referenceState;
      var posThreshold = 0.3;

      for (var nodeId in this.referenceState) {
        if (Object.prototype.hasOwnProperty.call(this.referenceState, nodeId) && nodes[nodeId] !== undefined) {
          dx = nodes[nodeId].x - reference[nodeId].positions.x;
          dy = nodes[nodeId].y - reference[nodeId].positions.y;
          dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

          if (dpos > posThreshold) {
            return false;
          }
        }
      }

      return true;
    }
    /**
     * move the nodes one timestep and check if they are stabilized
     */

  }, {
    key: "moveNodes",
    value: function moveNodes() {
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var maxNodeVelocity = 0;
      var averageNodeVelocity = 0; // the velocity threshold (energy in the system) for the adaptivity toggle

      var velocityAdaptiveThreshold = 5;

      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];

        var nodeVelocity = this._performStep(nodeId); // stabilized is true if stabilized is true and velocity is smaller than vmin --> all nodes must be stabilized


        maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);
        averageNodeVelocity += nodeVelocity;
      } // evaluating the stabilized and adaptiveTimestepEnabled conditions


      this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;
      this.stabilized = maxNodeVelocity < this.options.minVelocity;
    }
    /**
     * Calculate new velocity for a coordinate direction
     *
     * @param {number} v  velocity for current coordinate
     * @param {number} f  regular force for current coordinate
     * @param {number} m  mass of current node
     * @returns {number} new velocity for current coordinate
     * @private
     */

  }, {
    key: "calculateComponentVelocity",
    value: function calculateComponentVelocity(v, f, m) {
      var df = this.modelOptions.damping * v; // damping force

      var a = (f - df) / m; // acceleration

      v += a * this.timestep; // Put a limit on the velocities if it is really high

      var maxV = this.options.maxVelocity || 1e9;

      if (Math.abs(v) > maxV) {
        v = v > 0 ? maxV : -maxV;
      }

      return v;
    }
    /**
     * Perform the actual step
     *
     * @param {Node.id} nodeId
     * @returns {number} the new velocity of given node
     * @private
     */

  }, {
    key: "_performStep",
    value: function _performStep(nodeId) {
      var node = this.body.nodes[nodeId];
      var force = this.physicsBody.forces[nodeId];

      if (this.options.wind) {
        force.x += this.options.wind.x;
        force.y += this.options.wind.y;
      }

      var velocity = this.physicsBody.velocities[nodeId]; // store the state so we can revert

      this.previousStates[nodeId] = {
        x: node.x,
        y: node.y,
        vx: velocity.x,
        vy: velocity.y
      };

      if (node.options.fixed.x === false) {
        velocity.x = this.calculateComponentVelocity(velocity.x, force.x, node.options.mass);
        node.x += velocity.x * this.timestep;
      } else {
        force.x = 0;
        velocity.x = 0;
      }

      if (node.options.fixed.y === false) {
        velocity.y = this.calculateComponentVelocity(velocity.y, force.y, node.options.mass);
        node.y += velocity.y * this.timestep;
      } else {
        force.y = 0;
        velocity.y = 0;
      }

      var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));
      return totalVelocity;
    }
    /**
     * When initializing and stabilizing, we can freeze nodes with a predefined position.
     * This greatly speeds up stabilization because only the supportnodes for the smoothCurves have to settle.
     *
     * @private
     */

  }, {
    key: "_freezeNodes",
    value: function _freezeNodes() {
      var nodes = this.body.nodes;

      for (var id in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, id)) {
          if (nodes[id].x && nodes[id].y) {
            var fixed = nodes[id].options.fixed;
            this.freezeCache[id] = {
              x: fixed.x,
              y: fixed.y
            };
            fixed.x = true;
            fixed.y = true;
          }
        }
      }
    }
    /**
     * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.
     *
     * @private
     */

  }, {
    key: "_restoreFrozenNodes",
    value: function _restoreFrozenNodes() {
      var nodes = this.body.nodes;

      for (var id in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, id)) {
          if (this.freezeCache[id] !== undefined) {
            nodes[id].options.fixed.x = this.freezeCache[id].x;
            nodes[id].options.fixed.y = this.freezeCache[id].y;
          }
        }
      }

      this.freezeCache = {};
    }
    /**
     * Find a stable position for all nodes
     *
     * @param {number} [iterations=this.options.stabilization.iterations]
     */

  }, {
    key: "stabilize",
    value: function stabilize() {
      var _this3 = this;

      var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.stabilization.iterations;

      if (typeof iterations !== "number") {
        iterations = this.options.stabilization.iterations;
        console.error("The stabilize method needs a numeric amount of iterations. Switching to default: ", iterations);
      }

      if (this.physicsBody.physicsNodeIndices.length === 0) {
        this.ready = true;
        return;
      } // enable adaptive timesteps


      this.adaptiveTimestep = this.options.adaptiveTimestep; // this sets the width of all nodes initially which could be required for the avoidOverlap

      this.body.emitter.emit("_resizeNodes");
      this.stopSimulation(); // stop the render loop

      this.stabilized = false; // block redraw requests

      this.body.emitter.emit("_blockRedraw");
      this.targetIterations = iterations; // start the stabilization

      if (this.options.stabilization.onlyDynamicEdges === true) {
        this._freezeNodes();
      }

      this.stabilizationIterations = 0;

      setTimeout$1(function () {
        return _this3._stabilizationBatch();
      }, 0);
    }
    /**
     * If not already stabilizing, start it and emit a start event.
     *
     * @returns {boolean} true if stabilization started with this call
     * @private
     */

  }, {
    key: "_startStabilizing",
    value: function _startStabilizing() {
      if (this.startedStabilization === true) return false;
      this.body.emitter.emit("startStabilizing");
      this.startedStabilization = true;
      return true;
    }
    /**
     * One batch of stabilization
     *
     * @private
     */

  }, {
    key: "_stabilizationBatch",
    value: function _stabilizationBatch() {
      var _this4 = this;

      var running = function running() {
        return _this4.stabilized === false && _this4.stabilizationIterations < _this4.targetIterations;
      };

      var sendProgress = function sendProgress() {
        _this4.body.emitter.emit("stabilizationProgress", {
          iterations: _this4.stabilizationIterations,
          total: _this4.targetIterations
        });
      };

      if (this._startStabilizing()) {
        sendProgress(); // Ensure that there is at least one start event.
      }

      var count = 0;

      while (running() && count < this.options.stabilization.updateInterval) {
        this.physicsTick();
        count++;
      }

      sendProgress();

      if (running()) {
        var _context2;

        setTimeout$1(bind$6(_context2 = this._stabilizationBatch).call(_context2, this), 0);
      } else {
        this._finalizeStabilization();
      }
    }
    /**
     * Wrap up the stabilization, fit and emit the events.
     *
     * @private
     */

  }, {
    key: "_finalizeStabilization",
    value: function _finalizeStabilization() {
      this.body.emitter.emit("_allowRedraw");

      if (this.options.stabilization.fit === true) {
        this.body.emitter.emit("fit");
      }

      if (this.options.stabilization.onlyDynamicEdges === true) {
        this._restoreFrozenNodes();
      }

      this.body.emitter.emit("stabilizationIterationsDone");
      this.body.emitter.emit("_requestRedraw");

      if (this.stabilized === true) {
        this._emitStabilized();
      } else {
        this.startSimulation();
      }

      this.ready = true;
    } //---------------------------  DEBUGGING BELOW  ---------------------------//

    /**
     * Debug function that display arrows for the forces currently active in the network.
     *
     * Use this when debugging only.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */

  }, {
    key: "_drawForces",
    value: function _drawForces(ctx) {
      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
        var index = this.physicsBody.physicsNodeIndices[i];
        var node = this.body.nodes[index];
        var force = this.physicsBody.forces[index];
        var factor = 20;
        var colorFactor = 0.03;
        var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));
        var size = Math.min(Math.max(5, forceSize), 15);
        var arrowSize = 3 * size;
        var color = HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);
        var point = {
          x: node.x + factor * force.x,
          y: node.y + factor * force.y
        };
        ctx.lineWidth = size;
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(point.x, point.y);
        ctx.stroke();
        var angle = Math.atan2(force.y, force.x);
        ctx.fillStyle = color;
        EndPoints.draw(ctx, {
          type: "arrow",
          point: point,
          angle: angle,
          length: arrowSize
        });

        fill(ctx).call(ctx);
      }
    }
  }]);

  return PhysicsEngine;
}();

/**
 * Utility Class
 */

var NetworkUtil = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function NetworkUtil() {
    _classCallCheck(this, NetworkUtil);
  }
  /**
   * Find the center position of the network considering the bounding boxes
   *
   * @param {Array.<Node>} allNodes
   * @param {Array.<Node>} [specificNodes=[]]
   * @returns {{minX: number, maxX: number, minY: number, maxY: number}}
   * @static
   */


  _createClass(NetworkUtil, null, [{
    key: "getRange",
    value: function getRange(allNodes) {
      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var minY = 1e9,
          maxY = -1e9,
          minX = 1e9,
          maxX = -1e9,
          node;

      if (specificNodes.length > 0) {
        for (var i = 0; i < specificNodes.length; i++) {
          node = allNodes[specificNodes[i]];

          if (minX > node.shape.boundingBox.left) {
            minX = node.shape.boundingBox.left;
          }

          if (maxX < node.shape.boundingBox.right) {
            maxX = node.shape.boundingBox.right;
          }

          if (minY > node.shape.boundingBox.top) {
            minY = node.shape.boundingBox.top;
          } // top is negative, bottom is positive


          if (maxY < node.shape.boundingBox.bottom) {
            maxY = node.shape.boundingBox.bottom;
          } // top is negative, bottom is positive

        }
      }

      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
        minY = 0, maxY = 0, minX = 0, maxX = 0;
      }

      return {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY
      };
    }
    /**
     * Find the center position of the network
     *
     * @param {Array.<Node>} allNodes
     * @param {Array.<Node>} [specificNodes=[]]
     * @returns {{minX: number, maxX: number, minY: number, maxY: number}}
     * @static
     */

  }, {
    key: "getRangeCore",
    value: function getRangeCore(allNodes) {
      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var minY = 1e9,
          maxY = -1e9,
          minX = 1e9,
          maxX = -1e9,
          node;

      if (specificNodes.length > 0) {
        for (var i = 0; i < specificNodes.length; i++) {
          node = allNodes[specificNodes[i]];

          if (minX > node.x) {
            minX = node.x;
          }

          if (maxX < node.x) {
            maxX = node.x;
          }

          if (minY > node.y) {
            minY = node.y;
          } // top is negative, bottom is positive


          if (maxY < node.y) {
            maxY = node.y;
          } // top is negative, bottom is positive

        }
      }

      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
        minY = 0, maxY = 0, minX = 0, maxX = 0;
      }

      return {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY
      };
    }
    /**
     * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};
     * @returns {{x: number, y: number}}
     * @static
     */

  }, {
    key: "findCenter",
    value: function findCenter(range) {
      return {
        x: 0.5 * (range.maxX + range.minX),
        y: 0.5 * (range.maxY + range.minY)
      };
    }
    /**
     * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.
     *
     * @param {vis.Item} item
     * @param {'node'|undefined} type
     * @returns {{}}
     * @static
     */

  }, {
    key: "cloneOptions",
    value: function cloneOptions(item, type) {
      var clonedOptions = {};

      if (type === undefined || type === "node") {
        deepExtend(clonedOptions, item.options, true);
        clonedOptions.x = item.x;
        clonedOptions.y = item.y;
        clonedOptions.amountOfConnections = item.edges.length;
      } else {
        deepExtend(clonedOptions, item.options, true);
      }

      return clonedOptions;
    }
  }]);

  return NetworkUtil;
}();

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * A Cluster is a special Node that allows a group of Nodes positioned closely together
 * to be represented by a single Cluster Node.
 *
 * @augments Node
 */

var Cluster = /*#__PURE__*/function (_Node) {
  _inherits(Cluster, _Node);

  var _super = _createSuper$1(Cluster);

  /**
   * @param {object} options
   * @param {object} body
   * @param {Array.<HTMLImageElement>}imagelist
   * @param {Array} grouplist
   * @param {object} globalOptions
   * @param {object} defaultOptions     Global default options for nodes
   */
  function Cluster(options, body, imagelist, grouplist, globalOptions, defaultOptions) {
    var _this;

    _classCallCheck(this, Cluster);

    _this = _super.call(this, options, body, imagelist, grouplist, globalOptions, defaultOptions);
    _this.isCluster = true;
    _this.containedNodes = {};
    _this.containedEdges = {};
    return _this;
  }
  /**
   * Transfer child cluster data to current and disconnect the child cluster.
   *
   * Please consult the header comment in 'Clustering.js' for the fields set here.
   *
   * @param {string|number} childClusterId  id of child cluster to open
   */


  _createClass(Cluster, [{
    key: "_openChildCluster",
    value: function _openChildCluster(childClusterId) {
      var _this2 = this;

      var childCluster = this.body.nodes[childClusterId];

      if (this.containedNodes[childClusterId] === undefined) {
        throw new Error("node with id: " + childClusterId + " not in current cluster");
      }

      if (!childCluster.isCluster) {
        throw new Error("node with id: " + childClusterId + " is not a cluster");
      } // Disconnect child cluster from current cluster


      delete this.containedNodes[childClusterId];
      forEach$1(childCluster.edges, function (edge) {
        delete _this2.containedEdges[edge.id];
      }); // Transfer nodes and edges

      forEach$1(childCluster.containedNodes, function (node, nodeId) {
        _this2.containedNodes[nodeId] = node;
      });
      childCluster.containedNodes = {};
      forEach$1(childCluster.containedEdges, function (edge, edgeId) {
        _this2.containedEdges[edgeId] = edge;
      });
      childCluster.containedEdges = {}; // Transfer edges within cluster edges which are clustered

      forEach$1(childCluster.edges, function (clusterEdge) {
        forEach$1(_this2.edges, function (parentClusterEdge) {
          var _context, _context2;

          // Assumption: a clustered edge can only be present in a single clustering edge
          // Not tested here
          var index = indexOf(_context = parentClusterEdge.clusteringEdgeReplacingIds).call(_context, clusterEdge.id);

          if (index === -1) return;
          forEach$1(clusterEdge.clusteringEdgeReplacingIds, function (srcId) {
            parentClusterEdge.clusteringEdgeReplacingIds.push(srcId); // Maintain correct bookkeeping for transferred edge

            _this2.body.edges[srcId].edgeReplacedById = parentClusterEdge.id;
          }); // Remove cluster edge from parent cluster edge

          splice$1(_context2 = parentClusterEdge.clusteringEdgeReplacingIds).call(_context2, index, 1);
        });
      });
      childCluster.edges = [];
    }
  }]);

  return Cluster;
}(Node);

/**
 * The clustering engine
 */

var ClusterEngine = /*#__PURE__*/function () {
  /**
   * @param {object} body
   */
  function ClusterEngine(body) {
    var _this = this;

    _classCallCheck(this, ClusterEngine);

    this.body = body;
    this.clusteredNodes = {}; // key: node id, value: { clusterId: <id of cluster>, node: <node instance>}

    this.clusteredEdges = {}; // key: edge id, value: restore information for given edge

    this.options = {};
    this.defaultOptions = {};

    assign$2(this.options, this.defaultOptions);

    this.body.emitter.on("_resetData", function () {
      _this.clusteredNodes = {};
      _this.clusteredEdges = {};
    });
  }
  /**
   *
   * @param {number} hubsize
   * @param {object} options
   */


  _createClass(ClusterEngine, [{
    key: "clusterByHubsize",
    value: function clusterByHubsize(hubsize, options) {
      if (hubsize === undefined) {
        hubsize = this._getHubSize();
      } else if (_typeof(hubsize) === "object") {
        options = this._checkOptions(hubsize);
        hubsize = this._getHubSize();
      }

      var nodesToCluster = [];

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var node = this.body.nodes[this.body.nodeIndices[i]];

        if (node.edges.length >= hubsize) {
          nodesToCluster.push(node.id);
        }
      }

      for (var _i = 0; _i < nodesToCluster.length; _i++) {
        this.clusterByConnection(nodesToCluster[_i], options, true);
      }

      this.body.emitter.emit("_dataChanged");
    }
    /**
     * loop over all nodes, check if they adhere to the condition and cluster if needed.
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "cluster",
    value: function cluster() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (options.joinCondition === undefined) {
        throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");
      } // check if the options object is fine, append if needed


      options = this._checkOptions(options);
      var childNodesObj = {};
      var childEdgesObj = {}; // collect the nodes that will be in the cluster

      forEach$1(this.body.nodes, function (node, nodeId) {
        if (node.options && options.joinCondition(node.options) === true) {
          childNodesObj[nodeId] = node; // collect the edges that will be in the cluster

          forEach$1(node.edges, function (edge) {
            if (_this2.clusteredEdges[edge.id] === undefined) {
              childEdgesObj[edge.id] = edge;
            }
          });
        }
      });

      this._cluster(childNodesObj, childEdgesObj, options, refreshData);
    }
    /**
     * Cluster all nodes in the network that have only X edges
     *
     * @param {number} edgeCount
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "clusterByEdgeCount",
    value: function clusterByEdgeCount(edgeCount, options) {
      var _this3 = this;

      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      options = this._checkOptions(options);
      var clusters = [];
      var usedNodes = {};
      var edge, edges, relevantEdgeCount; // collect the nodes that will be in the cluster

      var _loop = function _loop(i) {
        var childNodesObj = {};
        var childEdgesObj = {};
        var nodeId = _this3.body.nodeIndices[i];
        var node = _this3.body.nodes[nodeId]; // if this node is already used in another cluster this session, we do not have to re-evaluate it.

        if (usedNodes[nodeId] === undefined) {
          relevantEdgeCount = 0;
          edges = [];

          for (var j = 0; j < node.edges.length; j++) {
            edge = node.edges[j];

            if (_this3.clusteredEdges[edge.id] === undefined) {
              if (edge.toId !== edge.fromId) {
                relevantEdgeCount++;
              }

              edges.push(edge);
            }
          } // this node qualifies, we collect its neighbours to start the clustering process.


          if (relevantEdgeCount === edgeCount) {
            var checkJoinCondition = function checkJoinCondition(node) {
              if (options.joinCondition === undefined || options.joinCondition === null) {
                return true;
              }

              var clonedOptions = NetworkUtil.cloneOptions(node);
              return options.joinCondition(clonedOptions);
            };

            var gatheringSuccessful = true;

            for (var _j = 0; _j < edges.length; _j++) {
              edge = edges[_j];

              var childNodeId = _this3._getConnectedId(edge, nodeId); // add the nodes to the list by the join condition.


              if (checkJoinCondition(node)) {
                childEdgesObj[edge.id] = edge;
                childNodesObj[nodeId] = node;
                childNodesObj[childNodeId] = _this3.body.nodes[childNodeId];
                usedNodes[nodeId] = true;
              } else {
                // this node does not qualify after all.
                gatheringSuccessful = false;
                break;
              }
            } // add to the cluster queue


            if (keys$4(childNodesObj).length > 0 && keys$4(childEdgesObj).length > 0 && gatheringSuccessful === true) {
              /**
               * Search for cluster data that contains any of the node id's
               *
               * @returns {boolean} true if no joinCondition, otherwise return value of joinCondition
               */
              var findClusterData = function findClusterData() {
                for (var n = 0; n < clusters.length; ++n) {
                  // Search for a cluster containing any of the node id's
                  for (var m in childNodesObj) {
                    if (clusters[n].nodes[m] !== undefined) {
                      return clusters[n];
                    }
                  }
                }

                return undefined;
              }; // If any of the found nodes is part of a cluster found in this method,
              // add the current values to that cluster


              var foundCluster = findClusterData();

              if (foundCluster !== undefined) {
                // Add nodes to found cluster if not present
                for (var m in childNodesObj) {
                  if (foundCluster.nodes[m] === undefined) {
                    foundCluster.nodes[m] = childNodesObj[m];
                  }
                } // Add edges to found cluster, if not present


                for (var _m in childEdgesObj) {
                  if (foundCluster.edges[_m] === undefined) {
                    foundCluster.edges[_m] = childEdgesObj[_m];
                  }
                }
              } else {
                // Create a new cluster group
                clusters.push({
                  nodes: childNodesObj,
                  edges: childEdgesObj
                });
              }
            }
          }
        }
      };

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        _loop(i);
      }

      for (var _i2 = 0; _i2 < clusters.length; _i2++) {
        this._cluster(clusters[_i2].nodes, clusters[_i2].edges, options, false);
      }

      if (refreshData === true) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Cluster all nodes in the network that have only 1 edge
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "clusterOutliers",
    value: function clusterOutliers(options) {
      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.clusterByEdgeCount(1, options, refreshData);
    }
    /**
     * Cluster all nodes in the network that have only 2 edge
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "clusterBridges",
    value: function clusterBridges(options) {
      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.clusterByEdgeCount(2, options, refreshData);
    }
    /**
     * suck all connected nodes of a node into the node.
     *
     * @param {Node.id} nodeId
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: "clusterByConnection",
    value: function clusterByConnection(nodeId, options) {
      var _context;

      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      // kill conditions
      if (nodeId === undefined) {
        throw new Error("No nodeId supplied to clusterByConnection!");
      }

      if (this.body.nodes[nodeId] === undefined) {
        throw new Error("The nodeId given to clusterByConnection does not exist!");
      }

      var node = this.body.nodes[nodeId];
      options = this._checkOptions(options, node);

      if (options.clusterNodeProperties.x === undefined) {
        options.clusterNodeProperties.x = node.x;
      }

      if (options.clusterNodeProperties.y === undefined) {
        options.clusterNodeProperties.y = node.y;
      }

      if (options.clusterNodeProperties.fixed === undefined) {
        options.clusterNodeProperties.fixed = {};
        options.clusterNodeProperties.fixed.x = node.options.fixed.x;
        options.clusterNodeProperties.fixed.y = node.options.fixed.y;
      }

      var childNodesObj = {};
      var childEdgesObj = {};
      var parentNodeId = node.id;
      var parentClonedOptions = NetworkUtil.cloneOptions(node);
      childNodesObj[parentNodeId] = node; // collect the nodes that will be in the cluster

      for (var i = 0; i < node.edges.length; i++) {
        var edge = node.edges[i];

        if (this.clusteredEdges[edge.id] === undefined) {
          var childNodeId = this._getConnectedId(edge, parentNodeId); // if the child node is not in a cluster


          if (this.clusteredNodes[childNodeId] === undefined) {
            if (childNodeId !== parentNodeId) {
              if (options.joinCondition === undefined) {
                childEdgesObj[edge.id] = edge;
                childNodesObj[childNodeId] = this.body.nodes[childNodeId];
              } else {
                // clone the options and insert some additional parameters that could be interesting.
                var childClonedOptions = NetworkUtil.cloneOptions(this.body.nodes[childNodeId]);

                if (options.joinCondition(parentClonedOptions, childClonedOptions) === true) {
                  childEdgesObj[edge.id] = edge;
                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                }
              }
            } else {
              // swallow the edge if it is self-referencing.
              childEdgesObj[edge.id] = edge;
            }
          }
        }
      }

      var childNodeIDs = map$3(_context = keys$4(childNodesObj)).call(_context, function (childNode) {
        return childNodesObj[childNode].id;
      });

      for (var childNodeKey in childNodesObj) {
        if (!Object.prototype.hasOwnProperty.call(childNodesObj, childNodeKey)) continue;
        var childNode = childNodesObj[childNodeKey];

        for (var y = 0; y < childNode.edges.length; y++) {
          var childEdge = childNode.edges[y];

          if (indexOf(childNodeIDs).call(childNodeIDs, this._getConnectedId(childEdge, childNode.id)) > -1) {
            childEdgesObj[childEdge.id] = childEdge;
          }
        }
      }

      this._cluster(childNodesObj, childEdgesObj, options, refreshData);
    }
    /**
     * This function creates the edges that will be attached to the cluster
     * It looks for edges that are connected to the nodes from the "outside' of the cluster.
     *
     * @param {{Node.id: vis.Node}} childNodesObj
     * @param {{vis.Edge.id: vis.Edge}} childEdgesObj
     * @param {object} clusterNodeProperties
     * @param {object} clusterEdgeProperties
     * @private
     */

  }, {
    key: "_createClusterEdges",
    value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {
      var edge, childNodeId, childNode, toId, fromId, otherNodeId; // loop over all child nodes and their edges to find edges going out of the cluster
      // these edges will be replaced by clusterEdges.

      var childKeys = keys$4(childNodesObj);

      var createEdges = [];

      for (var i = 0; i < childKeys.length; i++) {
        childNodeId = childKeys[i];
        childNode = childNodesObj[childNodeId]; // construct new edges from the cluster to others

        for (var j = 0; j < childNode.edges.length; j++) {
          edge = childNode.edges[j]; // we only handle edges that are visible to the system, not the disabled ones from the clustering process.

          if (this.clusteredEdges[edge.id] === undefined) {
            // self-referencing edges will be added to the "hidden" list
            if (edge.toId == edge.fromId) {
              childEdgesObj[edge.id] = edge;
            } else {
              // set up the from and to.
              if (edge.toId == childNodeId) {
                // this is a double equals because ints and strings can be interchanged here.
                toId = clusterNodeProperties.id;
                fromId = edge.fromId;
                otherNodeId = fromId;
              } else {
                toId = edge.toId;
                fromId = clusterNodeProperties.id;
                otherNodeId = toId;
              }
            } // Only edges from the cluster outwards are being replaced.


            if (childNodesObj[otherNodeId] === undefined) {
              createEdges.push({
                edge: edge,
                fromId: fromId,
                toId: toId
              });
            }
          }
        }
      } //
      // Here we actually create the replacement edges.
      //
      // We could not do this in the loop above as the creation process
      // would add an edge to the edges array we are iterating over.
      //
      // NOTE: a clustered edge can have multiple base edges!
      //


      var newEdges = [];
      /**
       * Find a cluster edge which matches the given created edge.
       *
       * @param {vis.Edge} createdEdge
       * @returns {vis.Edge}
       */

      var getNewEdge = function getNewEdge(createdEdge) {
        for (var _j2 = 0; _j2 < newEdges.length; _j2++) {
          var newEdge = newEdges[_j2]; // We replace both to and from edges with a single cluster edge

          var matchToDirection = createdEdge.fromId === newEdge.fromId && createdEdge.toId === newEdge.toId;
          var matchFromDirection = createdEdge.fromId === newEdge.toId && createdEdge.toId === newEdge.fromId;

          if (matchToDirection || matchFromDirection) {
            return newEdge;
          }
        }

        return null;
      };

      for (var _j3 = 0; _j3 < createEdges.length; _j3++) {
        var createdEdge = createEdges[_j3];
        var _edge = createdEdge.edge;
        var newEdge = getNewEdge(createdEdge);

        if (newEdge === null) {
          // Create a clustered edge for this connection
          newEdge = this._createClusteredEdge(createdEdge.fromId, createdEdge.toId, _edge, clusterEdgeProperties);
          newEdges.push(newEdge);
        } else {
          newEdge.clusteringEdgeReplacingIds.push(_edge.id);
        } // also reference the new edge in the old edge


        this.body.edges[_edge.id].edgeReplacedById = newEdge.id; // hide the replaced edge

        this._backupEdgeOptions(_edge);

        _edge.setOptions({
          physics: false
        });
      }
    }
    /**
     * This function checks the options that can be supplied to the different cluster functions
     * for certain fields and inserts defaults if needed
     *
     * @param {object} options
     * @returns {*}
     * @private
     */

  }, {
    key: "_checkOptions",
    value: function _checkOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.clusterEdgeProperties === undefined) {
        options.clusterEdgeProperties = {};
      }

      if (options.clusterNodeProperties === undefined) {
        options.clusterNodeProperties = {};
      }

      return options;
    }
    /**
     *
     * @param {object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node
     * @param {object}    childEdgesObj         | object with edge objects, id as keys
     * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}
     * @param {boolean}   refreshData | when true, do not wrap up
     * @private
     */

  }, {
    key: "_cluster",
    value: function _cluster(childNodesObj, childEdgesObj, options) {
      var refreshData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      // Remove nodes which are already clustered
      var tmpNodesToRemove = [];

      for (var nodeId in childNodesObj) {
        if (Object.prototype.hasOwnProperty.call(childNodesObj, nodeId)) {
          if (this.clusteredNodes[nodeId] !== undefined) {
            tmpNodesToRemove.push(nodeId);
          }
        }
      }

      for (var n = 0; n < tmpNodesToRemove.length; ++n) {
        delete childNodesObj[tmpNodesToRemove[n]];
      } // kill condition: no nodes don't bother


      if (keys$4(childNodesObj).length == 0) {
        return;
      } // allow clusters of 1 if options allow


      if (keys$4(childNodesObj).length == 1 && options.clusterNodeProperties.allowSingleNodeCluster != true) {
        return;
      }

      var clusterNodeProperties = deepExtend({}, options.clusterNodeProperties); // construct the clusterNodeProperties

      if (options.processProperties !== undefined) {
        // get the childNode options
        var childNodesOptions = [];

        for (var _nodeId in childNodesObj) {
          if (Object.prototype.hasOwnProperty.call(childNodesObj, _nodeId)) {
            var clonedOptions = NetworkUtil.cloneOptions(childNodesObj[_nodeId]);
            childNodesOptions.push(clonedOptions);
          }
        } // get cluster properties based on childNodes


        var childEdgesOptions = [];

        for (var edgeId in childEdgesObj) {
          if (Object.prototype.hasOwnProperty.call(childEdgesObj, edgeId)) {
            // these cluster edges will be removed on creation of the cluster.
            if (edgeId.substr(0, 12) !== "clusterEdge:") {
              var _clonedOptions = NetworkUtil.cloneOptions(childEdgesObj[edgeId], "edge");

              childEdgesOptions.push(_clonedOptions);
            }
          }
        }

        clusterNodeProperties = options.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);

        if (!clusterNodeProperties) {
          throw new Error("The processProperties function does not return properties!");
        }
      } // check if we have an unique id;


      if (clusterNodeProperties.id === undefined) {
        clusterNodeProperties.id = "cluster:" + v4();
      }

      var clusterId = clusterNodeProperties.id;

      if (clusterNodeProperties.label === undefined) {
        clusterNodeProperties.label = "cluster";
      } // give the clusterNode a position if it does not have one.


      var pos = undefined;

      if (clusterNodeProperties.x === undefined) {
        pos = this._getClusterPosition(childNodesObj);
        clusterNodeProperties.x = pos.x;
      }

      if (clusterNodeProperties.y === undefined) {
        if (pos === undefined) {
          pos = this._getClusterPosition(childNodesObj);
        }

        clusterNodeProperties.y = pos.y;
      } // force the ID to remain the same


      clusterNodeProperties.id = clusterId; // create the cluster Node
      // Note that allowSingleNodeCluster, if present, is stored in the options as well

      var clusterNode = this.body.functions.createNode(clusterNodeProperties, Cluster);
      clusterNode.containedNodes = childNodesObj;
      clusterNode.containedEdges = childEdgesObj; // cache a copy from the cluster edge properties if we have to reconnect others later on

      clusterNode.clusterEdgeProperties = options.clusterEdgeProperties; // finally put the cluster node into global

      this.body.nodes[clusterNodeProperties.id] = clusterNode;

      this._clusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options.clusterEdgeProperties); // set ID to undefined so no duplicates arise


      clusterNodeProperties.id = undefined; // wrap up

      if (refreshData === true) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     *
     * @param {Edge} edge
     * @private
     */

  }, {
    key: "_backupEdgeOptions",
    value: function _backupEdgeOptions(edge) {
      if (this.clusteredEdges[edge.id] === undefined) {
        this.clusteredEdges[edge.id] = {
          physics: edge.options.physics
        };
      }
    }
    /**
     *
     * @param {Edge} edge
     * @private
     */

  }, {
    key: "_restoreEdge",
    value: function _restoreEdge(edge) {
      var originalOptions = this.clusteredEdges[edge.id];

      if (originalOptions !== undefined) {
        edge.setOptions({
          physics: originalOptions.physics
        });
        delete this.clusteredEdges[edge.id];
      }
    }
    /**
     * Check if a node is a cluster.
     *
     * @param {Node.id} nodeId
     * @returns {*}
     */

  }, {
    key: "isCluster",
    value: function isCluster(nodeId) {
      if (this.body.nodes[nodeId] !== undefined) {
        return this.body.nodes[nodeId].isCluster === true;
      } else {
        console.error("Node does not exist.");
        return false;
      }
    }
    /**
     * get the position of the cluster node based on what's inside
     *
     * @param {object} childNodesObj    | object with node objects, id as keys
     * @returns {{x: number, y: number}}
     * @private
     */

  }, {
    key: "_getClusterPosition",
    value: function _getClusterPosition(childNodesObj) {
      var childKeys = keys$4(childNodesObj);

      var minX = childNodesObj[childKeys[0]].x;
      var maxX = childNodesObj[childKeys[0]].x;
      var minY = childNodesObj[childKeys[0]].y;
      var maxY = childNodesObj[childKeys[0]].y;
      var node;

      for (var i = 1; i < childKeys.length; i++) {
        node = childNodesObj[childKeys[i]];
        minX = node.x < minX ? node.x : minX;
        maxX = node.x > maxX ? node.x : maxX;
        minY = node.y < minY ? node.y : minY;
        maxY = node.y > maxY ? node.y : maxY;
      }

      return {
        x: 0.5 * (minX + maxX),
        y: 0.5 * (minY + maxY)
      };
    }
    /**
     * Open a cluster by calling this function.
     *
     * @param {vis.Edge.id}  clusterNodeId | the ID of the cluster node
     * @param {object} options
     * @param {boolean} refreshData | wrap up afterwards if not true
     */

  }, {
    key: "openCluster",
    value: function openCluster(clusterNodeId, options) {
      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      // kill conditions
      if (clusterNodeId === undefined) {
        throw new Error("No clusterNodeId supplied to openCluster.");
      }

      var clusterNode = this.body.nodes[clusterNodeId];

      if (clusterNode === undefined) {
        throw new Error("The clusterNodeId supplied to openCluster does not exist.");
      }

      if (clusterNode.isCluster !== true || clusterNode.containedNodes === undefined || clusterNode.containedEdges === undefined) {
        throw new Error("The node:" + clusterNodeId + " is not a valid cluster.");
      } // Check if current cluster is clustered itself


      var stack = this.findNode(clusterNodeId);
      var parentIndex = indexOf(stack).call(stack, clusterNodeId) - 1;

      if (parentIndex >= 0) {
        // Current cluster is clustered; transfer contained nodes and edges to parent
        var parentClusterNodeId = stack[parentIndex];
        var parentClusterNode = this.body.nodes[parentClusterNodeId]; // clustering.clusteredNodes and clustering.clusteredEdges remain unchanged

        parentClusterNode._openChildCluster(clusterNodeId); // All components of child cluster node have been transferred. It can die now.


        delete this.body.nodes[clusterNodeId];

        if (refreshData === true) {
          this.body.emitter.emit("_dataChanged");
        }

        return;
      } // main body


      var containedNodes = clusterNode.containedNodes;
      var containedEdges = clusterNode.containedEdges; // allow the user to position the nodes after release.

      if (options !== undefined && options.releaseFunction !== undefined && typeof options.releaseFunction === "function") {
        var positions = {};
        var clusterPosition = {
          x: clusterNode.x,
          y: clusterNode.y
        };

        for (var nodeId in containedNodes) {
          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {
            var containedNode = this.body.nodes[nodeId];
            positions[nodeId] = {
              x: containedNode.x,
              y: containedNode.y
            };
          }
        }

        var newPositions = options.releaseFunction(clusterPosition, positions);

        for (var _nodeId2 in containedNodes) {
          if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId2)) {
            var _containedNode = this.body.nodes[_nodeId2];

            if (newPositions[_nodeId2] !== undefined) {
              _containedNode.x = newPositions[_nodeId2].x === undefined ? clusterNode.x : newPositions[_nodeId2].x;
              _containedNode.y = newPositions[_nodeId2].y === undefined ? clusterNode.y : newPositions[_nodeId2].y;
            }
          }
        }
      } else {
        // copy the position from the cluster
        forEach$1(containedNodes, function (containedNode) {
          // inherit position
          if (containedNode.options.fixed.x === false) {
            containedNode.x = clusterNode.x;
          }

          if (containedNode.options.fixed.y === false) {
            containedNode.y = clusterNode.y;
          }
        });
      } // release nodes


      for (var _nodeId3 in containedNodes) {
        if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId3)) {
          var _containedNode2 = this.body.nodes[_nodeId3]; // inherit speed

          _containedNode2.vx = clusterNode.vx;
          _containedNode2.vy = clusterNode.vy;

          _containedNode2.setOptions({
            physics: true
          });

          delete this.clusteredNodes[_nodeId3];
        }
      } // copy the clusterNode edges because we cannot iterate over an object that we add or remove from.


      var edgesToBeDeleted = [];

      for (var i = 0; i < clusterNode.edges.length; i++) {
        edgesToBeDeleted.push(clusterNode.edges[i]);
      } // actually handling the deleting.


      for (var _i3 = 0; _i3 < edgesToBeDeleted.length; _i3++) {
        var edge = edgesToBeDeleted[_i3];

        var otherNodeId = this._getConnectedId(edge, clusterNodeId);

        var otherNode = this.clusteredNodes[otherNodeId];

        for (var j = 0; j < edge.clusteringEdgeReplacingIds.length; j++) {
          var transferId = edge.clusteringEdgeReplacingIds[j];
          var transferEdge = this.body.edges[transferId];
          if (transferEdge === undefined) continue; // if the other node is in another cluster, we transfer ownership of this edge to the other cluster

          if (otherNode !== undefined) {
            // transfer ownership:
            var otherCluster = this.body.nodes[otherNode.clusterId];
            otherCluster.containedEdges[transferEdge.id] = transferEdge; // delete local reference

            delete containedEdges[transferEdge.id]; // get to and from

            var fromId = transferEdge.fromId;
            var toId = transferEdge.toId;

            if (transferEdge.toId == otherNodeId) {
              toId = otherNode.clusterId;
            } else {
              fromId = otherNode.clusterId;
            } // create new cluster edge from the otherCluster


            this._createClusteredEdge(fromId, toId, transferEdge, otherCluster.clusterEdgeProperties, {
              hidden: false,
              physics: true
            });
          } else {
            this._restoreEdge(transferEdge);
          }
        }

        edge.remove();
      } // handle the releasing of the edges


      for (var edgeId in containedEdges) {
        if (Object.prototype.hasOwnProperty.call(containedEdges, edgeId)) {
          this._restoreEdge(containedEdges[edgeId]);
        }
      } // remove clusterNode


      delete this.body.nodes[clusterNodeId];

      if (refreshData === true) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     *
     * @param {Cluster.id} clusterId
     * @returns {Array.<Node.id>}
     */

  }, {
    key: "getNodesInCluster",
    value: function getNodesInCluster(clusterId) {
      var nodesArray = [];

      if (this.isCluster(clusterId) === true) {
        var containedNodes = this.body.nodes[clusterId].containedNodes;

        for (var nodeId in containedNodes) {
          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {
            nodesArray.push(this.body.nodes[nodeId].id);
          }
        }
      }

      return nodesArray;
    }
    /**
     * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node
     *
     * If a node can't be found in the chain, return an empty array.
     *
     * @param {string|number} nodeId
     * @returns {Array}
     */

  }, {
    key: "findNode",
    value: function findNode(nodeId) {
      var stack = [];
      var max = 100;
      var counter = 0;
      var node;

      while (this.clusteredNodes[nodeId] !== undefined && counter < max) {
        node = this.body.nodes[nodeId];
        if (node === undefined) return [];
        stack.push(node.id);
        nodeId = this.clusteredNodes[nodeId].clusterId;
        counter++;
      }

      node = this.body.nodes[nodeId];
      if (node === undefined) return [];
      stack.push(node.id);

      reverse(stack).call(stack);

      return stack;
    }
    /**
     * Using a clustered nodeId, update with the new options
     *
     * @param {Node.id} clusteredNodeId
     * @param {object} newOptions
     */

  }, {
    key: "updateClusteredNode",
    value: function updateClusteredNode(clusteredNodeId, newOptions) {
      if (clusteredNodeId === undefined) {
        throw new Error("No clusteredNodeId supplied to updateClusteredNode.");
      }

      if (newOptions === undefined) {
        throw new Error("No newOptions supplied to updateClusteredNode.");
      }

      if (this.body.nodes[clusteredNodeId] === undefined) {
        throw new Error("The clusteredNodeId supplied to updateClusteredNode does not exist.");
      }

      this.body.nodes[clusteredNodeId].setOptions(newOptions);
      this.body.emitter.emit("_dataChanged");
    }
    /**
     * Using a base edgeId, update all related clustered edges with the new options
     *
     * @param {vis.Edge.id} startEdgeId
     * @param {object} newOptions
     */

  }, {
    key: "updateEdge",
    value: function updateEdge(startEdgeId, newOptions) {
      if (startEdgeId === undefined) {
        throw new Error("No startEdgeId supplied to updateEdge.");
      }

      if (newOptions === undefined) {
        throw new Error("No newOptions supplied to updateEdge.");
      }

      if (this.body.edges[startEdgeId] === undefined) {
        throw new Error("The startEdgeId supplied to updateEdge does not exist.");
      }

      var allEdgeIds = this.getClusteredEdges(startEdgeId);

      for (var i = 0; i < allEdgeIds.length; i++) {
        var edge = this.body.edges[allEdgeIds[i]];
        edge.setOptions(newOptions);
      }

      this.body.emitter.emit("_dataChanged");
    }
    /**
     * Get a stack of clusterEdgeId's (+base edgeid) that a base edge is the same as. cluster edge C -> cluster edge B -> cluster edge A -> base edge(edgeId)
     *
     * @param {vis.Edge.id} edgeId
     * @returns {Array.<vis.Edge.id>}
     */

  }, {
    key: "getClusteredEdges",
    value: function getClusteredEdges(edgeId) {
      var stack = [];
      var max = 100;
      var counter = 0;

      while (edgeId !== undefined && this.body.edges[edgeId] !== undefined && counter < max) {
        stack.push(this.body.edges[edgeId].id);
        edgeId = this.body.edges[edgeId].edgeReplacedById;
        counter++;
      }

      reverse(stack).call(stack);

      return stack;
    }
    /**
     * Get the base edge id of clusterEdgeId. cluster edge (clusteredEdgeId) -> cluster edge B -> cluster edge C -> base edge
     *
     * @param {vis.Edge.id} clusteredEdgeId
     * @returns {vis.Edge.id} baseEdgeId
     *
     * TODO: deprecate in 5.0.0. Method getBaseEdges() is the correct one to use.
     */

  }, {
    key: "getBaseEdge",
    value: function getBaseEdge(clusteredEdgeId) {
      // Just kludge this by returning the first base edge id found
      return this.getBaseEdges(clusteredEdgeId)[0];
    }
    /**
     * Get all regular edges for this clustered edge id.
     *
     * @param {vis.Edge.id} clusteredEdgeId
     * @returns {Array.<vis.Edge.id>} all baseEdgeId's under this clustered edge
     */

  }, {
    key: "getBaseEdges",
    value: function getBaseEdges(clusteredEdgeId) {
      var IdsToHandle = [clusteredEdgeId];
      var doneIds = [];
      var foundIds = [];
      var max = 100;
      var counter = 0;

      while (IdsToHandle.length > 0 && counter < max) {
        var nextId = IdsToHandle.pop();
        if (nextId === undefined) continue; // Paranoia here and onwards

        var nextEdge = this.body.edges[nextId];
        if (nextEdge === undefined) continue;
        counter++;
        var replacingIds = nextEdge.clusteringEdgeReplacingIds;

        if (replacingIds === undefined) {
          // nextId is a base id
          foundIds.push(nextId);
        } else {
          // Another cluster edge, unravel this one as well
          for (var i = 0; i < replacingIds.length; ++i) {
            var replacingId = replacingIds[i]; // Don't add if already handled
            // TODO: never triggers; find a test-case which does

            if (indexOf(IdsToHandle).call(IdsToHandle, replacingIds) !== -1 || indexOf(doneIds).call(doneIds, replacingIds) !== -1) {
              continue;
            }

            IdsToHandle.push(replacingId);
          }
        }

        doneIds.push(nextId);
      }

      return foundIds;
    }
    /**
     * Get the Id the node is connected to
     *
     * @param {vis.Edge} edge
     * @param {Node.id} nodeId
     * @returns {*}
     * @private
     */

  }, {
    key: "_getConnectedId",
    value: function _getConnectedId(edge, nodeId) {
      if (edge.toId != nodeId) {
        return edge.toId;
      } else if (edge.fromId != nodeId) {
        return edge.fromId;
      } else {
        return edge.fromId;
      }
    }
    /**
     * We determine how many connections denote an important hub.
     * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)
     *
     * @returns {number}
     * @private
     */

  }, {
    key: "_getHubSize",
    value: function _getHubSize() {
      var average = 0;
      var averageSquared = 0;
      var hubCounter = 0;
      var largestHub = 0;

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var node = this.body.nodes[this.body.nodeIndices[i]];

        if (node.edges.length > largestHub) {
          largestHub = node.edges.length;
        }

        average += node.edges.length;
        averageSquared += Math.pow(node.edges.length, 2);
        hubCounter += 1;
      }

      average = average / hubCounter;
      averageSquared = averageSquared / hubCounter;
      var variance = averageSquared - Math.pow(average, 2);
      var standardDeviation = Math.sqrt(variance);
      var hubThreshold = Math.floor(average + 2 * standardDeviation); // always have at least one to cluster

      if (hubThreshold > largestHub) {
        hubThreshold = largestHub;
      }

      return hubThreshold;
    }
    /**
     * Create an edge for the cluster representation.
     *
     * @param {Node.id} fromId
     * @param {Node.id} toId
     * @param {vis.Edge} baseEdge
     * @param {object} clusterEdgeProperties
     * @param {object} extraOptions
     * @returns {Edge} newly created clustered edge
     * @private
     */

  }, {
    key: "_createClusteredEdge",
    value: function _createClusteredEdge(fromId, toId, baseEdge, clusterEdgeProperties, extraOptions) {
      // copy the options of the edge we will replace
      var clonedOptions = NetworkUtil.cloneOptions(baseEdge, "edge"); // make sure the properties of clusterEdges are superimposed on it

      deepExtend(clonedOptions, clusterEdgeProperties); // set up the edge

      clonedOptions.from = fromId;
      clonedOptions.to = toId;
      clonedOptions.id = "clusterEdge:" + v4(); // apply the edge specific options to it if specified

      if (extraOptions !== undefined) {
        deepExtend(clonedOptions, extraOptions);
      }

      var newEdge = this.body.functions.createEdge(clonedOptions);
      newEdge.clusteringEdgeReplacingIds = [baseEdge.id];
      newEdge.connect(); // Register the new edge

      this.body.edges[newEdge.id] = newEdge;
      return newEdge;
    }
    /**
     * Add the passed child nodes and edges to the given cluster node.
     *
     * @param {object | Node} childNodes  hash of nodes or single node to add in cluster
     * @param {object | Edge} childEdges  hash of edges or single edge to take into account when clustering
     * @param {Node} clusterNode  cluster node to add nodes and edges to
     * @param {object} [clusterEdgeProperties]
     * @private
     */

  }, {
    key: "_clusterEdges",
    value: function _clusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties) {
      if (childEdges instanceof Edge) {
        var edge = childEdges;
        var obj = {};
        obj[edge.id] = edge;
        childEdges = obj;
      }

      if (childNodes instanceof Node) {
        var node = childNodes;
        var _obj = {};
        _obj[node.id] = node;
        childNodes = _obj;
      }

      if (clusterNode === undefined || clusterNode === null) {
        throw new Error("_clusterEdges: parameter clusterNode required");
      }

      if (clusterEdgeProperties === undefined) {
        // Take the required properties from the cluster node
        clusterEdgeProperties = clusterNode.clusterEdgeProperties;
      } // create the new edges that will connect to the cluster.
      // All self-referencing edges will be added to childEdges here.


      this._createClusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties); // disable the childEdges


      for (var edgeId in childEdges) {
        if (Object.prototype.hasOwnProperty.call(childEdges, edgeId)) {
          if (this.body.edges[edgeId] !== undefined) {
            var _edge2 = this.body.edges[edgeId]; // cache the options before changing

            this._backupEdgeOptions(_edge2); // disable physics and hide the edge


            _edge2.setOptions({
              physics: false
            });
          }
        }
      } // disable the childNodes


      for (var nodeId in childNodes) {
        if (Object.prototype.hasOwnProperty.call(childNodes, nodeId)) {
          this.clusteredNodes[nodeId] = {
            clusterId: clusterNode.id,
            node: this.body.nodes[nodeId]
          };
          this.body.nodes[nodeId].setOptions({
            physics: false
          });
        }
      }
    }
    /**
     * Determine in which cluster given nodeId resides.
     *
     * If not in cluster, return undefined.
     *
     * NOTE: If you know a cleaner way to do this, please enlighten me (wimrijnders).
     *
     * @param {Node.id} nodeId
     * @returns {Node|undefined} Node instance for cluster, if present
     * @private
     */

  }, {
    key: "_getClusterNodeForNode",
    value: function _getClusterNodeForNode(nodeId) {
      if (nodeId === undefined) return undefined;
      var clusteredNode = this.clusteredNodes[nodeId]; // NOTE: If no cluster info found, it should actually be an error

      if (clusteredNode === undefined) return undefined;
      var clusterId = clusteredNode.clusterId;
      if (clusterId === undefined) return undefined;
      return this.body.nodes[clusterId];
    }
    /**
     * Internal helper function for conditionally removing items in array
     *
     * Done like this because Array.filter() is not fully supported by all IE's.
     *
     * @param {Array} arr
     * @param {Function} callback
     * @returns {Array}
     * @private
     */

  }, {
    key: "_filter",
    value: function _filter(arr, callback) {
      var ret = [];
      forEach$1(arr, function (item) {
        if (callback(item)) {
          ret.push(item);
        }
      });
      return ret;
    }
    /**
     * Scan all edges for changes in clustering and adjust this if necessary.
     *
     * Call this (internally) after there has been a change in node or edge data.
     *
     * Pre: States of this.body.nodes and this.body.edges consistent
     * Pre: this.clusteredNodes and this.clusteredEdge consistent with containedNodes and containedEdges
     *      of cluster nodes.
     */

  }, {
    key: "_updateState",
    value: function _updateState() {
      var _this4 = this;

      var nodeId;
      var deletedNodeIds = [];
      var deletedEdgeIds = {};
      /**
       * Utility function to iterate over clustering nodes only
       *
       * @param {Function} callback  function to call for each cluster node
       */

      var eachClusterNode = function eachClusterNode(callback) {
        forEach$1(_this4.body.nodes, function (node) {
          if (node.isCluster === true) {
            callback(node);
          }
        });
      }; //
      // Remove deleted regular nodes from clustering
      //
      // Determine the deleted nodes


      for (nodeId in this.clusteredNodes) {
        if (!Object.prototype.hasOwnProperty.call(this.clusteredNodes, nodeId)) continue;
        var node = this.body.nodes[nodeId];

        if (node === undefined) {
          deletedNodeIds.push(nodeId);
        }
      } // Remove nodes from cluster nodes


      eachClusterNode(function (clusterNode) {
        for (var n = 0; n < deletedNodeIds.length; n++) {
          delete clusterNode.containedNodes[deletedNodeIds[n]];
        }
      }); // Remove nodes from cluster list

      for (var n = 0; n < deletedNodeIds.length; n++) {
        delete this.clusteredNodes[deletedNodeIds[n]];
      } //
      // Remove deleted edges from clustering
      //
      // Add the deleted clustered edges to the list


      forEach$1(this.clusteredEdges, function (edgeId) {
        var edge = _this4.body.edges[edgeId];

        if (edge === undefined || !edge.endPointsValid()) {
          deletedEdgeIds[edgeId] = edgeId;
        }
      }); // Cluster nodes can also contain edges which are not clustered,
      // i.e. nodes 1-2 within cluster with an edge in between.
      // So the cluster nodes also need to be scanned for invalid edges

      eachClusterNode(function (clusterNode) {
        forEach$1(clusterNode.containedEdges, function (edge, edgeId) {
          if (!edge.endPointsValid() && !deletedEdgeIds[edgeId]) {
            deletedEdgeIds[edgeId] = edgeId;
          }
        });
      }); // Also scan for cluster edges which need to be removed in the active list.
      // Regular edges have been removed beforehand, so this only picks up the cluster edges.

      forEach$1(this.body.edges, function (edge, edgeId) {
        // Explicitly scan the contained edges for validity
        var isValid = true;
        var replacedIds = edge.clusteringEdgeReplacingIds;

        if (replacedIds !== undefined) {
          var numValid = 0;
          forEach$1(replacedIds, function (containedEdgeId) {
            var containedEdge = _this4.body.edges[containedEdgeId];

            if (containedEdge !== undefined && containedEdge.endPointsValid()) {
              numValid += 1;
            }
          });
          isValid = numValid > 0;
        }

        if (!edge.endPointsValid() || !isValid) {
          deletedEdgeIds[edgeId] = edgeId;
        }
      }); // Remove edges from cluster nodes

      eachClusterNode(function (clusterNode) {
        forEach$1(deletedEdgeIds, function (deletedEdgeId) {
          delete clusterNode.containedEdges[deletedEdgeId];
          forEach$1(clusterNode.edges, function (edge, m) {
            if (edge.id === deletedEdgeId) {
              clusterNode.edges[m] = null; // Don't want to directly delete here, because in the loop

              return;
            }

            edge.clusteringEdgeReplacingIds = _this4._filter(edge.clusteringEdgeReplacingIds, function (id) {
              return !deletedEdgeIds[id];
            });
          }); // Clean up the nulls

          clusterNode.edges = _this4._filter(clusterNode.edges, function (item) {
            return item !== null;
          });
        });
      }); // Remove from cluster list

      forEach$1(deletedEdgeIds, function (edgeId) {
        delete _this4.clusteredEdges[edgeId];
      }); // Remove cluster edges from active list (this.body.edges).
      // deletedEdgeIds still contains id of regular edges, but these should all
      // be gone when you reach here.

      forEach$1(deletedEdgeIds, function (edgeId) {
        delete _this4.body.edges[edgeId];
      }); //
      // Check changed cluster state of edges
      //
      // Iterating over keys here, because edges may be removed in the loop

      var ids = keys$4(this.body.edges);

      forEach$1(ids, function (edgeId) {
        var edge = _this4.body.edges[edgeId];

        var shouldBeClustered = _this4._isClusteredNode(edge.fromId) || _this4._isClusteredNode(edge.toId);

        if (shouldBeClustered === _this4._isClusteredEdge(edge.id)) {
          return; // all is well
        }

        if (shouldBeClustered) {
          // add edge to clustering
          var clusterFrom = _this4._getClusterNodeForNode(edge.fromId);

          if (clusterFrom !== undefined) {
            _this4._clusterEdges(_this4.body.nodes[edge.fromId], edge, clusterFrom);
          }

          var clusterTo = _this4._getClusterNodeForNode(edge.toId);

          if (clusterTo !== undefined) {
            _this4._clusterEdges(_this4.body.nodes[edge.toId], edge, clusterTo);
          } // TODO: check that it works for both edges clustered
          //       (This might be paranoia)

        } else {
          delete _this4._clusterEdges[edgeId];

          _this4._restoreEdge(edge); // This should not be happening, the state should
          // be properly updated at this point.
          //
          // If it *is* reached during normal operation, then we have to implement
          // undo clustering for this edge here.
          // throw new Error('remove edge from clustering not implemented!')

        }
      }); // Clusters may be nested to any level. Keep on opening until nothing to open

      var changed = false;
      var continueLoop = true;

      var _loop2 = function _loop2() {
        var clustersToOpen = []; // Determine the id's of clusters that need opening

        eachClusterNode(function (clusterNode) {
          var numNodes = keys$4(clusterNode.containedNodes).length;

          var allowSingle = clusterNode.options.allowSingleNodeCluster === true;

          if (allowSingle && numNodes < 1 || !allowSingle && numNodes < 2) {
            clustersToOpen.push(clusterNode.id);
          }
        }); // Open them

        for (var _n = 0; _n < clustersToOpen.length; ++_n) {
          _this4.openCluster(clustersToOpen[_n], {}, false
          /* Don't refresh, we're in an refresh/update already */
          );
        }

        continueLoop = clustersToOpen.length > 0;
        changed = changed || continueLoop;
      };

      while (continueLoop) {
        _loop2();
      }

      if (changed) {
        this._updateState(); // Redo this method (recursion possible! should be safe)

      }
    }
    /**
     * Determine if node with given id is part of a cluster.
     *
     * @param {Node.id} nodeId
     * @returns {boolean} true if part of a cluster.
     */

  }, {
    key: "_isClusteredNode",
    value: function _isClusteredNode(nodeId) {
      return this.clusteredNodes[nodeId] !== undefined;
    }
    /**
     * Determine if edge with given id is not visible due to clustering.
     *
     * An edge is considered clustered if:
     * - it is directly replaced by a clustering edge
     * - any of its connecting nodes is in a cluster
     *
     * @param {vis.Edge.id} edgeId
     * @returns {boolean} true if part of a cluster.
     */

  }, {
    key: "_isClusteredEdge",
    value: function _isClusteredEdge(edgeId) {
      return this.clusteredEdges[edgeId] !== undefined;
    }
  }]);

  return ClusterEngine;
}();

function _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$5(o, minLen) { var _context4; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = slice(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }

function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Initializes window.requestAnimationFrame() to a usable form.
 *
 * Specifically, set up this method for the case of running on node.js with jsdom enabled.
 *
 * NOTES:
 *
 * On node.js, when calling this directly outside of this class, `window` is not defined.
 *   This happens even if jsdom is used.
 * For node.js + jsdom, `window` is available at the moment the constructor is called.
 *   For this reason, the called is placed within the constructor.
 * Even then, `window.requestAnimationFrame()` is not defined, so it still needs to be added.
 * During unit testing, it happens that the window object is reset during execution, causing
 *   a runtime error due to missing `requestAnimationFrame()`. This needs to be compensated for,
 *   see `_requestNextFrame()`.
 * Since this is a global object, it may affect other modules besides `Network`. With normal
 *   usage, this does not cause any problems. During unit testing, errors may occur. These have
 *   been compensated for, see comment block in _requestNextFrame().
 *
 * @private
 */

function _initRequestAnimationFrame() {
  var func;

  if (window !== undefined) {
    func = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  }

  if (func === undefined) {
    // window or method not present, setting mock requestAnimationFrame
    window.requestAnimationFrame = function (callback) {
      //console.log("Called mock requestAnimationFrame");
      callback();
    };
  } else {
    window.requestAnimationFrame = func;
  }
}
/**
 * The canvas renderer
 */


var CanvasRenderer = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   */
  function CanvasRenderer(body, canvas) {
    _classCallCheck(this, CanvasRenderer);

    _initRequestAnimationFrame();

    this.body = body;
    this.canvas = canvas;
    this.redrawRequested = false;
    this.renderTimer = undefined;
    this.requiresTimeout = true;
    this.renderingActive = false;
    this.renderRequests = 0;
    this.allowRedraw = true;
    this.dragging = false;
    this.zooming = false;
    this.options = {};
    this.defaultOptions = {
      hideEdgesOnDrag: false,
      hideEdgesOnZoom: false,
      hideNodesOnDrag: false
    };

    assign$2(this.options, this.defaultOptions);

    this._determineBrowserMethod();

    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(CanvasRenderer, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this,
          _context2;

      this.body.emitter.on("dragStart", function () {
        _this.dragging = true;
      });
      this.body.emitter.on("dragEnd", function () {
        _this.dragging = false;
      });
      this.body.emitter.on("zoom", function () {
        _this.zooming = true;
        window.clearTimeout(_this.zoomTimeoutId);
        _this.zoomTimeoutId = setTimeout$1(function () {
          var _context;

          _this.zooming = false;

          bind$6(_context = _this._requestRedraw).call(_context, _this)();
        }, 250);
      });
      this.body.emitter.on("_resizeNodes", function () {
        _this._resizeNodes();
      });
      this.body.emitter.on("_redraw", function () {
        if (_this.renderingActive === false) {
          _this._redraw();
        }
      });
      this.body.emitter.on("_blockRedraw", function () {
        _this.allowRedraw = false;
      });
      this.body.emitter.on("_allowRedraw", function () {
        _this.allowRedraw = true;
        _this.redrawRequested = false;
      });
      this.body.emitter.on("_requestRedraw", bind$6(_context2 = this._requestRedraw).call(_context2, this));
      this.body.emitter.on("_startRendering", function () {
        _this.renderRequests += 1;
        _this.renderingActive = true;

        _this._startRendering();
      });
      this.body.emitter.on("_stopRendering", function () {
        _this.renderRequests -= 1;
        _this.renderingActive = _this.renderRequests > 0;
        _this.renderTimer = undefined;
      });
      this.body.emitter.on("destroy", function () {
        _this.renderRequests = 0;
        _this.allowRedraw = false;
        _this.renderingActive = false;

        if (_this.requiresTimeout === true) {
          clearTimeout(_this.renderTimer);
        } else {
          window.cancelAnimationFrame(_this.renderTimer);
        }

        _this.body.emitter.off();
      });
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        var fields = ["hideEdgesOnDrag", "hideEdgesOnZoom", "hideNodesOnDrag"];
        selectiveDeepExtend(fields, this.options, options);
      }
    }
    /**
     * Prepare the drawing of the next frame.
     *
     * Calls the callback when the next frame can or will be drawn.
     *
     * @param {Function} callback
     * @param {number} delay - timeout case only, wait this number of milliseconds
     * @returns {Function | undefined}
     * @private
     */

  }, {
    key: "_requestNextFrame",
    value: function _requestNextFrame(callback, delay) {
      // During unit testing, it happens that the mock window object is reset while
      // the next frame is still pending. Then, either 'window' is not present, or
      // 'requestAnimationFrame()' is not present because it is not defined on the
      // mock window object.
      //
      // As a consequence, unrelated unit tests may appear to fail, even if the problem
      // described happens in the current unit test.
      //
      // This is not something that will happen in normal operation, but we still need
      // to take it into account.
      //
      if (typeof window === "undefined") return; // Doing `if (window === undefined)` does not work here!

      var timer;
      var myWindow = window; // Grab a reference to reduce the possibility that 'window' is reset
      // while running this method.

      if (this.requiresTimeout === true) {
        // wait given number of milliseconds and perform the animation step function
        timer = setTimeout$1(callback, delay);
      } else {
        if (myWindow.requestAnimationFrame) {
          timer = myWindow.requestAnimationFrame(callback);
        }
      }

      return timer;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_startRendering",
    value: function _startRendering() {
      if (this.renderingActive === true) {
        if (this.renderTimer === undefined) {
          var _context3;

          this.renderTimer = this._requestNextFrame(bind$6(_context3 = this._renderStep).call(_context3, this), this.simulationInterval);
        }
      }
    }
    /**
     *
     * @private
     */

  }, {
    key: "_renderStep",
    value: function _renderStep() {
      if (this.renderingActive === true) {
        // reset the renderTimer so a new scheduled animation step can be set
        this.renderTimer = undefined;

        if (this.requiresTimeout === true) {
          // this schedules a new simulation step
          this._startRendering();
        }

        this._redraw();

        if (this.requiresTimeout === false) {
          // this schedules a new simulation step
          this._startRendering();
        }
      }
    }
    /**
     * Redraw the network with the current data
     * chart will be resized too.
     */

  }, {
    key: "redraw",
    value: function redraw() {
      this.body.emitter.emit("setSize");

      this._redraw();
    }
    /**
     * Redraw the network with the current data
     *
     * @private
     */

  }, {
    key: "_requestRedraw",
    value: function _requestRedraw() {
      var _this2 = this;

      if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {
        this.redrawRequested = true;

        this._requestNextFrame(function () {
          _this2._redraw(false);
        }, 0);
      }
    }
    /**
     * Redraw the network with the current data
     *
     * @param {boolean} [hidden=false] | Used to get the first estimate of the node sizes.
     *                                   Only the nodes are drawn after which they are quickly drawn over.
     * @private
     */

  }, {
    key: "_redraw",
    value: function _redraw() {
      var hidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.allowRedraw === true) {
        this.body.emitter.emit("initRedraw");
        this.redrawRequested = false;
        var drawLater = {
          drawExternalLabels: null
        }; // when the container div was hidden, this fixes it back up!

        if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {
          this.canvas.setSize();
        }

        this.canvas.setTransform();
        var ctx = this.canvas.getContext(); // clear the canvas

        var w = this.canvas.frame.canvas.clientWidth;
        var h = this.canvas.frame.canvas.clientHeight;
        ctx.clearRect(0, 0, w, h); // if the div is hidden, we stop the redraw here for performance.

        if (this.canvas.frame.clientWidth === 0) {
          return;
        } // set scaling and translation


        ctx.save();
        ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
        ctx.scale(this.body.view.scale, this.body.view.scale);
        ctx.beginPath();
        this.body.emitter.emit("beforeDrawing", ctx);
        ctx.closePath();

        if (hidden === false) {
          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {
            this._drawEdges(ctx);
          }
        }

        if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {
          var _this$_drawNodes = this._drawNodes(ctx, hidden),
              drawExternalLabels = _this$_drawNodes.drawExternalLabels;

          drawLater.drawExternalLabels = drawExternalLabels;
        } // draw the arrows last so they will be at the top


        if (hidden === false) {
          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {
            this._drawArrows(ctx);
          }
        }

        if (drawLater.drawExternalLabels != null) {
          drawLater.drawExternalLabels();
        }

        if (hidden === false) {
          this._drawSelectionBox(ctx);
        }

        ctx.beginPath();
        this.body.emitter.emit("afterDrawing", ctx);
        ctx.closePath(); // restore original scaling and translation

        ctx.restore();

        if (hidden === true) {
          ctx.clearRect(0, 0, w, h);
        }
      }
    }
    /**
     * Redraw all nodes
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @param {boolean} [alwaysShow]
     * @private
     */

  }, {
    key: "_resizeNodes",
    value: function _resizeNodes() {
      this.canvas.setTransform();
      var ctx = this.canvas.getContext();
      ctx.save();
      ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
      ctx.scale(this.body.view.scale, this.body.view.scale);
      var nodes = this.body.nodes;
      var node; // resize all nodes

      for (var nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
          node = nodes[nodeId];
          node.resize(ctx);
          node.updateBoundingBox(ctx, node.selected);
        }
      } // restore original scaling and translation


      ctx.restore();
    }
    /**
     * Redraw all nodes
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @param {boolean} [alwaysShow]
     * @private
     * @returns {object} Callbacks to draw later on higher layers.
     */

  }, {
    key: "_drawNodes",
    value: function _drawNodes(ctx) {
      var alwaysShow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var nodes = this.body.nodes;
      var nodeIndices = this.body.nodeIndices;
      var node;
      var selected = [];
      var hovered = [];
      var margin = 20;
      var topLeft = this.canvas.DOMtoCanvas({
        x: -margin,
        y: -margin
      });
      var bottomRight = this.canvas.DOMtoCanvas({
        x: this.canvas.frame.canvas.clientWidth + margin,
        y: this.canvas.frame.canvas.clientHeight + margin
      });
      var viewableArea = {
        top: topLeft.y,
        left: topLeft.x,
        bottom: bottomRight.y,
        right: bottomRight.x
      };
      var _drawExternalLabels = []; // draw unselected nodes;

      for (var _i = 0; _i < nodeIndices.length; _i++) {
        node = nodes[nodeIndices[_i]]; // set selected and hovered nodes aside

        if (node.hover) {
          hovered.push(nodeIndices[_i]);
        } else if (node.isSelected()) {
          selected.push(nodeIndices[_i]);
        } else {
          if (alwaysShow === true) {
            var drawLater = node.draw(ctx);

            if (drawLater.drawExternalLabel != null) {
              _drawExternalLabels.push(drawLater.drawExternalLabel);
            }
          } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {
            var _drawLater = node.draw(ctx);

            if (_drawLater.drawExternalLabel != null) {
              _drawExternalLabels.push(_drawLater.drawExternalLabel);
            }
          } else {
            node.updateBoundingBox(ctx, node.selected);
          }
        }
      }

      var i;
      var selectedLength = selected.length;
      var hoveredLength = hovered.length; // draw the selected nodes on top

      for (i = 0; i < selectedLength; i++) {
        node = nodes[selected[i]];

        var _drawLater2 = node.draw(ctx);

        if (_drawLater2.drawExternalLabel != null) {
          _drawExternalLabels.push(_drawLater2.drawExternalLabel);
        }
      } // draw hovered nodes above everything else: fixes https://github.com/visjs/vis-network/issues/226


      for (i = 0; i < hoveredLength; i++) {
        node = nodes[hovered[i]];

        var _drawLater3 = node.draw(ctx);

        if (_drawLater3.drawExternalLabel != null) {
          _drawExternalLabels.push(_drawLater3.drawExternalLabel);
        }
      }

      return {
        drawExternalLabels: function drawExternalLabels() {
          var _iterator = _createForOfIteratorHelper$5(_drawExternalLabels),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var draw = _step.value;
              draw();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      };
    }
    /**
     * Redraw all edges
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */

  }, {
    key: "_drawEdges",
    value: function _drawEdges(ctx) {
      var edges = this.body.edges;
      var edgeIndices = this.body.edgeIndices;

      for (var i = 0; i < edgeIndices.length; i++) {
        var edge = edges[edgeIndices[i]];

        if (edge.connected === true) {
          edge.draw(ctx);
        }
      }
    }
    /**
     * Redraw all arrows
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */

  }, {
    key: "_drawArrows",
    value: function _drawArrows(ctx) {
      var edges = this.body.edges;
      var edgeIndices = this.body.edgeIndices;

      for (var i = 0; i < edgeIndices.length; i++) {
        var edge = edges[edgeIndices[i]];

        if (edge.connected === true) {
          edge.drawArrows(ctx);
        }
      }
    }
    /**
     * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because
     * some implementations (safari and IE9) did not support requestAnimationFrame
     *
     * @private
     */

  }, {
    key: "_determineBrowserMethod",
    value: function _determineBrowserMethod() {
      if (typeof window !== "undefined") {
        var browserType = navigator.userAgent.toLowerCase();
        this.requiresTimeout = false;

        if (indexOf(browserType).call(browserType, "msie 9.0") != -1) {
          // IE 9
          this.requiresTimeout = true;
        } else if (indexOf(browserType).call(browserType, "safari") != -1) {
          // safari
          if (indexOf(browserType).call(browserType, "chrome") <= -1) {
            this.requiresTimeout = true;
          }
        }
      } else {
        this.requiresTimeout = true;
      }
    }
    /**
     * Redraw selection box
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */

  }, {
    key: "_drawSelectionBox",
    value: function _drawSelectionBox(ctx) {
      if (this.body.selectionBox.show) {
        ctx.beginPath();
        var width = this.body.selectionBox.position.end.x - this.body.selectionBox.position.start.x;
        var height = this.body.selectionBox.position.end.y - this.body.selectionBox.position.start.y;
        ctx.rect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);
        ctx.fillStyle = "rgba(151, 194, 252, 0.2)";
        ctx.fillRect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);
        ctx.strokeStyle = "rgba(151, 194, 252, 1)";
        ctx.stroke();
      } else {
        ctx.closePath();
      }
    }
  }]);

  return CanvasRenderer;
}();

var path$1 = path$y;
var setInterval$1 = path$1.setInterval;

var setInterval = setInterval$1;

/**
 * Register a touch event, taking place before a gesture
 *
 * @param {Hammer} hammer       A hammer instance
 * @param {Function} callback   Callback, called as callback(event)
 */
function onTouch(hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFirst) {
      callback(event);
    }
  };

  hammer.on("hammer.input", callback.inputHandler);
}
/**
 * Register a release event, taking place after a gesture
 *
 * @param {Hammer} hammer       A hammer instance
 * @param {Function} callback   Callback, called as callback(event)
 * @returns {*}
 */

function onRelease(hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFinal) {
      callback(event);
    }
  };

  return hammer.on("hammer.input", callback.inputHandler);
}

/**
 * Create the main frame for the Network.
 * This function is executed once when a Network object is created. The frame
 * contains a canvas, and this canvas contains all objects like the axis and
 * nodes.
 */

var Canvas = /*#__PURE__*/function () {
  /**
   * @param {object} body
   */
  function Canvas(body) {
    _classCallCheck(this, Canvas);

    this.body = body;
    this.pixelRatio = 1;
    this.cameraState = {};
    this.initialized = false;
    this.canvasViewCenter = {};
    this._cleanupCallbacks = [];
    this.options = {};
    this.defaultOptions = {
      autoResize: true,
      height: "100%",
      width: "100%"
    };

    assign$2(this.options, this.defaultOptions);

    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(Canvas, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this,
          _context;

      // bind the events
      this.body.emitter.once("resize", function (obj) {
        if (obj.width !== 0) {
          _this.body.view.translation.x = obj.width * 0.5;
        }

        if (obj.height !== 0) {
          _this.body.view.translation.y = obj.height * 0.5;
        }
      });
      this.body.emitter.on("setSize", bind$6(_context = this.setSize).call(_context, this));
      this.body.emitter.on("destroy", function () {
        _this.hammerFrame.destroy();

        _this.hammer.destroy();

        _this._cleanUp();
      });
    }
    /**
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var _this2 = this;

      if (options !== undefined) {
        var fields = ["width", "height", "autoResize"];
        selectiveDeepExtend(fields, this.options, options);
      } // Automatically adapt to changing size of the container element.


      this._cleanUp();

      if (this.options.autoResize === true) {
        var _context2;

        if (window.ResizeObserver) {
          // decent browsers, immediate reactions
          var observer = new ResizeObserver(function () {
            var changed = _this2.setSize();

            if (changed === true) {
              _this2.body.emitter.emit("_requestRedraw");
            }
          });
          var frame = this.frame;
          observer.observe(frame);

          this._cleanupCallbacks.push(function () {
            observer.unobserve(frame);
          });
        } else {
          // IE11, continous polling
          var resizeTimer = setInterval(function () {
            var changed = _this2.setSize();

            if (changed === true) {
              _this2.body.emitter.emit("_requestRedraw");
            }
          }, 1000);

          this._cleanupCallbacks.push(function () {
            clearInterval(resizeTimer);
          });
        } // Automatically adapt to changing size of the browser.


        var resizeFunction = bind$6(_context2 = this._onResize).call(_context2, this);

        addEventListener(window, "resize", resizeFunction);

        this._cleanupCallbacks.push(function () {
          removeEventListener(window, "resize", resizeFunction);
        });
      }
    }
    /**
     * @private
     */

  }, {
    key: "_cleanUp",
    value: function _cleanUp() {
      var _context3, _context4, _context5;

      forEach$2(_context3 = reverse(_context4 = splice$1(_context5 = this._cleanupCallbacks).call(_context5, 0)).call(_context4)).call(_context3, function (callback) {
        try {
          callback();
        } catch (error) {
          console.error(error);
        }
      });
    }
    /**
     * @private
     */

  }, {
    key: "_onResize",
    value: function _onResize() {
      this.setSize();
      this.body.emitter.emit("_redraw");
    }
    /**
     * Get and store the cameraState
     *
     * @param {number} [pixelRatio=this.pixelRatio]
     * @private
     */

  }, {
    key: "_getCameraState",
    value: function _getCameraState() {
      var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pixelRatio;

      if (this.initialized === true) {
        this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;
        this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;
        this.cameraState.scale = this.body.view.scale;
        this.cameraState.position = this.DOMtoCanvas({
          x: 0.5 * this.frame.canvas.width / pixelRatio,
          y: 0.5 * this.frame.canvas.height / pixelRatio
        });
      }
    }
    /**
     * Set the cameraState
     *
     * @private
     */

  }, {
    key: "_setCameraState",
    value: function _setCameraState() {
      if (this.cameraState.scale !== undefined && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0 && this.cameraState.previousHeight > 0) {
        var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;
        var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;
        var newScale = this.cameraState.scale;

        if (widthRatio != 1 && heightRatio != 1) {
          newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);
        } else if (widthRatio != 1) {
          newScale = this.cameraState.scale * widthRatio;
        } else if (heightRatio != 1) {
          newScale = this.cameraState.scale * heightRatio;
        }

        this.body.view.scale = newScale; // this comes from the view module.

        var currentViewCenter = this.DOMtoCanvas({
          x: 0.5 * this.frame.canvas.clientWidth,
          y: 0.5 * this.frame.canvas.clientHeight
        });
        var distanceFromCenter = {
          // offset from view, distance view has to change by these x and y to center the node
          x: currentViewCenter.x - this.cameraState.position.x,
          y: currentViewCenter.y - this.cameraState.position.y
        };
        this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;
        this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;
      }
    }
    /**
     *
     * @param {number|string} value
     * @returns {string}
     * @private
     */

  }, {
    key: "_prepareValue",
    value: function _prepareValue(value) {
      if (typeof value === "number") {
        return value + "px";
      } else if (typeof value === "string") {
        if (indexOf(value).call(value, "%") !== -1 || indexOf(value).call(value, "px") !== -1) {
          return value;
        } else if (indexOf(value).call(value, "%") === -1) {
          return value + "px";
        }
      }

      throw new Error("Could not use the value supplied for width or height:" + value);
    }
    /**
     * Create the HTML
     */

  }, {
    key: "_create",
    value: function _create() {
      // remove all elements from the container element.
      while (this.body.container.hasChildNodes()) {
        this.body.container.removeChild(this.body.container.firstChild);
      }

      this.frame = document.createElement("div");
      this.frame.className = "vis-network";
      this.frame.style.position = "relative";
      this.frame.style.overflow = "hidden";
      this.frame.tabIndex = 0; // tab index is required for keycharm to bind keystrokes to the div instead of the window
      //////////////////////////////////////////////////////////////////

      this.frame.canvas = document.createElement("canvas");
      this.frame.canvas.style.position = "relative";
      this.frame.appendChild(this.frame.canvas);

      if (!this.frame.canvas.getContext) {
        var noCanvas = document.createElement("DIV");
        noCanvas.style.color = "red";
        noCanvas.style.fontWeight = "bold";
        noCanvas.style.padding = "10px";
        noCanvas.innerText = "Error: your browser does not support HTML canvas";
        this.frame.canvas.appendChild(noCanvas);
      } else {
        this._setPixelRatio();

        this.setTransform();
      } // add the frame to the container element


      this.body.container.appendChild(this.frame);
      this.body.view.scale = 1;
      this.body.view.translation = {
        x: 0.5 * this.frame.canvas.clientWidth,
        y: 0.5 * this.frame.canvas.clientHeight
      };

      this._bindHammer();
    }
    /**
     * This function binds hammer, it can be repeated over and over due to the uniqueness check.
     *
     * @private
     */

  }, {
    key: "_bindHammer",
    value: function _bindHammer() {
      var _this3 = this;

      if (this.hammer !== undefined) {
        this.hammer.destroy();
      }

      this.drag = {};
      this.pinch = {}; // init hammer

      this.hammer = new Hammer(this.frame.canvas);
      this.hammer.get("pinch").set({
        enable: true
      }); // enable to get better response, todo: test on mobile.

      this.hammer.get("pan").set({
        threshold: 5,
        direction: Hammer.DIRECTION_ALL
      });
      onTouch(this.hammer, function (event) {
        _this3.body.eventListeners.onTouch(event);
      });
      this.hammer.on("tap", function (event) {
        _this3.body.eventListeners.onTap(event);
      });
      this.hammer.on("doubletap", function (event) {
        _this3.body.eventListeners.onDoubleTap(event);
      });
      this.hammer.on("press", function (event) {
        _this3.body.eventListeners.onHold(event);
      });
      this.hammer.on("panstart", function (event) {
        _this3.body.eventListeners.onDragStart(event);
      });
      this.hammer.on("panmove", function (event) {
        _this3.body.eventListeners.onDrag(event);
      });
      this.hammer.on("panend", function (event) {
        _this3.body.eventListeners.onDragEnd(event);
      });
      this.hammer.on("pinch", function (event) {
        _this3.body.eventListeners.onPinch(event);
      }); // TODO: neatly cleanup these handlers when re-creating the Canvas, IF these are done with hammer, event.stopPropagation will not work?

      this.frame.canvas.addEventListener("wheel", function (event) {
        _this3.body.eventListeners.onMouseWheel(event);
      });
      this.frame.canvas.addEventListener("mousemove", function (event) {
        _this3.body.eventListeners.onMouseMove(event);
      });
      this.frame.canvas.addEventListener("contextmenu", function (event) {
        _this3.body.eventListeners.onContext(event);
      });
      this.hammerFrame = new Hammer(this.frame);
      onRelease(this.hammerFrame, function (event) {
        _this3.body.eventListeners.onRelease(event);
      });
    }
    /**
     * Set a new size for the network
     *
     * @param {string} width   Width in pixels or percentage (for example '800px'
     *                         or '50%')
     * @param {string} height  Height in pixels or percentage  (for example '400px'
     *                         or '30%')
     * @returns {boolean}
     */

  }, {
    key: "setSize",
    value: function setSize() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.width;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.height;
      width = this._prepareValue(width);
      height = this._prepareValue(height);
      var emitEvent = false;
      var oldWidth = this.frame.canvas.width;
      var oldHeight = this.frame.canvas.height; // update the pixel ratio
      //
      // NOTE: Comment in following is rather inconsistent; this is the ONLY place in the code
      //       where it is assumed that the pixel ratio could change at runtime.
      //       The only way I can think of this happening is a rotating screen or tablet; but then
      //       there should be a mechanism for reloading the data (TODO: check if this is present).
      //
      //       If the assumption is true (i.e. pixel ratio can change at runtime), then *all* usage
      //       of pixel ratio must be overhauled for this.
      //
      //       For the time being, I will humor the assumption here, and in the rest of the code assume it is
      //       constant.

      var previousRatio = this.pixelRatio; // we cache this because the camera state storage needs the old value

      this._setPixelRatio();

      if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {
        this._getCameraState(previousRatio);

        this.frame.style.width = width;
        this.frame.style.height = height;
        this.frame.canvas.style.width = "100%";
        this.frame.canvas.style.height = "100%";
        this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
        this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
        this.options.width = width;
        this.options.height = height;
        this.canvasViewCenter = {
          x: 0.5 * this.frame.clientWidth,
          y: 0.5 * this.frame.clientHeight
        };
        emitEvent = true;
      } else {
        // this would adapt the width of the canvas to the width from 100% if and only if
        // there is a change.
        var newWidth = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
        var newHeight = Math.round(this.frame.canvas.clientHeight * this.pixelRatio); // store the camera if there is a change in size.

        if (this.frame.canvas.width !== newWidth || this.frame.canvas.height !== newHeight) {
          this._getCameraState(previousRatio);
        }

        if (this.frame.canvas.width !== newWidth) {
          this.frame.canvas.width = newWidth;
          emitEvent = true;
        }

        if (this.frame.canvas.height !== newHeight) {
          this.frame.canvas.height = newHeight;
          emitEvent = true;
        }
      }

      if (emitEvent === true) {
        this.body.emitter.emit("resize", {
          width: Math.round(this.frame.canvas.width / this.pixelRatio),
          height: Math.round(this.frame.canvas.height / this.pixelRatio),
          oldWidth: Math.round(oldWidth / this.pixelRatio),
          oldHeight: Math.round(oldHeight / this.pixelRatio)
        }); // restore the camera on change.

        this._setCameraState();
      } // set initialized so the get and set camera will work from now on.


      this.initialized = true;
      return emitEvent;
    }
    /**
     *
     * @returns {CanvasRenderingContext2D}
     */

  }, {
    key: "getContext",
    value: function getContext() {
      return this.frame.canvas.getContext("2d");
    }
    /**
     * Determine the pixel ratio for various browsers.
     *
     * @returns {number}
     * @private
     */

  }, {
    key: "_determinePixelRatio",
    value: function _determinePixelRatio() {
      var ctx = this.getContext();

      if (ctx === undefined) {
        throw new Error("Could not get canvax context");
      }

      var numerator = 1;

      if (typeof window !== "undefined") {
        // (window !== undefined) doesn't work here!
        // Protection during unit tests, where 'window' can be missing
        numerator = window.devicePixelRatio || 1;
      }

      var denominator = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
      return numerator / denominator;
    }
    /**
     * Lazy determination of pixel ratio.
     *
     * @private
     */

  }, {
    key: "_setPixelRatio",
    value: function _setPixelRatio() {
      this.pixelRatio = this._determinePixelRatio();
    }
    /**
     * Set the transform in the contained context, based on its pixelRatio
     */

  }, {
    key: "setTransform",
    value: function setTransform() {
      var ctx = this.getContext();

      if (ctx === undefined) {
        throw new Error("Could not get canvax context");
      }

      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
    }
    /**
     * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to
     * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
     *
     * @param {number} x
     * @returns {number}
     * @private
     */

  }, {
    key: "_XconvertDOMtoCanvas",
    value: function _XconvertDOMtoCanvas(x) {
      return (x - this.body.view.translation.x) / this.body.view.scale;
    }
    /**
     * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
     * the X coordinate in DOM-space (coordinate point in browser relative to the container div)
     *
     * @param {number} x
     * @returns {number}
     * @private
     */

  }, {
    key: "_XconvertCanvasToDOM",
    value: function _XconvertCanvasToDOM(x) {
      return x * this.body.view.scale + this.body.view.translation.x;
    }
    /**
     * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to
     * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
     *
     * @param {number} y
     * @returns {number}
     * @private
     */

  }, {
    key: "_YconvertDOMtoCanvas",
    value: function _YconvertDOMtoCanvas(y) {
      return (y - this.body.view.translation.y) / this.body.view.scale;
    }
    /**
     * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
     * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)
     *
     * @param {number} y
     * @returns {number}
     * @private
     */

  }, {
    key: "_YconvertCanvasToDOM",
    value: function _YconvertCanvasToDOM(y) {
      return y * this.body.view.scale + this.body.view.translation.y;
    }
    /**
     * @param {point} pos
     * @returns {point}
     */

  }, {
    key: "canvasToDOM",
    value: function canvasToDOM(pos) {
      return {
        x: this._XconvertCanvasToDOM(pos.x),
        y: this._YconvertCanvasToDOM(pos.y)
      };
    }
    /**
     *
     * @param {point} pos
     * @returns {point}
     */

  }, {
    key: "DOMtoCanvas",
    value: function DOMtoCanvas(pos) {
      return {
        x: this._XconvertDOMtoCanvas(pos.x),
        y: this._YconvertDOMtoCanvas(pos.y)
      };
    }
  }]);

  return Canvas;
}();

/**
 * Validate the fit options, replace missing optional values by defaults etc.
 *
 * @param rawOptions - The raw options.
 * @param allNodeIds - All node ids that will be used if nodes are omitted in
 * the raw options.
 * @returns Options with everything filled in and validated.
 */
function normalizeFitOptions(rawOptions, allNodeIds) {
  var options = assign$2({
    nodes: allNodeIds,
    minZoomLevel: Number.MIN_VALUE,
    maxZoomLevel: 1
  }, rawOptions !== null && rawOptions !== void 0 ? rawOptions : {});

  if (!isArray$2(options.nodes)) {
    throw new TypeError("Nodes has to be an array of ids.");
  }

  if (options.nodes.length === 0) {
    options.nodes = allNodeIds;
  }

  if (!(typeof options.minZoomLevel === "number" && options.minZoomLevel > 0)) {
    throw new TypeError("Min zoom level has to be a number higher than zero.");
  }

  if (!(typeof options.maxZoomLevel === "number" && options.minZoomLevel <= options.maxZoomLevel)) {
    throw new TypeError("Max zoom level has to be a number higher than min zoom level.");
  }

  return options;
}

/**
 * The view
 */

var View = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   */
  function View(body, canvas) {
    var _context,
        _this = this,
        _context2;

    _classCallCheck(this, View);

    this.body = body;
    this.canvas = canvas;
    this.animationSpeed = 1 / this.renderRefreshRate;
    this.animationEasingFunction = "easeInOutQuint";
    this.easingTime = 0;
    this.sourceScale = 0;
    this.targetScale = 0;
    this.sourceTranslation = 0;
    this.targetTranslation = 0;
    this.lockedOnNodeId = undefined;
    this.lockedOnNodeOffset = undefined;
    this.touchTime = 0;
    this.viewFunction = undefined;
    this.body.emitter.on("fit", bind$6(_context = this.fit).call(_context, this));
    this.body.emitter.on("animationFinished", function () {
      _this.body.emitter.emit("_stopRendering");
    });
    this.body.emitter.on("unlockNode", bind$6(_context2 = this.releaseNode).call(_context2, this));
  }
  /**
   *
   * @param {object} [options={}]
   */


  _createClass(View, [{
    key: "setOptions",
    value: function setOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.options = options;
    }
    /**
     * This function zooms out to fit all data on screen based on amount of nodes
     *
     * @param {object} [options={{nodes=Array}}]
     * @param options
     * @param {boolean} [initialZoom=false]  | zoom based on fitted formula or range, true = fitted, default = false;
     */

  }, {
    key: "fit",
    value: function fit(options) {
      var initialZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      options = normalizeFitOptions(options, this.body.nodeIndices);
      var canvasWidth = this.canvas.frame.canvas.clientWidth;
      var canvasHeight = this.canvas.frame.canvas.clientHeight;
      var range;
      var zoomLevel;

      if (canvasWidth === 0 || canvasHeight === 0) {
        // There's no point in trying to fit into zero sized canvas. This could
        // potentially even result in invalid values being computed. For example
        // for network without nodes and zero sized canvas the zoom level would
        // end up being computed as 0/0 which results in NaN. In any other case
        // this would be 0/something which is again pointless to compute.
        zoomLevel = 1;
        range = NetworkUtil.getRange(this.body.nodes, options.nodes);
      } else if (initialZoom === true) {
        // check if more than half of the nodes have a predefined position. If so, we use the range, not the approximation.
        var positionDefined = 0;

        for (var nodeId in this.body.nodes) {
          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
            var node = this.body.nodes[nodeId];

            if (node.predefinedPosition === true) {
              positionDefined += 1;
            }
          }
        }

        if (positionDefined > 0.5 * this.body.nodeIndices.length) {
          this.fit(options, false);
          return;
        }

        range = NetworkUtil.getRange(this.body.nodes, options.nodes);
        var numberOfNodes = this.body.nodeIndices.length;
        zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822; // this is obtained from fitting a dataset from 5 points with scale levels that looked good.
        // correct for larger canvasses.

        var factor = Math.min(canvasWidth / 600, canvasHeight / 600);
        zoomLevel *= factor;
      } else {
        this.body.emitter.emit("_resizeNodes");
        range = NetworkUtil.getRange(this.body.nodes, options.nodes);
        var xDistance = Math.abs(range.maxX - range.minX) * 1.1;
        var yDistance = Math.abs(range.maxY - range.minY) * 1.1;
        var xZoomLevel = canvasWidth / xDistance;
        var yZoomLevel = canvasHeight / yDistance;
        zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;
      }

      if (zoomLevel > options.maxZoomLevel) {
        zoomLevel = options.maxZoomLevel;
      } else if (zoomLevel < options.minZoomLevel) {
        zoomLevel = options.minZoomLevel;
      }

      var center = NetworkUtil.findCenter(range);
      var animationOptions = {
        position: center,
        scale: zoomLevel,
        animation: options.animation
      };
      this.moveTo(animationOptions);
    } // animation

    /**
     * Center a node in view.
     *
     * @param {number} nodeId
     * @param {number} [options]
     */

  }, {
    key: "focus",
    value: function focus(nodeId) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.body.nodes[nodeId] !== undefined) {
        var nodePosition = {
          x: this.body.nodes[nodeId].x,
          y: this.body.nodes[nodeId].y
        };
        options.position = nodePosition;
        options.lockedOnNode = nodeId;
        this.moveTo(options);
      } else {
        console.error("Node: " + nodeId + " cannot be found.");
      }
    }
    /**
     *
     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
     *                          |  options.scale    = number                 // scale to move to
     *                          |  options.position = {x:number, y:number}   // position to move to
     *                          |  options.animation = {duration:number, easingFunction:String} || Boolean   // position to move to
     */

  }, {
    key: "moveTo",
    value: function moveTo(options) {
      if (options === undefined) {
        options = {};
        return;
      }

      if (options.offset != null) {
        if (options.offset.x != null) {
          // Coerce and verify that x is valid.
          options.offset.x = +options.offset.x;

          if (!_isFinite(options.offset.x)) {
            throw new TypeError('The option "offset.x" has to be a finite number.');
          }
        } else {
          options.offset.x = 0;
        }

        if (options.offset.y != null) {
          // Coerce and verify that y is valid.
          options.offset.y = +options.offset.y;

          if (!_isFinite(options.offset.y)) {
            throw new TypeError('The option "offset.y" has to be a finite number.');
          }
        } else {
          options.offset.x = 0;
        }
      } else {
        options.offset = {
          x: 0,
          y: 0
        };
      }

      if (options.position != null) {
        if (options.position.x != null) {
          // Coerce and verify that x is valid.
          options.position.x = +options.position.x;

          if (!_isFinite(options.position.x)) {
            throw new TypeError('The option "position.x" has to be a finite number.');
          }
        } else {
          options.position.x = 0;
        }

        if (options.position.y != null) {
          // Coerce and verify that y is valid.
          options.position.y = +options.position.y;

          if (!_isFinite(options.position.y)) {
            throw new TypeError('The option "position.y" has to be a finite number.');
          }
        } else {
          options.position.x = 0;
        }
      } else {
        options.position = this.getViewPosition();
      }

      if (options.scale != null) {
        // Coerce and verify that the scale is valid.
        options.scale = +options.scale;

        if (!(options.scale > 0)) {
          throw new TypeError('The option "scale" has to be a number greater than zero.');
        }
      } else {
        options.scale = this.body.view.scale;
      }

      if (options.animation === undefined) {
        options.animation = {
          duration: 0
        };
      }

      if (options.animation === false) {
        options.animation = {
          duration: 0
        };
      }

      if (options.animation === true) {
        options.animation = {};
      }

      if (options.animation.duration === undefined) {
        options.animation.duration = 1000;
      } // default duration


      if (options.animation.easingFunction === undefined) {
        options.animation.easingFunction = "easeInOutQuad";
      } // default easing function


      this.animateView(options);
    }
    /**
     *
     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
     *                          |  options.time     = number                 // animation time in milliseconds
     *                          |  options.scale    = number                 // scale to animate to
     *                          |  options.position = {x:number, y:number}   // position to animate to
     *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,
     *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,
     *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,
     *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint
     */

  }, {
    key: "animateView",
    value: function animateView(options) {
      if (options === undefined) {
        return;
      }

      this.animationEasingFunction = options.animation.easingFunction; // release if something focussed on the node

      this.releaseNode();

      if (options.locked === true) {
        this.lockedOnNodeId = options.lockedOnNode;
        this.lockedOnNodeOffset = options.offset;
      } // forcefully complete the old animation if it was still running


      if (this.easingTime != 0) {
        this._transitionRedraw(true); // by setting easingtime to 1, we finish the animation.

      }

      this.sourceScale = this.body.view.scale;
      this.sourceTranslation = this.body.view.translation;
      this.targetScale = options.scale; // set the scale so the viewCenter is based on the correct zoom level. This is overridden in the transitionRedraw
      // but at least then we'll have the target transition

      this.body.view.scale = this.targetScale;
      var viewCenter = this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });
      var distanceFromCenter = {
        // offset from view, distance view has to change by these x and y to center the node
        x: viewCenter.x - options.position.x,
        y: viewCenter.y - options.position.y
      };
      this.targetTranslation = {
        x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options.offset.x,
        y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options.offset.y
      }; // if the time is set to 0, don't do an animation

      if (options.animation.duration === 0) {
        if (this.lockedOnNodeId != undefined) {
          var _context3;

          this.viewFunction = bind$6(_context3 = this._lockedRedraw).call(_context3, this);
          this.body.emitter.on("initRedraw", this.viewFunction);
        } else {
          this.body.view.scale = this.targetScale;
          this.body.view.translation = this.targetTranslation;
          this.body.emitter.emit("_requestRedraw");
        }
      } else {
        var _context4;

        this.animationSpeed = 1 / (60 * options.animation.duration * 0.001) || 1 / 60; // 60 for 60 seconds, 0.001 for milli's

        this.animationEasingFunction = options.animation.easingFunction;
        this.viewFunction = bind$6(_context4 = this._transitionRedraw).call(_context4, this);
        this.body.emitter.on("initRedraw", this.viewFunction);
        this.body.emitter.emit("_startRendering");
      }
    }
    /**
     * used to animate smoothly by hijacking the redraw function.
     *
     * @private
     */

  }, {
    key: "_lockedRedraw",
    value: function _lockedRedraw() {
      var nodePosition = {
        x: this.body.nodes[this.lockedOnNodeId].x,
        y: this.body.nodes[this.lockedOnNodeId].y
      };
      var viewCenter = this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });
      var distanceFromCenter = {
        // offset from view, distance view has to change by these x and y to center the node
        x: viewCenter.x - nodePosition.x,
        y: viewCenter.y - nodePosition.y
      };
      var sourceTranslation = this.body.view.translation;
      var targetTranslation = {
        x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,
        y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y
      };
      this.body.view.translation = targetTranslation;
    }
    /**
     * Resets state of a locked on Node
     */

  }, {
    key: "releaseNode",
    value: function releaseNode() {
      if (this.lockedOnNodeId !== undefined && this.viewFunction !== undefined) {
        this.body.emitter.off("initRedraw", this.viewFunction);
        this.lockedOnNodeId = undefined;
        this.lockedOnNodeOffset = undefined;
      }
    }
    /**
     * @param {boolean} [finished=false]
     * @private
     */

  }, {
    key: "_transitionRedraw",
    value: function _transitionRedraw() {
      var finished = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.easingTime += this.animationSpeed;
      this.easingTime = finished === true ? 1.0 : this.easingTime;
      var progress = easingFunctions[this.animationEasingFunction](this.easingTime);
      this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;
      this.body.view.translation = {
        x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,
        y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress
      }; // cleanup

      if (this.easingTime >= 1.0) {
        this.body.emitter.off("initRedraw", this.viewFunction);
        this.easingTime = 0;

        if (this.lockedOnNodeId != undefined) {
          var _context5;

          this.viewFunction = bind$6(_context5 = this._lockedRedraw).call(_context5, this);
          this.body.emitter.on("initRedraw", this.viewFunction);
        }

        this.body.emitter.emit("animationFinished");
      }
    }
    /**
     *
     * @returns {number}
     */

  }, {
    key: "getScale",
    value: function getScale() {
      return this.body.view.scale;
    }
    /**
     *
     * @returns {{x: number, y: number}}
     */

  }, {
    key: "getViewPosition",
    value: function getViewPosition() {
      return this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });
    }
  }]);

  return View;
}();

var css_248z$1 = "div.vis-network div.vis-navigation div.vis-button {\n  width: 34px;\n  height: 34px;\n  -moz-border-radius: 17px;\n  border-radius: 17px;\n  position: absolute;\n  display: inline-block;\n  background-position: 2px 2px;\n  background-repeat: no-repeat;\n  cursor: pointer;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network div.vis-navigation div.vis-button:hover {\n  box-shadow: 0 0 3px 3px rgba(56, 207, 21, 0.3);\n}\n\ndiv.vis-network div.vis-navigation div.vis-button:active {\n  box-shadow: 0 0 1px 3px rgba(56, 207, 21, 0.95);\n}\n\ndiv.vis-network div.vis-navigation div.vis-button.vis-up {\n  background-image: url('data:image/png;base64,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');\n  bottom: 50px;\n  left: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-down {\n  background-image: url('data:image/png;base64,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');\n  bottom: 10px;\n  left: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-left {\n  background-image: url('data:image/png;base64,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');\n  bottom: 10px;\n  left: 15px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-right {\n  background-image: url('data:image/png;base64,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');\n  bottom: 10px;\n  left: 95px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomIn {\n  background-image: url('data:image/png;base64,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');\n  bottom: 10px;\n  right: 15px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomOut {\n  background-image: url('data:image/png;base64,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');\n  bottom: 10px;\n  right: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomExtends {\n  background-image: url('data:image/png;base64,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');\n  bottom: 50px;\n  right: 15px;\n}\n";
styleInject(css_248z$1);

/**
 * Created by Alex on 11/6/2014.
 */
function keycharm(options) {
  var preventDefault = options && options.preventDefault || false;
  var container = options && options.container || window;
  var _exportFunctions = {};
  var _bound = {
    keydown: {},
    keyup: {}
  };
  var _keys = {};
  var i; // a - z

  for (i = 97; i <= 122; i++) {
    _keys[String.fromCharCode(i)] = {
      code: 65 + (i - 97),
      shift: false
    };
  } // A - Z


  for (i = 65; i <= 90; i++) {
    _keys[String.fromCharCode(i)] = {
      code: i,
      shift: true
    };
  } // 0 - 9


  for (i = 0; i <= 9; i++) {
    _keys['' + i] = {
      code: 48 + i,
      shift: false
    };
  } // F1 - F12


  for (i = 1; i <= 12; i++) {
    _keys['F' + i] = {
      code: 111 + i,
      shift: false
    };
  } // num0 - num9


  for (i = 0; i <= 9; i++) {
    _keys['num' + i] = {
      code: 96 + i,
      shift: false
    };
  } // numpad misc


  _keys['num*'] = {
    code: 106,
    shift: false
  };
  _keys['num+'] = {
    code: 107,
    shift: false
  };
  _keys['num-'] = {
    code: 109,
    shift: false
  };
  _keys['num/'] = {
    code: 111,
    shift: false
  };
  _keys['num.'] = {
    code: 110,
    shift: false
  }; // arrows

  _keys['left'] = {
    code: 37,
    shift: false
  };
  _keys['up'] = {
    code: 38,
    shift: false
  };
  _keys['right'] = {
    code: 39,
    shift: false
  };
  _keys['down'] = {
    code: 40,
    shift: false
  }; // extra keys

  _keys['space'] = {
    code: 32,
    shift: false
  };
  _keys['enter'] = {
    code: 13,
    shift: false
  };
  _keys['shift'] = {
    code: 16,
    shift: undefined
  };
  _keys['esc'] = {
    code: 27,
    shift: false
  };
  _keys['backspace'] = {
    code: 8,
    shift: false
  };
  _keys['tab'] = {
    code: 9,
    shift: false
  };
  _keys['ctrl'] = {
    code: 17,
    shift: false
  };
  _keys['alt'] = {
    code: 18,
    shift: false
  };
  _keys['delete'] = {
    code: 46,
    shift: false
  };
  _keys['pageup'] = {
    code: 33,
    shift: false
  };
  _keys['pagedown'] = {
    code: 34,
    shift: false
  }; // symbols

  _keys['='] = {
    code: 187,
    shift: false
  };
  _keys['-'] = {
    code: 189,
    shift: false
  };
  _keys[']'] = {
    code: 221,
    shift: false
  };
  _keys['['] = {
    code: 219,
    shift: false
  };

  var down = function (event) {
    handleEvent(event, 'keydown');
  };

  var up = function (event) {
    handleEvent(event, 'keyup');
  }; // handle the actualy bound key with the event


  var handleEvent = function (event, type) {
    if (_bound[type][event.keyCode] !== undefined) {
      var bound = _bound[type][event.keyCode];

      for (var i = 0; i < bound.length; i++) {
        if (bound[i].shift === undefined) {
          bound[i].fn(event);
        } else if (bound[i].shift == true && event.shiftKey == true) {
          bound[i].fn(event);
        } else if (bound[i].shift == false && event.shiftKey == false) {
          bound[i].fn(event);
        }
      }

      if (preventDefault == true) {
        event.preventDefault();
      }
    }
  }; // bind a key to a callback


  _exportFunctions.bind = function (key, callback, type) {
    if (type === undefined) {
      type = 'keydown';
    }

    if (_keys[key] === undefined) {
      throw new Error("unsupported key: " + key);
    }

    if (_bound[type][_keys[key].code] === undefined) {
      _bound[type][_keys[key].code] = [];
    }

    _bound[type][_keys[key].code].push({
      fn: callback,
      shift: _keys[key].shift
    });
  }; // bind all keys to a call back (demo purposes)


  _exportFunctions.bindAll = function (callback, type) {
    if (type === undefined) {
      type = 'keydown';
    }

    for (var key in _keys) {
      if (_keys.hasOwnProperty(key)) {
        _exportFunctions.bind(key, callback, type);
      }
    }
  }; // get the key label from an event


  _exportFunctions.getKey = function (event) {
    for (var key in _keys) {
      if (_keys.hasOwnProperty(key)) {
        if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
          return key;
        } else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
          return key;
        } else if (event.keyCode == _keys[key].code && key == 'shift') {
          return key;
        }
      }
    }

    return "unknown key, currently not supported";
  }; // unbind either a specific callback from a key or all of them (by leaving callback undefined)


  _exportFunctions.unbind = function (key, callback, type) {
    if (type === undefined) {
      type = 'keydown';
    }

    if (_keys[key] === undefined) {
      throw new Error("unsupported key: " + key);
    }

    if (callback !== undefined) {
      var newBindings = [];
      var bound = _bound[type][_keys[key].code];

      if (bound !== undefined) {
        for (var i = 0; i < bound.length; i++) {
          if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {
            newBindings.push(_bound[type][_keys[key].code][i]);
          }
        }
      }

      _bound[type][_keys[key].code] = newBindings;
    } else {
      _bound[type][_keys[key].code] = [];
    }
  }; // reset all bound variables.


  _exportFunctions.reset = function () {
    _bound = {
      keydown: {},
      keyup: {}
    };
  }; // unbind all listeners and reset all variables.


  _exportFunctions.destroy = function () {
    _bound = {
      keydown: {},
      keyup: {}
    };
    container.removeEventListener('keydown', down, true);
    container.removeEventListener('keyup', up, true);
  }; // create listeners.


  container.addEventListener('keydown', down, true);
  container.addEventListener('keyup', up, true); // return the public functions.

  return _exportFunctions;
}

/**
 * Navigation Handler
 */

var NavigationHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   */
  function NavigationHandler(body, canvas) {
    var _this = this;

    _classCallCheck(this, NavigationHandler);

    this.body = body;
    this.canvas = canvas;
    this.iconsCreated = false;
    this.navigationHammers = [];
    this.boundFunctions = {};
    this.touchTime = 0;
    this.activated = false;
    this.body.emitter.on("activate", function () {
      _this.activated = true;

      _this.configureKeyboardBindings();
    });
    this.body.emitter.on("deactivate", function () {
      _this.activated = false;

      _this.configureKeyboardBindings();
    });
    this.body.emitter.on("destroy", function () {
      if (_this.keycharm !== undefined) {
        _this.keycharm.destroy();
      }
    });
    this.options = {};
  }
  /**
   *
   * @param {object} options
   */


  _createClass(NavigationHandler, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        this.options = options;
        this.create();
      }
    }
    /**
     * Creates or refreshes navigation and sets key bindings
     */

  }, {
    key: "create",
    value: function create() {
      if (this.options.navigationButtons === true) {
        if (this.iconsCreated === false) {
          this.loadNavigationElements();
        }
      } else if (this.iconsCreated === true) {
        this.cleanNavigation();
      }

      this.configureKeyboardBindings();
    }
    /**
     * Cleans up previous navigation items
     */

  }, {
    key: "cleanNavigation",
    value: function cleanNavigation() {
      // clean hammer bindings
      if (this.navigationHammers.length != 0) {
        for (var i = 0; i < this.navigationHammers.length; i++) {
          this.navigationHammers[i].destroy();
        }

        this.navigationHammers = [];
      } // clean up previous navigation items


      if (this.navigationDOM && this.navigationDOM["wrapper"] && this.navigationDOM["wrapper"].parentNode) {
        this.navigationDOM["wrapper"].parentNode.removeChild(this.navigationDOM["wrapper"]);
      }

      this.iconsCreated = false;
    }
    /**
     * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation
     * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent
     * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.
     * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.
     *
     * @private
     */

  }, {
    key: "loadNavigationElements",
    value: function loadNavigationElements() {
      var _this2 = this;

      this.cleanNavigation();
      this.navigationDOM = {};
      var navigationDivs = ["up", "down", "left", "right", "zoomIn", "zoomOut", "zoomExtends"];
      var navigationDivActions = ["_moveUp", "_moveDown", "_moveLeft", "_moveRight", "_zoomIn", "_zoomOut", "_fit"];
      this.navigationDOM["wrapper"] = document.createElement("div");
      this.navigationDOM["wrapper"].className = "vis-navigation";
      this.canvas.frame.appendChild(this.navigationDOM["wrapper"]);

      for (var i = 0; i < navigationDivs.length; i++) {
        this.navigationDOM[navigationDivs[i]] = document.createElement("div");
        this.navigationDOM[navigationDivs[i]].className = "vis-button vis-" + navigationDivs[i];
        this.navigationDOM["wrapper"].appendChild(this.navigationDOM[navigationDivs[i]]);
        var hammer = new Hammer(this.navigationDOM[navigationDivs[i]]);

        if (navigationDivActions[i] === "_fit") {
          var _context;

          onTouch(hammer, bind$6(_context = this._fit).call(_context, this));
        } else {
          var _context2;

          onTouch(hammer, bind$6(_context2 = this.bindToRedraw).call(_context2, this, navigationDivActions[i]));
        }

        this.navigationHammers.push(hammer);
      } // use a hammer for the release so we do not require the one used in the rest of the network
      // the one the rest uses can be overloaded by the manipulation system.


      var hammerFrame = new Hammer(this.canvas.frame);
      onRelease(hammerFrame, function () {
        _this2._stopMovement();
      });
      this.navigationHammers.push(hammerFrame);
      this.iconsCreated = true;
    }
    /**
     *
     * @param {string} action
     */

  }, {
    key: "bindToRedraw",
    value: function bindToRedraw(action) {
      if (this.boundFunctions[action] === undefined) {
        var _context3;

        this.boundFunctions[action] = bind$6(_context3 = this[action]).call(_context3, this);
        this.body.emitter.on("initRedraw", this.boundFunctions[action]);
        this.body.emitter.emit("_startRendering");
      }
    }
    /**
     *
     * @param {string} action
     */

  }, {
    key: "unbindFromRedraw",
    value: function unbindFromRedraw(action) {
      if (this.boundFunctions[action] !== undefined) {
        this.body.emitter.off("initRedraw", this.boundFunctions[action]);
        this.body.emitter.emit("_stopRendering");
        delete this.boundFunctions[action];
      }
    }
    /**
     * this stops all movement induced by the navigation buttons
     *
     * @private
     */

  }, {
    key: "_fit",
    value: function _fit() {
      if (new Date().valueOf() - this.touchTime > 700) {
        // TODO: fix ugly hack to avoid hammer's double fireing of event (because we use release?)
        this.body.emitter.emit("fit", {
          duration: 700
        });
        this.touchTime = new Date().valueOf();
      }
    }
    /**
     * this stops all movement induced by the navigation buttons
     *
     * @private
     */

  }, {
    key: "_stopMovement",
    value: function _stopMovement() {
      for (var boundAction in this.boundFunctions) {
        if (Object.prototype.hasOwnProperty.call(this.boundFunctions, boundAction)) {
          this.body.emitter.off("initRedraw", this.boundFunctions[boundAction]);
          this.body.emitter.emit("_stopRendering");
        }
      }

      this.boundFunctions = {};
    }
    /**
     *
     * @private
     */

  }, {
    key: "_moveUp",
    value: function _moveUp() {
      this.body.view.translation.y += this.options.keyboard.speed.y;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_moveDown",
    value: function _moveDown() {
      this.body.view.translation.y -= this.options.keyboard.speed.y;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_moveLeft",
    value: function _moveLeft() {
      this.body.view.translation.x += this.options.keyboard.speed.x;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_moveRight",
    value: function _moveRight() {
      this.body.view.translation.x -= this.options.keyboard.speed.x;
    }
    /**
     *
     * @private
     */

  }, {
    key: "_zoomIn",
    value: function _zoomIn() {
      var scaleOld = this.body.view.scale;
      var scale = this.body.view.scale * (1 + this.options.keyboard.speed.zoom);
      var translation = this.body.view.translation;
      var scaleFrac = scale / scaleOld;
      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;
      this.body.view.scale = scale;
      this.body.view.translation = {
        x: tx,
        y: ty
      };
      this.body.emitter.emit("zoom", {
        direction: "+",
        scale: this.body.view.scale,
        pointer: null
      });
    }
    /**
     *
     * @private
     */

  }, {
    key: "_zoomOut",
    value: function _zoomOut() {
      var scaleOld = this.body.view.scale;
      var scale = this.body.view.scale / (1 + this.options.keyboard.speed.zoom);
      var translation = this.body.view.translation;
      var scaleFrac = scale / scaleOld;
      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;
      this.body.view.scale = scale;
      this.body.view.translation = {
        x: tx,
        y: ty
      };
      this.body.emitter.emit("zoom", {
        direction: "-",
        scale: this.body.view.scale,
        pointer: null
      });
    }
    /**
     * bind all keys using keycharm.
     */

  }, {
    key: "configureKeyboardBindings",
    value: function configureKeyboardBindings() {
      var _this3 = this;

      if (this.keycharm !== undefined) {
        this.keycharm.destroy();
      }

      if (this.options.keyboard.enabled === true) {
        if (this.options.keyboard.bindToWindow === true) {
          this.keycharm = keycharm({
            container: window,
            preventDefault: true
          });
        } else {
          this.keycharm = keycharm({
            container: this.canvas.frame,
            preventDefault: true
          });
        }

        this.keycharm.reset();

        if (this.activated === true) {
          var _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13, _context14, _context15, _context16, _context17, _context18, _context19, _context20, _context21, _context22, _context23, _context24, _context25, _context26, _context27;

          bind$6(_context4 = this.keycharm).call(_context4, "up", function () {
            _this3.bindToRedraw("_moveUp");
          }, "keydown");

          bind$6(_context5 = this.keycharm).call(_context5, "down", function () {
            _this3.bindToRedraw("_moveDown");
          }, "keydown");

          bind$6(_context6 = this.keycharm).call(_context6, "left", function () {
            _this3.bindToRedraw("_moveLeft");
          }, "keydown");

          bind$6(_context7 = this.keycharm).call(_context7, "right", function () {
            _this3.bindToRedraw("_moveRight");
          }, "keydown");

          bind$6(_context8 = this.keycharm).call(_context8, "=", function () {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");

          bind$6(_context9 = this.keycharm).call(_context9, "num+", function () {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");

          bind$6(_context10 = this.keycharm).call(_context10, "num-", function () {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");

          bind$6(_context11 = this.keycharm).call(_context11, "-", function () {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");

          bind$6(_context12 = this.keycharm).call(_context12, "[", function () {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");

          bind$6(_context13 = this.keycharm).call(_context13, "]", function () {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");

          bind$6(_context14 = this.keycharm).call(_context14, "pageup", function () {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");

          bind$6(_context15 = this.keycharm).call(_context15, "pagedown", function () {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");

          bind$6(_context16 = this.keycharm).call(_context16, "up", function () {
            _this3.unbindFromRedraw("_moveUp");
          }, "keyup");

          bind$6(_context17 = this.keycharm).call(_context17, "down", function () {
            _this3.unbindFromRedraw("_moveDown");
          }, "keyup");

          bind$6(_context18 = this.keycharm).call(_context18, "left", function () {
            _this3.unbindFromRedraw("_moveLeft");
          }, "keyup");

          bind$6(_context19 = this.keycharm).call(_context19, "right", function () {
            _this3.unbindFromRedraw("_moveRight");
          }, "keyup");

          bind$6(_context20 = this.keycharm).call(_context20, "=", function () {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");

          bind$6(_context21 = this.keycharm).call(_context21, "num+", function () {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");

          bind$6(_context22 = this.keycharm).call(_context22, "num-", function () {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");

          bind$6(_context23 = this.keycharm).call(_context23, "-", function () {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");

          bind$6(_context24 = this.keycharm).call(_context24, "[", function () {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");

          bind$6(_context25 = this.keycharm).call(_context25, "]", function () {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");

          bind$6(_context26 = this.keycharm).call(_context26, "pageup", function () {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");

          bind$6(_context27 = this.keycharm).call(_context27, "pagedown", function () {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");
        }
      }
    }
  }]);

  return NavigationHandler;
}();

function _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$4(o, minLen) { var _context15; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = slice(_context15 = Object.prototype.toString.call(o)).call(_context15, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Handler for interactions
 */

var InteractionHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   * @param {SelectionHandler} selectionHandler
   */
  function InteractionHandler(body, canvas, selectionHandler) {
    var _context, _context2, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13;

    _classCallCheck(this, InteractionHandler);

    this.body = body;
    this.canvas = canvas;
    this.selectionHandler = selectionHandler;
    this.navigationHandler = new NavigationHandler(body, canvas); // bind the events from hammer to functions in this object

    this.body.eventListeners.onTap = bind$6(_context = this.onTap).call(_context, this);
    this.body.eventListeners.onTouch = bind$6(_context2 = this.onTouch).call(_context2, this);
    this.body.eventListeners.onDoubleTap = bind$6(_context3 = this.onDoubleTap).call(_context3, this);
    this.body.eventListeners.onHold = bind$6(_context4 = this.onHold).call(_context4, this);
    this.body.eventListeners.onDragStart = bind$6(_context5 = this.onDragStart).call(_context5, this);
    this.body.eventListeners.onDrag = bind$6(_context6 = this.onDrag).call(_context6, this);
    this.body.eventListeners.onDragEnd = bind$6(_context7 = this.onDragEnd).call(_context7, this);
    this.body.eventListeners.onMouseWheel = bind$6(_context8 = this.onMouseWheel).call(_context8, this);
    this.body.eventListeners.onPinch = bind$6(_context9 = this.onPinch).call(_context9, this);
    this.body.eventListeners.onMouseMove = bind$6(_context10 = this.onMouseMove).call(_context10, this);
    this.body.eventListeners.onRelease = bind$6(_context11 = this.onRelease).call(_context11, this);
    this.body.eventListeners.onContext = bind$6(_context12 = this.onContext).call(_context12, this);
    this.touchTime = 0;
    this.drag = {};
    this.pinch = {};
    this.popup = undefined;
    this.popupObj = undefined;
    this.popupTimer = undefined;
    this.body.functions.getPointer = bind$6(_context13 = this.getPointer).call(_context13, this);
    this.options = {};
    this.defaultOptions = {
      dragNodes: true,
      dragView: true,
      hover: false,
      keyboard: {
        enabled: false,
        speed: {
          x: 10,
          y: 10,
          zoom: 0.02
        },
        bindToWindow: true,
        autoFocus: true
      },
      navigationButtons: false,
      tooltipDelay: 300,
      zoomView: true,
      zoomSpeed: 1
    };

    assign$2(this.options, this.defaultOptions);

    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(InteractionHandler, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this;

      this.body.emitter.on("destroy", function () {
        clearTimeout(_this.popupTimer);
        delete _this.body.functions.getPointer;
      });
    }
    /**
     *
     * @param {object} options
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        // extend all but the values in fields
        var fields = ["hideEdgesOnDrag", "hideEdgesOnZoom", "hideNodesOnDrag", "keyboard", "multiselect", "selectable", "selectConnectedEdges"];
        selectiveNotDeepExtend(fields, this.options, options); // merge the keyboard options in.

        mergeOptions(this.options, options, "keyboard");

        if (options.tooltip) {
          assign$2(this.options.tooltip, options.tooltip);

          if (options.tooltip.color) {
            this.options.tooltip.color = parseColor(options.tooltip.color);
          }
        }
      }

      this.navigationHandler.setOptions(this.options);
    }
    /**
     * Get the pointer location from a touch location
     *
     * @param {{x: number, y: number}} touch
     * @returns {{x: number, y: number}} pointer
     * @private
     */

  }, {
    key: "getPointer",
    value: function getPointer(touch) {
      return {
        x: touch.x - getAbsoluteLeft(this.canvas.frame.canvas),
        y: touch.y - getAbsoluteTop(this.canvas.frame.canvas)
      };
    }
    /**
     * On start of a touch gesture, store the pointer
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "onTouch",
    value: function onTouch(event) {
      if (new Date().valueOf() - this.touchTime > 50) {
        this.drag.pointer = this.getPointer(event.center);
        this.drag.pinched = false;
        this.pinch.scale = this.body.view.scale; // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)

        this.touchTime = new Date().valueOf();
      }
    }
    /**
     * handle tap/click event: select/unselect a node
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onTap",
    value: function onTap(event) {
      var pointer = this.getPointer(event.center);
      var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);
      this.checkSelectionChanges(pointer, multiselect);
      this.selectionHandler.commitAndEmit(pointer, event);
      this.selectionHandler.generateClickEvent("click", event, pointer);
    }
    /**
     * handle doubletap event
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onDoubleTap",
    value: function onDoubleTap(event) {
      var pointer = this.getPointer(event.center);
      this.selectionHandler.generateClickEvent("doubleClick", event, pointer);
    }
    /**
     * handle long tap event: multi select nodes
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onHold",
    value: function onHold(event) {
      var pointer = this.getPointer(event.center);
      var multiselect = this.selectionHandler.options.multiselect;
      this.checkSelectionChanges(pointer, multiselect);
      this.selectionHandler.commitAndEmit(pointer, event);
      this.selectionHandler.generateClickEvent("click", event, pointer);
      this.selectionHandler.generateClickEvent("hold", event, pointer);
    }
    /**
     * handle the release of the screen
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onRelease",
    value: function onRelease(event) {
      if (new Date().valueOf() - this.touchTime > 10) {
        var pointer = this.getPointer(event.center);
        this.selectionHandler.generateClickEvent("release", event, pointer); // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)

        this.touchTime = new Date().valueOf();
      }
    }
    /**
     *
     * @param {Event} event
     */

  }, {
    key: "onContext",
    value: function onContext(event) {
      var pointer = this.getPointer({
        x: event.clientX,
        y: event.clientY
      });
      this.selectionHandler.generateClickEvent("oncontext", event, pointer);
    }
    /**
     * Select and deselect nodes depending current selection change.
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [add=false]
     */

  }, {
    key: "checkSelectionChanges",
    value: function checkSelectionChanges(pointer) {
      var add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (add === true) {
        this.selectionHandler.selectAdditionalOnPoint(pointer);
      } else {
        this.selectionHandler.selectOnPoint(pointer);
      }
    }
    /**
     * Remove all node and edge id's from the first set that are present in the second one.
     *
     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} firstSet
     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} secondSet
     * @returns {{nodes: Array.<Node>, edges: Array.<vis.Edge>}}
     * @private
     */

  }, {
    key: "_determineDifference",
    value: function _determineDifference(firstSet, secondSet) {
      var arrayDiff = function arrayDiff(firstArr, secondArr) {
        var result = [];

        for (var i = 0; i < firstArr.length; i++) {
          var value = firstArr[i];

          if (indexOf(secondArr).call(secondArr, value) === -1) {
            result.push(value);
          }
        }

        return result;
      };

      return {
        nodes: arrayDiff(firstSet.nodes, secondSet.nodes),
        edges: arrayDiff(firstSet.edges, secondSet.edges)
      };
    }
    /**
     * This function is called by onDragStart.
     * It is separated out because we can then overload it for the datamanipulation system.
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onDragStart",
    value: function onDragStart(event) {
      // if already dragging, do not start
      // this can happen on touch screens with multiple fingers
      if (this.drag.dragging) {
        return;
      } //in case the touch event was triggered on an external div, do the initial touch now.


      if (this.drag.pointer === undefined) {
        this.onTouch(event);
      } // note: drag.pointer is set in onTouch to get the initial touch location


      var node = this.selectionHandler.getNodeAt(this.drag.pointer);
      this.drag.dragging = true;
      this.drag.selection = [];
      this.drag.translation = assign$2({}, this.body.view.translation); // copy the object

      this.drag.nodeId = undefined;

      if (event.srcEvent.shiftKey) {
        this.body.selectionBox.show = true;
        var pointer = this.getPointer(event.center);
        this.body.selectionBox.position.start = {
          x: this.canvas._XconvertDOMtoCanvas(pointer.x),
          y: this.canvas._YconvertDOMtoCanvas(pointer.y)
        };
        this.body.selectionBox.position.end = {
          x: this.canvas._XconvertDOMtoCanvas(pointer.x),
          y: this.canvas._YconvertDOMtoCanvas(pointer.y)
        };
      }

      if (node !== undefined && this.options.dragNodes === true) {
        this.drag.nodeId = node.id; // select the clicked node if not yet selected

        if (node.isSelected() === false) {
          this.selectionHandler.setSelection({
            nodes: [node.id]
          });
        } // after select to contain the node


        this.selectionHandler.generateClickEvent("dragStart", event, this.drag.pointer); // create an array with the selected nodes and their original location and status

        var _iterator = _createForOfIteratorHelper$4(this.selectionHandler.getSelectedNodes()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _node = _step.value;
            var s = {
              id: _node.id,
              node: _node,
              // store original x, y, xFixed and yFixed, make the node temporarily Fixed
              x: _node.x,
              y: _node.y,
              xFixed: _node.options.fixed.x,
              yFixed: _node.options.fixed.y
            };
            _node.options.fixed.x = true;
            _node.options.fixed.y = true;
            this.drag.selection.push(s);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        // fallback if no node is selected and thus the view is dragged.
        this.selectionHandler.generateClickEvent("dragStart", event, this.drag.pointer, undefined, true);
      }
    }
    /**
     * handle drag event
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onDrag",
    value: function onDrag(event) {
      var _this2 = this;

      if (this.drag.pinched === true) {
        return;
      } // remove the focus on node if it is focussed on by the focusOnNode


      this.body.emitter.emit("unlockNode");
      var pointer = this.getPointer(event.center);
      var selection = this.drag.selection;

      if (selection && selection.length && this.options.dragNodes === true) {
        this.selectionHandler.generateClickEvent("dragging", event, pointer); // calculate delta's and new location

        var deltaX = pointer.x - this.drag.pointer.x;
        var deltaY = pointer.y - this.drag.pointer.y; // update position of all selected nodes

        forEach$2(selection).call(selection, function (selection) {
          var node = selection.node; // only move the node if it was not fixed initially

          if (selection.xFixed === false) {
            node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection.x) + deltaX);
          } // only move the node if it was not fixed initially


          if (selection.yFixed === false) {
            node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection.y) + deltaY);
          }
        }); // start the simulation of the physics


        this.body.emitter.emit("startSimulation");
      } else {
        // create selection box
        if (event.srcEvent.shiftKey) {
          this.selectionHandler.generateClickEvent("dragging", event, pointer, undefined, true); // if the drag was not started properly because the click started outside the network div, start it now.

          if (this.drag.pointer === undefined) {
            this.onDragStart(event);
            return;
          }

          this.body.selectionBox.position.end = {
            x: this.canvas._XconvertDOMtoCanvas(pointer.x),
            y: this.canvas._YconvertDOMtoCanvas(pointer.y)
          };
          this.body.emitter.emit("_requestRedraw");
        } // move the network


        if (this.options.dragView === true && !event.srcEvent.shiftKey) {
          this.selectionHandler.generateClickEvent("dragging", event, pointer, undefined, true); // if the drag was not started properly because the click started outside the network div, start it now.

          if (this.drag.pointer === undefined) {
            this.onDragStart(event);
            return;
          }

          var diffX = pointer.x - this.drag.pointer.x;
          var diffY = pointer.y - this.drag.pointer.y;
          this.body.view.translation = {
            x: this.drag.translation.x + diffX,
            y: this.drag.translation.y + diffY
          };
          this.body.emitter.emit("_requestRedraw");
        }
      }
    }
    /**
     * handle drag start event
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "onDragEnd",
    value: function onDragEnd(event) {
      var _this3 = this;

      this.drag.dragging = false;

      if (this.body.selectionBox.show) {
        var _context14;

        this.body.selectionBox.show = false;
        var selectionBoxPosition = this.body.selectionBox.position;
        var selectionBoxPositionMinMax = {
          minX: Math.min(selectionBoxPosition.start.x, selectionBoxPosition.end.x),
          minY: Math.min(selectionBoxPosition.start.y, selectionBoxPosition.end.y),
          maxX: Math.max(selectionBoxPosition.start.x, selectionBoxPosition.end.x),
          maxY: Math.max(selectionBoxPosition.start.y, selectionBoxPosition.end.y)
        };

        var toBeSelectedNodes = filter(_context14 = this.body.nodeIndices).call(_context14, function (nodeId) {
          var node = _this3.body.nodes[nodeId];
          return node.x >= selectionBoxPositionMinMax.minX && node.x <= selectionBoxPositionMinMax.maxX && node.y >= selectionBoxPositionMinMax.minY && node.y <= selectionBoxPositionMinMax.maxY;
        });

        forEach$2(toBeSelectedNodes).call(toBeSelectedNodes, function (nodeId) {
          return _this3.selectionHandler.selectObject(_this3.body.nodes[nodeId]);
        });

        var pointer = this.getPointer(event.center);
        this.selectionHandler.commitAndEmit(pointer, event);
        this.selectionHandler.generateClickEvent("dragEnd", event, this.getPointer(event.center), undefined, true);
        this.body.emitter.emit("_requestRedraw");
      } else {
        var selection = this.drag.selection;

        if (selection && selection.length) {
          forEach$2(selection).call(selection, function (s) {
            // restore original xFixed and yFixed
            s.node.options.fixed.x = s.xFixed;
            s.node.options.fixed.y = s.yFixed;
          });

          this.selectionHandler.generateClickEvent("dragEnd", event, this.getPointer(event.center));
          this.body.emitter.emit("startSimulation");
        } else {
          this.selectionHandler.generateClickEvent("dragEnd", event, this.getPointer(event.center), undefined, true);
          this.body.emitter.emit("_requestRedraw");
        }
      }
    }
    /**
     * Handle pinch event
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "onPinch",
    value: function onPinch(event) {
      var pointer = this.getPointer(event.center);
      this.drag.pinched = true;

      if (this.pinch["scale"] === undefined) {
        this.pinch.scale = 1;
      } // TODO: enabled moving while pinching?


      var scale = this.pinch.scale * event.scale;
      this.zoom(scale, pointer);
    }
    /**
     * Zoom the network in or out
     *
     * @param {number} scale a number around 1, and between 0.01 and 10
     * @param {{x: number, y: number}} pointer    Position on screen
     * @private
     */

  }, {
    key: "zoom",
    value: function zoom(scale, pointer) {
      if (this.options.zoomView === true) {
        var scaleOld = this.body.view.scale;

        if (scale < 0.00001) {
          scale = 0.00001;
        }

        if (scale > 10) {
          scale = 10;
        }

        var preScaleDragPointer = undefined;

        if (this.drag !== undefined) {
          if (this.drag.dragging === true) {
            preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);
          }
        } // + this.canvas.frame.canvas.clientHeight / 2


        var translation = this.body.view.translation;
        var scaleFrac = scale / scaleOld;
        var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;
        var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;
        this.body.view.scale = scale;
        this.body.view.translation = {
          x: tx,
          y: ty
        };

        if (preScaleDragPointer != undefined) {
          var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);
          this.drag.pointer.x = postScaleDragPointer.x;
          this.drag.pointer.y = postScaleDragPointer.y;
        }

        this.body.emitter.emit("_requestRedraw");

        if (scaleOld < scale) {
          this.body.emitter.emit("zoom", {
            direction: "+",
            scale: this.body.view.scale,
            pointer: pointer
          });
        } else {
          this.body.emitter.emit("zoom", {
            direction: "-",
            scale: this.body.view.scale,
            pointer: pointer
          });
        }
      }
    }
    /**
     * Event handler for mouse wheel event, used to zoom the timeline
     * See http://adomas.org/javascript-mouse-wheel/
     *     https://github.com/EightMedia/hammer.js/issues/256
     *
     * @param {MouseEvent}  event
     * @private
     */

  }, {
    key: "onMouseWheel",
    value: function onMouseWheel(event) {
      if (this.options.zoomView === true) {
        // If delta is nonzero, handle it.
        // Basically, delta is now positive if wheel was scrolled up,
        // and negative, if wheel was scrolled down.
        if (event.deltaY !== 0) {
          // calculate the new scale
          var scale = this.body.view.scale;
          scale *= 1 + (event.deltaY < 0 ? 1 : -1) * (this.options.zoomSpeed * 0.1); // calculate the pointer location

          var pointer = this.getPointer({
            x: event.clientX,
            y: event.clientY
          }); // apply the new scale

          this.zoom(scale, pointer);
        } // Prevent default actions caused by mouse wheel.


        event.preventDefault();
      }
    }
    /**
     * Mouse move handler for checking whether the title moves over a node with a title.
     *
     * @param  {Event} event
     * @private
     */

  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      var _this4 = this;

      var pointer = this.getPointer({
        x: event.clientX,
        y: event.clientY
      });
      var popupVisible = false; // check if the previously selected node is still selected

      if (this.popup !== undefined) {
        if (this.popup.hidden === false) {
          this._checkHidePopup(pointer);
        } // if the popup was not hidden above


        if (this.popup.hidden === false) {
          popupVisible = true;
          this.popup.setPosition(pointer.x + 3, pointer.y - 5);
          this.popup.show();
        }
      } // if we bind the keyboard to the div, we have to highlight it to use it. This highlights it on mouse over.


      if (this.options.keyboard.autoFocus && this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {
        this.canvas.frame.focus();
      } // start a timeout that will check if the mouse is positioned above an element


      if (popupVisible === false) {
        if (this.popupTimer !== undefined) {
          clearInterval(this.popupTimer); // stop any running calculationTimer

          this.popupTimer = undefined;
        }

        if (!this.drag.dragging) {
          this.popupTimer = setTimeout$1(function () {
            return _this4._checkShowPopup(pointer);
          }, this.options.tooltipDelay);
        }
      } // adding hover highlights


      if (this.options.hover === true) {
        this.selectionHandler.hoverObject(event, pointer);
      }
    }
    /**
     * Check if there is an element on the given position in the network
     * (a node or edge). If so, and if this element has a title,
     * show a popup window with its title.
     *
     * @param {{x:number, y:number}} pointer
     * @private
     */

  }, {
    key: "_checkShowPopup",
    value: function _checkShowPopup(pointer) {
      var x = this.canvas._XconvertDOMtoCanvas(pointer.x);

      var y = this.canvas._YconvertDOMtoCanvas(pointer.y);

      var pointerObj = {
        left: x,
        top: y,
        right: x,
        bottom: y
      };
      var previousPopupObjId = this.popupObj === undefined ? undefined : this.popupObj.id;
      var nodeUnderCursor = false;
      var popupType = "node"; // check if a node is under the cursor.

      if (this.popupObj === undefined) {
        // search the nodes for overlap, select the top one in case of multiple nodes
        var nodeIndices = this.body.nodeIndices;
        var nodes = this.body.nodes;
        var node;
        var overlappingNodes = [];

        for (var i = 0; i < nodeIndices.length; i++) {
          node = nodes[nodeIndices[i]];

          if (node.isOverlappingWith(pointerObj) === true) {
            nodeUnderCursor = true;

            if (node.getTitle() !== undefined) {
              overlappingNodes.push(nodeIndices[i]);
            }
          }
        }

        if (overlappingNodes.length > 0) {
          // if there are overlapping nodes, select the last one, this is the one which is drawn on top of the others
          this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]]; // if you hover over a node, the title of the edge is not supposed to be shown.

          nodeUnderCursor = true;
        }
      }

      if (this.popupObj === undefined && nodeUnderCursor === false) {
        // search the edges for overlap
        var edgeIndices = this.body.edgeIndices;
        var edges = this.body.edges;
        var edge;
        var overlappingEdges = [];

        for (var _i = 0; _i < edgeIndices.length; _i++) {
          edge = edges[edgeIndices[_i]];

          if (edge.isOverlappingWith(pointerObj) === true) {
            if (edge.connected === true && edge.getTitle() !== undefined) {
              overlappingEdges.push(edgeIndices[_i]);
            }
          }
        }

        if (overlappingEdges.length > 0) {
          this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];
          popupType = "edge";
        }
      }

      if (this.popupObj !== undefined) {
        // show popup message window
        if (this.popupObj.id !== previousPopupObjId) {
          if (this.popup === undefined) {
            this.popup = new Popup(this.canvas.frame);
          }

          this.popup.popupTargetType = popupType;
          this.popup.popupTargetId = this.popupObj.id; // adjust a small offset such that the mouse cursor is located in the
          // bottom left location of the popup, and you can easily move over the
          // popup area

          this.popup.setPosition(pointer.x + 3, pointer.y - 5);
          this.popup.setText(this.popupObj.getTitle());
          this.popup.show();
          this.body.emitter.emit("showPopup", this.popupObj.id);
        }
      } else {
        if (this.popup !== undefined) {
          this.popup.hide();
          this.body.emitter.emit("hidePopup");
        }
      }
    }
    /**
     * Check if the popup must be hidden, which is the case when the mouse is no
     * longer hovering on the object
     *
     * @param {{x:number, y:number}} pointer
     * @private
     */

  }, {
    key: "_checkHidePopup",
    value: function _checkHidePopup(pointer) {
      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

      var stillOnObj = false;

      if (this.popup.popupTargetType === "node") {
        if (this.body.nodes[this.popup.popupTargetId] !== undefined) {
          stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj); // if the mouse is still one the node, we have to check if it is not also on one that is drawn on top of it.
          // we initially only check stillOnObj because this is much faster.

          if (stillOnObj === true) {
            var overNode = this.selectionHandler.getNodeAt(pointer);
            stillOnObj = overNode === undefined ? false : overNode.id === this.popup.popupTargetId;
          }
        }
      } else {
        if (this.selectionHandler.getNodeAt(pointer) === undefined) {
          if (this.body.edges[this.popup.popupTargetId] !== undefined) {
            stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);
          }
        }
      }

      if (stillOnObj === false) {
        this.popupObj = undefined;
        this.popup.hide();
        this.body.emitter.emit("hidePopup");
      }
    }
  }]);

  return InteractionHandler;
}();

var uncurryThis$1 = functionUncurryThis;
var redefineAll$1 = redefineAll$3;
var getWeakData = internalMetadata.exports.getWeakData;
var anObject = anObject$d;
var isObject$1 = isObject$j;
var anInstance = anInstance$3;
var iterate = iterate$3;
var ArrayIterationModule = arrayIteration;
var hasOwn = hasOwnProperty_1;
var InternalStateModule = internalState;
var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var splice = uncurryThis$1([].splice);
var id = 0; // fallback for uncaught frozen keys

var uncaughtFrozenStore = function (store) {
  return store.frozen || (store.frozen = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.entries = [];
};

var findUncaughtFrozen = function (store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.entries.push([key, value]);
  },
  'delete': function (key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) splice(this.entries, index, 1);
    return !!~index;
  }
};
var collectionWeak$1 = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: undefined
      });
      if (iterable != undefined) iterate(iterable, that[ADDER], {
        that: that,
        AS_ENTRIES: IS_MAP
      });
    });
    var Prototype = Constructor.prototype;
    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);else data[state.id] = value;
      return that;
    };

    redefineAll$1(Prototype, {
      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
      'delete': function (key) {
        var state = getInternalState(this);
        if (!isObject$1(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && hasOwn(data, state.id) && delete data[state.id];
      },
      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject$1(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && hasOwn(data, state.id);
      }
    });
    redefineAll$1(Prototype, IS_MAP ? {
      // `WeakMap.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
      get: function get(key) {
        var state = getInternalState(this);

        if (isObject$1(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          return data ? data[state.id] : undefined;
        }
      },
      // `WeakMap.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // `WeakSet.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-weakset.prototype.add
      add: function add(value) {
        return define(this, value, true);
      }
    });
    return Constructor;
  }
};

var global$1 = global$P;
var uncurryThis = functionUncurryThis;
var redefineAll = redefineAll$3;
var InternalMetadataModule = internalMetadata.exports;
var collection = collection$3;
var collectionWeak = collectionWeak$1;
var isObject = isObject$j;
var isExtensible = objectIsExtensible;
var enforceInternalState = internalState.enforce;
var NATIVE_WEAK_MAP = nativeWeakMap;
var IS_IE11 = !global$1.ActiveXObject && 'ActiveXObject' in global$1;
var InternalWeakMap;

var wrapper = function (init) {
  return function WeakMap() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}; // `WeakMap` constructor
// https://tc39.es/ecma262/#sec-weakmap-constructor


var $WeakMap = collection('WeakMap', wrapper, collectionWeak); // IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485

if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
  InternalMetadataModule.enable();
  var WeakMapPrototype = $WeakMap.prototype;
  var nativeDelete = uncurryThis(WeakMapPrototype['delete']);
  var nativeHas = uncurryThis(WeakMapPrototype.has);
  var nativeGet = uncurryThis(WeakMapPrototype.get);
  var nativeSet = uncurryThis(WeakMapPrototype.set);
  redefineAll(WeakMapPrototype, {
    'delete': function (key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeDelete(this, key) || state.frozen['delete'](key);
      }

      return nativeDelete(this, key);
    },
    has: function has(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) || state.frozen.has(key);
      }

      return nativeHas(this, key);
    },
    get: function get(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
      }

      return nativeGet(this, key);
    },
    set: function set(key, value) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
      } else nativeSet(this, key, value);

      return this;
    }
  });
}

var path = path$y;
var weakMap$2 = path.WeakMap;

var parent$1 = weakMap$2;
var weakMap$1 = parent$1;

var weakMap = weakMap$1;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}

function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$3(o, minLen) { var _context2; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = slice(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _SingleTypeSelectionAccumulator_previousSelection, _SingleTypeSelectionAccumulator_selection, _SelectionAccumulator_nodes, _SelectionAccumulator_edges, _SelectionAccumulator_commitHandler;
/**
 * @param prev
 * @param next
 */

function diffSets(prev, next) {
  var diff = new set();

  var _iterator = _createForOfIteratorHelper$3(next),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;

      if (!prev.has(item)) {
        diff.add(item);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return diff;
}

var SingleTypeSelectionAccumulator = /*#__PURE__*/function () {
  function SingleTypeSelectionAccumulator() {
    _classCallCheck(this, SingleTypeSelectionAccumulator);

    _SingleTypeSelectionAccumulator_previousSelection.set(this, new set());

    _SingleTypeSelectionAccumulator_selection.set(this, new set());
  }

  _createClass(SingleTypeSelectionAccumulator, [{
    key: "size",
    get: function get() {
      return __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").size;
    }
  }, {
    key: "add",
    value: function add() {
      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
        items[_key] = arguments[_key];
      }

      for (var _i = 0, _items = items; _i < _items.length; _i++) {
        var item = _items[_i];

        __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").add(item);
      }
    }
  }, {
    key: "delete",
    value: function _delete() {
      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }

      for (var _i2 = 0, _items2 = items; _i2 < _items2.length; _i2++) {
        var item = _items2[_i2];

        __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").delete(item);
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").clear();
    }
  }, {
    key: "getSelection",
    value: function getSelection() {
      return _toConsumableArray(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"));
    }
  }, {
    key: "getChanges",
    value: function getChanges() {
      return {
        added: _toConsumableArray(diffSets(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f"), __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"))),
        deleted: _toConsumableArray(diffSets(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"), __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f"))),
        previous: _toConsumableArray(new set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f"))),
        current: _toConsumableArray(new set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f")))
      };
    }
  }, {
    key: "commit",
    value: function commit() {
      var changes = this.getChanges();

      __classPrivateFieldSet(this, _SingleTypeSelectionAccumulator_previousSelection, __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"), "f");

      __classPrivateFieldSet(this, _SingleTypeSelectionAccumulator_selection, new set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f")), "f");

      var _iterator2 = _createForOfIteratorHelper$3(changes.added),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var item = _step2.value;
          item.select();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var _iterator3 = _createForOfIteratorHelper$3(changes.deleted),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _item = _step3.value;

          _item.unselect();
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return changes;
    }
  }]);

  return SingleTypeSelectionAccumulator;
}();

_SingleTypeSelectionAccumulator_previousSelection = new weakMap(), _SingleTypeSelectionAccumulator_selection = new weakMap();
var SelectionAccumulator = /*#__PURE__*/function () {
  function SelectionAccumulator() {
    var commitHandler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

    _classCallCheck(this, SelectionAccumulator);

    _SelectionAccumulator_nodes.set(this, new SingleTypeSelectionAccumulator());

    _SelectionAccumulator_edges.set(this, new SingleTypeSelectionAccumulator());

    _SelectionAccumulator_commitHandler.set(this, void 0);

    __classPrivateFieldSet(this, _SelectionAccumulator_commitHandler, commitHandler, "f");
  }

  _createClass(SelectionAccumulator, [{
    key: "sizeNodes",
    get: function get() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").size;
    }
  }, {
    key: "sizeEdges",
    get: function get() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").size;
    }
  }, {
    key: "getNodes",
    value: function getNodes() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").getSelection();
    }
  }, {
    key: "getEdges",
    value: function getEdges() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").getSelection();
    }
  }, {
    key: "addNodes",
    value: function addNodes() {
      var _classPrivateFieldGe;

      (_classPrivateFieldGe = __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f")).add.apply(_classPrivateFieldGe, arguments);
    }
  }, {
    key: "addEdges",
    value: function addEdges() {
      var _classPrivateFieldGe2;

      (_classPrivateFieldGe2 = __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f")).add.apply(_classPrivateFieldGe2, arguments);
    }
  }, {
    key: "deleteNodes",
    value: function deleteNodes(node) {
      __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").delete(node);
    }
  }, {
    key: "deleteEdges",
    value: function deleteEdges(edge) {
      __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").delete(edge);
    }
  }, {
    key: "clear",
    value: function clear() {
      __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").clear();

      __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").clear();
    }
  }, {
    key: "commit",
    value: function commit() {
      var _classPrivateFieldGe3, _context;

      var summary = {
        nodes: __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").commit(),
        edges: __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").commit()
      };

      for (var _len3 = arguments.length, rest = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        rest[_key3] = arguments[_key3];
      }

      (_classPrivateFieldGe3 = __classPrivateFieldGet(this, _SelectionAccumulator_commitHandler, "f")).call.apply(_classPrivateFieldGe3, concat(_context = [this, summary]).call(_context, rest));

      return summary;
    }
  }]);

  return SelectionAccumulator;
}();
_SelectionAccumulator_nodes = new weakMap(), _SelectionAccumulator_edges = new weakMap(), _SelectionAccumulator_commitHandler = new weakMap();

function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$2(o, minLen) { var _context3; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = slice(_context3 = Object.prototype.toString.call(o)).call(_context3, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * The handler for selections
 */

var SelectionHandler = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   */
  function SelectionHandler(body, canvas) {
    var _this = this;

    _classCallCheck(this, SelectionHandler);

    this.body = body;
    this.canvas = canvas; // TODO: Consider firing an event on any change to the selection, not
    // only those caused by clicks and taps. It would be easy to implement
    // now and (at least to me) it seems like something that could be
    // quite useful.

    this._selectionAccumulator = new SelectionAccumulator();
    this.hoverObj = {
      nodes: {},
      edges: {}
    };
    this.options = {};
    this.defaultOptions = {
      multiselect: false,
      selectable: true,
      selectConnectedEdges: true,
      hoverConnectedEdges: true
    };

    assign$2(this.options, this.defaultOptions);

    this.body.emitter.on("_dataChanged", function () {
      _this.updateSelection();
    });
  }
  /**
   *
   * @param {object} [options]
   */


  _createClass(SelectionHandler, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        var fields = ["multiselect", "hoverConnectedEdges", "selectable", "selectConnectedEdges"];
        selectiveDeepExtend(fields, this.options, options);
      }
    }
    /**
     * handles the selection part of the tap;
     *
     * @param {{x: number, y: number}} pointer
     * @returns {boolean}
     */

  }, {
    key: "selectOnPoint",
    value: function selectOnPoint(pointer) {
      var selected = false;

      if (this.options.selectable === true) {
        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer); // unselect after getting the objects in order to restore width and height.

        this.unselectAll();

        if (obj !== undefined) {
          selected = this.selectObject(obj);
        }

        this.body.emitter.emit("_requestRedraw");
      }

      return selected;
    }
    /**
     *
     * @param {{x: number, y: number}} pointer
     * @returns {boolean}
     */

  }, {
    key: "selectAdditionalOnPoint",
    value: function selectAdditionalOnPoint(pointer) {
      var selectionChanged = false;

      if (this.options.selectable === true) {
        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);

        if (obj !== undefined) {
          selectionChanged = true;

          if (obj.isSelected() === true) {
            this.deselectObject(obj);
          } else {
            this.selectObject(obj);
          }

          this.body.emitter.emit("_requestRedraw");
        }
      }

      return selectionChanged;
    }
    /**
     * Create an object containing the standard fields for an event.
     *
     * @param {Event} event
     * @param {{x: number, y: number}} pointer Object with the x and y screen coordinates of the mouse
     * @returns {{}}
     * @private
     */

  }, {
    key: "_initBaseEvent",
    value: function _initBaseEvent(event, pointer) {
      var properties = {};
      properties["pointer"] = {
        DOM: {
          x: pointer.x,
          y: pointer.y
        },
        canvas: this.canvas.DOMtoCanvas(pointer)
      };
      properties["event"] = event;
      return properties;
    }
    /**
     * Generate an event which the user can catch.
     *
     * This adds some extra data to the event with respect to cursor position and
     * selected nodes and edges.
     *
     * @param {string} eventType                          Name of event to send
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer            Object with the x and y screen coordinates of the mouse
     * @param {object | undefined} oldSelection             If present, selection state before event occured
     * @param {boolean|undefined} [emptySelection=false]  Indicate if selection data should be passed
     */

  }, {
    key: "generateClickEvent",
    value: function generateClickEvent(eventType, event, pointer, oldSelection) {
      var emptySelection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      var properties = this._initBaseEvent(event, pointer);

      if (emptySelection === true) {
        properties.nodes = [];
        properties.edges = [];
      } else {
        var tmp = this.getSelection();
        properties.nodes = tmp.nodes;
        properties.edges = tmp.edges;
      }

      if (oldSelection !== undefined) {
        properties["previousSelection"] = oldSelection;
      }

      if (eventType == "click") {
        // For the time being, restrict this functionality to
        // just the click event.
        properties.items = this.getClickedItems(pointer);
      }

      if (event.controlEdge !== undefined) {
        properties.controlEdge = event.controlEdge;
      }

      this.body.emitter.emit(eventType, properties);
    }
    /**
     *
     * @param {object} obj
     * @param {boolean} [highlightEdges=this.options.selectConnectedEdges]
     * @returns {boolean}
     */

  }, {
    key: "selectObject",
    value: function selectObject(obj) {
      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.selectConnectedEdges;

      if (obj !== undefined) {
        if (obj instanceof Node) {
          if (highlightEdges === true) {
            var _this$_selectionAccum;

            (_this$_selectionAccum = this._selectionAccumulator).addEdges.apply(_this$_selectionAccum, _toConsumableArray(obj.edges));
          }

          this._selectionAccumulator.addNodes(obj);
        } else {
          this._selectionAccumulator.addEdges(obj);
        }

        return true;
      }

      return false;
    }
    /**
     *
     * @param {object} obj
     */

  }, {
    key: "deselectObject",
    value: function deselectObject(obj) {
      if (obj.isSelected() === true) {
        obj.selected = false;

        this._removeFromSelection(obj);
      }
    }
    /**
     * retrieve all nodes overlapping with given object
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @returns {number[]}   An array with id's of the overlapping nodes
     * @private
     */

  }, {
    key: "_getAllNodesOverlappingWith",
    value: function _getAllNodesOverlappingWith(object) {
      var overlappingNodes = [];
      var nodes = this.body.nodes;

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var nodeId = this.body.nodeIndices[i];

        if (nodes[nodeId].isOverlappingWith(object)) {
          overlappingNodes.push(nodeId);
        }
      }

      return overlappingNodes;
    }
    /**
     * Return a position object in canvasspace from a single point in screenspace
     *
     * @param {{x: number, y: number}} pointer
     * @returns {{left: number, top: number, right: number, bottom: number}}
     * @private
     */

  }, {
    key: "_pointerToPositionObject",
    value: function _pointerToPositionObject(pointer) {
      var canvasPos = this.canvas.DOMtoCanvas(pointer);
      return {
        left: canvasPos.x - 1,
        top: canvasPos.y + 1,
        right: canvasPos.x + 1,
        bottom: canvasPos.y - 1
      };
    }
    /**
     * Get the top node at the passed point (like a click)
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [returnNode=true]
     * @returns {Node | undefined} node
     */

  }, {
    key: "getNodeAt",
    value: function getNodeAt(pointer) {
      var returnNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      // we first check if this is an navigation controls element
      var positionObject = this._pointerToPositionObject(pointer);

      var overlappingNodes = this._getAllNodesOverlappingWith(positionObject); // if there are overlapping nodes, select the last one, this is the
      // one which is drawn on top of the others


      if (overlappingNodes.length > 0) {
        if (returnNode === true) {
          return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];
        } else {
          return overlappingNodes[overlappingNodes.length - 1];
        }
      } else {
        return undefined;
      }
    }
    /**
     * retrieve all edges overlapping with given object, selector is around center
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @param {number[]} overlappingEdges An array with id's of the overlapping nodes
     * @private
     */

  }, {
    key: "_getEdgesOverlappingWith",
    value: function _getEdgesOverlappingWith(object, overlappingEdges) {
      var edges = this.body.edges;

      for (var i = 0; i < this.body.edgeIndices.length; i++) {
        var edgeId = this.body.edgeIndices[i];

        if (edges[edgeId].isOverlappingWith(object)) {
          overlappingEdges.push(edgeId);
        }
      }
    }
    /**
     * retrieve all nodes overlapping with given object
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @returns {number[]}   An array with id's of the overlapping nodes
     * @private
     */

  }, {
    key: "_getAllEdgesOverlappingWith",
    value: function _getAllEdgesOverlappingWith(object) {
      var overlappingEdges = [];

      this._getEdgesOverlappingWith(object, overlappingEdges);

      return overlappingEdges;
    }
    /**
     * Get the edges nearest to the passed point (like a click)
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [returnEdge=true]
     * @returns {Edge | undefined} node
     */

  }, {
    key: "getEdgeAt",
    value: function getEdgeAt(pointer) {
      var returnEdge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      // Iterate over edges, pick closest within 10
      var canvasPos = this.canvas.DOMtoCanvas(pointer);
      var mindist = 10;
      var overlappingEdge = null;
      var edges = this.body.edges;

      for (var i = 0; i < this.body.edgeIndices.length; i++) {
        var edgeId = this.body.edgeIndices[i];
        var edge = edges[edgeId];

        if (edge.connected) {
          var xFrom = edge.from.x;
          var yFrom = edge.from.y;
          var xTo = edge.to.x;
          var yTo = edge.to.y;
          var dist = edge.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, canvasPos.x, canvasPos.y);

          if (dist < mindist) {
            overlappingEdge = edgeId;
            mindist = dist;
          }
        }
      }

      if (overlappingEdge !== null) {
        if (returnEdge === true) {
          return this.body.edges[overlappingEdge];
        } else {
          return overlappingEdge;
        }
      } else {
        return undefined;
      }
    }
    /**
     * Add object to the selection array.
     *
     * @param {object} obj
     * @private
     */

  }, {
    key: "_addToHover",
    value: function _addToHover(obj) {
      if (obj instanceof Node) {
        this.hoverObj.nodes[obj.id] = obj;
      } else {
        this.hoverObj.edges[obj.id] = obj;
      }
    }
    /**
     * Remove a single option from selection.
     *
     * @param {object} obj
     * @private
     */

  }, {
    key: "_removeFromSelection",
    value: function _removeFromSelection(obj) {
      if (obj instanceof Node) {
        var _this$_selectionAccum2;

        this._selectionAccumulator.deleteNodes(obj);

        (_this$_selectionAccum2 = this._selectionAccumulator).deleteEdges.apply(_this$_selectionAccum2, _toConsumableArray(obj.edges));
      } else {
        this._selectionAccumulator.deleteEdges(obj);
      }
    }
    /**
     * Unselect all nodes and edges.
     */

  }, {
    key: "unselectAll",
    value: function unselectAll() {
      this._selectionAccumulator.clear();
    }
    /**
     * return the number of selected nodes
     *
     * @returns {number}
     */

  }, {
    key: "getSelectedNodeCount",
    value: function getSelectedNodeCount() {
      return this._selectionAccumulator.sizeNodes;
    }
    /**
     * return the number of selected edges
     *
     * @returns {number}
     */

  }, {
    key: "getSelectedEdgeCount",
    value: function getSelectedEdgeCount() {
      return this._selectionAccumulator.sizeEdges;
    }
    /**
     * select the edges connected to the node that is being selected
     *
     * @param {Node} node
     * @private
     */

  }, {
    key: "_hoverConnectedEdges",
    value: function _hoverConnectedEdges(node) {
      for (var i = 0; i < node.edges.length; i++) {
        var edge = node.edges[i];
        edge.hover = true;

        this._addToHover(edge);
      }
    }
    /**
     * Remove the highlight from a node or edge, in response to mouse movement
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
     * @param {Node|vis.Edge} object
     * @private
     */

  }, {
    key: "emitBlurEvent",
    value: function emitBlurEvent(event, pointer, object) {
      var properties = this._initBaseEvent(event, pointer);

      if (object.hover === true) {
        object.hover = false;

        if (object instanceof Node) {
          properties.node = object.id;
          this.body.emitter.emit("blurNode", properties);
        } else {
          properties.edge = object.id;
          this.body.emitter.emit("blurEdge", properties);
        }
      }
    }
    /**
     * Create the highlight for a node or edge, in response to mouse movement
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
     * @param {Node|vis.Edge} object
     * @returns {boolean} hoverChanged
     * @private
     */

  }, {
    key: "emitHoverEvent",
    value: function emitHoverEvent(event, pointer, object) {
      var properties = this._initBaseEvent(event, pointer);

      var hoverChanged = false;

      if (object.hover === false) {
        object.hover = true;

        this._addToHover(object);

        hoverChanged = true;

        if (object instanceof Node) {
          properties.node = object.id;
          this.body.emitter.emit("hoverNode", properties);
        } else {
          properties.edge = object.id;
          this.body.emitter.emit("hoverEdge", properties);
        }
      }

      return hoverChanged;
    }
    /**
     * Perform actions in response to a mouse movement.
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer | object with the x and y screen coordinates of the mouse
     */

  }, {
    key: "hoverObject",
    value: function hoverObject(event, pointer) {
      var object = this.getNodeAt(pointer);

      if (object === undefined) {
        object = this.getEdgeAt(pointer);
      }

      var hoverChanged = false; // remove all node hover highlights

      for (var nodeId in this.hoverObj.nodes) {
        if (Object.prototype.hasOwnProperty.call(this.hoverObj.nodes, nodeId)) {
          if (object === undefined || object instanceof Node && object.id != nodeId || object instanceof Edge) {
            this.emitBlurEvent(event, pointer, this.hoverObj.nodes[nodeId]);
            delete this.hoverObj.nodes[nodeId];
            hoverChanged = true;
          }
        }
      } // removing all edge hover highlights


      for (var edgeId in this.hoverObj.edges) {
        if (Object.prototype.hasOwnProperty.call(this.hoverObj.edges, edgeId)) {
          // if the hover has been changed here it means that the node has been hovered over or off
          // we then do not use the emitBlurEvent method here.
          if (hoverChanged === true) {
            this.hoverObj.edges[edgeId].hover = false;
            delete this.hoverObj.edges[edgeId];
          } // if the blur remains the same and the object is undefined (mouse off) or another
          // edge has been hovered, or another node has been hovered we blur the edge.
          else if (object === undefined || object instanceof Edge && object.id != edgeId || object instanceof Node && !object.hover) {
            this.emitBlurEvent(event, pointer, this.hoverObj.edges[edgeId]);
            delete this.hoverObj.edges[edgeId];
            hoverChanged = true;
          }
        }
      }

      if (object !== undefined) {
        var hoveredEdgesCount = keys$4(this.hoverObj.edges).length;

        var hoveredNodesCount = keys$4(this.hoverObj.nodes).length;

        var newOnlyHoveredEdge = object instanceof Edge && hoveredEdgesCount === 0 && hoveredNodesCount === 0;
        var newOnlyHoveredNode = object instanceof Node && hoveredEdgesCount === 0 && hoveredNodesCount === 0;

        if (hoverChanged || newOnlyHoveredEdge || newOnlyHoveredNode) {
          hoverChanged = this.emitHoverEvent(event, pointer, object);
        }

        if (object instanceof Node && this.options.hoverConnectedEdges === true) {
          this._hoverConnectedEdges(object);
        }
      }

      if (hoverChanged === true) {
        this.body.emitter.emit("_requestRedraw");
      }
    }
    /**
     * Commit the selection changes but don't emit any events.
     */

  }, {
    key: "commitWithoutEmitting",
    value: function commitWithoutEmitting() {
      this._selectionAccumulator.commit();
    }
    /**
     * Select and deselect nodes depending current selection change.
     *
     * For changing nodes, select/deselect events are fired.
     *
     * NOTE: For a given edge, if one connecting node is deselected and with the
     * same click the other node is selected, no events for the edge will fire. It
     * was selected and it will remain selected.
     *
     * @param {{x: number, y: number}} pointer - The x and y coordinates of the
     * click, tap, dragend… that triggered this.
     * @param {UIEvent} event - The event that triggered this.
     */

  }, {
    key: "commitAndEmit",
    value: function commitAndEmit(pointer, event) {
      var selected = false;

      var selectionChanges = this._selectionAccumulator.commit();

      var previousSelection = {
        nodes: selectionChanges.nodes.previous,
        edges: selectionChanges.edges.previous
      };

      if (selectionChanges.edges.deleted.length > 0) {
        this.generateClickEvent("deselectEdge", event, pointer, previousSelection);
        selected = true;
      }

      if (selectionChanges.nodes.deleted.length > 0) {
        this.generateClickEvent("deselectNode", event, pointer, previousSelection);
        selected = true;
      }

      if (selectionChanges.nodes.added.length > 0) {
        this.generateClickEvent("selectNode", event, pointer);
        selected = true;
      }

      if (selectionChanges.edges.added.length > 0) {
        this.generateClickEvent("selectEdge", event, pointer);
        selected = true;
      } // fire the select event if anything has been selected or deselected


      if (selected === true) {
        // select or unselect
        this.generateClickEvent("select", event, pointer);
      }
    }
    /**
     * Retrieve the currently selected node and edge ids.
     *
     * @returns {{nodes: Array.<string>, edges: Array.<string>}} Arrays with the
     * ids of the selected nodes and edges.
     */

  }, {
    key: "getSelection",
    value: function getSelection() {
      return {
        nodes: this.getSelectedNodeIds(),
        edges: this.getSelectedEdgeIds()
      };
    }
    /**
     * Retrieve the currently selected nodes.
     *
     * @returns {Array} An array with selected nodes.
     */

  }, {
    key: "getSelectedNodes",
    value: function getSelectedNodes() {
      return this._selectionAccumulator.getNodes();
    }
    /**
     * Retrieve the currently selected edges.
     *
     * @returns {Array} An array with selected edges.
     */

  }, {
    key: "getSelectedEdges",
    value: function getSelectedEdges() {
      return this._selectionAccumulator.getEdges();
    }
    /**
     * Retrieve the currently selected node ids.
     *
     * @returns {Array} An array with the ids of the selected nodes.
     */

  }, {
    key: "getSelectedNodeIds",
    value: function getSelectedNodeIds() {
      var _context;

      return map$3(_context = this._selectionAccumulator.getNodes()).call(_context, function (node) {
        return node.id;
      });
    }
    /**
     * Retrieve the currently selected edge ids.
     *
     * @returns {Array} An array with the ids of the selected edges.
     */

  }, {
    key: "getSelectedEdgeIds",
    value: function getSelectedEdgeIds() {
      var _context2;

      return map$3(_context2 = this._selectionAccumulator.getEdges()).call(_context2, function (edge) {
        return edge.id;
      });
    }
    /**
     * Updates the current selection
     *
     * @param {{nodes: Array.<string>, edges: Array.<string>}} selection
     * @param {object} options                                 Options
     */

  }, {
    key: "setSelection",
    value: function setSelection(selection) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!selection || !selection.nodes && !selection.edges) {
        throw new TypeError("Selection must be an object with nodes and/or edges properties");
      } // first unselect any selected node, if option is true or undefined


      if (options.unselectAll || options.unselectAll === undefined) {
        this.unselectAll();
      }

      if (selection.nodes) {
        var _iterator = _createForOfIteratorHelper$2(selection.nodes),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var id = _step.value;
            var node = this.body.nodes[id];

            if (!node) {
              throw new RangeError('Node with id "' + id + '" not found');
            } // don't select edges with it


            this.selectObject(node, options.highlightEdges);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      if (selection.edges) {
        var _iterator2 = _createForOfIteratorHelper$2(selection.edges),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _id = _step2.value;
            var edge = this.body.edges[_id];

            if (!edge) {
              throw new RangeError('Edge with id "' + _id + '" not found');
            }

            this.selectObject(edge);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      this.body.emitter.emit("_requestRedraw");

      this._selectionAccumulator.commit();
    }
    /**
     * select zero or more nodes with the option to highlight edges
     *
     * @param {number[] | string[]} selection     An array with the ids of the
     *                                            selected nodes.
     * @param {boolean} [highlightEdges]
     */

  }, {
    key: "selectNodes",
    value: function selectNodes(selection) {
      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (!selection || selection.length === undefined) throw "Selection must be an array with ids";
      this.setSelection({
        nodes: selection
      }, {
        highlightEdges: highlightEdges
      });
    }
    /**
     * select zero or more edges
     *
     * @param {number[] | string[]} selection     An array with the ids of the
     *                                            selected nodes.
     */

  }, {
    key: "selectEdges",
    value: function selectEdges(selection) {
      if (!selection || selection.length === undefined) throw "Selection must be an array with ids";
      this.setSelection({
        edges: selection
      });
    }
    /**
     * Validate the selection: remove ids of nodes which no longer exist
     *
     * @private
     */

  }, {
    key: "updateSelection",
    value: function updateSelection() {
      for (var node in this._selectionAccumulator.getNodes()) {
        if (!Object.prototype.hasOwnProperty.call(this.body.nodes, node.id)) {
          this._selectionAccumulator.deleteNodes(node);
        }
      }

      for (var edge in this._selectionAccumulator.getEdges()) {
        if (!Object.prototype.hasOwnProperty.call(this.body.edges, edge.id)) {
          this._selectionAccumulator.deleteEdges(edge);
        }
      }
    }
    /**
     * Determine all the visual elements clicked which are on the given point.
     *
     * All elements are returned; this includes nodes, edges and their labels.
     * The order returned is from highest to lowest, i.e. element 0 of the return
     * value is the topmost item clicked on.
     *
     * The return value consists of an array of the following possible elements:
     *
     * - `{nodeId:number}`             - node with given id clicked on
     * - `{nodeId:number, labelId:0}`  - label of node with given id clicked on
     * - `{edgeId:number}`             - edge with given id clicked on
     * - `{edge:number, labelId:0}`    - label of edge with given id clicked on
     *
     * ## NOTES
     *
     * - Currently, there is only one label associated with a node or an edge,
     *   but this is expected to change somewhere in the future.
     * - Since there is no z-indexing yet, it is not really possible to set the nodes and
     *   edges in the correct order. For the time being, nodes come first.
     *
     * @param {point} pointer  mouse position in screen coordinates
     * @returns {Array.<nodeClickItem|nodeLabelClickItem|edgeClickItem|edgeLabelClickItem>}
     * @private
     */

  }, {
    key: "getClickedItems",
    value: function getClickedItems(pointer) {
      var point = this.canvas.DOMtoCanvas(pointer);
      var items = []; // Note reverse order; we want the topmost clicked items to be first in the array
      // Also note that selected nodes are disregarded here; these normally display on top

      var nodeIndices = this.body.nodeIndices;
      var nodes = this.body.nodes;

      for (var i = nodeIndices.length - 1; i >= 0; i--) {
        var node = nodes[nodeIndices[i]];
        var ret = node.getItemsOnPoint(point);
        items.push.apply(items, ret); // Append the return value to the running list.
      }

      var edgeIndices = this.body.edgeIndices;
      var edges = this.body.edges;

      for (var _i = edgeIndices.length - 1; _i >= 0; _i--) {
        var edge = edges[edgeIndices[_i]];

        var _ret = edge.getItemsOnPoint(point);

        items.push.apply(items, _ret); // Append the return value to the running list.
      }

      return items;
    }
  }]);

  return SelectionHandler;
}();

var timsort$1 = {};

/****
 * The MIT License
 *
 * Copyright (c) 2015 Marco Ziccardi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 ****/

(function (exports) {
  (function (global, factory) {
    {
      factory(exports);
    }
  })(commonjsGlobal, function (exports) {

    exports.__esModule = true;
    exports.sort = sort;

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }

    var DEFAULT_MIN_MERGE = 32;
    var DEFAULT_MIN_GALLOPING = 7;
    var DEFAULT_TMP_STORAGE_LENGTH = 256;
    var POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];

    function log10(x) {
      if (x < 1e5) {
        if (x < 1e2) {
          return x < 1e1 ? 0 : 1;
        }

        if (x < 1e4) {
          return x < 1e3 ? 2 : 3;
        }

        return 4;
      }

      if (x < 1e7) {
        return x < 1e6 ? 5 : 6;
      }

      if (x < 1e9) {
        return x < 1e8 ? 7 : 8;
      }

      return 9;
    }

    function alphabeticalCompare(a, b) {
      if (a === b) {
        return 0;
      }

      if (~~a === a && ~~b === b) {
        if (a === 0 || b === 0) {
          return a < b ? -1 : 1;
        }

        if (a < 0 || b < 0) {
          if (b >= 0) {
            return -1;
          }

          if (a >= 0) {
            return 1;
          }

          a = -a;
          b = -b;
        }

        var al = log10(a);
        var bl = log10(b);
        var t = 0;

        if (al < bl) {
          a *= POWERS_OF_TEN[bl - al - 1];
          b /= 10;
          t = -1;
        } else if (al > bl) {
          b *= POWERS_OF_TEN[al - bl - 1];
          a /= 10;
          t = 1;
        }

        if (a === b) {
          return t;
        }

        return a < b ? -1 : 1;
      }

      var aStr = String(a);
      var bStr = String(b);

      if (aStr === bStr) {
        return 0;
      }

      return aStr < bStr ? -1 : 1;
    }

    function minRunLength(n) {
      var r = 0;

      while (n >= DEFAULT_MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
      }

      return n + r;
    }

    function makeAscendingRun(array, lo, hi, compare) {
      var runHi = lo + 1;

      if (runHi === hi) {
        return 1;
      }

      if (compare(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
          runHi++;
        }

        reverseRun(array, lo, runHi);
      } else {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
          runHi++;
        }
      }

      return runHi - lo;
    }

    function reverseRun(array, lo, hi) {
      hi--;

      while (lo < hi) {
        var t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
      }
    }

    function binaryInsertionSort(array, lo, hi, start, compare) {
      if (start === lo) {
        start++;
      }

      for (; start < hi; start++) {
        var pivot = array[start];
        var left = lo;
        var right = start;

        while (left < right) {
          var mid = left + right >>> 1;

          if (compare(pivot, array[mid]) < 0) {
            right = mid;
          } else {
            left = mid + 1;
          }
        }

        var n = start - left;

        switch (n) {
          case 3:
            array[left + 3] = array[left + 2];

          case 2:
            array[left + 2] = array[left + 1];

          case 1:
            array[left + 1] = array[left];
            break;

          default:
            while (n > 0) {
              array[left + n] = array[left + n - 1];
              n--;
            }

        }

        array[left] = pivot;
      }
    }

    function gallopLeft(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;

      if (compare(value, array[start + hint]) > 0) {
        maxOffset = length - hint;

        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        lastOffset += hint;
        offset += hint;
      } else {
        maxOffset = hint + 1;

        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      }

      lastOffset++;

      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);

        if (compare(value, array[start + m]) > 0) {
          lastOffset = m + 1;
        } else {
          offset = m;
        }
      }

      return offset;
    }

    function gallopRight(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;

      if (compare(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;

        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      } else {
        maxOffset = length - hint;

        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        lastOffset += hint;
        offset += hint;
      }

      lastOffset++;

      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);

        if (compare(value, array[start + m]) < 0) {
          offset = m;
        } else {
          lastOffset = m + 1;
        }
      }

      return offset;
    }

    var TimSort = function () {
      function TimSort(array, compare) {
        _classCallCheck(this, TimSort);

        this.array = null;
        this.compare = null;
        this.minGallop = DEFAULT_MIN_GALLOPING;
        this.length = 0;
        this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
        this.stackLength = 0;
        this.runStart = null;
        this.runLength = null;
        this.stackSize = 0;
        this.array = array;
        this.compare = compare;
        this.length = array.length;

        if (this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
          this.tmpStorageLength = this.length >>> 1;
        }

        this.tmp = new Array(this.tmpStorageLength);
        this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;
        this.runStart = new Array(this.stackLength);
        this.runLength = new Array(this.stackLength);
      }

      TimSort.prototype.pushRun = function pushRun(runStart, runLength) {
        this.runStart[this.stackSize] = runStart;
        this.runLength[this.stackSize] = runLength;
        this.stackSize += 1;
      };

      TimSort.prototype.mergeRuns = function mergeRuns() {
        while (this.stackSize > 1) {
          var n = this.stackSize - 2;

          if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {
            if (this.runLength[n - 1] < this.runLength[n + 1]) {
              n--;
            }
          } else if (this.runLength[n] > this.runLength[n + 1]) {
            break;
          }

          this.mergeAt(n);
        }
      };

      TimSort.prototype.forceMergeRuns = function forceMergeRuns() {
        while (this.stackSize > 1) {
          var n = this.stackSize - 2;

          if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
            n--;
          }

          this.mergeAt(n);
        }
      };

      TimSort.prototype.mergeAt = function mergeAt(i) {
        var compare = this.compare;
        var array = this.array;
        var start1 = this.runStart[i];
        var length1 = this.runLength[i];
        var start2 = this.runStart[i + 1];
        var length2 = this.runLength[i + 1];
        this.runLength[i] = length1 + length2;

        if (i === this.stackSize - 3) {
          this.runStart[i + 1] = this.runStart[i + 2];
          this.runLength[i + 1] = this.runLength[i + 2];
        }

        this.stackSize--;
        var k = gallopRight(array[start2], array, start1, length1, 0, compare);
        start1 += k;
        length1 -= k;

        if (length1 === 0) {
          return;
        }

        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

        if (length2 === 0) {
          return;
        }

        if (length1 <= length2) {
          this.mergeLow(start1, length1, start2, length2);
        } else {
          this.mergeHigh(start1, length1, start2, length2);
        }
      };

      TimSort.prototype.mergeLow = function mergeLow(start1, length1, start2, length2) {
        var compare = this.compare;
        var array = this.array;
        var tmp = this.tmp;
        var i = 0;

        for (i = 0; i < length1; i++) {
          tmp[i] = array[start1 + i];
        }

        var cursor1 = 0;
        var cursor2 = start2;
        var dest = start1;
        array[dest++] = array[cursor2++];

        if (--length2 === 0) {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }

          return;
        }

        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
          }

          array[dest + length2] = tmp[cursor1];
          return;
        }

        var minGallop = this.minGallop;

        while (true) {
          var count1 = 0;
          var count2 = 0;
          var exit = false;

          do {
            if (compare(array[cursor2], tmp[cursor1]) < 0) {
              array[dest++] = array[cursor2++];
              count2++;
              count1 = 0;

              if (--length2 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest++] = tmp[cursor1++];
              count1++;
              count2 = 0;

              if (--length1 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < minGallop);

          if (exit) {
            break;
          }

          do {
            count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

            if (count1 !== 0) {
              for (i = 0; i < count1; i++) {
                array[dest + i] = tmp[cursor1 + i];
              }

              dest += count1;
              cursor1 += count1;
              length1 -= count1;

              if (length1 <= 1) {
                exit = true;
                break;
              }
            }

            array[dest++] = array[cursor2++];

            if (--length2 === 0) {
              exit = true;
              break;
            }

            count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

            if (count2 !== 0) {
              for (i = 0; i < count2; i++) {
                array[dest + i] = array[cursor2 + i];
              }

              dest += count2;
              cursor2 += count2;
              length2 -= count2;

              if (length2 === 0) {
                exit = true;
                break;
              }
            }

            array[dest++] = tmp[cursor1++];

            if (--length1 === 1) {
              exit = true;
              break;
            }

            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

          if (exit) {
            break;
          }

          if (minGallop < 0) {
            minGallop = 0;
          }

          minGallop += 2;
        }

        this.minGallop = minGallop;

        if (minGallop < 1) {
          this.minGallop = 1;
        }

        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
          }

          array[dest + length2] = tmp[cursor1];
        } else if (length1 === 0) {
          throw new Error('mergeLow preconditions were not respected');
        } else {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
        }
      };

      TimSort.prototype.mergeHigh = function mergeHigh(start1, length1, start2, length2) {
        var compare = this.compare;
        var array = this.array;
        var tmp = this.tmp;
        var i = 0;

        for (i = 0; i < length2; i++) {
          tmp[i] = array[start2 + i];
        }

        var cursor1 = start1 + length1 - 1;
        var cursor2 = length2 - 1;
        var dest = start2 + length2 - 1;
        var customCursor = 0;
        var customDest = 0;
        array[dest--] = array[cursor1--];

        if (--length1 === 0) {
          customCursor = dest - (length2 - 1);

          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
          }

          return;
        }

        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }

          array[dest] = tmp[cursor2];
          return;
        }

        var minGallop = this.minGallop;

        while (true) {
          var count1 = 0;
          var count2 = 0;
          var exit = false;

          do {
            if (compare(tmp[cursor2], array[cursor1]) < 0) {
              array[dest--] = array[cursor1--];
              count1++;
              count2 = 0;

              if (--length1 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest--] = tmp[cursor2--];
              count2++;
              count1 = 0;

              if (--length2 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < minGallop);

          if (exit) {
            break;
          }

          do {
            count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

            if (count1 !== 0) {
              dest -= count1;
              cursor1 -= count1;
              length1 -= count1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;

              for (i = count1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
              }

              if (length1 === 0) {
                exit = true;
                break;
              }
            }

            array[dest--] = tmp[cursor2--];

            if (--length2 === 1) {
              exit = true;
              break;
            }

            count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

            if (count2 !== 0) {
              dest -= count2;
              cursor2 -= count2;
              length2 -= count2;
              customDest = dest + 1;
              customCursor = cursor2 + 1;

              for (i = 0; i < count2; i++) {
                array[customDest + i] = tmp[customCursor + i];
              }

              if (length2 <= 1) {
                exit = true;
                break;
              }
            }

            array[dest--] = array[cursor1--];

            if (--length1 === 0) {
              exit = true;
              break;
            }

            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

          if (exit) {
            break;
          }

          if (minGallop < 0) {
            minGallop = 0;
          }

          minGallop += 2;
        }

        this.minGallop = minGallop;

        if (minGallop < 1) {
          this.minGallop = 1;
        }

        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }

          array[dest] = tmp[cursor2];
        } else if (length2 === 0) {
          throw new Error('mergeHigh preconditions were not respected');
        } else {
          customCursor = dest - (length2 - 1);

          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
          }
        }
      };

      return TimSort;
    }();

    function sort(array, compare, lo, hi) {
      if (!Array.isArray(array)) {
        throw new TypeError('Can only sort arrays');
      }

      if (!compare) {
        compare = alphabeticalCompare;
      } else if (typeof compare !== 'function') {
        hi = lo;
        lo = compare;
        compare = alphabeticalCompare;
      }

      if (!lo) {
        lo = 0;
      }

      if (!hi) {
        hi = array.length;
      }

      var remaining = hi - lo;

      if (remaining < 2) {
        return;
      }

      var runLength = 0;

      if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
        return;
      }

      var ts = new TimSort(array, compare);
      var minRun = minRunLength(remaining);

      do {
        runLength = makeAscendingRun(array, lo, hi, compare);

        if (runLength < minRun) {
          var force = remaining;

          if (force > minRun) {
            force = minRun;
          }

          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
          runLength = force;
        }

        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
      } while (remaining !== 0);

      ts.forceMergeRuns();
    }
  });
})(timsort$1);

var timsort = timsort$1;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !construct) return false; if (construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Interface definition for direction strategy classes.
 *
 * This class describes the interface for the Strategy
 * pattern classes used to differentiate horizontal and vertical
 * direction of hierarchical results.
 *
 * For a given direction, one coordinate will be 'fixed', meaning that it is
 * determined by level.
 * The other coordinate is 'unfixed', meaning that the nodes on a given level
 * can still move along that coordinate. So:
 *
 * - `vertical` layout: `x` unfixed, `y` fixed per level
 * - `horizontal` layout: `x` fixed per level, `y` unfixed
 *
 * The local methods are stubs and should be regarded as abstract.
 * Derived classes **must** implement all the methods themselves.
 *
 * @private
 */

var DirectionInterface = /*#__PURE__*/function () {
  function DirectionInterface() {
    _classCallCheck(this, DirectionInterface);
  }

  _createClass(DirectionInterface, [{
    key: "abstract",
    value:
    /**
     * @ignore
     */
    function abstract() {
      throw new Error("Can't instantiate abstract class!");
    }
    /**
     * This is a dummy call which is used to suppress the jsdoc errors of type:
     *
     *   "'param' is assigned a value but never used"
     *
     * @ignore
     */

  }, {
    key: "fake_use",
    value: function fake_use() {// Do nothing special
    }
    /**
     * Type to use to translate dynamic curves to, in the case of hierarchical layout.
     * Dynamic curves do not work for these.
     *
     * The value should be perpendicular to the actual direction of the layout.
     *
     * @returns {string} Direction, either 'vertical' or 'horizontal'
     */

  }, {
    key: "curveType",
    value: function curveType() {
      return this.abstract();
    }
    /**
     * Return the value of the coordinate that is not fixed for this direction.
     *
     * @param {Node} node The node to read
     * @returns {number} Value of the unfixed coordinate
     */

  }, {
    key: "getPosition",
    value: function getPosition(node) {
      this.fake_use(node);
      return this.abstract();
    }
    /**
     * Set the value of the coordinate that is not fixed for this direction.
     *
     * @param {Node} node The node to adjust
     * @param {number} position
     * @param {number} [level] if specified, the hierarchy level that this node should be fixed to
     */

  }, {
    key: "setPosition",
    value: function setPosition(node, position) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      this.fake_use(node, position, level);
      this.abstract();
    }
    /**
     * Get the width of a tree.
     *
     * A `tree` here is a subset of nodes within the network which are not connected to other nodes,
     * only among themselves. In essence, it is a sub-network.
     *
     * @param {number} index The index number of a tree
     * @returns {number} the width of a tree in the view coordinates
     */

  }, {
    key: "getTreeSize",
    value: function getTreeSize(index) {
      this.fake_use(index);
      return this.abstract();
    }
    /**
     * Sort array of nodes on the unfixed coordinates.
     *
     * Note:** chrome has non-stable sorting implementation, which
     * has a tendency to change the order of the array items,
     * even if the custom sort function returns 0.
     *
     * For this reason, an external sort implementation is used,
     * which has the added benefit of being faster than the standard
     * platforms implementation. This has been verified on `node.js`,
     * `firefox` and `chrome` (all linux).
     *
     * @param {Array.<Node>} nodeArray array of nodes to sort
     */

  }, {
    key: "sort",
    value: function sort(nodeArray) {
      this.fake_use(nodeArray);
      this.abstract();
    }
    /**
     * Assign the fixed coordinate of the node to the given level
     *
     * @param {Node} node The node to adjust
     * @param {number} level The level to fix to
     */

  }, {
    key: "fix",
    value: function fix(node, level) {
      this.fake_use(node, level);
      this.abstract();
    }
    /**
     * Add an offset to the unfixed coordinate of the given node.
     *
     * @param {NodeId} nodeId Id of the node to adjust
     * @param {number} diff Offset to add to the unfixed coordinate
     */

  }, {
    key: "shift",
    value: function shift(nodeId, diff) {
      this.fake_use(nodeId, diff);
      this.abstract();
    }
  }]);

  return DirectionInterface;
}();
/**
 * Vertical Strategy
 *
 * Coordinate `y` is fixed on levels, coordinate `x` is unfixed.
 *
 * @augments DirectionInterface
 * @private
 */


var VerticalStrategy = /*#__PURE__*/function (_DirectionInterface) {
  _inherits(VerticalStrategy, _DirectionInterface);

  var _super = _createSuper(VerticalStrategy);

  /**
   * Constructor
   *
   * @param {object} layout reference to the parent LayoutEngine instance.
   */
  function VerticalStrategy(layout) {
    var _this;

    _classCallCheck(this, VerticalStrategy);

    _this = _super.call(this);
    _this.layout = layout;
    return _this;
  }
  /** @inheritDoc */


  _createClass(VerticalStrategy, [{
    key: "curveType",
    value: function curveType() {
      return "horizontal";
    }
    /** @inheritDoc */

  }, {
    key: "getPosition",
    value: function getPosition(node) {
      return node.x;
    }
    /** @inheritDoc */

  }, {
    key: "setPosition",
    value: function setPosition(node, position) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      if (level !== undefined) {
        this.layout.hierarchical.addToOrdering(node, level);
      }

      node.x = position;
    }
    /** @inheritDoc */

  }, {
    key: "getTreeSize",
    value: function getTreeSize(index) {
      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);
      return {
        min: res.min_x,
        max: res.max_x
      };
    }
    /** @inheritDoc */

  }, {
    key: "sort",
    value: function sort(nodeArray) {
      timsort.sort(nodeArray, function (a, b) {
        return a.x - b.x;
      });
    }
    /** @inheritDoc */

  }, {
    key: "fix",
    value: function fix(node, level) {
      node.y = this.layout.options.hierarchical.levelSeparation * level;
      node.options.fixed.y = true;
    }
    /** @inheritDoc */

  }, {
    key: "shift",
    value: function shift(nodeId, diff) {
      this.layout.body.nodes[nodeId].x += diff;
    }
  }]);

  return VerticalStrategy;
}(DirectionInterface);
/**
 * Horizontal Strategy
 *
 * Coordinate `x` is fixed on levels, coordinate `y` is unfixed.
 *
 * @augments DirectionInterface
 * @private
 */


var HorizontalStrategy = /*#__PURE__*/function (_DirectionInterface2) {
  _inherits(HorizontalStrategy, _DirectionInterface2);

  var _super2 = _createSuper(HorizontalStrategy);

  /**
   * Constructor
   *
   * @param {object} layout reference to the parent LayoutEngine instance.
   */
  function HorizontalStrategy(layout) {
    var _this2;

    _classCallCheck(this, HorizontalStrategy);

    _this2 = _super2.call(this);
    _this2.layout = layout;
    return _this2;
  }
  /** @inheritDoc */


  _createClass(HorizontalStrategy, [{
    key: "curveType",
    value: function curveType() {
      return "vertical";
    }
    /** @inheritDoc */

  }, {
    key: "getPosition",
    value: function getPosition(node) {
      return node.y;
    }
    /** @inheritDoc */

  }, {
    key: "setPosition",
    value: function setPosition(node, position) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      if (level !== undefined) {
        this.layout.hierarchical.addToOrdering(node, level);
      }

      node.y = position;
    }
    /** @inheritDoc */

  }, {
    key: "getTreeSize",
    value: function getTreeSize(index) {
      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);
      return {
        min: res.min_y,
        max: res.max_y
      };
    }
    /** @inheritDoc */

  }, {
    key: "sort",
    value: function sort(nodeArray) {
      timsort.sort(nodeArray, function (a, b) {
        return a.y - b.y;
      });
    }
    /** @inheritDoc */

  }, {
    key: "fix",
    value: function fix(node, level) {
      node.x = this.layout.options.hierarchical.levelSeparation * level;
      node.options.fixed.x = true;
    }
    /** @inheritDoc */

  }, {
    key: "shift",
    value: function shift(nodeId, diff) {
      this.layout.body.nodes[nodeId].y += diff;
    }
  }]);

  return HorizontalStrategy;
}(DirectionInterface);

var $ = _export;
var $every = arrayIteration.every;
var arrayMethodIsStrict = arrayMethodIsStrict$6;
var STRICT_METHOD = arrayMethodIsStrict('every'); // `Array.prototype.every` method
// https://tc39.es/ecma262/#sec-array.prototype.every

$({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD
}, {
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var entryVirtual = entryVirtual$l;
var every$3 = entryVirtual('Array').every;

var isPrototypeOf = objectIsPrototypeOf;
var method = every$3;
var ArrayPrototype = Array.prototype;

var every$2 = function (it) {
  var own = it.every;
  return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.every ? method : own;
};

var parent = every$2;
var every$1 = parent;

var every = every$1;

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$1(o, minLen) { var _context9; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = slice(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Try to assign levels to nodes according to their positions in the cyclic “hierarchy”.
 *
 * @param nodes - Visible nodes of the graph.
 * @param levels - If present levels will be added to it, if not a new object will be created.
 * @returns Populated node levels.
 */
function fillLevelsByDirectionCyclic(nodes, levels) {
  var edges = new set();

  forEach$2(nodes).call(nodes, function (node) {
    var _context;

    forEach$2(_context = node.edges).call(_context, function (edge) {
      if (edge.connected) {
        edges.add(edge);
      }
    });
  });

  forEach$2(edges).call(edges, function (edge) {
    var fromId = edge.from.id;
    var toId = edge.to.id;

    if (levels[fromId] == null) {
      levels[fromId] = 0;
    }

    if (levels[toId] == null || levels[fromId] >= levels[toId]) {
      levels[toId] = levels[fromId] + 1;
    }
  });

  return levels;
}
/**
 * Assign levels to nodes according to their positions in the hierarchy. Leaves will be lined up at the bottom and all other nodes as close to their children as possible.
 *
 * @param nodes - Visible nodes of the graph.
 * @returns Populated node levels.
 */


function fillLevelsByDirectionLeaves(nodes) {
  return fillLevelsByDirection( // Pick only leaves (nodes without children).
  function (node) {
    var _context2, _context3;

    return every(_context2 = filter(_context3 = node.edges // Take only visible nodes into account.
    ).call(_context3, function (edge) {
      return nodes.has(edge.toId);
    }) // Check that all edges lead to this node (leaf).
    ).call(_context2, function (edge) {
      return edge.to === node;
    });
  }, // Use the lowest level.
  function (newLevel, oldLevel) {
    return oldLevel > newLevel;
  }, // Go against the direction of the edges.
  "from", nodes);
}
/**
 * Assign levels to nodes according to their positions in the hierarchy. Roots will be lined up at the top and all nodes as close to their parents as possible.
 *
 * @param nodes - Visible nodes of the graph.
 * @returns Populated node levels.
 */

function fillLevelsByDirectionRoots(nodes) {
  return fillLevelsByDirection( // Pick only roots (nodes without parents).
  function (node) {
    var _context4, _context5;

    return every(_context4 = filter(_context5 = node.edges // Take only visible nodes into account.
    ).call(_context5, function (edge) {
      return nodes.has(edge.toId);
    }) // Check that all edges lead from this node (root).
    ).call(_context4, function (edge) {
      return edge.from === node;
    });
  }, // Use the highest level.
  function (newLevel, oldLevel) {
    return oldLevel < newLevel;
  }, // Go in the direction of the edges.
  "to", nodes);
}
/**
 * Assign levels to nodes according to their positions in the hierarchy.
 *
 * @param isEntryNode - Checks and return true if the graph should be traversed from this node.
 * @param shouldLevelBeReplaced - Checks and returns true if the level of given node should be updated to the new value.
 * @param direction - Wheter the graph should be traversed in the direction of the edges `"to"` or in the other way `"from"`.
 * @param nodes - Visible nodes of the graph.
 * @returns Populated node levels.
 */

function fillLevelsByDirection(isEntryNode, shouldLevelBeReplaced, direction, nodes) {
  var _context6;

  var levels = create$5(null); // If acyclic, the graph can be walked through with (most likely way) fewer
  // steps than the number bellow. The exact value isn't too important as long
  // as it's quick to compute (doesn't impact acyclic graphs too much), is
  // higher than the number of steps actually needed (doesn't cut off before
  // acyclic graph is walked through) and prevents infinite loops (cuts off for
  // cyclic graphs).


  var limit = reduce(_context6 = _toConsumableArray(values(nodes).call(nodes))).call(_context6, function (acc, node) {
    return acc + 1 + node.edges.length;
  }, 0);

  var edgeIdProp = direction + "Id";
  var newLevelDiff = direction === "to" ? 1 : -1;

  var _iterator = _createForOfIteratorHelper$1(nodes),
      _step;

  try {
    var _loop = function _loop() {
      var _step$value = _slicedToArray(_step.value, 2),
          entryNodeId = _step$value[0],
          entryNode = _step$value[1];

      if ( // Skip if the node is not visible.
      !nodes.has(entryNodeId) || // Skip if the node is not an entry node.
      !isEntryNode(entryNode)) {
        return "continue";
      } // Line up all the entry nodes on level 0.


      levels[entryNodeId] = 0;
      var stack = [entryNode];
      var done = 0;
      var node = void 0;

      var _loop2 = function _loop2() {
        var _context7, _context8;

        if (!nodes.has(entryNodeId)) {
          // Skip if the node is not visible.
          return "continue";
        }

        var newLevel = levels[node.id] + newLevelDiff;

        forEach$2(_context7 = filter(_context8 = node.edges).call(_context8, function (edge) {
          return (// Ignore disconnected edges.
            edge.connected && // Ignore circular edges.
            edge.to !== edge.from && // Ignore edges leading to the node that's currently being processed.
            edge[direction] !== node && // Ignore edges connecting to an invisible node.
            nodes.has(edge.toId) && // Ignore edges connecting from an invisible node.
            nodes.has(edge.fromId)
          );
        })).call(_context7, function (edge) {
          var targetNodeId = edge[edgeIdProp];
          var oldLevel = levels[targetNodeId];

          if (oldLevel == null || shouldLevelBeReplaced(newLevel, oldLevel)) {
            levels[targetNodeId] = newLevel;
            stack.push(edge[direction]);
          }
        });

        if (done > limit) {
          // This would run forever on a cyclic graph.
          return {
            v: {
              v: fillLevelsByDirectionCyclic(nodes, levels)
            }
          };
        } else {
          ++done;
        }
      };

      while (node = stack.pop()) {
        var _ret2 = _loop2();

        if (_ret2 === "continue") continue;
        if (_typeof(_ret2) === "object") return _ret2.v;
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();

      if (_ret === "continue") continue;
      if (_typeof(_ret) === "object") return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return levels;
}

/**
 * There's a mix-up with terms in the code. Following are the formal definitions:
 *
 *   tree   - a strict hierarchical network, i.e. every node has at most one parent
 *   forest - a collection of trees. These distinct trees are thus not connected.
 *
 * So:
 * - in a network that is not a tree, there exist nodes with multiple parents.
 * - a network consisting of unconnected sub-networks, of which at least one
 *   is not a tree, is not a forest.
 *
 * In the code, the definitions are:
 *
 *   tree   - any disconnected sub-network, strict hierarchical or not.
 *   forest - a bunch of these sub-networks
 *
 * The difference between tree and not-tree is important in the code, notably within
 * to the block-shifting algorithm. The algorithm assumes formal trees and fails
 * for not-trees, often in a spectacular manner (search for 'exploding network' in the issues).
 *
 * In order to distinguish the definitions in the following code, the adjective 'formal' is
 * used. If 'formal' is absent, you must assume the non-formal definition.
 *
 * ----------------------------------------------------------------------------------
 * NOTES
 * =====
 *
 * A hierarchical layout is a different thing from a hierarchical network.
 * The layout is a way to arrange the nodes in the view; this can be done
 * on non-hierarchical networks as well. The converse is also possible.
 */
/**
 * Container for derived data on current network, relating to hierarchy.
 *
 * @private
 */

var HierarchicalStatus = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function HierarchicalStatus() {
    _classCallCheck(this, HierarchicalStatus);

    this.childrenReference = {}; // child id's per node id

    this.parentReference = {}; // parent id's per node id

    this.trees = {}; // tree id per node id; i.e. to which tree does given node id belong

    this.distributionOrdering = {}; // The nodes per level, in the display order

    this.levels = {}; // hierarchy level per node id

    this.distributionIndex = {}; // The position of the node in the level sorting order, per node id.

    this.isTree = false; // True if current network is a formal tree

    this.treeIndex = -1; // Highest tree id in current network.
  }
  /**
   * Add the relation between given nodes to the current state.
   *
   * @param {Node.id} parentNodeId
   * @param {Node.id} childNodeId
   */


  _createClass(HierarchicalStatus, [{
    key: "addRelation",
    value: function addRelation(parentNodeId, childNodeId) {
      if (this.childrenReference[parentNodeId] === undefined) {
        this.childrenReference[parentNodeId] = [];
      }

      this.childrenReference[parentNodeId].push(childNodeId);

      if (this.parentReference[childNodeId] === undefined) {
        this.parentReference[childNodeId] = [];
      }

      this.parentReference[childNodeId].push(parentNodeId);
    }
    /**
     * Check if the current state is for a formal tree or formal forest.
     *
     * This is the case if every node has at most one parent.
     *
     * Pre: parentReference init'ed properly for current network
     */

  }, {
    key: "checkIfTree",
    value: function checkIfTree() {
      for (var i in this.parentReference) {
        if (this.parentReference[i].length > 1) {
          this.isTree = false;
          return;
        }
      }

      this.isTree = true;
    }
    /**
     * Return the number of separate trees in the current network.
     *
     * @returns {number}
     */

  }, {
    key: "numTrees",
    value: function numTrees() {
      return this.treeIndex + 1; // This assumes the indexes are assigned consecitively
    }
    /**
     * Assign a tree id to a node
     *
     * @param {Node} node
     * @param {string|number} treeId
     */

  }, {
    key: "setTreeIndex",
    value: function setTreeIndex(node, treeId) {
      if (treeId === undefined) return; // Don't bother

      if (this.trees[node.id] === undefined) {
        this.trees[node.id] = treeId;
        this.treeIndex = Math.max(treeId, this.treeIndex);
      }
    }
    /**
     * Ensure level for given id is defined.
     *
     * Sets level to zero for given node id if not already present
     *
     * @param {Node.id} nodeId
     */

  }, {
    key: "ensureLevel",
    value: function ensureLevel(nodeId) {
      if (this.levels[nodeId] === undefined) {
        this.levels[nodeId] = 0;
      }
    }
    /**
     * get the maximum level of a branch.
     *
     * TODO: Never entered; find a test case to test this!
     *
     * @param {Node.id} nodeId
     * @returns {number}
     */

  }, {
    key: "getMaxLevel",
    value: function getMaxLevel(nodeId) {
      var _this = this;

      var accumulator = {};

      var _getMaxLevel = function _getMaxLevel(nodeId) {
        if (accumulator[nodeId] !== undefined) {
          return accumulator[nodeId];
        }

        var level = _this.levels[nodeId];

        if (_this.childrenReference[nodeId]) {
          var children = _this.childrenReference[nodeId];

          if (children.length > 0) {
            for (var i = 0; i < children.length; i++) {
              level = Math.max(level, _getMaxLevel(children[i]));
            }
          }
        }

        accumulator[nodeId] = level;
        return level;
      };

      return _getMaxLevel(nodeId);
    }
    /**
     *
     * @param {Node} nodeA
     * @param {Node} nodeB
     */

  }, {
    key: "levelDownstream",
    value: function levelDownstream(nodeA, nodeB) {
      if (this.levels[nodeB.id] === undefined) {
        // set initial level
        if (this.levels[nodeA.id] === undefined) {
          this.levels[nodeA.id] = 0;
        } // set level


        this.levels[nodeB.id] = this.levels[nodeA.id] + 1;
      }
    }
    /**
     * Small util method to set the minimum levels of the nodes to zero.
     *
     * @param {Array.<Node>} nodes
     */

  }, {
    key: "setMinLevelToZero",
    value: function setMinLevelToZero(nodes) {
      var minLevel = 1e9; // get the minimum level

      for (var nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
          if (this.levels[nodeId] !== undefined) {
            minLevel = Math.min(this.levels[nodeId], minLevel);
          }
        }
      } // subtract the minimum from the set so we have a range starting from 0


      for (var _nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, _nodeId)) {
          if (this.levels[_nodeId] !== undefined) {
            this.levels[_nodeId] -= minLevel;
          }
        }
      }
    }
    /**
     * Get the min and max xy-coordinates of a given tree
     *
     * @param {Array.<Node>} nodes
     * @param {number} index
     * @returns {{min_x: number, max_x: number, min_y: number, max_y: number}}
     */

  }, {
    key: "getTreeSize",
    value: function getTreeSize(nodes, index) {
      var min_x = 1e9;
      var max_x = -1e9;
      var min_y = 1e9;
      var max_y = -1e9;

      for (var nodeId in this.trees) {
        if (Object.prototype.hasOwnProperty.call(this.trees, nodeId)) {
          if (this.trees[nodeId] === index) {
            var node = nodes[nodeId];
            min_x = Math.min(node.x, min_x);
            max_x = Math.max(node.x, max_x);
            min_y = Math.min(node.y, min_y);
            max_y = Math.max(node.y, max_y);
          }
        }
      }

      return {
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y
      };
    }
    /**
     * Check if two nodes have the same parent(s)
     *
     * @param {Node} node1
     * @param {Node} node2
     * @returns {boolean} true if the two nodes have a same ancestor node, false otherwise
     */

  }, {
    key: "hasSameParent",
    value: function hasSameParent(node1, node2) {
      var parents1 = this.parentReference[node1.id];
      var parents2 = this.parentReference[node2.id];

      if (parents1 === undefined || parents2 === undefined) {
        return false;
      }

      for (var i = 0; i < parents1.length; i++) {
        for (var j = 0; j < parents2.length; j++) {
          if (parents1[i] == parents2[j]) {
            return true;
          }
        }
      }

      return false;
    }
    /**
     * Check if two nodes are in the same tree.
     *
     * @param {Node} node1
     * @param {Node} node2
     * @returns {boolean} true if this is so, false otherwise
     */

  }, {
    key: "inSameSubNetwork",
    value: function inSameSubNetwork(node1, node2) {
      return this.trees[node1.id] === this.trees[node2.id];
    }
    /**
     * Get a list of the distinct levels in the current network
     *
     * @returns {Array}
     */

  }, {
    key: "getLevels",
    value: function getLevels() {
      return keys$4(this.distributionOrdering);
    }
    /**
     * Add a node to the ordering per level
     *
     * @param {Node} node
     * @param {number} level
     */

  }, {
    key: "addToOrdering",
    value: function addToOrdering(node, level) {
      if (this.distributionOrdering[level] === undefined) {
        this.distributionOrdering[level] = [];
      }

      var isPresent = false;
      var curLevel = this.distributionOrdering[level];

      for (var n in curLevel) {
        //if (curLevel[n].id === node.id) {
        if (curLevel[n] === node) {
          isPresent = true;
          break;
        }
      }

      if (!isPresent) {
        this.distributionOrdering[level].push(node);
        this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;
      }
    }
  }]);

  return HierarchicalStatus;
}();
/**
 * The Layout Engine
 */


var LayoutEngine = /*#__PURE__*/function () {
  /**
   * @param {object} body
   */
  function LayoutEngine(body) {
    _classCallCheck(this, LayoutEngine);

    this.body = body; // Make sure there always is some RNG because the setOptions method won't
    // set it unless there's a seed for it.

    this._resetRNG(Math.random() + ":" + now$1());

    this.setPhysics = false;
    this.options = {};
    this.optionsBackup = {
      physics: {}
    };
    this.defaultOptions = {
      randomSeed: undefined,
      improvedLayout: true,
      clusterThreshold: 150,
      hierarchical: {
        enabled: false,
        levelSeparation: 150,
        nodeSpacing: 100,
        treeSpacing: 200,
        blockShifting: true,
        edgeMinimization: true,
        parentCentralization: true,
        direction: "UD",
        // UD, DU, LR, RL
        sortMethod: "hubsize" // hubsize, directed

      }
    };

    assign$2(this.options, this.defaultOptions);

    this.bindEventListeners();
  }
  /**
   * Binds event listeners
   */


  _createClass(LayoutEngine, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this2 = this;

      this.body.emitter.on("_dataChanged", function () {
        _this2.setupHierarchicalLayout();
      });
      this.body.emitter.on("_dataLoaded", function () {
        _this2.layoutNetwork();
      });
      this.body.emitter.on("_resetHierarchicalLayout", function () {
        _this2.setupHierarchicalLayout();
      });
      this.body.emitter.on("_adjustEdgesForHierarchicalLayout", function () {
        if (_this2.options.hierarchical.enabled !== true) {
          return;
        } // get the type of static smooth curve in case it is required


        var type = _this2.direction.curveType(); // force all edges into static smooth curves.


        _this2.body.emitter.emit("_forceDisableDynamicCurves", type, false);
      });
    }
    /**
     *
     * @param {object} options
     * @param {object} allOptions
     * @returns {object}
     */

  }, {
    key: "setOptions",
    value: function setOptions(options, allOptions) {
      if (options !== undefined) {
        var hierarchical = this.options.hierarchical;
        var prevHierarchicalState = hierarchical.enabled;
        selectiveDeepExtend(["randomSeed", "improvedLayout", "clusterThreshold"], this.options, options);
        mergeOptions(this.options, options, "hierarchical");

        if (options.randomSeed !== undefined) {
          this._resetRNG(options.randomSeed);
        }

        if (hierarchical.enabled === true) {
          if (prevHierarchicalState === true) {
            // refresh the overridden options for nodes and edges.
            this.body.emitter.emit("refresh", true);
          } // make sure the level separation is the right way up


          if (hierarchical.direction === "RL" || hierarchical.direction === "DU") {
            if (hierarchical.levelSeparation > 0) {
              hierarchical.levelSeparation *= -1;
            }
          } else {
            if (hierarchical.levelSeparation < 0) {
              hierarchical.levelSeparation *= -1;
            }
          }

          this.setDirectionStrategy();
          this.body.emitter.emit("_resetHierarchicalLayout"); // because the hierarchical system needs it's own physics and smooth curve settings,
          // we adapt the other options if needed.

          return this.adaptAllOptionsForHierarchicalLayout(allOptions);
        } else {
          if (prevHierarchicalState === true) {
            // refresh the overridden options for nodes and edges.
            this.body.emitter.emit("refresh");
            return deepExtend(allOptions, this.optionsBackup);
          }
        }
      }

      return allOptions;
    }
    /**
     * Reset the random number generator with given seed.
     *
     * @param {any} seed - The seed that will be forwarded the the RNG.
     */

  }, {
    key: "_resetRNG",
    value: function _resetRNG(seed) {
      this.initialRandomSeed = seed;
      this._rng = Alea(this.initialRandomSeed);
    }
    /**
     *
     * @param {object} allOptions
     * @returns {object}
     */

  }, {
    key: "adaptAllOptionsForHierarchicalLayout",
    value: function adaptAllOptionsForHierarchicalLayout(allOptions) {
      if (this.options.hierarchical.enabled === true) {
        var backupPhysics = this.optionsBackup.physics; // set the physics

        if (allOptions.physics === undefined || allOptions.physics === true) {
          allOptions.physics = {
            enabled: backupPhysics.enabled === undefined ? true : backupPhysics.enabled,
            solver: "hierarchicalRepulsion"
          };
          backupPhysics.enabled = backupPhysics.enabled === undefined ? true : backupPhysics.enabled;
          backupPhysics.solver = backupPhysics.solver || "barnesHut";
        } else if (_typeof(allOptions.physics) === "object") {
          backupPhysics.enabled = allOptions.physics.enabled === undefined ? true : allOptions.physics.enabled;
          backupPhysics.solver = allOptions.physics.solver || "barnesHut";
          allOptions.physics.solver = "hierarchicalRepulsion";
        } else if (allOptions.physics !== false) {
          backupPhysics.solver = "barnesHut";
          allOptions.physics = {
            solver: "hierarchicalRepulsion"
          };
        } // get the type of static smooth curve in case it is required


        var type = this.direction.curveType(); // disable smooth curves if nothing is defined. If smooth curves have been turned on,
        // turn them into static smooth curves.

        if (allOptions.edges === undefined) {
          this.optionsBackup.edges = {
            smooth: {
              enabled: true,
              type: "dynamic"
            }
          };
          allOptions.edges = {
            smooth: false
          };
        } else if (allOptions.edges.smooth === undefined) {
          this.optionsBackup.edges = {
            smooth: {
              enabled: true,
              type: "dynamic"
            }
          };
          allOptions.edges.smooth = false;
        } else {
          if (typeof allOptions.edges.smooth === "boolean") {
            this.optionsBackup.edges = {
              smooth: allOptions.edges.smooth
            };
            allOptions.edges.smooth = {
              enabled: allOptions.edges.smooth,
              type: type
            };
          } else {
            var smooth = allOptions.edges.smooth; // allow custom types except for dynamic

            if (smooth.type !== undefined && smooth.type !== "dynamic") {
              type = smooth.type;
            } // TODO: this is options merging; see if the standard routines can be used here.


            this.optionsBackup.edges = {
              smooth: {
                enabled: smooth.enabled === undefined ? true : smooth.enabled,
                type: smooth.type === undefined ? "dynamic" : smooth.type,
                roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,
                forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection
              }
            }; // NOTE: Copying an object to self; this is basically setting defaults for undefined variables

            allOptions.edges.smooth = {
              enabled: smooth.enabled === undefined ? true : smooth.enabled,
              type: type,
              roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,
              forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection
            };
          }
        } // Force all edges into static smooth curves.
        // Only applies to edges that do not use the global options for smooth.


        this.body.emitter.emit("_forceDisableDynamicCurves", type);
      }

      return allOptions;
    }
    /**
     *
     * @param {Array.<Node>} nodesArray
     */

  }, {
    key: "positionInitially",
    value: function positionInitially(nodesArray) {
      if (this.options.hierarchical.enabled !== true) {
        this._resetRNG(this.initialRandomSeed);

        var radius = nodesArray.length + 50;

        for (var i = 0; i < nodesArray.length; i++) {
          var node = nodesArray[i];

          var angle = 2 * Math.PI * this._rng();

          if (node.x === undefined) {
            node.x = radius * Math.cos(angle);
          }

          if (node.y === undefined) {
            node.y = radius * Math.sin(angle);
          }
        }
      }
    }
    /**
     * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we
     * cluster them first to reduce the amount.
     */

  }, {
    key: "layoutNetwork",
    value: function layoutNetwork() {
      if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {
        var indices = this.body.nodeIndices; // first check if we should Kamada Kawai to layout. The threshold is if less than half of the visible
        // nodes have predefined positions we use this.

        var positionDefined = 0;

        for (var i = 0; i < indices.length; i++) {
          var node = this.body.nodes[indices[i]];

          if (node.predefinedPosition === true) {
            positionDefined += 1;
          }
        } // if less than half of the nodes have a predefined position we continue


        if (positionDefined < 0.5 * indices.length) {
          var MAX_LEVELS = 10;
          var level = 0;
          var clusterThreshold = this.options.clusterThreshold; //
          // Define the options for the hidden cluster nodes
          // These options don't propagate outside the clustering phase.
          //
          // Some options are explicitly disabled, because they may be set in group or default node options.
          // The clusters are never displayed, so most explicit settings here serve as performance optimizations.
          //
          // The explicit setting of 'shape' is to avoid `shape: 'image'`; images are not passed to the hidden
          // cluster nodes, leading to an exception on creation.
          //
          // All settings here are performance related, except when noted otherwise.
          //

          var clusterOptions = {
            clusterNodeProperties: {
              shape: "ellipse",
              // Bugfix: avoid type 'image', no images supplied
              label: "",
              // avoid label handling
              group: "",
              // avoid group handling
              font: {
                multi: false
              } // avoid font propagation

            },
            clusterEdgeProperties: {
              label: "",
              // avoid label handling
              font: {
                multi: false
              },
              // avoid font propagation
              smooth: {
                enabled: false // avoid drawing penalty for complex edges

              }
            }
          }; // if there are a lot of nodes, we cluster before we run the algorithm.
          // NOTE: this part fails to find clusters for large scale-free networks, which should
          //       be easily clusterable.
          // TODO: examine why this is so

          if (indices.length > clusterThreshold) {
            var startLength = indices.length;

            while (indices.length > clusterThreshold && level <= MAX_LEVELS) {
              //console.time("clustering")
              level += 1;
              var before = indices.length; // if there are many nodes we do a hubsize cluster

              if (level % 3 === 0) {
                this.body.modules.clustering.clusterBridges(clusterOptions);
              } else {
                this.body.modules.clustering.clusterOutliers(clusterOptions);
              }

              var after = indices.length;

              if (before == after && level % 3 !== 0) {
                this._declusterAll();

                this.body.emitter.emit("_layoutFailed");
                console.info("This network could not be positioned by this version of the improved layout algorithm." + " Please disable improvedLayout for better performance.");
                return;
              } //console.timeEnd("clustering")
              //console.log(before,level,after);

            } // increase the size of the edges


            this.body.modules.kamadaKawai.setOptions({
              springLength: Math.max(150, 2 * startLength)
            });
          }

          if (level > MAX_LEVELS) {
            console.info("The clustering didn't succeed within the amount of interations allowed," + " progressing with partial result.");
          } // position the system for these nodes and edges


          this.body.modules.kamadaKawai.solve(indices, this.body.edgeIndices, true); // shift to center point

          this._shiftToCenter(); // perturb the nodes a little bit to force the physics to kick in


          var offset = 70;

          for (var _i = 0; _i < indices.length; _i++) {
            // Only perturb the nodes that aren't fixed
            var _node = this.body.nodes[indices[_i]];

            if (_node.predefinedPosition === false) {
              _node.x += (0.5 - this._rng()) * offset;
              _node.y += (0.5 - this._rng()) * offset;
            }
          } // uncluster all clusters


          this._declusterAll(); // reposition all bezier nodes.


          this.body.emitter.emit("_repositionBezierNodes");
        }
      }
    }
    /**
     * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view
     *
     * @private
     */

  }, {
    key: "_shiftToCenter",
    value: function _shiftToCenter() {
      var range = NetworkUtil.getRangeCore(this.body.nodes, this.body.nodeIndices);
      var center = NetworkUtil.findCenter(range);

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var node = this.body.nodes[this.body.nodeIndices[i]];
        node.x -= center.x;
        node.y -= center.y;
      }
    }
    /**
     * Expands all clusters
     *
     * @private
     */

  }, {
    key: "_declusterAll",
    value: function _declusterAll() {
      var clustersPresent = true;

      while (clustersPresent === true) {
        clustersPresent = false;

        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {
            clustersPresent = true;
            this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);
          }
        }

        if (clustersPresent === true) {
          this.body.emitter.emit("_dataChanged");
        }
      }
    }
    /**
     *
     * @returns {number|*}
     */

  }, {
    key: "getSeed",
    value: function getSeed() {
      return this.initialRandomSeed;
    }
    /**
     * This is the main function to layout the nodes in a hierarchical way.
     * It checks if the node details are supplied correctly
     *
     * @private
     */

  }, {
    key: "setupHierarchicalLayout",
    value: function setupHierarchicalLayout() {
      if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {
        // get the size of the largest hubs and check if the user has defined a level for a node.
        var node, nodeId;
        var definedLevel = false;
        var undefinedLevel = false;
        this.lastNodeOnLevel = {};
        this.hierarchical = new HierarchicalStatus();

        for (nodeId in this.body.nodes) {
          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
            node = this.body.nodes[nodeId];

            if (node.options.level !== undefined) {
              definedLevel = true;
              this.hierarchical.levels[nodeId] = node.options.level;
            } else {
              undefinedLevel = true;
            }
          }
        } // if the user defined some levels but not all, alert and run without hierarchical layout


        if (undefinedLevel === true && definedLevel === true) {
          throw new Error("To use the hierarchical layout, nodes require either no predefined levels" + " or levels have to be defined for all nodes.");
        } else {
          // define levels if undefined by the users. Based on hubsize.
          if (undefinedLevel === true) {
            var sortMethod = this.options.hierarchical.sortMethod;

            if (sortMethod === "hubsize") {
              this._determineLevelsByHubsize();
            } else if (sortMethod === "directed") {
              this._determineLevelsDirected();
            } else if (sortMethod === "custom") {
              this._determineLevelsCustomCallback();
            }
          } // fallback for cases where there are nodes but no edges


          for (var _nodeId2 in this.body.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {
              this.hierarchical.ensureLevel(_nodeId2);
            }
          } // check the distribution of the nodes per level.


          var distribution = this._getDistribution(); // get the parent children relations.


          this._generateMap(); // place the nodes on the canvas.


          this._placeNodesByHierarchy(distribution); // condense the whitespace.


          this._condenseHierarchy(); // shift to center so gravity does not have to do much


          this._shiftToCenter();
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "_condenseHierarchy",
    value: function _condenseHierarchy() {
      var _this3 = this;

      // Global var in this scope to define when the movement has stopped.
      var stillShifting = false;
      var branches = {}; // first we have some methods to help shifting trees around.
      // the main method to shift the trees

      var shiftTrees = function shiftTrees() {
        var treeSizes = getTreeSizes();
        var shiftBy = 0;

        for (var i = 0; i < treeSizes.length - 1; i++) {
          var diff = treeSizes[i].max - treeSizes[i + 1].min;
          shiftBy += diff + _this3.options.hierarchical.treeSpacing;
          shiftTree(i + 1, shiftBy);
        }
      }; // shift a single tree by an offset


      var shiftTree = function shiftTree(index, offset) {
        var trees = _this3.hierarchical.trees;

        for (var nodeId in trees) {
          if (Object.prototype.hasOwnProperty.call(trees, nodeId)) {
            if (trees[nodeId] === index) {
              _this3.direction.shift(nodeId, offset);
            }
          }
        }
      }; // get the width of all trees


      var getTreeSizes = function getTreeSizes() {
        var treeWidths = [];

        for (var i = 0; i < _this3.hierarchical.numTrees(); i++) {
          treeWidths.push(_this3.direction.getTreeSize(i));
        }

        return treeWidths;
      }; // get a map of all nodes in this branch


      var getBranchNodes = function getBranchNodes(source, map) {
        if (map[source.id]) {
          return;
        }

        map[source.id] = true;

        if (_this3.hierarchical.childrenReference[source.id]) {
          var children = _this3.hierarchical.childrenReference[source.id];

          if (children.length > 0) {
            for (var i = 0; i < children.length; i++) {
              getBranchNodes(_this3.body.nodes[children[i]], map);
            }
          }
        }
      }; // get a min max width as well as the maximum movement space it has on either sides
      // we use min max terminology because width and height can interchange depending on the direction of the layout


      var getBranchBoundary = function getBranchBoundary(branchMap) {
        var maxLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e9;
        var minSpace = 1e9;
        var maxSpace = 1e9;
        var min = 1e9;
        var max = -1e9;

        for (var branchNode in branchMap) {
          if (Object.prototype.hasOwnProperty.call(branchMap, branchNode)) {
            var node = _this3.body.nodes[branchNode];
            var level = _this3.hierarchical.levels[node.id];

            var position = _this3.direction.getPosition(node); // get the space around the node.


            var _this3$_getSpaceAroun = _this3._getSpaceAroundNode(node, branchMap),
                _this3$_getSpaceAroun2 = _slicedToArray(_this3$_getSpaceAroun, 2),
                minSpaceNode = _this3$_getSpaceAroun2[0],
                maxSpaceNode = _this3$_getSpaceAroun2[1];

            minSpace = Math.min(minSpaceNode, minSpace);
            maxSpace = Math.min(maxSpaceNode, maxSpace); // the width is only relevant for the levels two nodes have in common. This is why we filter on this.

            if (level <= maxLevel) {
              min = Math.min(position, min);
              max = Math.max(position, max);
            }
          }
        }

        return [min, max, minSpace, maxSpace];
      }; // check what the maximum level is these nodes have in common.


      var getCollisionLevel = function getCollisionLevel(node1, node2) {
        var maxLevel1 = _this3.hierarchical.getMaxLevel(node1.id);

        var maxLevel2 = _this3.hierarchical.getMaxLevel(node2.id);

        return Math.min(maxLevel1, maxLevel2);
      };
      /**
       * Condense elements. These can be nodes or branches depending on the callback.
       *
       * @param {Function} callback
       * @param {Array.<number>} levels
       * @param {*} centerParents
       */


      var shiftElementsCloser = function shiftElementsCloser(callback, levels, centerParents) {
        var hier = _this3.hierarchical;

        for (var i = 0; i < levels.length; i++) {
          var level = levels[i];
          var levelNodes = hier.distributionOrdering[level];

          if (levelNodes.length > 1) {
            for (var j = 0; j < levelNodes.length - 1; j++) {
              var node1 = levelNodes[j];
              var node2 = levelNodes[j + 1]; // NOTE: logic maintained as it was; if nodes have same ancestor,
              //       then of course they are in the same sub-network.

              if (hier.hasSameParent(node1, node2) && hier.inSameSubNetwork(node1, node2)) {
                callback(node1, node2, centerParents);
              }
            }
          }
        }
      }; // callback for shifting branches


      var branchShiftCallback = function branchShiftCallback(node1, node2) {
        var centerParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        //window.CALLBACKS.push(() => {
        var pos1 = _this3.direction.getPosition(node1);

        var pos2 = _this3.direction.getPosition(node2);

        var diffAbs = Math.abs(pos2 - pos1);
        var nodeSpacing = _this3.options.hierarchical.nodeSpacing; //console.log("NOW CHECKING:", node1.id, node2.id, diffAbs);

        if (diffAbs > nodeSpacing) {
          var branchNodes1 = {};
          var branchNodes2 = {};
          getBranchNodes(node1, branchNodes1);
          getBranchNodes(node2, branchNodes2); // check the largest distance between the branches

          var maxLevel = getCollisionLevel(node1, node2);
          var branchNodeBoundary1 = getBranchBoundary(branchNodes1, maxLevel);
          var branchNodeBoundary2 = getBranchBoundary(branchNodes2, maxLevel);
          var max1 = branchNodeBoundary1[1];
          var min2 = branchNodeBoundary2[0];
          var minSpace2 = branchNodeBoundary2[2]; //console.log(node1.id, getBranchBoundary(branchNodes1, maxLevel), node2.id,
          //            getBranchBoundary(branchNodes2, maxLevel), maxLevel);

          var diffBranch = Math.abs(max1 - min2);

          if (diffBranch > nodeSpacing) {
            var offset = max1 - min2 + nodeSpacing;

            if (offset < -minSpace2 + nodeSpacing) {
              offset = -minSpace2 + nodeSpacing; //console.log("RESETTING OFFSET", max1 - min2 + this.options.hierarchical.nodeSpacing, -minSpace2, offset);
            }

            if (offset < 0) {
              //console.log("SHIFTING", node2.id, offset);
              _this3._shiftBlock(node2.id, offset);

              stillShifting = true;
              if (centerParent === true) _this3._centerParent(node2);
            }
          }
        } //this.body.emitter.emit("_redraw");})

      };

      var minimizeEdgeLength = function minimizeEdgeLength(iterations, node) {
        //window.CALLBACKS.push(() => {
        //  console.log("ts",node.id);
        var nodeId = node.id;
        var allEdges = node.edges;
        var nodeLevel = _this3.hierarchical.levels[node.id]; // gather constants

        var C2 = _this3.options.hierarchical.levelSeparation * _this3.options.hierarchical.levelSeparation;
        var referenceNodes = {};
        var aboveEdges = [];

        for (var i = 0; i < allEdges.length; i++) {
          var edge = allEdges[i];

          if (edge.toId != edge.fromId) {
            var otherNode = edge.toId == nodeId ? edge.from : edge.to;
            referenceNodes[allEdges[i].id] = otherNode;

            if (_this3.hierarchical.levels[otherNode.id] < nodeLevel) {
              aboveEdges.push(edge);
            }
          }
        } // differentiated sum of lengths based on only moving one node over one axis


        var getFx = function getFx(point, edges) {
          var sum = 0;

          for (var _i2 = 0; _i2 < edges.length; _i2++) {
            if (referenceNodes[edges[_i2].id] !== undefined) {
              var a = _this3.direction.getPosition(referenceNodes[edges[_i2].id]) - point;
              sum += a / Math.sqrt(a * a + C2);
            }
          }

          return sum;
        }; // doubly differentiated sum of lengths based on only moving one node over one axis


        var getDFx = function getDFx(point, edges) {
          var sum = 0;

          for (var _i3 = 0; _i3 < edges.length; _i3++) {
            if (referenceNodes[edges[_i3].id] !== undefined) {
              var a = _this3.direction.getPosition(referenceNodes[edges[_i3].id]) - point;
              sum -= C2 * Math.pow(a * a + C2, -1.5);
            }
          }

          return sum;
        };

        var getGuess = function getGuess(iterations, edges) {
          var guess = _this3.direction.getPosition(node); // Newton's method for optimization


          var guessMap = {};

          for (var _i4 = 0; _i4 < iterations; _i4++) {
            var fx = getFx(guess, edges);
            var dfx = getDFx(guess, edges); // we limit the movement to avoid instability.

            var limit = 40;
            var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));
            guess = guess - ratio; // reduce duplicates

            if (guessMap[guess] !== undefined) {
              break;
            }

            guessMap[guess] = _i4;
          }

          return guess;
        };

        var moveBranch = function moveBranch(guess) {
          // position node if there is space
          var nodePosition = _this3.direction.getPosition(node); // check movable area of the branch


          if (branches[node.id] === undefined) {
            var branchNodes = {};
            getBranchNodes(node, branchNodes);
            branches[node.id] = branchNodes;
          }

          var branchBoundary = getBranchBoundary(branches[node.id]);
          var minSpaceBranch = branchBoundary[2];
          var maxSpaceBranch = branchBoundary[3];
          var diff = guess - nodePosition; // check if we are allowed to move the node:

          var branchOffset = 0;

          if (diff > 0) {
            branchOffset = Math.min(diff, maxSpaceBranch - _this3.options.hierarchical.nodeSpacing);
          } else if (diff < 0) {
            branchOffset = -Math.min(-diff, minSpaceBranch - _this3.options.hierarchical.nodeSpacing);
          }

          if (branchOffset != 0) {
            //console.log("moving branch:",branchOffset, maxSpaceBranch, minSpaceBranch)
            _this3._shiftBlock(node.id, branchOffset); //this.body.emitter.emit("_redraw");


            stillShifting = true;
          }
        };

        var moveNode = function moveNode(guess) {
          var nodePosition = _this3.direction.getPosition(node); // position node if there is space


          var _this3$_getSpaceAroun3 = _this3._getSpaceAroundNode(node),
              _this3$_getSpaceAroun4 = _slicedToArray(_this3$_getSpaceAroun3, 2),
              minSpace = _this3$_getSpaceAroun4[0],
              maxSpace = _this3$_getSpaceAroun4[1];

          var diff = guess - nodePosition; // check if we are allowed to move the node:

          var newPosition = nodePosition;

          if (diff > 0) {
            newPosition = Math.min(nodePosition + (maxSpace - _this3.options.hierarchical.nodeSpacing), guess);
          } else if (diff < 0) {
            newPosition = Math.max(nodePosition - (minSpace - _this3.options.hierarchical.nodeSpacing), guess);
          }

          if (newPosition !== nodePosition) {
            //console.log("moving Node:",diff, minSpace, maxSpace);
            _this3.direction.setPosition(node, newPosition); //this.body.emitter.emit("_redraw");


            stillShifting = true;
          }
        };

        var guess = getGuess(iterations, aboveEdges);
        moveBranch(guess);
        guess = getGuess(iterations, allEdges);
        moveNode(guess); //})
      }; // method to remove whitespace between branches. Because we do bottom up, we can center the parents.


      var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp(iterations) {
        var levels = _this3.hierarchical.getLevels();

        levels = reverse(levels).call(levels);

        for (var i = 0; i < iterations; i++) {
          stillShifting = false;

          for (var j = 0; j < levels.length; j++) {
            var level = levels[j];
            var levelNodes = _this3.hierarchical.distributionOrdering[level];

            for (var k = 0; k < levelNodes.length; k++) {
              minimizeEdgeLength(1000, levelNodes[k]);
            }
          }

          if (stillShifting !== true) {
            //console.log("FINISHED minimizeEdgeLengthBottomUp IN " + i);
            break;
          }
        }
      }; // method to remove whitespace between branches. Because we do bottom up, we can center the parents.


      var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp(iterations) {
        var levels = _this3.hierarchical.getLevels();

        levels = reverse(levels).call(levels);

        for (var i = 0; i < iterations; i++) {
          stillShifting = false;
          shiftElementsCloser(branchShiftCallback, levels, true);

          if (stillShifting !== true) {
            //console.log("FINISHED shiftBranchesCloserBottomUp IN " + (i+1));
            break;
          }
        }
      }; // center all parents


      var centerAllParents = function centerAllParents() {
        for (var nodeId in _this3.body.nodes) {
          if (Object.prototype.hasOwnProperty.call(_this3.body.nodes, nodeId)) _this3._centerParent(_this3.body.nodes[nodeId]);
        }
      }; // center all parents


      var centerAllParentsBottomUp = function centerAllParentsBottomUp() {
        var levels = _this3.hierarchical.getLevels();

        levels = reverse(levels).call(levels);

        for (var i = 0; i < levels.length; i++) {
          var level = levels[i];
          var levelNodes = _this3.hierarchical.distributionOrdering[level];

          for (var j = 0; j < levelNodes.length; j++) {
            _this3._centerParent(levelNodes[j]);
          }
        }
      }; // the actual work is done here.


      if (this.options.hierarchical.blockShifting === true) {
        shiftBranchesCloserBottomUp(5);
        centerAllParents();
      } // minimize edge length


      if (this.options.hierarchical.edgeMinimization === true) {
        minimizeEdgeLengthBottomUp(20);
      }

      if (this.options.hierarchical.parentCentralization === true) {
        centerAllParentsBottomUp();
      }

      shiftTrees();
    }
    /**
     * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.
     * This is used to only get the distances to nodes outside of a branch.
     *
     * @param {Node} node
     * @param {{Node.id: vis.Node}} map
     * @returns {number[]}
     * @private
     */

  }, {
    key: "_getSpaceAroundNode",
    value: function _getSpaceAroundNode(node, map) {
      var useMap = true;

      if (map === undefined) {
        useMap = false;
      }

      var level = this.hierarchical.levels[node.id];

      if (level !== undefined) {
        var index = this.hierarchical.distributionIndex[node.id];
        var position = this.direction.getPosition(node);
        var ordering = this.hierarchical.distributionOrdering[level];
        var minSpace = 1e9;
        var maxSpace = 1e9;

        if (index !== 0) {
          var prevNode = ordering[index - 1];

          if (useMap === true && map[prevNode.id] === undefined || useMap === false) {
            var prevPos = this.direction.getPosition(prevNode);
            minSpace = position - prevPos;
          }
        }

        if (index != ordering.length - 1) {
          var nextNode = ordering[index + 1];

          if (useMap === true && map[nextNode.id] === undefined || useMap === false) {
            var nextPos = this.direction.getPosition(nextNode);
            maxSpace = Math.min(maxSpace, nextPos - position);
          }
        }

        return [minSpace, maxSpace];
      } else {
        return [0, 0];
      }
    }
    /**
     * We use this method to center a parent node and check if it does not cross other nodes when it does.
     *
     * @param {Node} node
     * @private
     */

  }, {
    key: "_centerParent",
    value: function _centerParent(node) {
      if (this.hierarchical.parentReference[node.id]) {
        var parents = this.hierarchical.parentReference[node.id];

        for (var i = 0; i < parents.length; i++) {
          var parentId = parents[i];
          var parentNode = this.body.nodes[parentId];
          var children = this.hierarchical.childrenReference[parentId];

          if (children !== undefined) {
            // get the range of the children
            var newPosition = this._getCenterPosition(children);

            var position = this.direction.getPosition(parentNode);

            var _this$_getSpaceAround = this._getSpaceAroundNode(parentNode),
                _this$_getSpaceAround2 = _slicedToArray(_this$_getSpaceAround, 2),
                minSpace = _this$_getSpaceAround2[0],
                maxSpace = _this$_getSpaceAround2[1];

            var diff = position - newPosition;

            if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {
              this.direction.setPosition(parentNode, newPosition);
            }
          }
        }
      }
    }
    /**
     * This function places the nodes on the canvas based on the hierarchial distribution.
     *
     * @param {object} distribution | obtained by the function this._getDistribution()
     * @private
     */

  }, {
    key: "_placeNodesByHierarchy",
    value: function _placeNodesByHierarchy(distribution) {
      this.positionedNodes = {}; // start placing all the level 0 nodes first. Then recursively position their branches.

      for (var level in distribution) {
        if (Object.prototype.hasOwnProperty.call(distribution, level)) {
          var _context;

          // sort nodes in level by position:
          var nodeArray = keys$4(distribution[level]);

          nodeArray = this._indexArrayToNodes(nodeArray);

          sort(_context = this.direction).call(_context, nodeArray);

          var handledNodeCount = 0;

          for (var i = 0; i < nodeArray.length; i++) {
            var node = nodeArray[i];

            if (this.positionedNodes[node.id] === undefined) {
              var spacing = this.options.hierarchical.nodeSpacing;
              var pos = spacing * handledNodeCount; // We get the X or Y values we need and store them in pos and previousPos.
              // The get and set make sure we get X or Y

              if (handledNodeCount > 0) {
                pos = this.direction.getPosition(nodeArray[i - 1]) + spacing;
              }

              this.direction.setPosition(node, pos, level);

              this._validatePositionAndContinue(node, level, pos);

              handledNodeCount++;
            }
          }
        }
      }
    }
    /**
     * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes
     * on a X position that ensures there will be no overlap.
     *
     * @param {Node.id} parentId
     * @param {number} parentLevel
     * @private
     */

  }, {
    key: "_placeBranchNodes",
    value: function _placeBranchNodes(parentId, parentLevel) {
      var _context2;

      var childRef = this.hierarchical.childrenReference[parentId]; // if this is not a parent, cancel the placing. This can happen with multiple parents to one child.

      if (childRef === undefined) {
        return;
      } // get a list of childNodes


      var childNodes = [];

      for (var i = 0; i < childRef.length; i++) {
        childNodes.push(this.body.nodes[childRef[i]]);
      } // use the positions to order the nodes.


      sort(_context2 = this.direction).call(_context2, childNodes); // position the childNodes


      for (var _i5 = 0; _i5 < childNodes.length; _i5++) {
        var childNode = childNodes[_i5];
        var childNodeLevel = this.hierarchical.levels[childNode.id]; // check if the child node is below the parent node and if it has already been positioned.

        if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === undefined) {
          // get the amount of space required for this node. If parent the width is based on the amount of children.
          var spacing = this.options.hierarchical.nodeSpacing;
          var pos = void 0; // we get the X or Y values we need and store them in pos and previousPos.
          // The get and set make sure we get X or Y

          if (_i5 === 0) {
            pos = this.direction.getPosition(this.body.nodes[parentId]);
          } else {
            pos = this.direction.getPosition(childNodes[_i5 - 1]) + spacing;
          }

          this.direction.setPosition(childNode, pos, childNodeLevel);

          this._validatePositionAndContinue(childNode, childNodeLevel, pos);
        } else {
          return;
        }
      } // center the parent nodes.


      var center = this._getCenterPosition(childNodes);

      this.direction.setPosition(this.body.nodes[parentId], center, parentLevel);
    }
    /**
     * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.
     * Finally it will call _placeBranchNodes to place the branch nodes.
     *
     * @param {Node} node
     * @param {number} level
     * @param {number} pos
     * @private
     */

  }, {
    key: "_validatePositionAndContinue",
    value: function _validatePositionAndContinue(node, level, pos) {
      // This method only works for formal trees and formal forests
      // Early exit if this is not the case
      if (!this.hierarchical.isTree) return; // if overlap has been detected, we shift the branch

      if (this.lastNodeOnLevel[level] !== undefined) {
        var previousPos = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[level]]);

        if (pos - previousPos < this.options.hierarchical.nodeSpacing) {
          var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;

          var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);

          this._shiftBlock(sharedParent.withChild, diff);
        }
      }

      this.lastNodeOnLevel[level] = node.id; // store change in position.

      this.positionedNodes[node.id] = true;

      this._placeBranchNodes(node.id, level);
    }
    /**
     * Receives an array with node indices and returns an array with the actual node references.
     * Used for sorting based on node properties.
     *
     * @param {Array.<Node.id>} idArray
     * @returns {Array.<Node>}
     */

  }, {
    key: "_indexArrayToNodes",
    value: function _indexArrayToNodes(idArray) {
      var array = [];

      for (var i = 0; i < idArray.length; i++) {
        array.push(this.body.nodes[idArray[i]]);
      }

      return array;
    }
    /**
     * This function get the distribution of levels based on hubsize
     *
     * @returns {object}
     * @private
     */

  }, {
    key: "_getDistribution",
    value: function _getDistribution() {
      var distribution = {};
      var nodeId, node; // we fix Y because the hierarchy is vertical,
      // we fix X so we do not give a node an x position for a second time.
      // the fix of X is removed after the x value has been set.

      for (nodeId in this.body.nodes) {
        if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
          node = this.body.nodes[nodeId];
          var level = this.hierarchical.levels[nodeId] === undefined ? 0 : this.hierarchical.levels[nodeId];
          this.direction.fix(node, level);

          if (distribution[level] === undefined) {
            distribution[level] = {};
          }

          distribution[level][nodeId] = node;
        }
      }

      return distribution;
    }
    /**
     * Return the active (i.e. visible) edges for this node
     *
     * @param {Node} node
     * @returns {Array.<vis.Edge>} Array of edge instances
     * @private
     */

  }, {
    key: "_getActiveEdges",
    value: function _getActiveEdges(node) {
      var _this4 = this;

      var result = [];
      forEach$1(node.edges, function (edge) {
        var _context3;

        if (indexOf(_context3 = _this4.body.edgeIndices).call(_context3, edge.id) !== -1) {
          result.push(edge);
        }
      });
      return result;
    }
    /**
     * Get the hubsizes for all active nodes.
     *
     * @returns {number}
     * @private
     */

  }, {
    key: "_getHubSizes",
    value: function _getHubSizes() {
      var _this5 = this;

      var hubSizes = {};
      var nodeIds = this.body.nodeIndices;
      forEach$1(nodeIds, function (nodeId) {
        var node = _this5.body.nodes[nodeId];

        var hubSize = _this5._getActiveEdges(node).length;

        hubSizes[hubSize] = true;
      }); // Make an array of the size sorted descending

      var result = [];
      forEach$1(hubSizes, function (size) {
        result.push(Number(size));
      });

      sort(timsort).call(timsort, result, function (a, b) {
        return b - a;
      });

      return result;
    }
    /**
     * this function allocates nodes in levels based on the recursive branching from the largest hubs.
     *
     * @private
     */

  }, {
    key: "_determineLevelsByHubsize",
    value: function _determineLevelsByHubsize() {
      var _this6 = this;

      var levelDownstream = function levelDownstream(nodeA, nodeB) {
        _this6.hierarchical.levelDownstream(nodeA, nodeB);
      };

      var hubSizes = this._getHubSizes();

      var _loop = function _loop(i) {
        var hubSize = hubSizes[i];
        if (hubSize === 0) return "break";
        forEach$1(_this6.body.nodeIndices, function (nodeId) {
          var node = _this6.body.nodes[nodeId];

          if (hubSize === _this6._getActiveEdges(node).length) {
            _this6._crawlNetwork(levelDownstream, nodeId);
          }
        });
      };

      for (var i = 0; i < hubSizes.length; ++i) {
        var _ret = _loop(i);

        if (_ret === "break") break;
      }
    }
    /**
     * TODO: release feature
     * TODO: Determine if this feature is needed at all
     *
     * @private
     */

  }, {
    key: "_determineLevelsCustomCallback",
    value: function _determineLevelsCustomCallback() {
      var _this7 = this;

      var minLevel = 100000; // TODO: this should come from options.
      // eslint-disable-next-line no-unused-vars -- This should eventually be implemented with these parameters used.

      var customCallback = function customCallback(nodeA, nodeB, edge) {}; // TODO: perhaps move to HierarchicalStatus.
      //       But I currently don't see the point, this method is not used.


      var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {
        var levelA = _this7.hierarchical.levels[nodeA.id]; // set initial level

        if (levelA === undefined) {
          levelA = _this7.hierarchical.levels[nodeA.id] = minLevel;
        }

        var diff = customCallback(NetworkUtil.cloneOptions(nodeA, "node"), NetworkUtil.cloneOptions(nodeB, "node"), NetworkUtil.cloneOptions(edge, "edge"));
        _this7.hierarchical.levels[nodeB.id] = levelA + diff;
      };

      this._crawlNetwork(levelByDirection);

      this.hierarchical.setMinLevelToZero(this.body.nodes);
    }
    /**
     * Allocate nodes in levels based on the direction of the edges.
     *
     * @private
     */

  }, {
    key: "_determineLevelsDirected",
    value: function _determineLevelsDirected() {
      var _context4,
          _this8 = this;

      var nodes = reduce(_context4 = this.body.nodeIndices).call(_context4, function (acc, id) {
        acc.set(id, _this8.body.nodes[id]);
        return acc;
      }, new map());

      if (this.options.hierarchical.shakeTowards === "roots") {
        this.hierarchical.levels = fillLevelsByDirectionRoots(nodes);
      } else {
        this.hierarchical.levels = fillLevelsByDirectionLeaves(nodes);
      }

      this.hierarchical.setMinLevelToZero(this.body.nodes);
    }
    /**
     * Update the bookkeeping of parent and child.
     *
     * @private
     */

  }, {
    key: "_generateMap",
    value: function _generateMap() {
      var _this9 = this;

      var fillInRelations = function fillInRelations(parentNode, childNode) {
        if (_this9.hierarchical.levels[childNode.id] > _this9.hierarchical.levels[parentNode.id]) {
          _this9.hierarchical.addRelation(parentNode.id, childNode.id);
        }
      };

      this._crawlNetwork(fillInRelations);

      this.hierarchical.checkIfTree();
    }
    /**
     * Crawl over the entire network and use a callback on each node couple that is connected to each other.
     *
     * @param {Function} [callback=function(){}]          | will receive nodeA, nodeB and the connecting edge. A and B are distinct.
     * @param {Node.id} startingNodeId
     * @private
     */

  }, {
    key: "_crawlNetwork",
    value: function _crawlNetwork() {
      var _this10 = this;

      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
      var startingNodeId = arguments.length > 1 ? arguments[1] : undefined;
      var progress = {};

      var crawler = function crawler(node, tree) {
        if (progress[node.id] === undefined) {
          _this10.hierarchical.setTreeIndex(node, tree);

          progress[node.id] = true;
          var childNode;

          var edges = _this10._getActiveEdges(node);

          for (var i = 0; i < edges.length; i++) {
            var edge = edges[i];

            if (edge.connected === true) {
              if (edge.toId == node.id) {
                // Not '===' because id's can be string and numeric
                childNode = edge.from;
              } else {
                childNode = edge.to;
              }

              if (node.id != childNode.id) {
                // Not '!==' because id's can be string and numeric
                callback(node, childNode, edge);
                crawler(childNode, tree);
              }
            }
          }
        }
      };

      if (startingNodeId === undefined) {
        // Crawl over all nodes
        var treeIndex = 0; // Serves to pass a unique id for the current distinct tree

        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var nodeId = this.body.nodeIndices[i];

          if (progress[nodeId] === undefined) {
            var node = this.body.nodes[nodeId];
            crawler(node, treeIndex);
            treeIndex += 1;
          }
        }
      } else {
        // Crawl from the given starting node
        var _node2 = this.body.nodes[startingNodeId];

        if (_node2 === undefined) {
          console.error("Node not found:", startingNodeId);
          return;
        }

        crawler(_node2);
      }
    }
    /**
     * Shift a branch a certain distance
     *
     * @param {Node.id} parentId
     * @param {number} diff
     * @private
     */

  }, {
    key: "_shiftBlock",
    value: function _shiftBlock(parentId, diff) {
      var _this11 = this;

      var progress = {};

      var shifter = function shifter(parentId) {
        if (progress[parentId]) {
          return;
        }

        progress[parentId] = true;

        _this11.direction.shift(parentId, diff);

        var childRef = _this11.hierarchical.childrenReference[parentId];

        if (childRef !== undefined) {
          for (var i = 0; i < childRef.length; i++) {
            shifter(childRef[i]);
          }
        }
      };

      shifter(parentId);
    }
    /**
     * Find a common parent between branches.
     *
     * @param {Node.id} childA
     * @param {Node.id} childB
     * @returns {{foundParent, withChild}}
     * @private
     */

  }, {
    key: "_findCommonParent",
    value: function _findCommonParent(childA, childB) {
      var _this12 = this;

      var parents = {};

      var iterateParents = function iterateParents(parents, child) {
        var parentRef = _this12.hierarchical.parentReference[child];

        if (parentRef !== undefined) {
          for (var i = 0; i < parentRef.length; i++) {
            var parent = parentRef[i];
            parents[parent] = true;
            iterateParents(parents, parent);
          }
        }
      };

      var findParent = function findParent(parents, child) {
        var parentRef = _this12.hierarchical.parentReference[child];

        if (parentRef !== undefined) {
          for (var i = 0; i < parentRef.length; i++) {
            var parent = parentRef[i];

            if (parents[parent] !== undefined) {
              return {
                foundParent: parent,
                withChild: child
              };
            }

            var branch = findParent(parents, parent);

            if (branch.foundParent !== null) {
              return branch;
            }
          }
        }

        return {
          foundParent: null,
          withChild: child
        };
      };

      iterateParents(parents, childA);
      return findParent(parents, childB);
    }
    /**
     * Set the strategy pattern for handling the coordinates given the current direction.
     *
     * The individual instances contain all the operations and data specific to a layout direction.
     *
     * @param {Node} node
     * @param {{x: number, y: number}} position
     * @param {number} level
     * @param {boolean} [doNotUpdate=false]
     * @private
     */

  }, {
    key: "setDirectionStrategy",
    value: function setDirectionStrategy() {
      var isVertical = this.options.hierarchical.direction === "UD" || this.options.hierarchical.direction === "DU";

      if (isVertical) {
        this.direction = new VerticalStrategy(this);
      } else {
        this.direction = new HorizontalStrategy(this);
      }
    }
    /**
     * Determine the center position of a branch from the passed list of child nodes
     *
     * This takes into account the positions of all the child nodes.
     *
     * @param {Array.<Node|vis.Node.id>} childNodes  Array of either child nodes or node id's
     * @returns {number}
     * @private
     */

  }, {
    key: "_getCenterPosition",
    value: function _getCenterPosition(childNodes) {
      var minPos = 1e9;
      var maxPos = -1e9;

      for (var i = 0; i < childNodes.length; i++) {
        var childNode = void 0;

        if (childNodes[i].id !== undefined) {
          childNode = childNodes[i];
        } else {
          var childNodeId = childNodes[i];
          childNode = this.body.nodes[childNodeId];
        }

        var position = this.direction.getPosition(childNode);
        minPos = Math.min(minPos, position);
        maxPos = Math.max(maxPos, position);
      }

      return 0.5 * (minPos + maxPos);
    }
  }]);

  return LayoutEngine;
}();

var css_248z = "div.vis-network div.vis-manipulation {\n  box-sizing: content-box;\n\n  border-width: 0;\n  border-bottom: 1px;\n  border-style: solid;\n  border-color: #d6d9d8;\n  background: #ffffff; /* Old browsers */\n  background: -moz-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #ffffff),\n    color-stop(48%, #fcfcfc),\n    color-stop(50%, #fafafa),\n    color-stop(100%, #fcfcfc)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* IE10+ */\n  background: linear-gradient(\n    to bottom,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#fcfcfc',GradientType=0 ); /* IE6-9 */\n\n  padding-top: 4px;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 28px;\n}\n\ndiv.vis-network div.vis-edit-mode,\ndiv.vis-network button.vis-edit-mode {\n  position: absolute;\n  left: 0;\n  top: 5px;\n  height: 30px;\n}\n\n/* FIXME: shouldn't the vis-close button be a child of the vis-manipulation div? */\n\ndiv.vis-network button.vis-close {\n  position: absolute;\n  right: 0;\n  top: 0;\n  width: 30px;\n  height: 30px;\n\n  background-color: transparent;\n  background-position: 20px 3px;\n  background-repeat: no-repeat;\n  background-image: url('data:image/png;base64,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/GMzLdsAADvGaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTQtMDItMTRUMTE6NTU6MzUrMDE6MDA8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE0LTAyLTE0VDEyOjA1OjE3KzAxOjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxNC0wMi0xNFQxMjowNToxNyswMTowMDwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnhtcC5paWQ6NjU0YmM5YmQtMWI2Yi1jYjRhLTllOWQtNWY2MzgxNDVjZjk0PC94bXBNTTpJbnN0YW5jZUlEPgogICAgICAgICA8eG1wTU06RG9jdW1lbnRJRD54bXAuZGlkOjk4MmM2MGIwLWUzZjMtMDk0MC04MjU0LTFiZTliNWE0ZTE4MzwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjk4MmM2MGIwLWUzZjMtMDk0MC04MjU0LTFiZTliNWE0ZTE4MzwveG1wTU06T3JpZ2luYWxEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06SGlzdG9yeT4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNyZWF0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo5ODJjNjBiMC1lM2YzLTA5NDAtODI1NC0xYmU5YjVhNGUxODM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMTRUMTE6NTU6MzUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjIxODYxNmM2LTM1MWMtNDI0OS04YWFkLWJkZDQ2ZTczNWE0NDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0xNFQxMTo1NTozNSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6NjU0YmM5YmQtMWI2Yi1jYjRhLTllOWQtNWY2MzgxNDVjZjk0PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAyLTE0VDEyOjA1OjE3KzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjc8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NzwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+cZUZMwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAA2ElEQVR42gDLADT/AS0tLUQFBQUVFxcXtPHx8fPl5eUNCAgITCkpKesEHx8fGgYGBjH+/v4a+Pj4qgQEBFU6OjodMTExzwQUFBSvEBAQEfX19SD19fVqNDQ0CElJSd/9/f2vAwEBAfrn5+fkBwcHLRYWFgsXFxfz29vbo9LS0uwDDQ0NDfPz81orKysXIyMj+ODg4Avh4eEa/f391gMkJCRYPz8/KUhISOMCAgKh8fHxHRsbGx4UFBQQBDk5OeY7Ozv7CAgItPb29vMEBASaJSUlTQ0NDesDAEwpT0Ko8Ri2AAAAAElFTkSuQmCC');\n  border: none;\n  cursor: pointer;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network button.vis-close:hover {\n  opacity: 0.6;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button,\ndiv.vis-network div.vis-edit-mode button.vis-button {\n  float: left;\n  font-family: verdana;\n  font-size: 12px;\n  border: none;\n  box-sizing: content-box;\n  -moz-border-radius: 15px;\n  border-radius: 15px;\n  background-color: transparent;\n  background-position: 0px 0px;\n  background-repeat: no-repeat;\n  height: 24px;\n  margin-left: 10px;\n  cursor: pointer;\n  padding: 0px 8px 0px 8px;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button:hover {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.2);\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button:active {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.5);\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-back {\n  background-image: url('data:image/png;base64,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/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNTowMTowOSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTU6MDE6MDkrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOmI2YjQwMjVkLTAxNjQtMzU0OC1hOTdlLTQ4ZmYxMWM3NTYzMzwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpmOWQ3OGY4ZC1lNzY0LTc1NDgtODZiNy1iNmQ1OGMzZDg2OTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTU6MDE6MDkrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOmI2YjQwMjVkLTAxNjQtMzU0OC1hOTdlLTQ4ZmYxMWM3NTYzMzwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNTowMTowOSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOmY5ZDc4ZjhkLWU3NjQtNzU0OC04NmI3LWI2ZDU4YzNkODY5Nzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4jq1U/AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAVTSURBVHjanFVfTFNnFP+d77ve8qeVFbBrpcVgRrCRFikFByLxwSAaE32oRCHD6JMxxhhn8G2RxxH3MsOTbyYsmCAxPMmMMYtkIUYmK60OO0qAK23BFlNob0uh3x7WS5jLZPpLbm6+k/P9zrm5v9855PF4UFhYCABgjIExBgAgIqRSqRIi6gDQRkQ1RGTB3wgR0e8AHgH4Sa/XR/EBiAiJRAJ04cIF5Ofng4g2n0gkUkxENwF0c843LzHGQEQQQkCLExEA9ALotVgsUQAQQmgNQhJCbF5kjCEUCl0moj4t5na7fTU1NUpVVVXUYrEkASAcDhe8efOmxOfzWScmJqoBdBNR99LS0hWz2dynNSSEAF28eBGFhYVgjCEcDn9HRD1EhIMHD3o9Hs9kWVlZAh9BKBQqGB4edr58+dKZ+6JbJpOpBwBWV1fB6+rqIMsyIpHIFcZYL2MMra2tY5cuXRrfuXNnBtvAYDBk3G63oqpqZm5uzgrgSDKZjBoMhueZTAbc5XIhFouVEtFTxhiOHTs2dv78eS8+Efv374+oqpqZnZ21cs5PJJPJPlmWkyynnBuMMTQ0NHi7uro+mVyDx+Pxulwu71ZOlkqlSonoJhGhvb39s8k1nDx50ss5hyRJN9PpdKlERB2aWjSVaEilUvzBgwcORVEs5eXloXPnzk1sV8BkMiUdDofP7/dXZ7PZDilnIhw4cGBeS1pbW2P37t1zBwKBikQiUUREWFhYsHHO0d7evm0Ru90+/+rVq2rO+XGJiJxEhMrKyhgAjI6OWoeHh5tWVla+4JzDZrO9bW5unhwcHGzz+/32np4e+xaDbfoHAMxmc6ijo2O0oqIiJkkSNjY2HBIRmRljMJvNyWfPnln7+/tPMMZQXl6+0NbW9qK2tjYcj8floaEhqKpq+HCkbD3PzMwYBgYG0NXV9UuusFna2kEgELAQEQ4dOvSis7PzN41Ar9dnrl27NqCNkv/C3bt3zy4tLVmICJxzEBFJRBQmorLFxcWCqqqq0Pj4eO3Y2JhbUZTdra2tL2pra8OJRGLHnTt3zkqS9K+huHU4EhHMZnMoGo0W5OIh7nK5jjLGKq1W69vDhw8rRqMxMjc3t2t5eXnX5ORklc/nM+fl5SWnpqa+0uv1K/n5+Ws6nW5NluXNd15e3ppOp1uz2WyzZ86cGQ0Gg6ZAIFCZzWZ/lYjokRDiuN/vt7W0tMw3NTUpbrd78P79++5gMFgRiUTKHj58WMYYQ3V19etTp05tq6Lp6Wkb5xxCiEfc7XZPM8a6FxcXTfX19a/1en2Gcy5qamreNjY2/qGq6joRZe12+9Tp06e3JY/FYgWPHz8+mhvr3/CWlpbk+vp6PmOseWVlBS6XS9GSJUkSdrs93NDQ8Oe+ffvC/8fJIyMjddFo9Esi6pVleVjT2m0A8Hq9zqGhIefnjoknT544A4GAM/eDbxMReFNTE0pKSpKqqsaI6Pj8/LxVVdWM3W6PfCr5xMTE1zllXS0uLn6aSqXAGxsbodPpoNfrn6uqCs75EUVRrJFIZMfevXsXdTrdxseIE4mEPDIyUu/3++tynd8yGo29RIR0Og26fv06ioqKwBgD5xzv3r27zBjrIyJIkgSHwzFZWVmp7NmzJ1ZaWpoAgGg0WqgoSvHMzIw1GAw6tvjhitFo7NPW5fv370Hd3d0oKCgA53zTQMvLy+VCiKuSJH0rSdLmztZytIWv5RPRD0T0Y3Fx8dzWfby6ugopHo//w4mcc8iyPMc5v5FOp7/PZrOdQohWInIC2C2EgBBigYi8Qoifs9lsv06nWyIiaFxagXg8jr8GAGxuIe7LBeWhAAAAAElFTkSuQmCC');\n}\n\ndiv.vis-network div.vis-manipulation div.vis-none:hover {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0);\n  cursor: default;\n}\ndiv.vis-network div.vis-manipulation div.vis-none:active {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0);\n}\ndiv.vis-network div.vis-manipulation div.vis-none {\n  padding: 0px;\n  line-height: 23px;\n}\ndiv.vis-network div.vis-manipulation div.notification {\n  margin: 2px;\n  font-weight: bold;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-add {\n  background-image: url('data:image/png;base64,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/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDo0MDoyOSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6NDA6MjkrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjVkNWIwNmQwLTVmMjAtOGE0NC1hMzIwLWZmMTEzMzQwNDc0YjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo2OWVmYWE1NS01ZTI5LTIzNGUtYTUzMy0xNDkxYjM1NDNmYmE8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6NDA6MjkrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjVkNWIwNmQwLTVmMjAtOGE0NC1hMzIwLWZmMTEzMzQwNDc0Yjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDo0MDoyOSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjY5ZWZhYTU1LTVlMjktMjM0ZS1hNTMzLTE0OTFiMzU0M2ZiYTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz5WKqp9AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYXSURBVHjafFZtUFTXGX7e9z27sveuMCwYV8ElrA7YSFYHtJUPkaaI0aRqG8wP00zUzljDINNSA/2ROtpO24SxnahlxjYd7SSjmUkymcxYlDhQPzHGisEVp8HwYWCVVVgEsrsuLnL74+5uqTF9Z+7cO/d8PO95zvO851BlZSV0XQcAMDOYGQBARDhX3JRmMDYZwLPMWAzGHACYIgwS46oBNBNwtOL8CwE8EkSEUCgE2rJlC2w2G4go8Zwo/bMDgnoG6gxLfAAAYvPDMCCszKTAMIAGAhrWnf15AAAMwwARIRKJgDZv3gy73Q4iAjPjxIr9VVOMRhbAYKB8zvrO0llrfEsdKwLZek6YAPSFvtSu3GtLawu0ZJ6625SHGBQB1T88t6MxvopgMAjaunUrdF0HM+P4yv27DMYeJmB1RqW3Jnf3tQX2p0L4P9EXuqEd7PmDp+XuMU9sRbvXnnt1TxxACgoKYLVacbzsQDUJGkSATe6qi28uPtzusM6Kxie6NHLGUX3lxVUNX9StPHnn4wy3njuUYcu6n2pNi66avcEXnByP/nv8aiaIyrqz2gO5A9+9FI1GIfn5+WhZdTAdjFMkwMvZOy7uWnTAOz3L4Yk71m3t69fdfTDoUGTBeHTUfiHQ6lo7Z2OXJvpDAChKe+aOCdKRKWxZ2+1qb3yyd3GYmRkQ7GQBVs99wfv6on3eR2k4PdTkDEbH7IuS8/svld/561PJS/pDk1/bzwx94pze7xc5v/H+YPY6r5BAkdrJzODTK46lE6PeYEJt7u+8j+OZwCBiEAgAoNgKJoEQf6PvNvdrXgtZoNhSf7q0KZ3B2AQmVMze0Jmt54S/DcDCVig2NcvEUGxJAE4Pl+YOr0iv6BRSIPAmBeBZAmHlE2sH4p1uhrq1s0MnnEQMBsf8wRASAICQQCCITN1X7/sOuc0kgOVp3/fPs2WHv+coG7gQOJUnLGsUCTxEjPzUohEA+NfIWUdtx0+efzA1kSSkIGyBAQNCKgHAEBAJ3u79U7kiAcWoem/gb5Fd33nrH3kp+SMWtuAB+GllMJxMjCx9QRgA3uiqL5kwHiTlpxb3smlfMDGYGPP1hcMAkJvs8ScpfdJspdj+MK6Pf+5+u29vyb4lR4+BGEziVESAkEpw6Av1OhUpHCz4qOXbzFWz4Ncdj/v/o08Lt92ODDgZDCEFJYoUGH4mzugP92puPTf0pD3H7wvfdFZdqSxnMtWjoGAAmG9fOLxjwesdjT2/XzIQ7ks3sycYMSEwGHNtWf5bkX5NkYCJBxUBXiGV0XHvosOt54Zey33j/K+8P33++vjnbiGJbbLE+J9SANAb6nJ2B79wcUwETAwQQ7fMjPzMvfP8ja87HUIKMOiaAqMZhrGmLdAy78eZrwwsTS0eObTs+IdtgVanxBUExqGbb5VzrIISGIoUXsmqbgEhJldCQWqRf27SvPAn/o8XmgLhZsUkR4ll37mhk3n94Z4OlzY/7NLcYZfm7o1z2zT4vsvUNSXqprBCkmiTFbPX90/fh8GIT2sf+zTPdDMf4dVnNg4z+E0ixsGeBs9jd5ViSgLHjCb/peaR+MD3d4/ZJg2llyuG2Vwy7QWAs8PNnn1f7vkGSGxAzE6mk+kxkx/p/4unffSCR0hAoL1EBCYiPNdWNcwkNQTCR7feWX6g+7f/A7I8rcw/U6UEe0Ndrhc/W7mtL9ztmqlSgstSS/zTJ28dalpOpkRryrwbhwBACgsLMWPGDOT4ll3qyeqAkJTdCF7P/CrUY/GkLL1rE+2hTbSH8+0Lb/WEuhzhyaA905blf9Vd/895WnZwLHrPevir/cvOB1oLYpTtLrm6oYGIMDExAaqtrUVKSgqYGSKCk0WHq5ikkWEWtNL0imv5qUW+RclLRjJsrhBAuH1/QL8R7HR4xy5nescuP23E6hOA6mLv+sb4uTw6Ogqqq6uDpmkQkcStorX4XRcM1FjZ+kvFFjCJKU1WpkNJJUqIMtX1RyLeX3JtQ0JRhmGYZ/L27duRnJycuFGISOJ9pqh5lrB6iYgqGOxRrOaa54DcZmKvkJxk8JHC9rKh+KVhOsD4+Dj+MwADIf8n5m4xGwAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-edit,\ndiv.vis-network div.vis-edit-mode button.vis-button.vis-edit {\n  background-image: url('data:image/png;base64,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/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNVQxNDoxMjoyNSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDVUMTQ6MTI6MjUrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjY5OTM3ZGZjLTJjNzQtYTU0YS05OTIzLTQyMmZhNDNkMjljNDwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDozOWNhNzE5ZC03YzNlLTUyNGEtYmY1NS03NGVmMmM1MzE0YTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDVUMTQ6MTI6MjUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjY5OTM3ZGZjLTJjNzQtYTU0YS05OTIzLTQyMmZhNDNkMjljNDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNVQxNDoxMjoyNSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjM5Y2E3MTlkLTdjM2UtNTI0YS1iZjU1LTc0ZWYyYzUzMTRhNzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4ykninAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYpSURBVHjafFZtTFvnFX7Oea+NudiY2Hwam4CBlgQwXdKREDKUoYg0jbRJ29RJ2VZ1mjRFUxSpA3VTfkzJfkQbS7spU6rtx5Z2UtppScjaHxvLuiatWi2jLEoMIUDCh23g2gbj7+tPuPvhOurawPl1dc99n+c55z33fV46ceIEZFkGADAziAgAQERoe/9ZK4GPM/AcgbsIXAcABCgMvkfAqAa89eDoJyF8LogIqqqChoaGYDAYHr8kItS8uc8iIH6iAa9IkAo5EAQX8pqmgUVBCBggYFgDhv0/GAsBgKZpICJkMhnQ4OAgZFkGEYGZUXmp+0cS+CKBwWA0DVRPOg5Zl2q6zaHyJlnVAMQXVTkwHrUqH0Xsvn+tdQAAMQDgpPLS2MViFY8rkGUZzIzaS/t/xqCzGggtz9e697zsnKhoLUtim4jOq/LE6x7X0nsh16dEZ5a/O3a2SCAOHjwInU6Hujd6ThJ4mCDQ+b2G232v7v6vwarPbQn8MGlMr+X0kpE3Wr5Zt5hL5HPhqYSdQIfKJ+yhxDPKWC6Xg+jt7UXD5b5KBt1kCHS85Ljd8/On3NupfnhFaZj4rWff1B98B1R/hnUmKd36bdtCNl4g0en4edNE/cXwLq8qMTMIPAQwmo/WuHvObA8+9c58k/dKtD0TyZWXN5YGA7ej7epKxspM//7SoNOdWc/Jyq2wiwhDzPxT8cP0jys3VMM7OmL0/77zn4Ydui3b8uiK0jD7RrA77c9Wd57cefPpF+2T6bWsFPWkaiPTCWvTsZpHFU+XrS+8G3AR08F6X+1FJvBxQQzHQOWk2SmrW4FPX/U2LVwPuDZj+fJKl2khPpeyAqA9rzR/YqwuiWXX8taN/CabGkrVuq9YJlkQQDjOAJ5jAhz9Vt9W4N5/rNp8I+vtMV/aZm4zLnUNNt0urdYnF68HWoJj4Wo1mLGUNRr8LEgDgNqeCh8xQIKOsgC7iAjVe83rT9zQa8uNM28u70kspessu8q8zq/V3NcZpVzb9+0zmVhOvvvrhaMVzrJg0zeq7xMVCCwdpnWSGBqjUyJwLTFgbvxie3w31uoWR1Y74r60rdxZqrR8q85t2W2MGCp12bm/KC3hyaSTiMhxuGrKcahqpbjOaDOoEhOEoFqJQCCJvqA85I6bfTdDjQlf2lbxVNlS6wt19yy7jRHZZlDnrinNj/6sHMhnNw2Ogco7O79e5fm/xQywRBBCEAuwn4gQ96bkYj4Vyuq9N1Z3Bj4Od5bs0MXt/dZZ21ctiqFan174q985P+Lfp+U1g7XDON/1ctP458WlVjLyJhOISZE0wM0S1QfuRC3lTjkJAKKEtNC9eIOhSh9xHLZOJRZTFuXDsEoStLkR/768ummsaJG9Pb9oe+9J+xaeSVokiQDSJphAo5uaBuWjiKP4QTqS1cUWU7ayesN66wu22frD1vmVW6GW6T8u9eVjGyZzs+w78Nqu0a2mbvVu1KEJQAgeZRL0liQYyx+GOmKeQpu0rMYsAJPNEFGD2dLodLIy6c9Ys7G8yeSUl3tf2/X3rcBVJSOv34l3sCBogi7z1LH/rBHjl4IJ93/ncQFAnjeImJD0Z8zuCwu9q3djDXqTlAKID5xv+9t2R8n8VcUFBljQ8Gyfe40BYBM4DwDLt8Kue79ZcFkbzfEdbUbv+oN4c9KTtsfm1MbYQqqh+2zrVZYKs/7Ef+byimt1POYiJhDhPBFBIiIEXhxfs7/dfYoIF+auBfYTE/pebx/V8hqBP2ODvD34yvuh/WCAmU75Bx6sIgaI/v5+6PV6JLqUsYr7dpDAoehs0h73pHTWrvKgThYbRSt9UmSjef3MpaUvBz4O72UmADgTOPJguGiZor+/HyUlJWBmJFz+D8xTtlUiOpbwpmrmrweeSXrT+g11k4SBN3RGKUcAVCVdFhyP1nreDbY//NPyEXUlU/Pp4XYycGT6V0Ux2WwWdO7cOZSWlkII8diX7SPPNgDaKdbxoNAxwATBAEkEEgSWCEQAqPAMwqvMdCEwMO0tVqZpWsGTT58+DaPR+PhGIYQAAAgh0P7B3ioW/B0iGiCGiwXbCuOHFSJys6AbYFye2T+xWhT3WYJEIoH/DQBMw3kes8OJPgAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-edit-mode button.vis-button.vis-edit.vis-edit-mode {\n  background-color: #fcfcfc;\n  border: 1px solid #cccccc;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-connect {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDozODo1NyswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6Mzg6NTcrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjlmYjUwMDU0LWE3ODEtMWQ0OC05ZTllLTU2ZWQ5YzhlYjdjNjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo3ZWRhMjI0MC0yYTQxLTNlNDQtYWM2My1iNzNiYTE5OWI3Y2E8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6Mzg6NTcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjlmYjUwMDU0LWE3ODEtMWQ0OC05ZTllLTU2ZWQ5YzhlYjdjNjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDozODo1NyswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjdlZGEyMjQwLTJhNDEtM2U0NC1hYzYzLWI3M2JhMTk5YjdjYTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4ubxs+AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAUtSURBVHjajJZ/bNT1Gcdfz/P53PV6B4W7VltLqdAaplIOiMOoyxxJCSs/Gv/yB4gzJroAosmmDklwkYWR0bQsdmkykoojTpcsWYLxD/lRZdMQkTHRtkLZRqG0tIVe7662vTu43n32x/VKZ/jh89cn38/zvN7P5/l88zwf2blzJz6fDwARQUSm1n8s31CM0/VAnbNmsUPuAsDpgEO+Bg4C7//iyv5hvmMiQiqVQpqamvB6vVNwEeG1JZtCBrYi/MrkAwDNgjhwAlbzICBLA0rDb0+/839C6XQaaWxspLCw8Dp86cbNmqVFJQddE6KzdjZ9D89g+B6fSyCOcyn1nxil+O9xKg5HqWFSHGXLjrP7W/ICqVQK2bNnDz6fDxFh65KNvxbHDhF4rJj2bXPo+IGfcW5h5xL4f99P+FCEMIAob75x9t0dAMlkElNXV4e1lteXbNqiQoMaeOFOjrdU868SD2luYyEP6dUh+sYmSHeOU6GO5Z8VLx5+NNZxIpPJ5AS2L3upROCoCvz8Lo7vnkf77cAHhpiz/zIL9vWz8L8p/NvupmM0Q7pjnAoLqz8tDrc8MnQqYVUVhVdF4LEg7b+rvDn8wDDlH0WoPpukLJImSBaMwjcJqmwWts2jPZLG/8kwYVFeVdXXZcFf4yVDc2cNKfBFmD9X+0ncCP58F48eG+Feo2CAUkvs4dl0V/uJvdXLiiV+ut++n7YLSfxPfMMG54ChzB3WIesVWB2i82bw1AR6fJR7C4VsfYiv6u/k3A9nEgP4zXke8DiYHyAOMK+QxPIgnZ9GqSHr1itQJ8DK2fTerDQ+S/bHRXQJaHSCwNIZ2Xh+7+S3VAmwNMBA/tuPZtErgKquUmdMWIFlRURvdamRNEXGwIWrlP47pTMzLiunxghGMwTLvcTWlHAp77s4QNSrYMQtss6ZMgWqCm5cHoDHO1nbk6K8zEN8+3zatv2Hn1b59EqJZdxmYUERg9P9KwpIiAOTdWUWBXuLzB/vZG3P1Un4PNp2d1MbmyD45TWCxuCsQm0x56bHGHFYEZwxok7toAA9Sfw3hCcoL/NOwi9QO5wmWO1j4JEgZxTkodmcWRGkf3pcX0r8xoAaBixKu4U5/xwndM+0tpAvS6mP+PZK2nb1UBvPEKwKMLDvPj4ESGc55lGy303sdJKQdZB2rkMdctAB/4gzN+/Q2ENNd4LyUi/xN+bTtquX2thk5nk4wI3gAF+OMNcA1nFQDfK+BY5GqbkwWabTY5QZhXWlnNx1ntrY1Rz87fuvw29m/Sn8J+PUGAFj5T19baA1IspuBZp7cx1x4SwG1cEf+lgRSROs8jGwb+Ht4QB/GSSsAhYano39LWIBxNEIbP14hPDuiyS2VtJuHXQlKKvxM/jiXDq/D/xPlwifGMkJZB2NIoKpr69nxeiZxLHicFSFVWfGqBidIP3LSjrWltD94CyufF/4kQgPuVz2Lz93+dDRa9eu5QQ8Hg8/iXee+Dy4CKMs7xqn4nwKz9IirhQqmVuB42m8ey+x7LMoD6iAON782eChhqmRuXfvXgKBAKqKqtI0/8nNKrQI4BVYXkzHgzPpC88gWuHL/caXrhLoGiN0apSKr0ZZRBZM7q2w5ZnLR1oAnHOMjY0hra2tFBQUYIyZmstvVT1Z6eDlAuEVq7merxmwueNPDXy9PvybjKP5mctHLk4/XTKZRJqbm/H7/VNw1VyEMYbW4FN3WNWnnchKoy5sHeVGBRX6VWi3ymFx7r11Ix8MTX/y5C2RSPC/AQB61erowbpqSwAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-delete {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDo0MTowNCswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6NDE6MDQrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjc3NDkzYmUxLTEyZGItOTg0NC1iNDYyLTg2NGVmNGIzMzM3MTwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDowNmE3NWYwMy04MDdhLWUzNGYtYjk1Zi1jZGU2MjM0Mzg4OGY8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6NDE6MDQrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjc3NDkzYmUxLTEyZGItOTg0NC1iNDYyLTg2NGVmNGIzMzM3MTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDo0MTowNCswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjA2YTc1ZjAzLTgwN2EtZTM0Zi1iOTVmLWNkZTYyMzQzODg4Zjwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4aYJzYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYGSURBVHjalJZ7UJTnFcZ/73m/72PdJY1RbhoQp6lkXRAvmIYxdCUadLVOozPNtGObap1JsKipjiShbdoRbeKEiQHpQK3xj0xa03aamTbaTGyAYV1QGeqFi+JyiZFLAlmESBkWRmS3fyzslGkmnZ5/v/M873Oe75zzvqqoqAibzQaAiKCUAkApRdHIK/NFsx2NR91nOSILADDoJyzNaM4xxbtvPHh0iC+JiYkJ1OHDh4mJiUEpFSXPv/ziPC28TIiXDCOSrAClQDSEpsCwJPIhrEBRQpiSytXlQwDhcBilFPfu3UMVFxdjt9ujFTzfcLBADCoEEAFr1ZbrrNjch2vtEImPBgHob7fTcWE+bVXJNJ/NiFQlEGLvieXHKmYqGB8fRx05cgSbzYaIsPvywV8pKFaA7fGtLTzz61YWpo/xVTHQbufsq5lcez9zWuWhk5mvFwMEg0H0+vXrMU2Tn1wp3CtCiQ5DjGd3A/m/v8IDCZP8r4iNmyRrWx/j/5qktykZpXKzAjVDVxPzGqemptDr1q1jX3NRnIJarcDKK2hgR2ULXRfncv7UYv7xpovhnhiW5Mz+kefeSKO6LJ1A1xzEuk/Ojm4mRibpuZaMZW3OCtRUND60NmiICCIUShisx7a2sLMiQn4s77uEQgIabnqdfHIlgT1/qQeg8vs5dHhdCNB1wYn3RIiC995j26stjAbsNH+YiZJCESnS1Y/XxIXu8r4YIPv/VkVs3CTnTy2ms34xro1+sp9po6sxlTu34ultmsPVvy6is86FCHgO+DDs49zpjufBpCG+seYOC9OHaTidieicb9ouVAhKtouAseI710ma7pLuqwmgYfHqAFt+6WdLoQ/LBl11Lm7VudAa8vb72PCin9TlAWIsGGhLACD+kSAZnusYBii1XQAPYWDllt6ov2lrBkDBR2+6Ofuak2//3M+G/T4wAAPW7fPhKfRTVeqk9qQbFKRmDUTxS3N7QYGYmwzCkqklBGlPDEcTNv+sg9tNCbTXuvBWujE0bHrZj9JE1B/wU1Pm5PwJN6YBS9a2kVvQEcWnrh5GTFD3lxkYkqRMgYQlwVldUvDnen73LHTUuqitdKM0eAr9AFQfd1J/yo2aJn+2sn4Wdn5qEFODJskgBIjx5T0uCrQA08pnIjS9PERDjPnfOKXAMEBECUoGEIHBj+2zkt76UQ6dXheGAev3+cg74Kf6uJPqcicbfuond7cPy4SOiy7+tD9nFvZurx00KOk3CNEC+mE+vjSPBc7IWqgqTaPT60IMcO/xsXGa3HfKjRgRdbl7/KDg0jtubje6aHj7c7J3dgLQ2zoPwwQ91SooOQdAW1VKVMHty0kA5Bb48BycJn/LjWFGbLv4thvvb53kFvjJ+XEdWkPfjQVR/CcNKYgGMc8JWt5Fa2j+MIPPuyI2pa4IoHSkt6vLIuRaQ9q32khzt4GCxtNu6k46GeiIR2lIfDQQsafPzq1LGRGL9Gk9d+vrwewvfHPQOoexQVjxdB/auk/zmaUMdsfz6bVUtIalT7bxveP1ZHh6GPDPYeSzeD69kcpIfxymFWLNrka+ljhBTWkWwz2JiJT84YHnz2iPx0P20PkmRF5i6HYiwZFJsn/YzdezbzE3cQibY5xV266z6RfXohakb+xB9CjanCD9qTbW7Grk4WV38VZm0l6dhQiEw9taHSuDqrS0FIfDwXM3X9mHMsvRAk/sauDpQy38P+GtzOTGB9mEpkD0C2dS8n8zOjqK9ng8WJZFU+JTjasGvaCNXPpvJBPoMlm0OoDNMfWVxONfWNSUPUZ7TUQ56tCZlPwSgMnJSVRpaSmxsbFE1raw82ZxAZZRQUiBYUKGp5UlOX2krBzmoUVjiIKhHge9rfPo+Wcy3ZeXIYASgL1/X5RfMXMvj46OosrLy7HZbGitUUohIuzoem0RofALaOsghgWGjky0MiJTL8b0lOvI8hN1DKXKP0jd3TNTWDgcJhgMoo4ePYrD4Yi+KmaeLlprnrtXFo9h/AAlG1AqE8yFmBrC+jO0bgH9EVpO/1F2Dc5g//OAsbEx/j0Af+USsQynL1UAAAAASUVORK5CYII=');\n}\n/* top right bottom left */\ndiv.vis-network div.vis-manipulation div.vis-label,\ndiv.vis-network div.vis-edit-mode div.vis-label {\n  margin: 0 0 0 23px;\n  line-height: 25px;\n}\ndiv.vis-network div.vis-manipulation div.vis-separator-line {\n  float: left;\n  display: inline-block;\n  width: 1px;\n  height: 21px;\n  background-color: #bdbdbd;\n  margin: 0px 7px 0 15px; /*top right bottom left*/\n}\n\n/* TODO: is this redundant?\ndiv.network-navigation_wrapper {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n*/\n";
styleInject(css_248z);

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof symbol !== "undefined" && getIteratorMethod$1(o) || o["@@iterator"]; if (!it) { if (isArray$2(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { var _context32; if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = slice(_context32 = Object.prototype.toString.call(o)).call(_context32, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from$3(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Clears the toolbar div element of children
 *
 * @private
 */

var ManipulationSystem = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {Canvas} canvas
   * @param {SelectionHandler} selectionHandler
   * @param {InteractionHandler} interactionHandler
   */
  function ManipulationSystem(body, canvas, selectionHandler, interactionHandler) {
    var _this = this,
        _context,
        _context2;

    _classCallCheck(this, ManipulationSystem);

    this.body = body;
    this.canvas = canvas;
    this.selectionHandler = selectionHandler;
    this.interactionHandler = interactionHandler;
    this.editMode = false;
    this.manipulationDiv = undefined;
    this.editModeDiv = undefined;
    this.closeDiv = undefined;
    this._domEventListenerCleanupQueue = [];
    this.temporaryUIFunctions = {};
    this.temporaryEventFunctions = [];
    this.touchTime = 0;
    this.temporaryIds = {
      nodes: [],
      edges: []
    };
    this.guiEnabled = false;
    this.inMode = false;
    this.selectedControlNode = undefined;
    this.options = {};
    this.defaultOptions = {
      enabled: false,
      initiallyActive: false,
      addNode: true,
      addEdge: true,
      editNode: undefined,
      editEdge: true,
      deleteNode: true,
      deleteEdge: true,
      controlNodeStyle: {
        shape: "dot",
        size: 6,
        color: {
          background: "#ff0000",
          border: "#3c3c3c",
          highlight: {
            background: "#07f968",
            border: "#3c3c3c"
          }
        },
        borderWidth: 2,
        borderWidthSelected: 2
      }
    };

    assign$2(this.options, this.defaultOptions);

    this.body.emitter.on("destroy", function () {
      _this._clean();
    });
    this.body.emitter.on("_dataChanged", bind$6(_context = this._restore).call(_context, this));
    this.body.emitter.on("_resetData", bind$6(_context2 = this._restore).call(_context2, this));
  }
  /**
   * If something changes in the data during editing, switch back to the initial datamanipulation state and close all edit modes.
   *
   * @private
   */


  _createClass(ManipulationSystem, [{
    key: "_restore",
    value: function _restore() {
      if (this.inMode !== false) {
        if (this.options.initiallyActive === true) {
          this.enableEditMode();
        } else {
          this.disableEditMode();
        }
      }
    }
    /**
     * Set the Options
     *
     * @param {object} options
     * @param {object} allOptions
     * @param {object} globalOptions
     */

  }, {
    key: "setOptions",
    value: function setOptions(options, allOptions, globalOptions) {
      if (allOptions !== undefined) {
        if (allOptions.locale !== undefined) {
          this.options.locale = allOptions.locale;
        } else {
          this.options.locale = globalOptions.locale;
        }

        if (allOptions.locales !== undefined) {
          this.options.locales = allOptions.locales;
        } else {
          this.options.locales = globalOptions.locales;
        }
      }

      if (options !== undefined) {
        if (typeof options === "boolean") {
          this.options.enabled = options;
        } else {
          this.options.enabled = true;
          deepExtend(this.options, options);
        }

        if (this.options.initiallyActive === true) {
          this.editMode = true;
        }

        this._setup();
      }
    }
    /**
     * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.
     *
     * @private
     */

  }, {
    key: "toggleEditMode",
    value: function toggleEditMode() {
      if (this.editMode === true) {
        this.disableEditMode();
      } else {
        this.enableEditMode();
      }
    }
    /**
     * Enables Edit Mode
     */

  }, {
    key: "enableEditMode",
    value: function enableEditMode() {
      this.editMode = true;

      this._clean();

      if (this.guiEnabled === true) {
        this.manipulationDiv.style.display = "block";
        this.closeDiv.style.display = "block";
        this.editModeDiv.style.display = "none";
        this.showManipulatorToolbar();
      }
    }
    /**
     * Disables Edit Mode
     */

  }, {
    key: "disableEditMode",
    value: function disableEditMode() {
      this.editMode = false;

      this._clean();

      if (this.guiEnabled === true) {
        this.manipulationDiv.style.display = "none";
        this.closeDiv.style.display = "none";
        this.editModeDiv.style.display = "block";

        this._createEditButton();
      }
    }
    /**
     * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.
     *
     * @private
     */

  }, {
    key: "showManipulatorToolbar",
    value: function showManipulatorToolbar() {
      // restore the state of any bound functions or events, remove control nodes, restore physics
      this._clean(); // reset global variables


      this.manipulationDOM = {}; // if the gui is enabled, draw all elements.

      if (this.guiEnabled === true) {
        var _context3, _context4;

        // a _restore will hide these menus
        this.editMode = true;
        this.manipulationDiv.style.display = "block";
        this.closeDiv.style.display = "block";
        var selectedNodeCount = this.selectionHandler.getSelectedNodeCount();
        var selectedEdgeCount = this.selectionHandler.getSelectedEdgeCount();
        var selectedTotalCount = selectedNodeCount + selectedEdgeCount;
        var locale = this.options.locales[this.options.locale];
        var needSeperator = false;

        if (this.options.addNode !== false) {
          this._createAddNodeButton(locale);

          needSeperator = true;
        }

        if (this.options.addEdge !== false) {
          if (needSeperator === true) {
            this._createSeperator(1);
          } else {
            needSeperator = true;
          }

          this._createAddEdgeButton(locale);
        }

        if (selectedNodeCount === 1 && typeof this.options.editNode === "function") {
          if (needSeperator === true) {
            this._createSeperator(2);
          } else {
            needSeperator = true;
          }

          this._createEditNodeButton(locale);
        } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {
          if (needSeperator === true) {
            this._createSeperator(3);
          } else {
            needSeperator = true;
          }

          this._createEditEdgeButton(locale);
        } // remove buttons


        if (selectedTotalCount !== 0) {
          if (selectedNodeCount > 0 && this.options.deleteNode !== false) {
            if (needSeperator === true) {
              this._createSeperator(4);
            }

            this._createDeleteButton(locale);
          } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {
            if (needSeperator === true) {
              this._createSeperator(4);
            }

            this._createDeleteButton(locale);
          }
        } // bind the close button


        this._bindElementEvents(this.closeDiv, bind$6(_context3 = this.toggleEditMode).call(_context3, this)); // refresh this bar based on what has been selected


        this._temporaryBindEvent("select", bind$6(_context4 = this.showManipulatorToolbar).call(_context4, this));
      } // redraw to show any possible changes


      this.body.emitter.emit("_redraw");
    }
    /**
     * Create the toolbar for adding Nodes
     */

  }, {
    key: "addNodeMode",
    value: function addNodeMode() {
      var _context6;

      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      this.inMode = "addNode";

      if (this.guiEnabled === true) {
        var _context5;

        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};

        this._createBackButton(locale);

        this._createSeperator();

        this._createDescription(locale["addDescription"] || this.options.locales["en"]["addDescription"]); // bind the close button


        this._bindElementEvents(this.closeDiv, bind$6(_context5 = this.toggleEditMode).call(_context5, this));
      }

      this._temporaryBindEvent("click", bind$6(_context6 = this._performAddNode).call(_context6, this));
    }
    /**
     * call the bound function to handle the editing of the node. The node has to be selected.
     */

  }, {
    key: "editNode",
    value: function editNode() {
      var _this2 = this;

      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      var node = this.selectionHandler.getSelectedNodes()[0];

      if (node !== undefined) {
        this.inMode = "editNode";

        if (typeof this.options.editNode === "function") {
          if (node.isCluster !== true) {
            var data = deepExtend({}, node.options, false);
            data.x = node.x;
            data.y = node.y;

            if (this.options.editNode.length === 2) {
              this.options.editNode(data, function (finalizedData) {
                if (finalizedData !== null && finalizedData !== undefined && _this2.inMode === "editNode") {
                  // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
                  _this2.body.data.nodes.getDataSet().update(finalizedData);
                }

                _this2.showManipulatorToolbar();
              });
            } else {
              throw new Error("The function for edit does not support two arguments (data, callback)");
            }
          } else {
            alert(this.options.locales[this.options.locale]["editClusterError"] || this.options.locales["en"]["editClusterError"]);
          }
        } else {
          throw new Error("No function has been configured to handle the editing of nodes.");
        }
      } else {
        this.showManipulatorToolbar();
      }
    }
    /**
     * create the toolbar to connect nodes
     */

  }, {
    key: "addEdgeMode",
    value: function addEdgeMode() {
      var _context8, _context9, _context10, _context11, _context12;

      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      this.inMode = "addEdge";

      if (this.guiEnabled === true) {
        var _context7;

        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};

        this._createBackButton(locale);

        this._createSeperator();

        this._createDescription(locale["edgeDescription"] || this.options.locales["en"]["edgeDescription"]); // bind the close button


        this._bindElementEvents(this.closeDiv, bind$6(_context7 = this.toggleEditMode).call(_context7, this));
      } // temporarily overload functions


      this._temporaryBindUI("onTouch", bind$6(_context8 = this._handleConnect).call(_context8, this));

      this._temporaryBindUI("onDragEnd", bind$6(_context9 = this._finishConnect).call(_context9, this));

      this._temporaryBindUI("onDrag", bind$6(_context10 = this._dragControlNode).call(_context10, this));

      this._temporaryBindUI("onRelease", bind$6(_context11 = this._finishConnect).call(_context11, this));

      this._temporaryBindUI("onDragStart", bind$6(_context12 = this._dragStartEdge).call(_context12, this));

      this._temporaryBindUI("onHold", function () {});
    }
    /**
     * create the toolbar to edit edges
     */

  }, {
    key: "editEdgeMode",
    value: function editEdgeMode() {
      // when using the gui, enable edit mode if it wasn't already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      this.inMode = "editEdge";

      if (_typeof(this.options.editEdge) === "object" && typeof this.options.editEdge.editWithoutDrag === "function") {
        this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];

        if (this.edgeBeingEditedId !== undefined) {
          var edge = this.body.edges[this.edgeBeingEditedId];

          this._performEditEdge(edge.from.id, edge.to.id);

          return;
        }
      }

      if (this.guiEnabled === true) {
        var _context13;

        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};

        this._createBackButton(locale);

        this._createSeperator();

        this._createDescription(locale["editEdgeDescription"] || this.options.locales["en"]["editEdgeDescription"]); // bind the close button


        this._bindElementEvents(this.closeDiv, bind$6(_context13 = this.toggleEditMode).call(_context13, this));
      }

      this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];

      if (this.edgeBeingEditedId !== undefined) {
        var _context14, _context15, _context16, _context17;

        var _edge = this.body.edges[this.edgeBeingEditedId]; // create control nodes

        var controlNodeFrom = this._getNewTargetNode(_edge.from.x, _edge.from.y);

        var controlNodeTo = this._getNewTargetNode(_edge.to.x, _edge.to.y);

        this.temporaryIds.nodes.push(controlNodeFrom.id);
        this.temporaryIds.nodes.push(controlNodeTo.id);
        this.body.nodes[controlNodeFrom.id] = controlNodeFrom;
        this.body.nodeIndices.push(controlNodeFrom.id);
        this.body.nodes[controlNodeTo.id] = controlNodeTo;
        this.body.nodeIndices.push(controlNodeTo.id); // temporarily overload UI functions, cleaned up automatically because of _temporaryBindUI

        this._temporaryBindUI("onTouch", bind$6(_context14 = this._controlNodeTouch).call(_context14, this)); // used to get the position


        this._temporaryBindUI("onTap", function () {}); // disabled


        this._temporaryBindUI("onHold", function () {}); // disabled


        this._temporaryBindUI("onDragStart", bind$6(_context15 = this._controlNodeDragStart).call(_context15, this)); // used to select control node


        this._temporaryBindUI("onDrag", bind$6(_context16 = this._controlNodeDrag).call(_context16, this)); // used to drag control node


        this._temporaryBindUI("onDragEnd", bind$6(_context17 = this._controlNodeDragEnd).call(_context17, this)); // used to connect or revert control nodes


        this._temporaryBindUI("onMouseMove", function () {}); // disabled
        // create function to position control nodes correctly on movement
        // automatically cleaned up because we use the temporary bind


        this._temporaryBindEvent("beforeDrawing", function (ctx) {
          var positions = _edge.edgeType.findBorderPositions(ctx);

          if (controlNodeFrom.selected === false) {
            controlNodeFrom.x = positions.from.x;
            controlNodeFrom.y = positions.from.y;
          }

          if (controlNodeTo.selected === false) {
            controlNodeTo.x = positions.to.x;
            controlNodeTo.y = positions.to.y;
          }
        });

        this.body.emitter.emit("_redraw");
      } else {
        this.showManipulatorToolbar();
      }
    }
    /**
     * delete everything in the selection
     */

  }, {
    key: "deleteSelected",
    value: function deleteSelected() {
      var _this3 = this;

      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      } // restore the state of any bound functions or events, remove control nodes, restore physics


      this._clean();

      this.inMode = "delete";
      var selectedNodes = this.selectionHandler.getSelectedNodeIds();
      var selectedEdges = this.selectionHandler.getSelectedEdgeIds();
      var deleteFunction = undefined;

      if (selectedNodes.length > 0) {
        for (var i = 0; i < selectedNodes.length; i++) {
          if (this.body.nodes[selectedNodes[i]].isCluster === true) {
            alert(this.options.locales[this.options.locale]["deleteClusterError"] || this.options.locales["en"]["deleteClusterError"]);
            return;
          }
        }

        if (typeof this.options.deleteNode === "function") {
          deleteFunction = this.options.deleteNode;
        }
      } else if (selectedEdges.length > 0) {
        if (typeof this.options.deleteEdge === "function") {
          deleteFunction = this.options.deleteEdge;
        }
      }

      if (typeof deleteFunction === "function") {
        var data = {
          nodes: selectedNodes,
          edges: selectedEdges
        };

        if (deleteFunction.length === 2) {
          deleteFunction(data, function (finalizedData) {
            if (finalizedData !== null && finalizedData !== undefined && _this3.inMode === "delete") {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
              _this3.body.data.edges.getDataSet().remove(finalizedData.edges);

              _this3.body.data.nodes.getDataSet().remove(finalizedData.nodes);

              _this3.body.emitter.emit("startSimulation");

              _this3.showManipulatorToolbar();
            } else {
              _this3.body.emitter.emit("startSimulation");

              _this3.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error("The function for delete does not support two arguments (data, callback)");
        }
      } else {
        this.body.data.edges.getDataSet().remove(selectedEdges);
        this.body.data.nodes.getDataSet().remove(selectedNodes);
        this.body.emitter.emit("startSimulation");
        this.showManipulatorToolbar();
      }
    } //********************************************** PRIVATE ***************************************//

    /**
     * draw or remove the DOM
     *
     * @private
     */

  }, {
    key: "_setup",
    value: function _setup() {
      if (this.options.enabled === true) {
        // Enable the GUI
        this.guiEnabled = true;

        this._createWrappers();

        if (this.editMode === false) {
          this._createEditButton();
        } else {
          this.showManipulatorToolbar();
        }
      } else {
        this._removeManipulationDOM(); // disable the gui


        this.guiEnabled = false;
      }
    }
    /**
     * create the div overlays that contain the DOM
     *
     * @private
     */

  }, {
    key: "_createWrappers",
    value: function _createWrappers() {
      // load the manipulator HTML elements. All styling done in css.
      if (this.manipulationDiv === undefined) {
        this.manipulationDiv = document.createElement("div");
        this.manipulationDiv.className = "vis-manipulation";

        if (this.editMode === true) {
          this.manipulationDiv.style.display = "block";
        } else {
          this.manipulationDiv.style.display = "none";
        }

        this.canvas.frame.appendChild(this.manipulationDiv);
      } // container for the edit button.


      if (this.editModeDiv === undefined) {
        this.editModeDiv = document.createElement("div");
        this.editModeDiv.className = "vis-edit-mode";

        if (this.editMode === true) {
          this.editModeDiv.style.display = "none";
        } else {
          this.editModeDiv.style.display = "block";
        }

        this.canvas.frame.appendChild(this.editModeDiv);
      } // container for the close div button


      if (this.closeDiv === undefined) {
        var _this$options$locales, _this$options$locales2;

        this.closeDiv = document.createElement("button");
        this.closeDiv.className = "vis-close";
        this.closeDiv.setAttribute("aria-label", (_this$options$locales = (_this$options$locales2 = this.options.locales[this.options.locale]) === null || _this$options$locales2 === void 0 ? void 0 : _this$options$locales2["close"]) !== null && _this$options$locales !== void 0 ? _this$options$locales : this.options.locales["en"]["close"]);
        this.closeDiv.style.display = this.manipulationDiv.style.display;
        this.canvas.frame.appendChild(this.closeDiv);
      }
    }
    /**
     * generate a new target node. Used for creating new edges and editing edges
     *
     * @param {number} x
     * @param {number} y
     * @returns {Node}
     * @private
     */

  }, {
    key: "_getNewTargetNode",
    value: function _getNewTargetNode(x, y) {
      var controlNodeStyle = deepExtend({}, this.options.controlNodeStyle);
      controlNodeStyle.id = "targetNode" + v4();
      controlNodeStyle.hidden = false;
      controlNodeStyle.physics = false;
      controlNodeStyle.x = x;
      controlNodeStyle.y = y; // we have to define the bounding box in order for the nodes to be drawn immediately

      var node = this.body.functions.createNode(controlNodeStyle);
      node.shape.boundingBox = {
        left: x,
        right: x,
        top: y,
        bottom: y
      };
      return node;
    }
    /**
     * Create the edit button
     */

  }, {
    key: "_createEditButton",
    value: function _createEditButton() {
      var _context18;

      // restore everything to it's original state (if applicable)
      this._clean(); // reset the manipulationDOM


      this.manipulationDOM = {}; // empty the editModeDiv

      recursiveDOMDelete(this.editModeDiv); // create the contents for the editMode button

      var locale = this.options.locales[this.options.locale];

      var button = this._createButton("editMode", "vis-edit vis-edit-mode", locale["edit"] || this.options.locales["en"]["edit"]);

      this.editModeDiv.appendChild(button); // bind a hammer listener to the button, calling the function toggleEditMode.

      this._bindElementEvents(button, bind$6(_context18 = this.toggleEditMode).call(_context18, this));
    }
    /**
     * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.
     *
     * @private
     */

  }, {
    key: "_clean",
    value: function _clean() {
      // not in mode
      this.inMode = false; // _clean the divs

      if (this.guiEnabled === true) {
        recursiveDOMDelete(this.editModeDiv);
        recursiveDOMDelete(this.manipulationDiv); // removes all the bindings and overloads

        this._cleanupDOMEventListeners();
      } // remove temporary nodes and edges


      this._cleanupTemporaryNodesAndEdges(); // restore overloaded UI functions


      this._unbindTemporaryUIs(); // remove the temporaryEventFunctions


      this._unbindTemporaryEvents(); // restore the physics if required


      this.body.emitter.emit("restorePhysics");
    }
    /**
     * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.
     *
     * @private
     */

  }, {
    key: "_cleanupDOMEventListeners",
    value: function _cleanupDOMEventListeners() {
      var _context19;

      // _clean DOM event listener bindings
      var _iterator = _createForOfIteratorHelper(splice$1(_context19 = this._domEventListenerCleanupQueue).call(_context19, 0)),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var callback = _step.value;
          callback();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Remove all DOM elements created by this module.
     *
     * @private
     */

  }, {
    key: "_removeManipulationDOM",
    value: function _removeManipulationDOM() {
      // removes all the bindings and overloads
      this._clean(); // empty the manipulation divs


      recursiveDOMDelete(this.manipulationDiv);
      recursiveDOMDelete(this.editModeDiv);
      recursiveDOMDelete(this.closeDiv); // remove the manipulation divs

      if (this.manipulationDiv) {
        this.canvas.frame.removeChild(this.manipulationDiv);
      }

      if (this.editModeDiv) {
        this.canvas.frame.removeChild(this.editModeDiv);
      }

      if (this.closeDiv) {
        this.canvas.frame.removeChild(this.closeDiv);
      } // set the references to undefined


      this.manipulationDiv = undefined;
      this.editModeDiv = undefined;
      this.closeDiv = undefined;
    }
    /**
     * create a seperator line. the index is to differentiate in the manipulation dom
     *
     * @param {number} [index=1]
     * @private
     */

  }, {
    key: "_createSeperator",
    value: function _createSeperator() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      this.manipulationDOM["seperatorLineDiv" + index] = document.createElement("div");
      this.manipulationDOM["seperatorLineDiv" + index].className = "vis-separator-line";
      this.manipulationDiv.appendChild(this.manipulationDOM["seperatorLineDiv" + index]);
    } // ----------------------    DOM functions for buttons    --------------------------//

    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createAddNodeButton",
    value: function _createAddNodeButton(locale) {
      var _context20;

      var button = this._createButton("addNode", "vis-add", locale["addNode"] || this.options.locales["en"]["addNode"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context20 = this.addNodeMode).call(_context20, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createAddEdgeButton",
    value: function _createAddEdgeButton(locale) {
      var _context21;

      var button = this._createButton("addEdge", "vis-connect", locale["addEdge"] || this.options.locales["en"]["addEdge"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context21 = this.addEdgeMode).call(_context21, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createEditNodeButton",
    value: function _createEditNodeButton(locale) {
      var _context22;

      var button = this._createButton("editNode", "vis-edit", locale["editNode"] || this.options.locales["en"]["editNode"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context22 = this.editNode).call(_context22, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createEditEdgeButton",
    value: function _createEditEdgeButton(locale) {
      var _context23;

      var button = this._createButton("editEdge", "vis-edit", locale["editEdge"] || this.options.locales["en"]["editEdge"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context23 = this.editEdgeMode).call(_context23, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createDeleteButton",
    value: function _createDeleteButton(locale) {
      var _context24;

      var deleteBtnClass;

      if (this.options.rtl) {
        deleteBtnClass = "vis-delete-rtl";
      } else {
        deleteBtnClass = "vis-delete";
      }

      var button = this._createButton("delete", deleteBtnClass, locale["del"] || this.options.locales["en"]["del"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context24 = this.deleteSelected).call(_context24, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: "_createBackButton",
    value: function _createBackButton(locale) {
      var _context25;

      var button = this._createButton("back", "vis-back", locale["back"] || this.options.locales["en"]["back"]);

      this.manipulationDiv.appendChild(button);

      this._bindElementEvents(button, bind$6(_context25 = this.showManipulatorToolbar).call(_context25, this));
    }
    /**
     *
     * @param {number|string} id
     * @param {string} className
     * @param {label} label
     * @param {string} labelClassName
     * @returns {HTMLElement}
     * @private
     */

  }, {
    key: "_createButton",
    value: function _createButton(id, className, label) {
      var labelClassName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "vis-label";
      this.manipulationDOM[id + "Div"] = document.createElement("button");
      this.manipulationDOM[id + "Div"].className = "vis-button " + className;
      this.manipulationDOM[id + "Label"] = document.createElement("div");
      this.manipulationDOM[id + "Label"].className = labelClassName;
      this.manipulationDOM[id + "Label"].innerText = label;
      this.manipulationDOM[id + "Div"].appendChild(this.manipulationDOM[id + "Label"]);
      return this.manipulationDOM[id + "Div"];
    }
    /**
     *
     * @param {Label} label
     * @private
     */

  }, {
    key: "_createDescription",
    value: function _createDescription(label) {
      this.manipulationDOM["descriptionLabel"] = document.createElement("div");
      this.manipulationDOM["descriptionLabel"].className = "vis-none";
      this.manipulationDOM["descriptionLabel"].innerText = label;
      this.manipulationDiv.appendChild(this.manipulationDOM["descriptionLabel"]);
    } // -------------------------- End of DOM functions for buttons ------------------------------//

    /**
     * this binds an event until cleanup by the clean functions.
     *
     * @param {Event}  event   The event
     * @param {Function} newFunction
     * @private
     */

  }, {
    key: "_temporaryBindEvent",
    value: function _temporaryBindEvent(event, newFunction) {
      this.temporaryEventFunctions.push({
        event: event,
        boundFunction: newFunction
      });
      this.body.emitter.on(event, newFunction);
    }
    /**
     * this overrides an UI function until cleanup by the clean function
     *
     * @param {string} UIfunctionName
     * @param {Function} newFunction
     * @private
     */

  }, {
    key: "_temporaryBindUI",
    value: function _temporaryBindUI(UIfunctionName, newFunction) {
      if (this.body.eventListeners[UIfunctionName] !== undefined) {
        this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];
        this.body.eventListeners[UIfunctionName] = newFunction;
      } else {
        throw new Error("This UI function does not exist. Typo? You tried: " + UIfunctionName + " possible are: " + stringify$1(keys$4(this.body.eventListeners)));
      }
    }
    /**
     * Restore the overridden UI functions to their original state.
     *
     * @private
     */

  }, {
    key: "_unbindTemporaryUIs",
    value: function _unbindTemporaryUIs() {
      for (var functionName in this.temporaryUIFunctions) {
        if (Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions, functionName)) {
          this.body.eventListeners[functionName] = this.temporaryUIFunctions[functionName];
          delete this.temporaryUIFunctions[functionName];
        }
      }

      this.temporaryUIFunctions = {};
    }
    /**
     * Unbind the events created by _temporaryBindEvent
     *
     * @private
     */

  }, {
    key: "_unbindTemporaryEvents",
    value: function _unbindTemporaryEvents() {
      for (var i = 0; i < this.temporaryEventFunctions.length; i++) {
        var eventName = this.temporaryEventFunctions[i].event;
        var boundFunction = this.temporaryEventFunctions[i].boundFunction;
        this.body.emitter.off(eventName, boundFunction);
      }

      this.temporaryEventFunctions = [];
    }
    /**
     * Bind an hammer instance to a DOM element.
     *
     * @param {Element} domElement
     * @param {Function} boundFunction
     */

  }, {
    key: "_bindElementEvents",
    value: function _bindElementEvents(domElement, boundFunction) {
      // Bind touch events.
      var hammer = new Hammer(domElement, {});
      onTouch(hammer, boundFunction);

      this._domEventListenerCleanupQueue.push(function () {
        hammer.destroy();
      }); // Bind keyboard events.


      var keyupListener = function keyupListener(_ref) {
        var keyCode = _ref.keyCode,
            key = _ref.key;

        if (key === "Enter" || key === " " || keyCode === 13 || keyCode === 32) {
          boundFunction();
        }
      };

      domElement.addEventListener("keyup", keyupListener, false);

      this._domEventListenerCleanupQueue.push(function () {
        domElement.removeEventListener("keyup", keyupListener, false);
      });
    }
    /**
     * Neatly clean up temporary edges and nodes
     *
     * @private
     */

  }, {
    key: "_cleanupTemporaryNodesAndEdges",
    value: function _cleanupTemporaryNodesAndEdges() {
      // _clean temporary edges
      for (var i = 0; i < this.temporaryIds.edges.length; i++) {
        var _context26;

        this.body.edges[this.temporaryIds.edges[i]].disconnect();
        delete this.body.edges[this.temporaryIds.edges[i]];

        var indexTempEdge = indexOf(_context26 = this.body.edgeIndices).call(_context26, this.temporaryIds.edges[i]);

        if (indexTempEdge !== -1) {
          var _context27;

          splice$1(_context27 = this.body.edgeIndices).call(_context27, indexTempEdge, 1);
        }
      } // _clean temporary nodes


      for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {
        var _context28;

        delete this.body.nodes[this.temporaryIds.nodes[_i]];

        var indexTempNode = indexOf(_context28 = this.body.nodeIndices).call(_context28, this.temporaryIds.nodes[_i]);

        if (indexTempNode !== -1) {
          var _context29;

          splice$1(_context29 = this.body.nodeIndices).call(_context29, indexTempNode, 1);
        }
      }

      this.temporaryIds = {
        nodes: [],
        edges: []
      };
    } // ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//

    /**
     * the touch is used to get the position of the initial click
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_controlNodeTouch",
    value: function _controlNodeTouch(event) {
      this.selectionHandler.unselectAll();
      this.lastTouch = this.body.functions.getPointer(event.center);
      this.lastTouch.translation = assign$2({}, this.body.view.translation); // copy the object
    }
    /**
     * the drag start is used to mark one of the control nodes as selected.
     *
     * @private
     */

  }, {
    key: "_controlNodeDragStart",
    value: function _controlNodeDragStart() {
      var pointer = this.lastTouch;

      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

      var from = this.body.nodes[this.temporaryIds.nodes[0]];
      var to = this.body.nodes[this.temporaryIds.nodes[1]];
      var edge = this.body.edges[this.edgeBeingEditedId];
      this.selectedControlNode = undefined;
      var fromSelect = from.isOverlappingWith(pointerObj);
      var toSelect = to.isOverlappingWith(pointerObj);

      if (fromSelect === true) {
        this.selectedControlNode = from;
        edge.edgeType.from = from;
      } else if (toSelect === true) {
        this.selectedControlNode = to;
        edge.edgeType.to = to;
      } // we use the selection to find the node that is being dragged. We explicitly select it here.


      if (this.selectedControlNode !== undefined) {
        this.selectionHandler.selectObject(this.selectedControlNode);
      }

      this.body.emitter.emit("_redraw");
    }
    /**
     * dragging the control nodes or the canvas
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_controlNodeDrag",
    value: function _controlNodeDrag(event) {
      this.body.emitter.emit("disablePhysics");
      var pointer = this.body.functions.getPointer(event.center);
      var pos = this.canvas.DOMtoCanvas(pointer);

      if (this.selectedControlNode !== undefined) {
        this.selectedControlNode.x = pos.x;
        this.selectedControlNode.y = pos.y;
      } else {
        this.interactionHandler.onDrag(event);
      }

      this.body.emitter.emit("_redraw");
    }
    /**
     * connecting or restoring the control nodes.
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_controlNodeDragEnd",
    value: function _controlNodeDragEnd(event) {
      var pointer = this.body.functions.getPointer(event.center);

      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

      var edge = this.body.edges[this.edgeBeingEditedId]; // if the node that was dragged is not a control node, return

      if (this.selectedControlNode === undefined) {
        return;
      } // we use the selection to find the node that is being dragged. We explicitly DEselect the control node here.


      this.selectionHandler.unselectAll();

      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);

      var node = undefined;

      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        if (overlappingNodeIds[i] !== this.selectedControlNode.id) {
          node = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      } // perform the connection


      if (node !== undefined && this.selectedControlNode !== undefined) {
        if (node.isCluster === true) {
          alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
        } else {
          var from = this.body.nodes[this.temporaryIds.nodes[0]];

          if (this.selectedControlNode.id === from.id) {
            this._performEditEdge(node.id, edge.to.id);
          } else {
            this._performEditEdge(edge.from.id, node.id);
          }
        }
      } else {
        edge.updateEdgeType();
        this.body.emitter.emit("restorePhysics");
      }

      this.body.emitter.emit("_redraw");
    } // ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//
    // ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//

    /**
     * the function bound to the selection event. It checks if you want to connect a cluster and changes the description
     * to walk the user through the process.
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "_handleConnect",
    value: function _handleConnect(event) {
      // check to avoid double fireing of this function.
      if (new Date().valueOf() - this.touchTime > 100) {
        this.lastTouch = this.body.functions.getPointer(event.center);
        this.lastTouch.translation = assign$2({}, this.body.view.translation); // copy the object

        this.interactionHandler.drag.pointer = this.lastTouch; // Drag pointer is not updated when adding edges

        this.interactionHandler.drag.translation = this.lastTouch.translation;
        var pointer = this.lastTouch;
        var node = this.selectionHandler.getNodeAt(pointer);

        if (node !== undefined) {
          if (node.isCluster === true) {
            alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
          } else {
            // create a node the temporary line can look at
            var targetNode = this._getNewTargetNode(node.x, node.y);

            this.body.nodes[targetNode.id] = targetNode;
            this.body.nodeIndices.push(targetNode.id); // create a temporary edge

            var connectionEdge = this.body.functions.createEdge({
              id: "connectionEdge" + v4(),
              from: node.id,
              to: targetNode.id,
              physics: false,
              smooth: {
                enabled: true,
                type: "continuous",
                roundness: 0.5
              }
            });
            this.body.edges[connectionEdge.id] = connectionEdge;
            this.body.edgeIndices.push(connectionEdge.id);
            this.temporaryIds.nodes.push(targetNode.id);
            this.temporaryIds.edges.push(connectionEdge.id);
          }
        }

        this.touchTime = new Date().valueOf();
      }
    }
    /**
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "_dragControlNode",
    value: function _dragControlNode(event) {
      var pointer = this.body.functions.getPointer(event.center);

      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer); // remember the edge id


      var connectFromId = undefined;

      if (this.temporaryIds.edges[0] !== undefined) {
        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
      } // get the overlapping node but NOT the temporary node;


      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);

      var node = undefined;

      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        var _context30;

        // if the node id is NOT a temporary node, accept the node.
        if (indexOf(_context30 = this.temporaryIds.nodes).call(_context30, overlappingNodeIds[i]) === -1) {
          node = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      }

      event.controlEdge = {
        from: connectFromId,
        to: node ? node.id : undefined
      };
      this.selectionHandler.generateClickEvent("controlNodeDragging", event, pointer);

      if (this.temporaryIds.nodes[0] !== undefined) {
        var targetNode = this.body.nodes[this.temporaryIds.nodes[0]]; // there is only one temp node in the add edge mode.

        targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);
        targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);
        this.body.emitter.emit("_redraw");
      } else {
        this.interactionHandler.onDrag(event);
      }
    }
    /**
     * Connect the new edge to the target if one exists, otherwise remove temp line
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: "_finishConnect",
    value: function _finishConnect(event) {
      var pointer = this.body.functions.getPointer(event.center);

      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer); // remember the edge id


      var connectFromId = undefined;

      if (this.temporaryIds.edges[0] !== undefined) {
        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
      } // get the overlapping node but NOT the temporary node;


      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);

      var node = undefined;

      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        var _context31;

        // if the node id is NOT a temporary node, accept the node.
        if (indexOf(_context31 = this.temporaryIds.nodes).call(_context31, overlappingNodeIds[i]) === -1) {
          node = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      } // clean temporary nodes and edges.


      this._cleanupTemporaryNodesAndEdges(); // perform the connection


      if (node !== undefined) {
        if (node.isCluster === true) {
          alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
        } else {
          if (this.body.nodes[connectFromId] !== undefined && this.body.nodes[node.id] !== undefined) {
            this._performAddEdge(connectFromId, node.id);
          }
        }
      }

      event.controlEdge = {
        from: connectFromId,
        to: node ? node.id : undefined
      };
      this.selectionHandler.generateClickEvent("controlNodeDragEnd", event, pointer); // No need to do _generateclickevent('dragEnd') here, the regular dragEnd event fires.

      this.body.emitter.emit("_redraw");
    }
    /**
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: "_dragStartEdge",
    value: function _dragStartEdge(event) {
      var pointer = this.lastTouch;
      this.selectionHandler.generateClickEvent("dragStart", event, pointer, undefined, true);
    } // --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//
    // ------------------------------ Performing all the actual data manipulation ------------------------//

    /**
     * Adds a node on the specified location
     *
     * @param {object} clickData
     * @private
     */

  }, {
    key: "_performAddNode",
    value: function _performAddNode(clickData) {
      var _this4 = this;

      var defaultData = {
        id: v4(),
        x: clickData.pointer.canvas.x,
        y: clickData.pointer.canvas.y,
        label: "new"
      };

      if (typeof this.options.addNode === "function") {
        if (this.options.addNode.length === 2) {
          this.options.addNode(defaultData, function (finalizedData) {
            if (finalizedData !== null && finalizedData !== undefined && _this4.inMode === "addNode") {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback
              _this4.body.data.nodes.getDataSet().add(finalizedData);
            }

            _this4.showManipulatorToolbar();
          });
        } else {
          this.showManipulatorToolbar();
          throw new Error("The function for add does not support two arguments (data,callback)");
        }
      } else {
        this.body.data.nodes.getDataSet().add(defaultData);
        this.showManipulatorToolbar();
      }
    }
    /**
     * connect two nodes with a new edge.
     *
     * @param {Node.id} sourceNodeId
     * @param {Node.id} targetNodeId
     * @private
     */

  }, {
    key: "_performAddEdge",
    value: function _performAddEdge(sourceNodeId, targetNodeId) {
      var _this5 = this;

      var defaultData = {
        from: sourceNodeId,
        to: targetNodeId
      };

      if (typeof this.options.addEdge === "function") {
        if (this.options.addEdge.length === 2) {
          this.options.addEdge(defaultData, function (finalizedData) {
            if (finalizedData !== null && finalizedData !== undefined && _this5.inMode === "addEdge") {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback
              _this5.body.data.edges.getDataSet().add(finalizedData);

              _this5.selectionHandler.unselectAll();

              _this5.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error("The function for connect does not support two arguments (data,callback)");
        }
      } else {
        this.body.data.edges.getDataSet().add(defaultData);
        this.selectionHandler.unselectAll();
        this.showManipulatorToolbar();
      }
    }
    /**
     * connect two nodes with a new edge.
     *
     * @param {Node.id} sourceNodeId
     * @param {Node.id} targetNodeId
     * @private
     */

  }, {
    key: "_performEditEdge",
    value: function _performEditEdge(sourceNodeId, targetNodeId) {
      var _this6 = this;

      var defaultData = {
        id: this.edgeBeingEditedId,
        from: sourceNodeId,
        to: targetNodeId,
        label: this.body.data.edges.get(this.edgeBeingEditedId).label
      };
      var eeFunct = this.options.editEdge;

      if (_typeof(eeFunct) === "object") {
        eeFunct = eeFunct.editWithoutDrag;
      }

      if (typeof eeFunct === "function") {
        if (eeFunct.length === 2) {
          eeFunct(defaultData, function (finalizedData) {
            if (finalizedData === null || finalizedData === undefined || _this6.inMode !== "editEdge") {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
              _this6.body.edges[defaultData.id].updateEdgeType();

              _this6.body.emitter.emit("_redraw");

              _this6.showManipulatorToolbar();
            } else {
              _this6.body.data.edges.getDataSet().update(finalizedData);

              _this6.selectionHandler.unselectAll();

              _this6.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error("The function for edit does not support two arguments (data, callback)");
        }
      } else {
        this.body.data.edges.getDataSet().update(defaultData);
        this.selectionHandler.unselectAll();
        this.showManipulatorToolbar();
      }
    }
  }]);

  return ManipulationSystem;
}();

/**
 * This object contains all possible options. It will check if the types are correct, if required if the option is one
 * of the allowed values.
 *
 * __any__ means that the name of the property does not matter.
 * __type__ is a required field for all objects and contains the allowed types of all objects
 */
var string = "string";
var bool = "boolean";
var number = "number";
var array = "array";
var object = "object"; // should only be in a __type__ property

var dom = "dom";
var any = "any"; // List of endpoints

var endPoints = ["arrow", "bar", "box", "circle", "crow", "curve", "diamond", "image", "inv_curve", "inv_triangle", "triangle", "vee"];
/* eslint-disable @typescript-eslint/naming-convention -- The __*__ format is used to prevent collisions with actual option names. */

var nodeOptions = {
  borderWidth: {
    number: number
  },
  borderWidthSelected: {
    number: number,
    undefined: "undefined"
  },
  brokenImage: {
    string: string,
    undefined: "undefined"
  },
  chosen: {
    label: {
      boolean: bool,
      function: "function"
    },
    node: {
      boolean: bool,
      function: "function"
    },
    __type__: {
      object: object,
      boolean: bool
    }
  },
  color: {
    border: {
      string: string
    },
    background: {
      string: string
    },
    highlight: {
      border: {
        string: string
      },
      background: {
        string: string
      },
      __type__: {
        object: object,
        string: string
      }
    },
    hover: {
      border: {
        string: string
      },
      background: {
        string: string
      },
      __type__: {
        object: object,
        string: string
      }
    },
    __type__: {
      object: object,
      string: string
    }
  },
  opacity: {
    number: number,
    undefined: "undefined"
  },
  fixed: {
    x: {
      boolean: bool
    },
    y: {
      boolean: bool
    },
    __type__: {
      object: object,
      boolean: bool
    }
  },
  font: {
    align: {
      string: string
    },
    color: {
      string: string
    },
    size: {
      number: number
    },
    face: {
      string: string
    },
    background: {
      string: string
    },
    strokeWidth: {
      number: number
    },
    strokeColor: {
      string: string
    },
    vadjust: {
      number: number
    },
    multi: {
      boolean: bool,
      string: string
    },
    bold: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      mod: {
        string: string
      },
      vadjust: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    boldital: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      mod: {
        string: string
      },
      vadjust: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    ital: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      mod: {
        string: string
      },
      vadjust: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    mono: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      mod: {
        string: string
      },
      vadjust: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    __type__: {
      object: object,
      string: string
    }
  },
  group: {
    string: string,
    number: number,
    undefined: "undefined"
  },
  heightConstraint: {
    minimum: {
      number: number
    },
    valign: {
      string: string
    },
    __type__: {
      object: object,
      boolean: bool,
      number: number
    }
  },
  hidden: {
    boolean: bool
  },
  icon: {
    face: {
      string: string
    },
    code: {
      string: string
    },
    size: {
      number: number
    },
    color: {
      string: string
    },
    weight: {
      string: string,
      number: number
    },
    __type__: {
      object: object
    }
  },
  id: {
    string: string,
    number: number
  },
  image: {
    selected: {
      string: string,
      undefined: "undefined"
    },
    unselected: {
      string: string,
      undefined: "undefined"
    },
    __type__: {
      object: object,
      string: string
    }
  },
  imagePadding: {
    top: {
      number: number
    },
    right: {
      number: number
    },
    bottom: {
      number: number
    },
    left: {
      number: number
    },
    __type__: {
      object: object,
      number: number
    }
  },
  label: {
    string: string,
    undefined: "undefined"
  },
  labelHighlightBold: {
    boolean: bool
  },
  level: {
    number: number,
    undefined: "undefined"
  },
  margin: {
    top: {
      number: number
    },
    right: {
      number: number
    },
    bottom: {
      number: number
    },
    left: {
      number: number
    },
    __type__: {
      object: object,
      number: number
    }
  },
  mass: {
    number: number
  },
  physics: {
    boolean: bool
  },
  scaling: {
    min: {
      number: number
    },
    max: {
      number: number
    },
    label: {
      enabled: {
        boolean: bool
      },
      min: {
        number: number
      },
      max: {
        number: number
      },
      maxVisible: {
        number: number
      },
      drawThreshold: {
        number: number
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    customScalingFunction: {
      function: "function"
    },
    __type__: {
      object: object
    }
  },
  shadow: {
    enabled: {
      boolean: bool
    },
    color: {
      string: string
    },
    size: {
      number: number
    },
    x: {
      number: number
    },
    y: {
      number: number
    },
    __type__: {
      object: object,
      boolean: bool
    }
  },
  shape: {
    string: ["custom", "ellipse", "circle", "database", "box", "text", "image", "circularImage", "diamond", "dot", "star", "triangle", "triangleDown", "square", "icon", "hexagon"]
  },
  ctxRenderer: {
    function: "function"
  },
  shapeProperties: {
    borderDashes: {
      boolean: bool,
      array: array
    },
    borderRadius: {
      number: number
    },
    interpolation: {
      boolean: bool
    },
    useImageSize: {
      boolean: bool
    },
    useBorderWithImage: {
      boolean: bool
    },
    coordinateOrigin: {
      string: ["center", "top-left"]
    },
    __type__: {
      object: object
    }
  },
  size: {
    number: number
  },
  title: {
    string: string,
    dom: dom,
    undefined: "undefined"
  },
  value: {
    number: number,
    undefined: "undefined"
  },
  widthConstraint: {
    minimum: {
      number: number
    },
    maximum: {
      number: number
    },
    __type__: {
      object: object,
      boolean: bool,
      number: number
    }
  },
  x: {
    number: number
  },
  y: {
    number: number
  },
  __type__: {
    object: object
  }
};
var allOptions = {
  configure: {
    enabled: {
      boolean: bool
    },
    filter: {
      boolean: bool,
      string: string,
      array: array,
      function: "function"
    },
    container: {
      dom: dom
    },
    showButton: {
      boolean: bool
    },
    __type__: {
      object: object,
      boolean: bool,
      string: string,
      array: array,
      function: "function"
    }
  },
  edges: {
    arrows: {
      to: {
        enabled: {
          boolean: bool
        },
        scaleFactor: {
          number: number
        },
        type: {
          string: endPoints
        },
        imageHeight: {
          number: number
        },
        imageWidth: {
          number: number
        },
        src: {
          string: string
        },
        __type__: {
          object: object,
          boolean: bool
        }
      },
      middle: {
        enabled: {
          boolean: bool
        },
        scaleFactor: {
          number: number
        },
        type: {
          string: endPoints
        },
        imageWidth: {
          number: number
        },
        imageHeight: {
          number: number
        },
        src: {
          string: string
        },
        __type__: {
          object: object,
          boolean: bool
        }
      },
      from: {
        enabled: {
          boolean: bool
        },
        scaleFactor: {
          number: number
        },
        type: {
          string: endPoints
        },
        imageWidth: {
          number: number
        },
        imageHeight: {
          number: number
        },
        src: {
          string: string
        },
        __type__: {
          object: object,
          boolean: bool
        }
      },
      __type__: {
        string: ["from", "to", "middle"],
        object: object
      }
    },
    endPointOffset: {
      from: {
        number: number
      },
      to: {
        number: number
      },
      __type__: {
        object: object,
        number: number
      }
    },
    arrowStrikethrough: {
      boolean: bool
    },
    background: {
      enabled: {
        boolean: bool
      },
      color: {
        string: string
      },
      size: {
        number: number
      },
      dashes: {
        boolean: bool,
        array: array
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    chosen: {
      label: {
        boolean: bool,
        function: "function"
      },
      edge: {
        boolean: bool,
        function: "function"
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    color: {
      color: {
        string: string
      },
      highlight: {
        string: string
      },
      hover: {
        string: string
      },
      inherit: {
        string: ["from", "to", "both"],
        boolean: bool
      },
      opacity: {
        number: number
      },
      __type__: {
        object: object,
        string: string
      }
    },
    dashes: {
      boolean: bool,
      array: array
    },
    font: {
      color: {
        string: string
      },
      size: {
        number: number
      },
      face: {
        string: string
      },
      background: {
        string: string
      },
      strokeWidth: {
        number: number
      },
      strokeColor: {
        string: string
      },
      align: {
        string: ["horizontal", "top", "middle", "bottom"]
      },
      vadjust: {
        number: number
      },
      multi: {
        boolean: bool,
        string: string
      },
      bold: {
        color: {
          string: string
        },
        size: {
          number: number
        },
        face: {
          string: string
        },
        mod: {
          string: string
        },
        vadjust: {
          number: number
        },
        __type__: {
          object: object,
          string: string
        }
      },
      boldital: {
        color: {
          string: string
        },
        size: {
          number: number
        },
        face: {
          string: string
        },
        mod: {
          string: string
        },
        vadjust: {
          number: number
        },
        __type__: {
          object: object,
          string: string
        }
      },
      ital: {
        color: {
          string: string
        },
        size: {
          number: number
        },
        face: {
          string: string
        },
        mod: {
          string: string
        },
        vadjust: {
          number: number
        },
        __type__: {
          object: object,
          string: string
        }
      },
      mono: {
        color: {
          string: string
        },
        size: {
          number: number
        },
        face: {
          string: string
        },
        mod: {
          string: string
        },
        vadjust: {
          number: number
        },
        __type__: {
          object: object,
          string: string
        }
      },
      __type__: {
        object: object,
        string: string
      }
    },
    hidden: {
      boolean: bool
    },
    hoverWidth: {
      function: "function",
      number: number
    },
    label: {
      string: string,
      undefined: "undefined"
    },
    labelHighlightBold: {
      boolean: bool
    },
    length: {
      number: number,
      undefined: "undefined"
    },
    physics: {
      boolean: bool
    },
    scaling: {
      min: {
        number: number
      },
      max: {
        number: number
      },
      label: {
        enabled: {
          boolean: bool
        },
        min: {
          number: number
        },
        max: {
          number: number
        },
        maxVisible: {
          number: number
        },
        drawThreshold: {
          number: number
        },
        __type__: {
          object: object,
          boolean: bool
        }
      },
      customScalingFunction: {
        function: "function"
      },
      __type__: {
        object: object
      }
    },
    selectionWidth: {
      function: "function",
      number: number
    },
    selfReferenceSize: {
      number: number
    },
    selfReference: {
      size: {
        number: number
      },
      angle: {
        number: number
      },
      renderBehindTheNode: {
        boolean: bool
      },
      __type__: {
        object: object
      }
    },
    shadow: {
      enabled: {
        boolean: bool
      },
      color: {
        string: string
      },
      size: {
        number: number
      },
      x: {
        number: number
      },
      y: {
        number: number
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    smooth: {
      enabled: {
        boolean: bool
      },
      type: {
        string: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"]
      },
      roundness: {
        number: number
      },
      forceDirection: {
        string: ["horizontal", "vertical", "none"],
        boolean: bool
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    title: {
      string: string,
      undefined: "undefined"
    },
    width: {
      number: number
    },
    widthConstraint: {
      maximum: {
        number: number
      },
      __type__: {
        object: object,
        boolean: bool,
        number: number
      }
    },
    value: {
      number: number,
      undefined: "undefined"
    },
    __type__: {
      object: object
    }
  },
  groups: {
    useDefaultGroups: {
      boolean: bool
    },
    __any__: nodeOptions,
    __type__: {
      object: object
    }
  },
  interaction: {
    dragNodes: {
      boolean: bool
    },
    dragView: {
      boolean: bool
    },
    hideEdgesOnDrag: {
      boolean: bool
    },
    hideEdgesOnZoom: {
      boolean: bool
    },
    hideNodesOnDrag: {
      boolean: bool
    },
    hover: {
      boolean: bool
    },
    keyboard: {
      enabled: {
        boolean: bool
      },
      speed: {
        x: {
          number: number
        },
        y: {
          number: number
        },
        zoom: {
          number: number
        },
        __type__: {
          object: object
        }
      },
      bindToWindow: {
        boolean: bool
      },
      autoFocus: {
        boolean: bool
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    multiselect: {
      boolean: bool
    },
    navigationButtons: {
      boolean: bool
    },
    selectable: {
      boolean: bool
    },
    selectConnectedEdges: {
      boolean: bool
    },
    hoverConnectedEdges: {
      boolean: bool
    },
    tooltipDelay: {
      number: number
    },
    zoomView: {
      boolean: bool
    },
    zoomSpeed: {
      number: number
    },
    __type__: {
      object: object
    }
  },
  layout: {
    randomSeed: {
      undefined: "undefined",
      number: number,
      string: string
    },
    improvedLayout: {
      boolean: bool
    },
    clusterThreshold: {
      number: number
    },
    hierarchical: {
      enabled: {
        boolean: bool
      },
      levelSeparation: {
        number: number
      },
      nodeSpacing: {
        number: number
      },
      treeSpacing: {
        number: number
      },
      blockShifting: {
        boolean: bool
      },
      edgeMinimization: {
        boolean: bool
      },
      parentCentralization: {
        boolean: bool
      },
      direction: {
        string: ["UD", "DU", "LR", "RL"]
      },
      sortMethod: {
        string: ["hubsize", "directed"]
      },
      shakeTowards: {
        string: ["leaves", "roots"]
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    __type__: {
      object: object
    }
  },
  manipulation: {
    enabled: {
      boolean: bool
    },
    initiallyActive: {
      boolean: bool
    },
    addNode: {
      boolean: bool,
      function: "function"
    },
    addEdge: {
      boolean: bool,
      function: "function"
    },
    editNode: {
      function: "function"
    },
    editEdge: {
      editWithoutDrag: {
        function: "function"
      },
      __type__: {
        object: object,
        boolean: bool,
        function: "function"
      }
    },
    deleteNode: {
      boolean: bool,
      function: "function"
    },
    deleteEdge: {
      boolean: bool,
      function: "function"
    },
    controlNodeStyle: nodeOptions,
    __type__: {
      object: object,
      boolean: bool
    }
  },
  nodes: nodeOptions,
  physics: {
    enabled: {
      boolean: bool
    },
    barnesHut: {
      theta: {
        number: number
      },
      gravitationalConstant: {
        number: number
      },
      centralGravity: {
        number: number
      },
      springLength: {
        number: number
      },
      springConstant: {
        number: number
      },
      damping: {
        number: number
      },
      avoidOverlap: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    forceAtlas2Based: {
      theta: {
        number: number
      },
      gravitationalConstant: {
        number: number
      },
      centralGravity: {
        number: number
      },
      springLength: {
        number: number
      },
      springConstant: {
        number: number
      },
      damping: {
        number: number
      },
      avoidOverlap: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    repulsion: {
      centralGravity: {
        number: number
      },
      springLength: {
        number: number
      },
      springConstant: {
        number: number
      },
      nodeDistance: {
        number: number
      },
      damping: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    hierarchicalRepulsion: {
      centralGravity: {
        number: number
      },
      springLength: {
        number: number
      },
      springConstant: {
        number: number
      },
      nodeDistance: {
        number: number
      },
      damping: {
        number: number
      },
      avoidOverlap: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    maxVelocity: {
      number: number
    },
    minVelocity: {
      number: number
    },
    solver: {
      string: ["barnesHut", "repulsion", "hierarchicalRepulsion", "forceAtlas2Based"]
    },
    stabilization: {
      enabled: {
        boolean: bool
      },
      iterations: {
        number: number
      },
      updateInterval: {
        number: number
      },
      onlyDynamicEdges: {
        boolean: bool
      },
      fit: {
        boolean: bool
      },
      __type__: {
        object: object,
        boolean: bool
      }
    },
    timestep: {
      number: number
    },
    adaptiveTimestep: {
      boolean: bool
    },
    wind: {
      x: {
        number: number
      },
      y: {
        number: number
      },
      __type__: {
        object: object
      }
    },
    __type__: {
      object: object,
      boolean: bool
    }
  },
  //globals :
  autoResize: {
    boolean: bool
  },
  clickToUse: {
    boolean: bool
  },
  locale: {
    string: string
  },
  locales: {
    __any__: {
      any: any
    },
    __type__: {
      object: object
    }
  },
  height: {
    string: string
  },
  width: {
    string: string
  },
  __type__: {
    object: object
  }
};
/* eslint-enable @typescript-eslint/naming-convention */

/**
 * This provides ranges, initial values, steps and dropdown menu choices for the
 * configuration.
 *
 * @remarks
 * Checkbox: `boolean`
 *   The value supllied will be used as the initial value.
 *
 * Text field: `string`
 *   The passed text will be used as the initial value. Any text will be
 *   accepted afterwards.
 *
 * Number range: `[number, number, number, number]`
 *   The meanings are `[initial value, min, max, step]`.
 *
 * Dropdown: `[Exclude<string, "color">, ...(string | number | boolean)[]]`
 *   Translations for people with poor understanding of TypeScript: the first
 *   value always has to be a string but never `"color"`, the rest can be any
 *   combination of strings, numbers and booleans.
 *
 * Color picker: `["color", string]`
 *   The first value says this will be a color picker not a dropdown menu. The
 *   next value is the initial color.
 */

var configureOptions = {
  nodes: {
    borderWidth: [1, 0, 10, 1],
    borderWidthSelected: [2, 0, 10, 1],
    color: {
      border: ["color", "#2B7CE9"],
      background: ["color", "#97C2FC"],
      highlight: {
        border: ["color", "#2B7CE9"],
        background: ["color", "#D2E5FF"]
      },
      hover: {
        border: ["color", "#2B7CE9"],
        background: ["color", "#D2E5FF"]
      }
    },
    opacity: [0, 0, 1, 0.1],
    fixed: {
      x: false,
      y: false
    },
    font: {
      color: ["color", "#343434"],
      size: [14, 0, 100, 1],
      face: ["arial", "verdana", "tahoma"],
      background: ["color", "none"],
      strokeWidth: [0, 0, 50, 1],
      strokeColor: ["color", "#ffffff"]
    },
    //group: 'string',
    hidden: false,
    labelHighlightBold: true,
    //icon: {
    //  face: 'string',  //'FontAwesome',
    //  code: 'string',  //'\uf007',
    //  size: [50, 0, 200, 1],  //50,
    //  color: ['color','#2B7CE9']   //'#aa00ff'
    //},
    //image: 'string', // --> URL
    physics: true,
    scaling: {
      min: [10, 0, 200, 1],
      max: [30, 0, 200, 1],
      label: {
        enabled: false,
        min: [14, 0, 200, 1],
        max: [30, 0, 200, 1],
        maxVisible: [30, 0, 200, 1],
        drawThreshold: [5, 0, 20, 1]
      }
    },
    shadow: {
      enabled: false,
      color: "rgba(0,0,0,0.5)",
      size: [10, 0, 20, 1],
      x: [5, -30, 30, 1],
      y: [5, -30, 30, 1]
    },
    shape: ["ellipse", "box", "circle", "database", "diamond", "dot", "square", "star", "text", "triangle", "triangleDown", "hexagon"],
    shapeProperties: {
      borderDashes: false,
      borderRadius: [6, 0, 20, 1],
      interpolation: true,
      useImageSize: false
    },
    size: [25, 0, 200, 1]
  },
  edges: {
    arrows: {
      to: {
        enabled: false,
        scaleFactor: [1, 0, 3, 0.05],
        type: "arrow"
      },
      middle: {
        enabled: false,
        scaleFactor: [1, 0, 3, 0.05],
        type: "arrow"
      },
      from: {
        enabled: false,
        scaleFactor: [1, 0, 3, 0.05],
        type: "arrow"
      }
    },
    endPointOffset: {
      from: [0, -10, 10, 1],
      to: [0, -10, 10, 1]
    },
    arrowStrikethrough: true,
    color: {
      color: ["color", "#848484"],
      highlight: ["color", "#848484"],
      hover: ["color", "#848484"],
      inherit: ["from", "to", "both", true, false],
      opacity: [1, 0, 1, 0.05]
    },
    dashes: false,
    font: {
      color: ["color", "#343434"],
      size: [14, 0, 100, 1],
      face: ["arial", "verdana", "tahoma"],
      background: ["color", "none"],
      strokeWidth: [2, 0, 50, 1],
      strokeColor: ["color", "#ffffff"],
      align: ["horizontal", "top", "middle", "bottom"]
    },
    hidden: false,
    hoverWidth: [1.5, 0, 5, 0.1],
    labelHighlightBold: true,
    physics: true,
    scaling: {
      min: [1, 0, 100, 1],
      max: [15, 0, 100, 1],
      label: {
        enabled: true,
        min: [14, 0, 200, 1],
        max: [30, 0, 200, 1],
        maxVisible: [30, 0, 200, 1],
        drawThreshold: [5, 0, 20, 1]
      }
    },
    selectionWidth: [1.5, 0, 5, 0.1],
    selfReferenceSize: [20, 0, 200, 1],
    selfReference: {
      size: [20, 0, 200, 1],
      angle: [Math.PI / 2, -6 * Math.PI, 6 * Math.PI, Math.PI / 8],
      renderBehindTheNode: true
    },
    shadow: {
      enabled: false,
      color: "rgba(0,0,0,0.5)",
      size: [10, 0, 20, 1],
      x: [5, -30, 30, 1],
      y: [5, -30, 30, 1]
    },
    smooth: {
      enabled: true,
      type: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"],
      forceDirection: ["horizontal", "vertical", "none"],
      roundness: [0.5, 0, 1, 0.05]
    },
    width: [1, 0, 30, 1]
  },
  layout: {
    //randomSeed: [0, 0, 500, 1],
    //improvedLayout: true,
    hierarchical: {
      enabled: false,
      levelSeparation: [150, 20, 500, 5],
      nodeSpacing: [100, 20, 500, 5],
      treeSpacing: [200, 20, 500, 5],
      blockShifting: true,
      edgeMinimization: true,
      parentCentralization: true,
      direction: ["UD", "DU", "LR", "RL"],
      sortMethod: ["hubsize", "directed"],
      shakeTowards: ["leaves", "roots"] // leaves, roots

    }
  },
  interaction: {
    dragNodes: true,
    dragView: true,
    hideEdgesOnDrag: false,
    hideEdgesOnZoom: false,
    hideNodesOnDrag: false,
    hover: false,
    keyboard: {
      enabled: false,
      speed: {
        x: [10, 0, 40, 1],
        y: [10, 0, 40, 1],
        zoom: [0.02, 0, 0.1, 0.005]
      },
      bindToWindow: true,
      autoFocus: true
    },
    multiselect: false,
    navigationButtons: false,
    selectable: true,
    selectConnectedEdges: true,
    hoverConnectedEdges: true,
    tooltipDelay: [300, 0, 1000, 25],
    zoomView: true,
    zoomSpeed: [1, 0.1, 2, 0.1]
  },
  manipulation: {
    enabled: false,
    initiallyActive: false
  },
  physics: {
    enabled: true,
    barnesHut: {
      theta: [0.5, 0.1, 1, 0.05],
      gravitationalConstant: [-2000, -30000, 0, 50],
      centralGravity: [0.3, 0, 10, 0.05],
      springLength: [95, 0, 500, 5],
      springConstant: [0.04, 0, 1.2, 0.005],
      damping: [0.09, 0, 1, 0.01],
      avoidOverlap: [0, 0, 1, 0.01]
    },
    forceAtlas2Based: {
      theta: [0.5, 0.1, 1, 0.05],
      gravitationalConstant: [-50, -500, 0, 1],
      centralGravity: [0.01, 0, 1, 0.005],
      springLength: [95, 0, 500, 5],
      springConstant: [0.08, 0, 1.2, 0.005],
      damping: [0.4, 0, 1, 0.01],
      avoidOverlap: [0, 0, 1, 0.01]
    },
    repulsion: {
      centralGravity: [0.2, 0, 10, 0.05],
      springLength: [200, 0, 500, 5],
      springConstant: [0.05, 0, 1.2, 0.005],
      nodeDistance: [100, 0, 500, 5],
      damping: [0.09, 0, 1, 0.01]
    },
    hierarchicalRepulsion: {
      centralGravity: [0.2, 0, 10, 0.05],
      springLength: [100, 0, 500, 5],
      springConstant: [0.01, 0, 1.2, 0.005],
      nodeDistance: [120, 0, 500, 5],
      damping: [0.09, 0, 1, 0.01],
      avoidOverlap: [0, 0, 1, 0.01]
    },
    maxVelocity: [50, 0, 150, 1],
    minVelocity: [0.1, 0.01, 0.5, 0.01],
    solver: ["barnesHut", "forceAtlas2Based", "repulsion", "hierarchicalRepulsion"],
    timestep: [0.5, 0.01, 1, 0.01],
    wind: {
      x: [0, -10, 10, 0.1],
      y: [0, -10, 10, 0.1]
    } //adaptiveTimestep: true

  }
};
var configuratorHideOption = function configuratorHideOption(parentPath, optionName, options) {
  var _context;

  if (includes(parentPath).call(parentPath, "physics") && includes(_context = configureOptions.physics.solver).call(_context, optionName) && options.physics.solver !== optionName && optionName !== "wind") {
    return true;
  }

  return false;
};

var options = /*#__PURE__*/Object.freeze({
	__proto__: null,
	configuratorHideOption: configuratorHideOption,
	allOptions: allOptions,
	configureOptions: configureOptions
});

/**
 *  The Floyd–Warshall algorithm is an algorithm for finding shortest paths in
 *  a weighted graph with positive or negative edge weights (but with no negative
 *  cycles). - https://en.wikipedia.org/wiki/Floyd–Warshall_algorithm
 */
var FloydWarshall = /*#__PURE__*/function () {
  /**
   * @ignore
   */
  function FloydWarshall() {
    _classCallCheck(this, FloydWarshall);
  }
  /**
   *
   * @param {object} body
   * @param {Array.<Node>} nodesArray
   * @param {Array.<Edge>} edgesArray
   * @returns {{}}
   */


  _createClass(FloydWarshall, [{
    key: "getDistances",
    value: function getDistances(body, nodesArray, edgesArray) {
      var D_matrix = {};
      var edges = body.edges; // prepare matrix with large numbers

      for (var i = 0; i < nodesArray.length; i++) {
        var node = nodesArray[i];
        var cell = {};
        D_matrix[node] = cell;

        for (var j = 0; j < nodesArray.length; j++) {
          cell[nodesArray[j]] = i == j ? 0 : 1e9;
        }
      } // put the weights for the edges in. This assumes unidirectionality.


      for (var _i = 0; _i < edgesArray.length; _i++) {
        var edge = edges[edgesArray[_i]]; // edge has to be connected if it counts to the distances. If it is connected to inner clusters it will crash so we also check if it is in the D_matrix

        if (edge.connected === true && D_matrix[edge.fromId] !== undefined && D_matrix[edge.toId] !== undefined) {
          D_matrix[edge.fromId][edge.toId] = 1;
          D_matrix[edge.toId][edge.fromId] = 1;
        }
      }

      var nodeCount = nodesArray.length; // Adapted FloydWarshall based on unidirectionality to greatly reduce complexity.

      for (var k = 0; k < nodeCount; k++) {
        var knode = nodesArray[k];
        var kcolm = D_matrix[knode];

        for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {
          var inode = nodesArray[_i2];
          var icolm = D_matrix[inode];

          for (var _j = _i2 + 1; _j < nodeCount; _j++) {
            var jnode = nodesArray[_j];
            var jcolm = D_matrix[jnode];
            var val = Math.min(icolm[jnode], icolm[knode] + kcolm[jnode]);
            icolm[jnode] = val;
            jcolm[inode] = val;
          }
        }
      }

      return D_matrix;
    }
  }]);

  return FloydWarshall;
}();

/**
 * KamadaKawai positions the nodes initially based on
 *
 * "AN ALGORITHM FOR DRAWING GENERAL UNDIRECTED GRAPHS"
 * -- Tomihisa KAMADA and Satoru KAWAI in 1989
 *
 * Possible optimizations in the distance calculation can be implemented.
 */

var KamadaKawai = /*#__PURE__*/function () {
  /**
   * @param {object} body
   * @param {number} edgeLength
   * @param {number} edgeStrength
   */
  function KamadaKawai(body, edgeLength, edgeStrength) {
    _classCallCheck(this, KamadaKawai);

    this.body = body;
    this.springLength = edgeLength;
    this.springConstant = edgeStrength;
    this.distanceSolver = new FloydWarshall();
  }
  /**
   * Not sure if needed but can be used to update the spring length and spring constant
   *
   * @param {object} options
   */


  _createClass(KamadaKawai, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options) {
        if (options.springLength) {
          this.springLength = options.springLength;
        }

        if (options.springConstant) {
          this.springConstant = options.springConstant;
        }
      }
    }
    /**
     * Position the system
     *
     * @param {Array.<Node>} nodesArray
     * @param {Array.<vis.Edge>} edgesArray
     * @param {boolean} [ignoreClusters=false]
     */

  }, {
    key: "solve",
    value: function solve(nodesArray, edgesArray) {
      var ignoreClusters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // get distance matrix
      var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray); // distance matrix
      // get the L Matrix

      this._createL_matrix(D_matrix); // get the K Matrix


      this._createK_matrix(D_matrix); // initial E Matrix


      this._createE_matrix(); // calculate positions


      var threshold = 0.01;
      var innerThreshold = 1;
      var iterations = 0;
      var maxIterations = Math.max(1000, Math.min(10 * this.body.nodeIndices.length, 6000));
      var maxInnerIterations = 5;
      var maxEnergy = 1e9;
      var highE_nodeId = 0,
          dE_dx = 0,
          dE_dy = 0,
          delta_m = 0,
          subIterations = 0;

      while (maxEnergy > threshold && iterations < maxIterations) {
        iterations += 1;

        var _this$_getHighestEner = this._getHighestEnergyNode(ignoreClusters);

        var _this$_getHighestEner2 = _slicedToArray(_this$_getHighestEner, 4);

        highE_nodeId = _this$_getHighestEner2[0];
        maxEnergy = _this$_getHighestEner2[1];
        dE_dx = _this$_getHighestEner2[2];
        dE_dy = _this$_getHighestEner2[3];
        delta_m = maxEnergy;
        subIterations = 0;

        while (delta_m > innerThreshold && subIterations < maxInnerIterations) {
          subIterations += 1;

          this._moveNode(highE_nodeId, dE_dx, dE_dy);

          var _this$_getEnergy = this._getEnergy(highE_nodeId);

          var _this$_getEnergy2 = _slicedToArray(_this$_getEnergy, 3);

          delta_m = _this$_getEnergy2[0];
          dE_dx = _this$_getEnergy2[1];
          dE_dy = _this$_getEnergy2[2];
        }
      }
    }
    /**
     * get the node with the highest energy
     *
     * @param {boolean} ignoreClusters
     * @returns {number[]}
     * @private
     */

  }, {
    key: "_getHighestEnergyNode",
    value: function _getHighestEnergyNode(ignoreClusters) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var maxEnergy = 0;
      var maxEnergyNodeId = nodesArray[0];
      var dE_dx_max = 0,
          dE_dy_max = 0;

      for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {
        var m = nodesArray[nodeIdx]; // by not evaluating nodes with predefined positions we should only move nodes that have no positions.

        if (nodes[m].predefinedPosition !== true || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x !== true || nodes[m].options.fixed.y !== true) {
          var _this$_getEnergy3 = this._getEnergy(m),
              _this$_getEnergy4 = _slicedToArray(_this$_getEnergy3, 3),
              delta_m = _this$_getEnergy4[0],
              dE_dx = _this$_getEnergy4[1],
              dE_dy = _this$_getEnergy4[2];

          if (maxEnergy < delta_m) {
            maxEnergy = delta_m;
            maxEnergyNodeId = m;
            dE_dx_max = dE_dx;
            dE_dy_max = dE_dy;
          }
        }
      }

      return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];
    }
    /**
     * calculate the energy of a single node
     *
     * @param {Node.id} m
     * @returns {number[]}
     * @private
     */

  }, {
    key: "_getEnergy",
    value: function _getEnergy(m) {
      var _this$E_sums$m = _slicedToArray(this.E_sums[m], 2),
          dE_dx = _this$E_sums$m[0],
          dE_dy = _this$E_sums$m[1];

      var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));
      return [delta_m, dE_dx, dE_dy];
    }
    /**
     * move the node based on it's energy
     * the dx and dy are calculated from the linear system proposed by Kamada and Kawai
     *
     * @param {number} m
     * @param {number} dE_dx
     * @param {number} dE_dy
     * @private
     */

  }, {
    key: "_moveNode",
    value: function _moveNode(m, dE_dx, dE_dy) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var d2E_dx2 = 0;
      var d2E_dxdy = 0;
      var d2E_dy2 = 0;
      var x_m = nodes[m].x;
      var y_m = nodes[m].y;
      var km = this.K_matrix[m];
      var lm = this.L_matrix[m];

      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
        var i = nodesArray[iIdx];

        if (i !== m) {
          var x_i = nodes[i].x;
          var y_i = nodes[i].y;
          var kmat = km[i];
          var lmat = lm[i];
          var denominator = 1.0 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);
          d2E_dx2 += kmat * (1 - lmat * Math.pow(y_m - y_i, 2) * denominator);
          d2E_dxdy += kmat * (lmat * (x_m - x_i) * (y_m - y_i) * denominator);
          d2E_dy2 += kmat * (1 - lmat * Math.pow(x_m - x_i, 2) * denominator);
        }
      } // make the variable names easier to make the solving of the linear system easier to read


      var A = d2E_dx2,
          B = d2E_dxdy,
          C = dE_dx,
          D = d2E_dy2,
          E = dE_dy; // solve the linear system for dx and dy

      var dy = (C / A + E / B) / (B / A - D / B);
      var dx = -(B * dy + C) / A; // move the node

      nodes[m].x += dx;
      nodes[m].y += dy; // Recalculate E_matrix (should be incremental)

      this._updateE_matrix(m);
    }
    /**
     * Create the L matrix: edge length times shortest path
     *
     * @param {object} D_matrix
     * @private
     */

  }, {
    key: "_createL_matrix",
    value: function _createL_matrix(D_matrix) {
      var nodesArray = this.body.nodeIndices;
      var edgeLength = this.springLength;
      this.L_matrix = [];

      for (var i = 0; i < nodesArray.length; i++) {
        this.L_matrix[nodesArray[i]] = {};

        for (var j = 0; j < nodesArray.length; j++) {
          this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];
        }
      }
    }
    /**
     * Create the K matrix: spring constants times shortest path
     *
     * @param {object} D_matrix
     * @private
     */

  }, {
    key: "_createK_matrix",
    value: function _createK_matrix(D_matrix) {
      var nodesArray = this.body.nodeIndices;
      var edgeStrength = this.springConstant;
      this.K_matrix = [];

      for (var i = 0; i < nodesArray.length; i++) {
        this.K_matrix[nodesArray[i]] = {};

        for (var j = 0; j < nodesArray.length; j++) {
          this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);
        }
      }
    }
    /**
     *  Create matrix with all energies between nodes
     *
     *  @private
     */

  }, {
    key: "_createE_matrix",
    value: function _createE_matrix() {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      this.E_matrix = {};
      this.E_sums = {};

      for (var mIdx = 0; mIdx < nodesArray.length; mIdx++) {
        this.E_matrix[nodesArray[mIdx]] = [];
      }

      for (var _mIdx = 0; _mIdx < nodesArray.length; _mIdx++) {
        var m = nodesArray[_mIdx];
        var x_m = nodes[m].x;
        var y_m = nodes[m].y;
        var dE_dx = 0;
        var dE_dy = 0;

        for (var iIdx = _mIdx; iIdx < nodesArray.length; iIdx++) {
          var i = nodesArray[iIdx];

          if (i !== m) {
            var x_i = nodes[i].x;
            var y_i = nodes[i].y;
            var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
            this.E_matrix[m][iIdx] = [this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator), this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator)];
            this.E_matrix[i][_mIdx] = this.E_matrix[m][iIdx];
            dE_dx += this.E_matrix[m][iIdx][0];
            dE_dy += this.E_matrix[m][iIdx][1];
          }
        } //Store sum


        this.E_sums[m] = [dE_dx, dE_dy];
      }
    }
    /**
     * Update method, just doing single column (rows are auto-updated) (update all sums)
     *
     * @param {number} m
     * @private
     */

  }, {
    key: "_updateE_matrix",
    value: function _updateE_matrix(m) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var colm = this.E_matrix[m];
      var kcolm = this.K_matrix[m];
      var lcolm = this.L_matrix[m];
      var x_m = nodes[m].x;
      var y_m = nodes[m].y;
      var dE_dx = 0;
      var dE_dy = 0;

      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
        var i = nodesArray[iIdx];

        if (i !== m) {
          //Keep old energy value for sum modification below
          var cell = colm[iIdx];
          var oldDx = cell[0];
          var oldDy = cell[1]; //Calc new energy:

          var x_i = nodes[i].x;
          var y_i = nodes[i].y;
          var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
          var dx = kcolm[i] * (x_m - x_i - lcolm[i] * (x_m - x_i) * denominator);
          var dy = kcolm[i] * (y_m - y_i - lcolm[i] * (y_m - y_i) * denominator);
          colm[iIdx] = [dx, dy];
          dE_dx += dx;
          dE_dy += dy; //add new energy to sum of each column

          var sum = this.E_sums[i];
          sum[0] += dx - oldDx;
          sum[1] += dy - oldDy;
        }
      } //Store sum at -1 index


      this.E_sums[m] = [dE_dx, dE_dy];
    }
  }]);

  return KamadaKawai;
}();

/**
 * Create a network visualization, displaying nodes and edges.
 *
 * @param {Element} container   The DOM element in which the Network will
 *                                  be created. Normally a div element.
 * @param {object} data         An object containing parameters
 *                              {Array} nodes
 *                              {Array} edges
 * @param {object} options      Options
 * @class Network
 */

function Network(container, data, options) {
  var _context,
      _context2,
      _context3,
      _context4,
      _this = this;

  if (!(this instanceof Network)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  } // set constant values


  this.options = {};
  this.defaultOptions = {
    locale: "en",
    locales: locales,
    clickToUse: false
  };

  assign$2(this.options, this.defaultOptions);
  /**
   * Containers for nodes and edges.
   *
   * 'edges' and 'nodes' contain the full definitions of all the network elements.
   * 'nodeIndices' and 'edgeIndices' contain the id's of the active elements.
   *
   * The distinction is important, because a defined node need not be active, i.e.
   * visible on the canvas. This happens in particular when clusters are defined, in
   * that case there will be nodes and edges not displayed.
   * The bottom line is that all code with actions related to visibility, *must* use
   * 'nodeIndices' and 'edgeIndices', not 'nodes' and 'edges' directly.
   */


  this.body = {
    container: container,
    // See comment above for following fields
    nodes: {},
    nodeIndices: [],
    edges: {},
    edgeIndices: [],
    emitter: {
      on: bind$6(_context = this.on).call(_context, this),
      off: bind$6(_context2 = this.off).call(_context2, this),
      emit: bind$6(_context3 = this.emit).call(_context3, this),
      once: bind$6(_context4 = this.once).call(_context4, this)
    },
    eventListeners: {
      onTap: function onTap() {},
      onTouch: function onTouch() {},
      onDoubleTap: function onDoubleTap() {},
      onHold: function onHold() {},
      onDragStart: function onDragStart() {},
      onDrag: function onDrag() {},
      onDragEnd: function onDragEnd() {},
      onMouseWheel: function onMouseWheel() {},
      onPinch: function onPinch() {},
      onMouseMove: function onMouseMove() {},
      onRelease: function onRelease() {},
      onContext: function onContext() {}
    },
    data: {
      nodes: null,
      // A DataSet or DataView
      edges: null // A DataSet or DataView

    },
    functions: {
      createNode: function createNode() {},
      createEdge: function createEdge() {},
      getPointer: function getPointer() {}
    },
    modules: {},
    view: {
      scale: 1,
      translation: {
        x: 0,
        y: 0
      }
    },
    selectionBox: {
      show: false,
      position: {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: 0
        }
      }
    }
  }; // bind the event listeners

  this.bindEventListeners(); // setting up all modules

  this.images = new Images(function () {
    return _this.body.emitter.emit("_requestRedraw");
  }); // object with images

  this.groups = new Groups(); // object with groups

  this.canvas = new Canvas(this.body); // DOM handler

  this.selectionHandler = new SelectionHandler(this.body, this.canvas); // Selection handler

  this.interactionHandler = new InteractionHandler(this.body, this.canvas, this.selectionHandler); // Interaction handler handles all the hammer bindings (that are bound by canvas), key

  this.view = new View(this.body, this.canvas); // camera handler, does animations and zooms

  this.renderer = new CanvasRenderer(this.body, this.canvas); // renderer, starts renderloop, has events that modules can hook into

  this.physics = new PhysicsEngine(this.body); // physics engine, does all the simulations

  this.layoutEngine = new LayoutEngine(this.body); // layout engine for inital layout and hierarchical layout

  this.clustering = new ClusterEngine(this.body); // clustering api

  this.manipulation = new ManipulationSystem(this.body, this.canvas, this.selectionHandler, this.interactionHandler); // data manipulation system

  this.nodesHandler = new NodesHandler(this.body, this.images, this.groups, this.layoutEngine); // Handle adding, deleting and updating of nodes as well as global options

  this.edgesHandler = new EdgesHandler(this.body, this.images, this.groups); // Handle adding, deleting and updating of edges as well as global options

  this.body.modules["kamadaKawai"] = new KamadaKawai(this.body, 150, 0.05); // Layouting algorithm.

  this.body.modules["clustering"] = this.clustering; // create the DOM elements

  this.canvas._create(); // apply options


  this.setOptions(options); // load data (the disable start variable will be the same as the enabled clustering)

  this.setData(data);
} // Extend Network with an Emitter mixin

Emitter(Network.prototype);
/**
 * Set options
 *
 * @param {object} options
 */

Network.prototype.setOptions = function (options) {
  var _this2 = this;

  if (options === null) {
    options = undefined; // This ensures that options handling doesn't crash in the handling
  }

  if (options !== undefined) {
    var errorFound = Validator.validate(options, allOptions);

    if (errorFound === true) {
      console.error("%cErrors have been found in the supplied options object.", VALIDATOR_PRINT_STYLE);
    } // copy the global fields over


    var fields = ["locale", "locales", "clickToUse"];
    selectiveDeepExtend(fields, this.options, options); // normalize the locale or use English

    if (options.locale !== undefined) {
      options.locale = normalizeLanguageCode(options.locales || this.options.locales, options.locale);
    } // the hierarchical system can adapt the edges and the physics to it's own options because not all combinations work with the hierarichical system.


    options = this.layoutEngine.setOptions(options.layout, options);
    this.canvas.setOptions(options); // options for canvas are in globals
    // pass the options to the modules

    this.groups.setOptions(options.groups);
    this.nodesHandler.setOptions(options.nodes);
    this.edgesHandler.setOptions(options.edges);
    this.physics.setOptions(options.physics);
    this.manipulation.setOptions(options.manipulation, options, this.options); // manipulation uses the locales in the globals

    this.interactionHandler.setOptions(options.interaction);
    this.renderer.setOptions(options.interaction); // options for rendering are in interaction

    this.selectionHandler.setOptions(options.interaction); // options for selection are in interaction
    // reload the settings of the nodes to apply changes in groups that are not referenced by pointer.

    if (options.groups !== undefined) {
      this.body.emitter.emit("refreshNodes");
    } // these two do not have options at the moment, here for completeness
    //this.view.setOptions(options.view);
    //this.clustering.setOptions(options.clustering);


    if ("configure" in options) {
      if (!this.configurator) {
        this.configurator = new Configurator(this, this.body.container, configureOptions, this.canvas.pixelRatio, configuratorHideOption);
      }

      this.configurator.setOptions(options.configure);
    } // if the configuration system is enabled, copy all options and put them into the config system


    if (this.configurator && this.configurator.options.enabled === true) {
      var networkOptions = {
        nodes: {},
        edges: {},
        layout: {},
        interaction: {},
        manipulation: {},
        physics: {},
        global: {}
      };
      deepExtend(networkOptions.nodes, this.nodesHandler.options);
      deepExtend(networkOptions.edges, this.edgesHandler.options);
      deepExtend(networkOptions.layout, this.layoutEngine.options); // load the selectionHandler and render default options in to the interaction group

      deepExtend(networkOptions.interaction, this.selectionHandler.options);
      deepExtend(networkOptions.interaction, this.renderer.options);
      deepExtend(networkOptions.interaction, this.interactionHandler.options);
      deepExtend(networkOptions.manipulation, this.manipulation.options);
      deepExtend(networkOptions.physics, this.physics.options); // load globals into the global object

      deepExtend(networkOptions.global, this.canvas.options);
      deepExtend(networkOptions.global, this.options);
      this.configurator.setModuleOptions(networkOptions);
    } // handle network global options


    if (options.clickToUse !== undefined) {
      if (options.clickToUse === true) {
        if (this.activator === undefined) {
          this.activator = new Activator(this.canvas.frame);
          this.activator.on("change", function () {
            _this2.body.emitter.emit("activate");
          });
        }
      } else {
        if (this.activator !== undefined) {
          this.activator.destroy();
          delete this.activator;
        }

        this.body.emitter.emit("activate");
      }
    } else {
      this.body.emitter.emit("activate");
    }

    this.canvas.setSize(); // start the physics simulation. Can be safely called multiple times.

    this.body.emitter.emit("startSimulation");
  }
};
/**
 * Update the visible nodes and edges list with the most recent node state.
 *
 * Visible nodes are stored in this.body.nodeIndices.
 * Visible edges are stored in this.body.edgeIndices.
 * A node or edges is visible if it is not hidden or clustered.
 *
 * @private
 */


Network.prototype._updateVisibleIndices = function () {
  var nodes = this.body.nodes;
  var edges = this.body.edges;
  this.body.nodeIndices = [];
  this.body.edgeIndices = [];

  for (var nodeId in nodes) {
    if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
      if (!this.clustering._isClusteredNode(nodeId) && nodes[nodeId].options.hidden === false) {
        this.body.nodeIndices.push(nodes[nodeId].id);
      }
    }
  }

  for (var edgeId in edges) {
    if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {
      var edge = edges[edgeId]; // It can happen that this is executed *after* a node edge has been removed,
      // but *before* the edge itself has been removed. Taking this into account.

      var fromNode = nodes[edge.fromId];
      var toNode = nodes[edge.toId];
      var edgeNodesPresent = fromNode !== undefined && toNode !== undefined;
      var isVisible = !this.clustering._isClusteredEdge(edgeId) && edge.options.hidden === false && edgeNodesPresent && fromNode.options.hidden === false && // Also hidden if any of its connecting nodes are hidden
      toNode.options.hidden === false; // idem

      if (isVisible) {
        this.body.edgeIndices.push(edge.id);
      }
    }
  }
};
/**
 * Bind all events
 */


Network.prototype.bindEventListeners = function () {
  var _this3 = this;

  // This event will trigger a rebuilding of the cache everything.
  // Used when nodes or edges have been added or removed.
  this.body.emitter.on("_dataChanged", function () {
    _this3.edgesHandler._updateState();

    _this3.body.emitter.emit("_dataUpdated");
  }); // this is called when options of EXISTING nodes or edges have changed.

  this.body.emitter.on("_dataUpdated", function () {
    // Order important in following block
    _this3.clustering._updateState();

    _this3._updateVisibleIndices();

    _this3._updateValueRange(_this3.body.nodes);

    _this3._updateValueRange(_this3.body.edges); // start simulation (can be called safely, even if already running)


    _this3.body.emitter.emit("startSimulation");

    _this3.body.emitter.emit("_requestRedraw");
  });
};
/**
 * Set nodes and edges, and optionally options as well.
 *
 * @param {object} data              Object containing parameters:
 *                                   {Array | DataSet | DataView} [nodes] Array with nodes
 *                                   {Array | DataSet | DataView} [edges] Array with edges
 *                                   {String} [dot] String containing data in DOT format
 *                                   {String} [gephi] String containing data in gephi JSON format
 *                                   {Options} [options] Object with options
 */


Network.prototype.setData = function (data) {
  // reset the physics engine.
  this.body.emitter.emit("resetPhysics");
  this.body.emitter.emit("_resetData"); // unselect all to ensure no selections from old data are carried over.

  this.selectionHandler.unselectAll();

  if (data && data.dot && (data.nodes || data.edges)) {
    throw new SyntaxError('Data must contain either parameter "dot" or ' + ' parameter pair "nodes" and "edges", but not both.');
  } // set options


  this.setOptions(data && data.options); // set all data

  if (data && data.dot) {
    console.warn("The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);"); // parse DOT file

    var dotData = DOTToGraph(data.dot);
    this.setData(dotData);
    return;
  } else if (data && data.gephi) {
    // parse DOT file
    console.warn("The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);");
    var gephiData = parseGephi(data.gephi);
    this.setData(gephiData);
    return;
  } else {
    this.nodesHandler.setData(data && data.nodes, true);
    this.edgesHandler.setData(data && data.edges, true);
  } // emit change in data


  this.body.emitter.emit("_dataChanged"); // emit data loaded

  this.body.emitter.emit("_dataLoaded"); // find a stable position or start animating to a stable position

  this.body.emitter.emit("initPhysics");
};
/**
 * Cleans up all bindings of the network, removing it fully from the memory IF the variable is set to null after calling this function.
 * var network = new vis.Network(..);
 * network.destroy();
 * network = null;
 */


Network.prototype.destroy = function () {
  this.body.emitter.emit("destroy"); // clear events

  this.body.emitter.off();
  this.off(); // delete modules

  delete this.groups;
  delete this.canvas;
  delete this.selectionHandler;
  delete this.interactionHandler;
  delete this.view;
  delete this.renderer;
  delete this.physics;
  delete this.layoutEngine;
  delete this.clustering;
  delete this.manipulation;
  delete this.nodesHandler;
  delete this.edgesHandler;
  delete this.configurator;
  delete this.images;

  for (var nodeId in this.body.nodes) {
    if (!Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) continue;
    delete this.body.nodes[nodeId];
  }

  for (var edgeId in this.body.edges) {
    if (!Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) continue;
    delete this.body.edges[edgeId];
  } // remove the container and everything inside it recursively


  recursiveDOMDelete(this.body.container);
};
/**
 * Update the values of all object in the given array according to the current
 * value range of the objects in the array.
 *
 * @param {object} obj    An object containing a set of Edges or Nodes
 *                        The objects must have a method getValue() and
 *                        setValueRange(min, max).
 * @private
 */


Network.prototype._updateValueRange = function (obj) {
  var id; // determine the range of the objects

  var valueMin = undefined;
  var valueMax = undefined;
  var valueTotal = 0;

  for (id in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, id)) {
      var value = obj[id].getValue();

      if (value !== undefined) {
        valueMin = valueMin === undefined ? value : Math.min(value, valueMin);
        valueMax = valueMax === undefined ? value : Math.max(value, valueMax);
        valueTotal += value;
      }
    }
  } // adjust the range of all objects


  if (valueMin !== undefined && valueMax !== undefined) {
    for (id in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, id)) {
        obj[id].setValueRange(valueMin, valueMax, valueTotal);
      }
    }
  }
};
/**
 * Returns true when the Network is active.
 *
 * @returns {boolean}
 */


Network.prototype.isActive = function () {
  return !this.activator || this.activator.active;
};

Network.prototype.setSize = function () {
  return this.canvas.setSize.apply(this.canvas, arguments);
};

Network.prototype.canvasToDOM = function () {
  return this.canvas.canvasToDOM.apply(this.canvas, arguments);
};

Network.prototype.DOMtoCanvas = function () {
  return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);
};
/**
 * Nodes can be in clusters. Clusters can also be in clusters. This function returns and array of
 * nodeIds showing where the node is.
 *
 * If any nodeId in the chain, especially the first passed in as a parameter, is not present in
 * the current nodes list, an empty array is returned.
 *
 * Example:
 * cluster 'A' contains cluster 'B',
 * cluster 'B' contains cluster 'C',
 * cluster 'C' contains node 'fred'.
 * `jsnetwork.clustering.findNode('fred')` will return `['A','B','C','fred']`.
 *
 * @param {string|number} nodeId
 * @returns {Array}
 */


Network.prototype.findNode = function () {
  return this.clustering.findNode.apply(this.clustering, arguments);
};

Network.prototype.isCluster = function () {
  return this.clustering.isCluster.apply(this.clustering, arguments);
};

Network.prototype.openCluster = function () {
  return this.clustering.openCluster.apply(this.clustering, arguments);
};

Network.prototype.cluster = function () {
  return this.clustering.cluster.apply(this.clustering, arguments);
};

Network.prototype.getNodesInCluster = function () {
  return this.clustering.getNodesInCluster.apply(this.clustering, arguments);
};

Network.prototype.clusterByConnection = function () {
  return this.clustering.clusterByConnection.apply(this.clustering, arguments);
};

Network.prototype.clusterByHubsize = function () {
  return this.clustering.clusterByHubsize.apply(this.clustering, arguments);
};

Network.prototype.updateClusteredNode = function () {
  return this.clustering.updateClusteredNode.apply(this.clustering, arguments);
};

Network.prototype.getClusteredEdges = function () {
  return this.clustering.getClusteredEdges.apply(this.clustering, arguments);
};

Network.prototype.getBaseEdge = function () {
  return this.clustering.getBaseEdge.apply(this.clustering, arguments);
};

Network.prototype.getBaseEdges = function () {
  return this.clustering.getBaseEdges.apply(this.clustering, arguments);
};

Network.prototype.updateEdge = function () {
  return this.clustering.updateEdge.apply(this.clustering, arguments);
};
/**
 * This method will cluster all nodes with 1 edge with their respective connected node.
 * The options object is explained in full <a data-scroll="" data-options="{ &quot;easing&quot;: &quot;easeInCubic&quot; }" href="#optionsObject">below</a>.
 *
 * @param {object} [options]
 * @returns {undefined}
 */


Network.prototype.clusterOutliers = function () {
  return this.clustering.clusterOutliers.apply(this.clustering, arguments);
};

Network.prototype.getSeed = function () {
  return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);
};

Network.prototype.enableEditMode = function () {
  return this.manipulation.enableEditMode.apply(this.manipulation, arguments);
};

Network.prototype.disableEditMode = function () {
  return this.manipulation.disableEditMode.apply(this.manipulation, arguments);
};

Network.prototype.addNodeMode = function () {
  return this.manipulation.addNodeMode.apply(this.manipulation, arguments);
};

Network.prototype.editNode = function () {
  return this.manipulation.editNode.apply(this.manipulation, arguments);
};

Network.prototype.editNodeMode = function () {
  console.warn("Deprecated: Please use editNode instead of editNodeMode.");
  return this.manipulation.editNode.apply(this.manipulation, arguments);
};

Network.prototype.addEdgeMode = function () {
  return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);
};

Network.prototype.editEdgeMode = function () {
  return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);
};

Network.prototype.deleteSelected = function () {
  return this.manipulation.deleteSelected.apply(this.manipulation, arguments);
};

Network.prototype.getPositions = function () {
  return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);
};

Network.prototype.getPosition = function () {
  return this.nodesHandler.getPosition.apply(this.nodesHandler, arguments);
};

Network.prototype.storePositions = function () {
  return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);
};

Network.prototype.moveNode = function () {
  return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);
};

Network.prototype.getBoundingBox = function () {
  return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);
};

Network.prototype.getConnectedNodes = function (objectId) {
  if (this.body.nodes[objectId] !== undefined) {
    return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);
  } else {
    return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);
  }
};

Network.prototype.getConnectedEdges = function () {
  return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);
};

Network.prototype.startSimulation = function () {
  return this.physics.startSimulation.apply(this.physics, arguments);
};

Network.prototype.stopSimulation = function () {
  return this.physics.stopSimulation.apply(this.physics, arguments);
};

Network.prototype.stabilize = function () {
  return this.physics.stabilize.apply(this.physics, arguments);
};

Network.prototype.getSelection = function () {
  return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);
};

Network.prototype.setSelection = function () {
  return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);
};

Network.prototype.getSelectedNodes = function () {
  return this.selectionHandler.getSelectedNodeIds.apply(this.selectionHandler, arguments);
};

Network.prototype.getSelectedEdges = function () {
  return this.selectionHandler.getSelectedEdgeIds.apply(this.selectionHandler, arguments);
};

Network.prototype.getNodeAt = function () {
  var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);

  if (node !== undefined && node.id !== undefined) {
    return node.id;
  }

  return node;
};

Network.prototype.getEdgeAt = function () {
  var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);

  if (edge !== undefined && edge.id !== undefined) {
    return edge.id;
  }

  return edge;
};

Network.prototype.selectNodes = function () {
  return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);
};

Network.prototype.selectEdges = function () {
  return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);
};

Network.prototype.unselectAll = function () {
  this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);
  this.selectionHandler.commitWithoutEmitting.apply(this.selectionHandler);
  this.redraw();
};

Network.prototype.redraw = function () {
  return this.renderer.redraw.apply(this.renderer, arguments);
};

Network.prototype.getScale = function () {
  return this.view.getScale.apply(this.view, arguments);
};

Network.prototype.getViewPosition = function () {
  return this.view.getViewPosition.apply(this.view, arguments);
};

Network.prototype.fit = function () {
  return this.view.fit.apply(this.view, arguments);
};

Network.prototype.moveTo = function () {
  return this.view.moveTo.apply(this.view, arguments);
};

Network.prototype.focus = function () {
  return this.view.focus.apply(this.view, arguments);
};

Network.prototype.releaseNode = function () {
  return this.view.releaseNode.apply(this.view, arguments);
};

Network.prototype.getOptionsFromConfigurator = function () {
  var options = {};

  if (this.configurator) {
    options = this.configurator.getOptions.apply(this.configurator);
  }

  return options;
};

var parseDOTNetwork = DOTToGraph;
// overflow in UMD builds. They all export vis namespace therefore reexporting
// leads to loading vis to load vis to load vis…


//# sourceMappingURL=vis-network.js.map


/***/ }),

/***/ "./node_modules/vis-network/standalone/index.js":
/*!******************************************************!*\
  !*** ./node_modules/vis-network/standalone/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataSet": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.DataSet),
/* harmony export */   "DataView": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.DataView),
/* harmony export */   "Network": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.Network),
/* harmony export */   "NetworkImages": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.NetworkImages),
/* harmony export */   "Queue": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.Queue),
/* harmony export */   "data": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.data),
/* harmony export */   "networkDOTParser": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.networkDOTParser),
/* harmony export */   "networkGephiParser": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.networkGephiParser),
/* harmony export */   "networkOptions": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.networkOptions),
/* harmony export */   "parseDOTNetwork": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.parseDOTNetwork),
/* harmony export */   "parseGephiNetwork": () => (/* reexport safe */ _esm__WEBPACK_IMPORTED_MODULE_0__.parseGephiNetwork)
/* harmony export */ });
/* harmony import */ var _esm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./esm */ "./node_modules/vis-network/standalone/esm/index.js");



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__(__webpack_require__.s = "./src/vis_dawg.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHLEdBQUc7QUFDTjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWE7QUFDZDtBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGLEVBQUU7O0FBRUY7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQSxvQkFBb0IsMkNBQTJDO0FBQy9ELE1BQU07QUFDTix3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRzs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMs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O0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsVUFBVTtBQUN6Qjs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUJBQXFCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsR0FBRztBQUNsQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsMEJBQTBCLEVBQUUsZUFBZSxFQUFFO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25COztBQUVB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dkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzRUFBc0U7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQSxRQUFRLGFBQWE7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0EsUUFBUSxhQUFhO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUU7O0FBRWpFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsUUFBUTtBQUNSO0FB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LFVBQVU7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7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QUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsd0NBQXdDO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEseUVBQXlFO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isb0JBQW9CO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFLGFBQWE7QUFDekY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRzs7QUFFZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsNkNBQTZDLDJCQUEyQiw2QkFBNkIsNkNBQTZDLDRFQUE0RSw0REFBNEQsc0NBQXNDOztBQUVoVSxtQ0FBbUMsZ0JBQWdCLHNCQUFzQixPQUFPLDBCQUEwQix1REFBdUQsOEZBQThGLDRDQUE0QyxnTEFBZ0wseUVBQXlFLEtBQUs7QUFDemlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTs7QUFFdkU7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFROztBQUVSLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7O0FBRzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7OztBQUdsRzs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQkFBc0Isb0JBQW9CLEdBQUc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtEQUErRDtBQUMvRDs7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c0Y7O0FBRXRGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRzs7QUFFWjtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnRUFBZ0U7O0FBRW5FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRLFdBQVc7QUFDaEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUSxXQUFXLGFBQWE7QUFDL0M7QUFDQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUSxnQ0FBZ0Msc0JBQXNCO0FBQzdFO0FBQ0EsdURBQXVELHNCQUFzQjtBQUM3RSx3REFBd0Qsd0NBQXdDO0FBQ2hHOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUSxnQ0FBZ0Msc0JBQXNCO0FBQzdFO0FBQ0E7QUFDQSx1REFBdUQsc0JBQXNCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FB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akI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQix1QkFBdUI7QUFDdkMsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQix1QkFBdUI7QUFDdkMsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQix1QkFBdUI7QUFDdkM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGFBQWE7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGFBQWE7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWOztBQUVBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELG1EQUFtRCxPQUFPLHlDQUF5Qzs7QUFFNVcsdUNBQXVDLGdFQUFnRSxrQ0FBa0MsOENBQThDLE1BQU0sb0VBQW9FLElBQUksZUFBZSxZQUFZO0FBQ2hTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixRQUFRO0FBQ3pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMkRBQTJELHFGQUFxRixXQUFXLHNIQUFzSCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0sMkRBQTJELFVBQVU7O0FBRTM4QixvREFBb0QsZUFBZSxnQkFBZ0Isa0VBQWtFLHFGQUFxRiw2REFBNkQsa0RBQWtEOztBQUV6Vix5Q0FBeUMsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COztBQUUzSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDhCQUE4QjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxjQUFjO0FBQzNCLGFBQWEsY0FBYztBQUMzQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUIsc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0EsUUFBUTs7O0FBR1IsdUJBQXVCLHdCQUF3QjtBQUMvQywwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDOztBQUV6QyxzQkFBc0IsZUFBZTtBQUNyQztBQUNBOztBQUVBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTs7QUFFQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsa0JBQWtCO0FBQ2pDLGVBQWUsU0FBUztBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7O0FBRUEsc0NBQXNDOzs7QUFHdEMsc0NBQXNDOzs7QUFHdEMsOEJBQThCOzs7QUFHOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsNkJBQTZCO0FBQ3pELHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLDBCQUEwQjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsdUJBQXVCO0FBQzdDOztBQUVBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsdUJBQXVCO0FBQzdDOztBQUVBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLDBCQUEwQjtBQUNuRDtBQUNBOztBQUVBLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsMEJBQTBCO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsaUNBQWlDLE9BQU87QUFDeEMsaUNBQWlDLE9BQU87QUFDeEMsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0M7QUFDaEMsb0NBQW9DO0FBQ3BDLDRDQUE0QztBQUM1QyxrQ0FBa0M7QUFDbEMsNENBQTRDO0FBQzVDLGtDQUFrQztBQUNsQyx3Q0FBd0M7QUFDeEMsOENBQThDO0FBQzlDLG9DQUFvQztBQUNwQyw0Q0FBNEM7QUFDNUMsd0NBQXdDO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBLDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUM7QUFDQSxLQUFLO0FBQ0wsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU4sOEJBQThCOztBQUU5Qix1Q0FBdUM7O0FBRXZDLHdFQUF3RTs7QUFFeEUsbUdBQW1HOztBQUVuRyxnREFBZ0Q7O0FBRWhELDhEQUE4RDs7QUFFOUQsK0NBQStDOztBQUUvQyxtREFBbUQ7O0FBRW5ELGtEQUFrRDs7QUFFbEQsc0hBQXNIOztBQUV0SCxnR0FBZ0c7O0FBRWhHLDZFQUE2RTs7QUFFN0UsNEVBQTRFOztBQUU1RSxxREFBcUQ7O0FBRXJELHlCQUF5Qjs7O0FBR3pCLDRCQUE0Qjs7QUFFNUI7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTs7QUFFL0U7QUFDQSxtREFBbUQ7O0FBRW5ELDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlEQUFpRDs7O0FBR2pEOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLHNDQUFzQyw0QkFBNEI7QUFDbEUsc0NBQXNDLDRCQUE0QjtBQUNsRSxzQ0FBc0MsUUFBUTtBQUM5QyxzQ0FBc0MsUUFBUTtBQUM5QyxzQ0FBc0MsU0FBUztBQUMvQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0oseUNBQXlDOztBQUV6QztBQUNBLDJRQUEyUSxJQUFJOztBQUUvUTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxtUkFBbVI7QUFDblI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSiwwQ0FBMEM7O0FBRTFDLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsTUFBTSxZQUFZLFFBQVEsbUJBQW1CO0FBQzFIO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9PO0FBQ3BPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFxM0NzQjs7Ozs7OztVQ0F0QjtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7Ozs7V0M1QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0EsQ0FBQzs7Ozs7V0NQRDs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1dDTkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7Ozs7VUVKQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Zpc2RzLy4vc3JjL2Rhd2cudHMiLCJ3ZWJwYWNrOi8vdmlzZHMvLi9zcmMvdmlzX2Rhd2cudHMiLCJ3ZWJwYWNrOi8vdmlzZHMvLi9zcmMvdmlzanNfZGVmYXVsdF9vcHRpb25zLnRzIiwid2VicGFjazovL3Zpc2RzLy4vbm9kZV9tb2R1bGVzL3Zpcy1uZXR3b3JrL3N0YW5kYWxvbmUvZXNtL2luZGV4LmpzIiwid2VicGFjazovL3Zpc2RzLy4vbm9kZV9tb2R1bGVzL3Zpcy1uZXR3b3JrL3N0YW5kYWxvbmUvZXNtL3Zpcy1uZXR3b3JrLmpzIiwid2VicGFjazovL3Zpc2RzLy4vbm9kZV9tb2R1bGVzL3Zpcy1uZXR3b3JrL3N0YW5kYWxvbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmlzZHMvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vdmlzZHMvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3Zpc2RzL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vdmlzZHMvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly92aXNkcy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3Zpc2RzL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vdmlzZHMvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly92aXNkcy93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vdmlzZHMvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE5vZGUge1xuICBiaXJ0aF90aW1lOiBudW1iZXI7XG4gIGRlcHRoOiBudW1iZXI7XG4gIGNoaWxkcmVuOiBNYXA8c3RyaW5nLCBOb2RlPjtcbiAgc2xpbms6IE5vZGU7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGJpcnRoX3RpbWU6IG51bWJlcixcbiAgICBkZXB0aDogbnVtYmVyLFxuICAgIGNoaWxkcmVuOiBNYXA8c3RyaW5nLCBOb2RlPiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbiAgICBzbGluazogTm9kZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICApIHtcbiAgICB0aGlzLmJpcnRoX3RpbWUgPSBiaXJ0aF90aW1lO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBjaGlsZHJlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zZXQoaywgdik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2xpbmsgPSBzbGluayA/IHNsaW5rIDogdGhpcztcbiAgfVxufVxuXG4vLyBTdXBlck5vZGUgaXMgYSB2aXJ0dWFsIG5vZGUgc3VjaCB0aGF0XG4vLyBpdCBpcyBhIG5vZGUgcG9pbnRpbmcgcm9vdCdzIHN1ZmZpeCBsaW5rXG4vLyBpdCBjYW4gYmUgbW92ZWQgdG8gcm9vdCBieSBhbnkgY2hhcmFjdGVycy5cbmNsYXNzIFN1cGVyTm9kZSBleHRlbmRzIE5vZGUge1xuICBkZXB0aDogbnVtYmVyO1xuICBjaGlsZHJlbjogYW55O1xuICBjb25zdHJ1Y3Rvcihyb290OiBOb2RlKSB7XG4gICAgc3VwZXIoLTEsIC0xKTtcbiAgICB0aGlzLmRlcHRoID0gLTE7XG4gICAgdGhpcy5jaGlsZHJlbiA9IHsgZ2V0OiB1bmRlZmluZWQgfTtcbiAgICByb290LnNsaW5rID0gdGhpcztcbiAgICB0aGlzLmNoaWxkcmVuLmdldCA9IChjaGFyOiBzdHJpbmcpID0+IHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH07XG4gICAgdGhpcy5jaGlsZHJlbi5oYXMgPSAoY2hhcjogc3RyaW5nKSA9PiB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEQVdHIHtcbiAgbm9kZXM6IEFycmF5PE5vZGU+O1xuICByb290OiBOb2RlO1xuICB0YWlsOiBOb2RlO1xuICBzdXBlcm5vZGU6IFN1cGVyTm9kZTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuY3JlYXRlX25vZGUoMCk7XG4gICAgdGhpcy50YWlsID0gdGhpcy5yb290O1xuICAgIHRoaXMuc3VwZXJub2RlID0gbmV3IFN1cGVyTm9kZSh0aGlzLnJvb3QpO1xuICB9XG5cbiAgY3JlYXRlX25vZGUoZGVwdGg6IG51bWJlcik6IE5vZGUge1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgTm9kZSh0aGlzLm5vZGVzLmxlbmd0aCwgZGVwdGgpO1xuICAgIHRoaXMubm9kZXMucHVzaChub2RlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGNvcHlfbm9kZShub2RlOiBOb2RlKSB7XG4gICAgY29uc3QgbmV3X25vZGUgPSBuZXcgTm9kZShcbiAgICAgIHRoaXMubm9kZXMubGVuZ3RoLFxuICAgICAgbm9kZS5kZXB0aCxcbiAgICAgIG5vZGUuY2hpbGRyZW4sXG4gICAgICBub2RlLnNsaW5rXG4gICAgKTtcbiAgICB0aGlzLm5vZGVzLnB1c2gobmV3X25vZGUpO1xuICAgIHJldHVybiBuZXdfbm9kZTtcbiAgfVxuXG4gIGluc2VydChjaGFyOiBzdHJpbmcpIHtcbiAgICBsZXQgY3VyID0gdGhpcy50YWlsO1xuICAgIHRoaXMudGFpbCA9IHRoaXMuY3JlYXRlX25vZGUodGhpcy50YWlsLmRlcHRoICsgMSk7XG4gICAgd2hpbGUgKCFjdXIuY2hpbGRyZW4uaGFzKGNoYXIpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnY3VyJywgY3VyKVxuICAgICAgY3VyLmNoaWxkcmVuLnNldChjaGFyLCB0aGlzLnRhaWwpO1xuICAgICAgY3VyID0gY3VyLnNsaW5rIGFzIE5vZGU7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkID0gY3VyLmNoaWxkcmVuLmdldChjaGFyKSBhcyBOb2RlO1xuICAgIGlmIChjdXIuZGVwdGggKyAxID09PSBjaGlsZC5kZXB0aCkge1xuICAgICAgdGhpcy50YWlsLnNsaW5rID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5ld19ub2RlID0gdGhpcy5jb3B5X25vZGUoY2hpbGQpO1xuICAgICAgbmV3X25vZGUuZGVwdGggPSBjdXIuZGVwdGggKyAxO1xuICAgICAgY3VyLmNoaWxkcmVuLnNldChjaGFyLCBuZXdfbm9kZSk7XG4gICAgICB0aGlzLnRhaWwuc2xpbmsgPSBuZXdfbm9kZTtcbiAgICAgIGNoaWxkLnNsaW5rID0gbmV3X25vZGU7XG5cbiAgICAgIGN1ciA9IGN1ci5zbGluaztcbiAgICAgIHdoaWxlIChjdXIuZGVwdGggKyAxIDwgKGN1ci5jaGlsZHJlbi5nZXQoY2hhcikgYXMgTm9kZSkuZGVwdGgpIHtcbiAgICAgICAgY3VyLmNoaWxkcmVuLnNldChjaGFyLCBuZXdfbm9kZSk7XG4gICAgICAgIGN1ciA9IGN1ci5zbGluaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBqc29uKHNob3dfc3VmZml4X2xpbmtzOiBib29sZWFuID0gdHJ1ZSkge1xuICAgIGNvbnN0IG5vZGVzOiBhbnkgPSBbXTtcbiAgICBsZXQgZWRnZXM6IGFueSA9IFtdO1xuICAgIGNvbnN0IG5pZCA9IG5ldyBNYXAoKTtcbiAgICBsZXQgbWF4X2RpZmZfZGVwdGggPSAwO1xuICAgIGNvbnN0IG1pbl9yb3VuZG5lc3MgPSAwLjI7XG4gICAgY29uc3QgbWF4X3JvdW5kbmVzcyA9IDAuNTtcbiAgICB0aGlzLm5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIG1heF9kaWZmX2RlcHRoID0gTWF0aC5tYXgobWF4X2RpZmZfZGVwdGgsIG5vZGUuZGVwdGgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJvdW5kbmVzcyA9IChkaWZmX2RlcHRoOiBudW1iZXIpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIG1pbl9yb3VuZG5lc3MgK1xuICAgICAgICAoKG1heF9yb3VuZG5lc3MgLSBtaW5fcm91bmRuZXNzKSAqIGRpZmZfZGVwdGgpIC8gbWF4X2RpZmZfZGVwdGhcbiAgICAgICk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNyZWF0ZV9qc29uX25vZGUgPSAobm9kZTogTm9kZSkgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2pzb25fbm9kZScsIG5vZGUsIG5pZFtub2RlXSwgbmlkKVxuICAgICAgaWYgKCFuaWQuaGFzKG5vZGUpKSB7XG4gICAgICAgIG5pZC5zZXQobm9kZSwgbm9kZS5iaXJ0aF90aW1lKTtcbiAgICAgICAgY29uc3QgbmRpYyA9IHtcbiAgICAgICAgICBsYWJlbDogXCJcIiArIG5pZC5nZXQobm9kZSksXG4gICAgICAgICAgaWQ6IG5pZC5nZXQobm9kZSksXG4gICAgICAgICAgbGV2ZWw6IG5vZGUuZGVwdGgsXG4gICAgICAgIH07XG4gICAgICAgIG5vZGVzLnB1c2gobmRpYyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm5vZGVzLmZvckVhY2goKGZyb21fbm9kZSkgPT4ge1xuICAgICAgY3JlYXRlX2pzb25fbm9kZShmcm9tX25vZGUpO1xuICAgICAgZnJvbV9ub2RlLmNoaWxkcmVuLmZvckVhY2goKHRvX25vZGUsIGxhYmVsKSA9PiB7XG4gICAgICAgIGNyZWF0ZV9qc29uX25vZGUodG9fbm9kZSk7XG4gICAgICAgIGNvbnN0IGRpZmZfZGVwdGggPSBNYXRoLmFicyh0b19ub2RlLmRlcHRoIC0gZnJvbV9ub2RlLmRlcHRoKTtcbiAgICAgICAgY29uc3QgZWRnZSA9IHtcbiAgICAgICAgICBmcm9tOiBuaWQuZ2V0KGZyb21fbm9kZSksXG4gICAgICAgICAgdG86IG5pZC5nZXQodG9fbm9kZSksXG4gICAgICAgICAgaWQ6IG5pZC5nZXQoZnJvbV9ub2RlKSArIFwiLVwiICsgbmlkLmdldCh0b19ub2RlKSxcbiAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgZm9udDogeyBhbGlnbjogXCJ0b3BcIiB9LFxuICAgICAgICAgIHNtb290aDogeyB0eXBlOiBcImN1cnZlZENXXCIsIHJvdW5kbmVzczogcm91bmRuZXNzKGRpZmZfZGVwdGgpIH0sXG4gICAgICAgIH07XG4gICAgICAgIGVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIHN1ZmZpeCBsaW5rXG4gICAgaWYgKHNob3dfc3VmZml4X2xpbmtzKSB7XG4gICAgICBjb25zdCBzbGlua3MgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZnJvbV9ub2RlIG9mIHRoaXMubm9kZXMpIHtcbiAgICAgICAgaWYgKGZyb21fbm9kZSA9PT0gdGhpcy5yb290KSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdG9fbm9kZSA9IGZyb21fbm9kZS5zbGluaztcbiAgICAgICAgY29uc29sZS5sb2coXCJmcm9tX25vZGVcIiwgZnJvbV9ub2RlKTtcbiAgICAgICAgY29uc3QgZGlmZl9kZXB0aCA9IE1hdGguYWJzKHRvX25vZGUuZGVwdGggLSBmcm9tX25vZGUuZGVwdGgpO1xuICAgICAgICBjb25zdCBzbGluayA9IHtcbiAgICAgICAgICBmcm9tOiBuaWQuZ2V0KGZyb21fbm9kZSksXG4gICAgICAgICAgdG86IG5pZC5nZXQodG9fbm9kZSksXG4gICAgICAgICAgaWQ6IFwic1wiICsgbmlkLmdldChmcm9tX25vZGUpICsgXCItXCIgKyBuaWQuZ2V0KHRvX25vZGUpLFxuICAgICAgICAgIGRhc2hlczogdHJ1ZSxcbiAgICAgICAgICAvLyBjb2xvcjogeyBjb2xvcjogJyM4NDg0ODQnIH0sXG4gICAgICAgICAgY29sb3I6IHsgY29sb3I6IFwiI2ZmMDAwMFwiIH0sXG4gICAgICAgICAgc21vb3RoOiB7IHR5cGU6IFwiY3VydmVkQ1dcIiwgcm91bmRuZXNzOiByb3VuZG5lc3MoZGlmZl9kZXB0aCkgfSxcbiAgICAgICAgfTtcbiAgICAgICAgc2xpbmtzLnB1c2goc2xpbmspO1xuICAgICAgfVxuICAgICAgZWRnZXMgPSBlZGdlcy5jb25jYXQoc2xpbmtzKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcm9vdDogbmlkLmdldCh0aGlzLnJvb3QpLCBub2Rlczogbm9kZXMsIGVkZ2VzOiBlZGdlcyB9O1xuICB9XG4gIGJ1bGRfc3VmZml4X2xpbmtzKCkge31cbn1cblxuZnVuY3Rpb24gbWFpbih0ZXh0OiBzdHJpbmcpIHtcbiAgY29uc3QgZGF3ZyA9IG5ldyBEQVdHKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgIGRhd2cuaW5zZXJ0KHRleHRbaV0pO1xuICB9XG4gIGNvbnNvbGUubG9nKGRhd2cpO1xuICBjb25zb2xlLmxvZyhkYXdnLmpzb24pO1xufVxuXG5pZiAocmVxdWlyZS5tYWluID09PSBtb2R1bGUpIHtcbiAgaWYgKHByb2Nlc3MuYXJndi5sZW5ndGggPT09IDMpIHtcbiAgICBtYWluKHByb2Nlc3MuYXJndlsyXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdXNhZ2UgPVxuICAgICAgcHJvY2Vzcy5hcmd2WzFdICtcbiAgICAgIFwiIGlucHV0X3N0clxcblwiICtcbiAgICAgIFwiXFx0YnVpbGQgc3VmZml4IHRyZWUgb2YgaW5wdXRfc3RyIGFuZCBzaG93IHRoZSBzdHJ1Y3R1cmUgaW4ganNvbiBmb3JtYXQuXCI7XG4gICAgY29uc29sZS5sb2codXNhZ2UpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEYXRhU2V0LCBOZXR3b3JrIH0gZnJvbSBcInZpcy1uZXR3b3JrL3N0YW5kYWxvbmVcIjtcbmltcG9ydCB7IERBV0cgfSBmcm9tIFwiLi9kYXdnXCI7XG5pbXBvcnQgKiBhcyB2aXNqc19kZWZhdWx0X29wdGlvbnMgZnJvbSBcIi4vdmlzanNfZGVmYXVsdF9vcHRpb25zXCI7XG5cbmNvbnN0IG9wdGlvbnMgPSB2aXNqc19kZWZhdWx0X29wdGlvbnMub3B0aW9ucztcbmNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibmV0d29ya1wiKSBhcyBIVE1MRWxlbWVudDtcbmNvbnN0IG5ldHdvcmsgPSBuZXcgTmV0d29yayhjb250YWluZXIsIHt9LCBvcHRpb25zKTtcbmxldCBuZXR3b3JrRGF0YSA9IHtcbiAgbm9kZXM6IG5ldyBEYXRhU2V0KFtdKSxcbiAgZWRnZXM6IG5ldyBEYXRhU2V0KFtdKSxcbn07XG5sZXQgZGF3ZyA9IG5ldyBEQVdHKCk7XG5cbmludGVyZmFjZSBQYXJhbXMge1xuICBpbnB1dF90ZXh0OiBzdHJpbmc7XG4gIHNob3dfc3VmZml4X2xpbmtzOiBib29sZWFuO1xufVxuXG5jb25zdCBsb2FkX3BhcmFtc19mcm9tX3VybCA9ICgpID0+IHtcbiAgY29uc3QgcXVlcnlTdHJpbmcgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xuICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHF1ZXJ5U3RyaW5nKTtcbiAgbGV0IHBhcmFtczogUGFyYW1zID0ge1xuICAgIGlucHV0X3RleHQ6IFwiY29jb2FcIixcbiAgICBzaG93X3N1ZmZpeF9saW5rczogdHJ1ZSxcbiAgfTtcblxuICBjb25zdCB1cmxrZXkgPSB1cmxQYXJhbXMuZ2V0KFwiaW5wdXRfdGV4dFwiKTtcbiAgaWYgKHVybGtleSAhPT0gbnVsbCkgcGFyYW1zLmlucHV0X3RleHQgPSB1cmxrZXk7XG4gIHBhcmFtcy5zaG93X3N1ZmZpeF9saW5rcyA9IHVybFBhcmFtcy5nZXQoXCJzaG93X3N1ZmZpeF9saW5rc1wiKSA9PT0gXCJ0cnVlXCI7XG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG5jb25zdCBsb2FkX3BhcmFtc19mcm9tX2h0bWwgPSAoKSA9PiB7XG4gIGNvbnN0IGlucHV0X3RleHQgPSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dF90ZXh0XCIpIGFzIEhUTUxJbnB1dEVsZW1lbnQpXG4gICAgLnZhbHVlO1xuICBjb25zdCBzaG93X3N1ZmZpeF9saW5rcyA9IChcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNob3dfc3VmZml4X2xpbmtzXCIpIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgKS5jaGVja2VkO1xuICBjb25zdCBwYXJhbXM6IFBhcmFtcyA9IHtcbiAgICBpbnB1dF90ZXh0OiBpbnB1dF90ZXh0LFxuICAgIHNob3dfc3VmZml4X2xpbmtzOiBzaG93X3N1ZmZpeF9saW5rcyxcbiAgfTtcbiAgcmV0dXJuIHBhcmFtcztcbn07XG5cbmNvbnN0IHNldF9wYXJhbXNfdG9fdXJsID0gKHBhcmFtczogUGFyYW1zKSA9PiB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xuICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMocGFyYW1zKSkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgcGFyYW1zW2tleSBhcyBrZXlvZiBQYXJhbXNdLnRvU3RyaW5nKCkpO1xuICB9XG4gIGhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCBcIlwiLCB1cmwudG9TdHJpbmcoKSk7XG59O1xuXG5jb25zdCBzZXRfcGFyYW1zX3RvX2h0bWwgPSAocGFyYW1zOiBQYXJhbXMpID0+IHtcbiAgY29uc29sZS5sb2coXCJzZXRwYXJhbXNcIik7XG4gIGNvbnN0IGlucHV0X3RleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0X3RleHRcIikgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgY29uc3Qgc2hvd19zdWZmaXhfbGlua3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICBcInNob3dfc3VmZml4X2xpbmtzXCJcbiAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICBjb25zdCBpbXBsaWNpdF9jZGF3ZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgIFwiaW1wbGljaXRfY2Rhd2dcIlxuICApIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gIGlucHV0X3RleHQudmFsdWUgPSBwYXJhbXMuaW5wdXRfdGV4dDtcbiAgc2hvd19zdWZmaXhfbGlua3MuY2hlY2tlZCA9IHBhcmFtcy5zaG93X3N1ZmZpeF9saW5rcztcbn07XG5cbmNvbnN0IHJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gc2V0IHBhcmFtcyB0byB1cmxcbiAgY29uc3QgcGFyYW1zID0gbG9hZF9wYXJhbXNfZnJvbV9odG1sKCk7XG4gIHNldF9wYXJhbXNfdG9fdXJsKHBhcmFtcyk7XG5cbiAgZGF3ZyA9IG5ldyBEQVdHKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmlucHV0X3RleHQubGVuZ3RoOyBpKyspIHtcbiAgICBkYXdnLmluc2VydChwYXJhbXMuaW5wdXRfdGV4dFtpXSk7XG4gIH1cbiAgY29uc3QganNvbiA9IGRhd2cuanNvbihwYXJhbXMuc2hvd19zdWZmaXhfbGlua3MpO1xuICBjb25zb2xlLmxvZyhcImpzb25cIiwganNvbik7XG4gIG5ldHdvcmtEYXRhID0ge1xuICAgIG5vZGVzOiBuZXcgRGF0YVNldChqc29uLm5vZGVzKSxcbiAgICBlZGdlczogbmV3IERhdGFTZXQoanNvbi5lZGdlcyksXG4gIH07XG4gIG5ldHdvcmsuc2V0RGF0YShuZXR3b3JrRGF0YSk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBtYXAgZnJvbSBub2RlIGlkIHRvIHRoZSBzdHJpbmdzIGZyb20gcm9vdCB0byB0aGUgbm9kZS5cbiAqL1xuLy8gY29uc3QgbWFrZV9ub2RlX3N0cnMgPSAoKTogTWFwPG51bWJlciwgU2V0PHN0cmluZz4+ID0+IHtcbmNvbnN0IG1ha2Vfbm9kZV9zdHJzID0gKCk6IE1hcDxudW1iZXIsIHN0cmluZ1tdPiA9PiB7XG4gIGNvbnN0IGpzb24gPSBkYXdnLmpzb24oKTtcbiAgY29uc3QgbWFwID0gbmV3IE1hcDxudW1iZXIsIHN0cmluZ1tdPigpO1xuICAvLyBjb25zdCBtYXAgPSBuZXcgTWFwPG51bWJlciwgU2V0PHN0cmluZz4+KCk7XG4gIC8vIGNvbnN0IG1hcCA9IG5ldyBNYXA8bnVtYmVyLCBTZXQ8c3RyaW5nPj4oKTtcbiAgY29uc3QgY2hpbGRyZW4gPSAobmlkOiBudW1iZXIpID0+IHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgZm9yIChsZXQgZWRnZSBvZiBqc29uLmVkZ2VzKSB7XG4gICAgICBpZiAoZWRnZS5pZFswXSA9PT0gXCJzXCIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGVkZ2UuZnJvbSAhPT0gbmlkKSBjb250aW51ZTtcbiAgICAgIHJlcy5wdXNoKGVkZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICBjb25zdCByZWMgPSAobmlkOiBudW1iZXIsIHByZWZpeDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFtYXAuaGFzKG5pZCkpIHtcbiAgICAgIC8vIG1hcC5zZXQobmlkLCBuZXcgU2V0KCkpO1xuICAgICAgbWFwLnNldChuaWQsIFtdKTtcbiAgICB9XG4gICAgbWFwLmdldChuaWQpIS5wdXNoKHByZWZpeCk7XG4gICAgZm9yIChsZXQgZWRnZSBvZiBjaGlsZHJlbihuaWQpKSB7XG4gICAgICBpZiAoZWRnZS5mcm9tICE9PSBuaWQpIGNvbnRpbnVlO1xuICAgICAgcmVjKGVkZ2UudG8sIHByZWZpeCArIGVkZ2UubGFiZWwpO1xuICAgIH1cbiAgfTtcbiAgcmVjKGpzb24ucm9vdCwgXCJcIik7XG4gIGZvciAobGV0IFtrLCB2XSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgdi5zb3J0KChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbWFwO1xufTtcblxuY29uc3Qgc2hvd19ub2RlX3N0ciA9IChuaWQ6IG51bWJlciB8IG51bGwpID0+IHtcbiAgY29uc3QgZWxtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJub2RlX3N0clwiKSBhcyBIVE1MRWxlbWVudDtcbiAgbGV0IHRleHQgPSBcIlwiO1xuICBpZiAobmlkICE9PSBudWxsKSB7XG4gICAgY29uc3QgbnN0cnMgPSBtYWtlX25vZGVfc3RycygpO1xuICAgIGZvciAobGV0IG5zdHIgb2YgbnN0cnMuZ2V0KG5pZCkhKSB7XG4gICAgICB0ZXh0ICs9IFwiPHA+XCIgKyBuc3RyICsgXCI8L3A+XCI7XG4gICAgfVxuICB9XG4gIGVsbS5pbm5lckhUTUwgPSB0ZXh0O1xufTtcblxuY29uc3QgbWFpbiA9ICgpID0+IHtcbiAgLy8gc2V0IGV2ZW50IGxpc3RlbmVyXG4gIGNvbnN0IGlucHV0X3RleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0X3RleHRcIikgYXMgSFRNTEVsZW1lbnQ7XG4gIGlucHV0X3RleHQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHJlZHJhdyk7XG4gIGlucHV0X3RleHQuYWRkRXZlbnRMaXN0ZW5lcihcInByb3BlcnR5Y2hhbmdlXCIsIHJlZHJhdyk7XG4gIGNvbnN0IHNob3dfc2xfYnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgXCJzaG93X3N1ZmZpeF9saW5rc1wiXG4gICkgYXMgSFRNTEVsZW1lbnQ7XG4gIHNob3dfc2xfYnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgcmVkcmF3KTtcblxuICBuZXR3b3JrLm9uKFwiaG92ZXJFZGdlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgY29uc29sZS5sb2coXCJob3ZlckVkZ2VcIiwgZSk7XG4gICAgLy8gY29uc29sZS5sb2coJ25ldHdvcmtEYXRhLmVkZ2VzJywgbmV0d29ya0RhdGEuZWRnZXMuZ2V0KGUuZWRnZSkpXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIG5ldHdvcmtEYXRhLmVkZ2VzLnVwZGF0ZSh7IGlkOiBlLmVkZ2UsIGZvbnQ6IHsgc2l6ZTogMzQgfSB9KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgbmlkID0gbmV0d29ya0RhdGEuZWRnZXMuZ2V0KGUuZWRnZSkudG87XG4gICAgc2hvd19ub2RlX3N0cihuaWQpO1xuICB9KTtcbiAgbmV0d29yay5vbihcImJsdXJFZGdlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgY29uc29sZS5sb2coXCJibHVyRWRnZVwiLCBlKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbmV0d29ya0RhdGEuZWRnZXMudXBkYXRlKHsgaWQ6IGUuZWRnZSwgZm9udDogeyBzaXplOiAxNCB9IH0pO1xuICAgIC8vIHNob3dfbm9kZV9zdHIobnVsbCk7XG4gIH0pO1xuICBuZXR3b3JrLm9uKFwiaG92ZXJOb2RlXCIsIChuKSA9PiB7XG4gICAgc2hvd19ub2RlX3N0cihuLm5vZGUpO1xuICB9KTtcbiAgbmV0d29yay5vbihcImJsdXJOb2RlXCIsIChuKSA9PiB7XG4gICAgLy8gc2hvd19ub2RlX3N0cihudWxsKTtcbiAgfSk7XG5cbiAgLy8gbG9hZCBhbmQgc2V0IHBhcmFtZXRlcnNcbiAgY29uc3QgcGFyYW1zID0gbG9hZF9wYXJhbXNfZnJvbV91cmwoKTtcbiAgc2V0X3BhcmFtc190b19odG1sKHBhcmFtcyk7XG5cbiAgcmVkcmF3KCk7XG59O1xuXG5tYWluKCk7XG4iLCJleHBvcnQgY29uc3Qgb3B0aW9ucyA9IHtcbiAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgbGF5b3V0OiB7XG4gICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICAvLyBlbmFibGVkOiB0cnVlXG4gICAgICAvLyBkaXJlY3Rpb246ICdVRCcsXG4gICAgICBkaXJlY3Rpb246IFwiTFJcIixcbiAgICAgIC8vIHNvcnRNZXRob2Q6ICdkaXJlY3RlZCcsXG4gICAgICB0cmVlU3BhY2luZzogMTg1LFxuICAgICAgbGV2ZWxTZXBhcmF0aW9uOiA5NSxcbiAgICAgIG5vZGVTcGFjaW5nOiA0MCxcbiAgICB9LFxuICB9LFxuICBub2Rlczoge1xuICAgIHNpemU6IDEwLFxuICB9LFxuICBlZGdlczoge1xuICAgIGFycm93czoge1xuICAgICAgdG86IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IDAuNSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBlZGdlIGxhYmVsIGlzIG5vdCBkaXNwbGF5ZWQgYXQgdGhlIGNlbnRlciBvZiB0aGUgZWRnZVxuICAgIC8vIGlmIGBzbW9vdGhgIGlzIHNwZWNpZmllZFxuICAgIHNtb290aDoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIC8vIHR5cGU6ICdkeW5hbWljJyxcbiAgICAgIHR5cGU6IFwidmVydGljYWxcIiwgLy8gVGhpcyBpcyBiZXR0ZXIgZm9yIExSXG4gICAgICAvLyB0eXBlOiAnaG9yaXpvbnRhbCcsIC8vIFRoaXMgaXMgYmV0dGVyIGZvciBVRFxuICAgICAgLy8gdHlwZTogJ2NvbnRpbnVvdXMnLFxuICAgICAgLy8gdHlwZTogJ2N1cnZlZENDVycsXG4gICAgICAvLyB0eXBlOiAnc3RyYWlnaHRDcm9zcycsXG4gICAgICByb3VuZG5lc3M6IDEuMCxcbiAgICB9LFxuICB9LFxuICBpbnRlcmFjdGlvbjoge1xuICAgIGhvdmVyOiB0cnVlLFxuICAgIG5hdmlnYXRpb25CdXR0b25zOiB0cnVlLFxuICB9LFxuICBwaHlzaWNzOiBmYWxzZSxcbn07XG4iLCJleHBvcnQgKiBmcm9tIFwiLi92aXMtbmV0d29ya1wiO1xuIiwiLyoqXG4gKiB2aXMtbmV0d29ya1xuICogaHR0cHM6Ly92aXNqcy5naXRodWIuaW8vdmlzLW5ldHdvcmsvXG4gKlxuICogQSBkeW5hbWljLCBicm93c2VyLWJhc2VkIHZpc3VhbGl6YXRpb24gbGlicmFyeS5cbiAqXG4gKiBAdmVyc2lvbiA5LjEuMlxuICogQGRhdGUgICAgMjAyMi0wMy0yOFQyMDoxMzo1MS4wNDZaXG4gKlxuICogQGNvcHlyaWdodCAoYykgMjAxMS0yMDE3IEFsbWVuZGUgQi5WLCBodHRwOi8vYWxtZW5kZS5jb21cbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTctMjAxOSB2aXNqcyBjb250cmlidXRvcnMsIGh0dHBzOi8vZ2l0aHViLmNvbS92aXNqc1xuICpcbiAqIEBsaWNlbnNlXG4gKiB2aXMuanMgaXMgZHVhbCBsaWNlbnNlZCB1bmRlciBib3RoXG4gKlxuICogICAxLiBUaGUgQXBhY2hlIDIuMCBMaWNlbnNlXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICAgYW5kXG4gKlxuICogICAyLiBUaGUgTUlUIExpY2Vuc2VcbiAqICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIHZpcy5qcyBtYXkgYmUgZGlzdHJpYnV0ZWQgdW5kZXIgZWl0aGVyIGxpY2Vuc2UuXG4gKi9cblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcblxuXG52YXIgZ2xvYmFsJFAgPSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZ2xvYmFsLXRoaXMgLS0gc2FmZVxuY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHwgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHwgY2hlY2sodHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsKSB8fCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbmZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIGZhaWxzJHQgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIGZhaWxzJHMgPSBmYWlscyR0O1xudmFyIGZ1bmN0aW9uQmluZE5hdGl2ZSA9ICFmYWlscyRzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfS5iaW5kKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuXG5cbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDQgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMyA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSQ2ID0gRnVuY3Rpb25Qcm90b3R5cGUkMy5hcHBseTtcbnZhciBjYWxsJGQgPSBGdW5jdGlvblByb3RvdHlwZSQzLmNhbGw7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1yZWZsZWN0IC0tIHNhZmVcblxudmFyIGZ1bmN0aW9uQXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmFwcGx5IHx8IChOQVRJVkVfQklORCQ0ID8gY2FsbCRkLmJpbmQoYXBwbHkkNikgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsJGQuYXBwbHkoYXBwbHkkNiwgYXJndW1lbnRzKTtcbn0pO1xuXG52YXIgTkFUSVZFX0JJTkQkMyA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcbnZhciBGdW5jdGlvblByb3RvdHlwZSQyID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGJpbmQkZCA9IEZ1bmN0aW9uUHJvdG90eXBlJDIuYmluZDtcbnZhciBjYWxsJGMgPSBGdW5jdGlvblByb3RvdHlwZSQyLmNhbGw7XG52YXIgdW5jdXJyeVRoaXMkdyA9IE5BVElWRV9CSU5EJDMgJiYgYmluZCRkLmJpbmQoY2FsbCRjLCBjYWxsJGMpO1xudmFyIGZ1bmN0aW9uVW5jdXJyeVRoaXMgPSBOQVRJVkVfQklORCQzID8gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiB1bmN1cnJ5VGhpcyR3KGZuKTtcbn0gOiBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuICYmIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbCRjLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG5cbnZhciBpc0NhbGxhYmxlJGggPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHt9O1xuXG52YXIgZmFpbHMkciA9IGZhaWxzJHQ7IC8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG5cbnZhciBkZXNjcmlwdG9ycyA9ICFmYWlscyRyKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gNztcbiAgICB9XG4gIH0pWzFdICE9IDc7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDIgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG52YXIgY2FsbCRiID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG52YXIgZnVuY3Rpb25DYWxsID0gTkFUSVZFX0JJTkQkMiA/IGNhbGwkYi5iaW5kKGNhbGwkYikgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsJGIuYXBwbHkoY2FsbCRiLCBhcmd1bWVudHMpO1xufTtcblxudmFyIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlID0ge307XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUkMiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkOCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IC8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xuXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkOCAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlJDIuY2FsbCh7XG4gIDE6IDJcbn0sIDEpOyAvLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcblxub2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ4KHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiAkcHJvcGVydHlJc0VudW1lcmFibGUkMjtcblxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1ID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyR2ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b1N0cmluZyRhID0gdW5jdXJyeVRoaXMkdih7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UkMSA9IHVuY3VycnlUaGlzJHYoJycuc2xpY2UpO1xuXG52YXIgY2xhc3NvZlJhdyQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBzdHJpbmdTbGljZSQxKHRvU3RyaW5nJGEoaXQpLCA4LCAtMSk7XG59O1xuXG52YXIgZ2xvYmFsJE8gPSBnbG9iYWwkUDtcbnZhciB1bmN1cnJ5VGhpcyR1ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyRxID0gZmFpbHMkdDtcbnZhciBjbGFzc29mJGYgPSBjbGFzc29mUmF3JDE7XG52YXIgT2JqZWN0JGEgPSBnbG9iYWwkTy5PYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcyR1KCcnLnNwbGl0KTsgLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcblxudmFyIGluZGV4ZWRPYmplY3QgPSBmYWlscyRxKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICFPYmplY3QkYSgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YkZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogT2JqZWN0JGEoaXQpO1xufSA6IE9iamVjdCRhO1xuXG52YXIgZ2xvYmFsJE4gPSBnbG9iYWwkUDtcbnZhciBUeXBlRXJyb3IkaiA9IGdsb2JhbCROLlR5cGVFcnJvcjsgLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yJGooXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxudmFyIEluZGV4ZWRPYmplY3QkMyA9IGluZGV4ZWRPYmplY3Q7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ0ID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JGIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QkMyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQoaXQpKTtcbn07XG5cbnZhciBpc0NhbGxhYmxlJGcgPSBpc0NhbGxhYmxlJGg7XG5cbnZhciBpc09iamVjdCRqID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUkZyhpdCk7XG59O1xuXG52YXIgcGF0aCR5ID0ge307XG5cbnZhciBwYXRoJHggPSBwYXRoJHk7XG52YXIgZ2xvYmFsJE0gPSBnbG9iYWwkUDtcbnZhciBpc0NhbGxhYmxlJGYgPSBpc0NhbGxhYmxlJGg7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkZih2YXJpYWJsZSkgPyB2YXJpYWJsZSA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBnZXRCdWlsdEluJDkgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKHBhdGgkeFtuYW1lc3BhY2VdKSB8fCBhRnVuY3Rpb24oZ2xvYmFsJE1bbmFtZXNwYWNlXSkgOiBwYXRoJHhbbmFtZXNwYWNlXSAmJiBwYXRoJHhbbmFtZXNwYWNlXVttZXRob2RdIHx8IGdsb2JhbCRNW25hbWVzcGFjZV0gJiYgZ2xvYmFsJE1bbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxudmFyIHVuY3VycnlUaGlzJHQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIG9iamVjdElzUHJvdG90eXBlT2YgPSB1bmN1cnJ5VGhpcyR0KHt9LmlzUHJvdG90eXBlT2YpO1xuXG52YXIgZ2V0QnVpbHRJbiQ4ID0gZ2V0QnVpbHRJbiQ5O1xudmFyIGVuZ2luZVVzZXJBZ2VudCA9IGdldEJ1aWx0SW4kOCgnbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuXG52YXIgZ2xvYmFsJEwgPSBnbG9iYWwkUDtcbnZhciB1c2VyQWdlbnQkMyA9IGVuZ2luZVVzZXJBZ2VudDtcbnZhciBwcm9jZXNzID0gZ2xvYmFsJEwucHJvY2VzcztcbnZhciBEZW5vID0gZ2xvYmFsJEwuRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucyB8fCBEZW5vICYmIERlbm8udmVyc2lvbjtcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpOyAvLyBpbiBvbGQgQ2hyb21lLCB2ZXJzaW9ucyBvZiBWOCBpc24ndCBWOCA9IENocm9tZSAvIDEwXG4gIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXG5cbiAgdmVyc2lvbiA9IG1hdGNoWzBdID4gMCAmJiBtYXRjaFswXSA8IDQgPyAxIDogKyhtYXRjaFswXSArIG1hdGNoWzFdKTtcbn0gLy8gQnJvd3NlckZTIE5vZGVKUyBgcHJvY2Vzc2AgcG9seWZpbGwgaW5jb3JyZWN0bHkgc2V0IGAudjhgIHRvIGAwLjBgXG4vLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcblxuXG5pZiAoIXZlcnNpb24gJiYgdXNlckFnZW50JDMpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQkMy5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuXG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudCQzLm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSArbWF0Y2hbMV07XG4gIH1cbn1cblxudmFyIGVuZ2luZVY4VmVyc2lvbiA9IHZlcnNpb247XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIFY4X1ZFUlNJT04kMiA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBmYWlscyRwID0gZmFpbHMkdDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcblxudmFyIG5hdGl2ZVN5bWJvbCA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMkcChmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTsgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuXG4gIHJldHVybiAhU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHwgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04kMiAmJiBWOF9WRVJTSU9OJDIgPCA0MTtcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBOQVRJVkVfU1lNQk9MJDIgPSBuYXRpdmVTeW1ib2w7XG52YXIgdXNlU3ltYm9sQXNVaWQgPSBOQVRJVkVfU1lNQk9MJDIgJiYgIVN5bWJvbC5zaGFtICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cbnZhciBnbG9iYWwkSyA9IGdsb2JhbCRQO1xudmFyIGdldEJ1aWx0SW4kNyA9IGdldEJ1aWx0SW4kOTtcbnZhciBpc0NhbGxhYmxlJGUgPSBpc0NhbGxhYmxlJGg7XG52YXIgaXNQcm90b3R5cGVPZiRtID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCQxID0gdXNlU3ltYm9sQXNVaWQ7XG52YXIgT2JqZWN0JDkgPSBnbG9iYWwkSy5PYmplY3Q7XG52YXIgaXNTeW1ib2wkMyA9IFVTRV9TWU1CT0xfQVNfVUlEJDEgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluJDcoJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSRlKCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YkbSgkU3ltYm9sLnByb3RvdHlwZSwgT2JqZWN0JDkoaXQpKTtcbn07XG5cbnZhciBnbG9iYWwkSiA9IGdsb2JhbCRQO1xudmFyIFN0cmluZyQ0ID0gZ2xvYmFsJEouU3RyaW5nO1xuXG52YXIgdHJ5VG9TdHJpbmckNCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB0cnkge1xuICAgIHJldHVybiBTdHJpbmckNChhcmd1bWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG59O1xuXG52YXIgZ2xvYmFsJEkgPSBnbG9iYWwkUDtcbnZhciBpc0NhbGxhYmxlJGQgPSBpc0NhbGxhYmxlJGg7XG52YXIgdHJ5VG9TdHJpbmckMyA9IHRyeVRvU3RyaW5nJDQ7XG52YXIgVHlwZUVycm9yJGkgPSBnbG9iYWwkSS5UeXBlRXJyb3I7IC8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG5cbnZhciBhQ2FsbGFibGUkNyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZSRkKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBUeXBlRXJyb3IkaSh0cnlUb1N0cmluZyQzKGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbn07XG5cbnZhciBhQ2FsbGFibGUkNiA9IGFDYWxsYWJsZSQ3OyAvLyBgR2V0TWV0aG9kYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXG5cbnZhciBnZXRNZXRob2QkMyA9IGZ1bmN0aW9uIChWLCBQKSB7XG4gIHZhciBmdW5jID0gVltQXTtcbiAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZSQ2KGZ1bmMpO1xufTtcblxudmFyIGdsb2JhbCRIID0gZ2xvYmFsJFA7XG52YXIgY2FsbCRhID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzQ2FsbGFibGUkYyA9IGlzQ2FsbGFibGUkaDtcbnZhciBpc09iamVjdCRpID0gaXNPYmplY3QkajtcbnZhciBUeXBlRXJyb3IkaCA9IGdsb2JhbCRILlR5cGVFcnJvcjsgLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG5cbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJGMoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JGkodmFsID0gY2FsbCRhKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoaXNDYWxsYWJsZSRjKGZuID0gaW5wdXQudmFsdWVPZikgJiYgIWlzT2JqZWN0JGkodmFsID0gY2FsbCRhKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSRjKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCRpKHZhbCA9IGNhbGwkYShmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yJGgoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG52YXIgc2hhcmVkJDQgPSB7ZXhwb3J0czoge319O1xuXG52YXIgZ2xvYmFsJEcgPSBnbG9iYWwkUDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSRlID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgc2V0R2xvYmFsJDEgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGRlZmluZVByb3BlcnR5JGUoZ2xvYmFsJEcsIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWwkR1trZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgZ2xvYmFsJEYgPSBnbG9iYWwkUDtcbnZhciBzZXRHbG9iYWwgPSBzZXRHbG9iYWwkMTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSQzID0gZ2xvYmFsJEZbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XG52YXIgc2hhcmVkU3RvcmUgPSBzdG9yZSQzO1xuXG52YXIgc3RvcmUkMiA9IHNoYXJlZFN0b3JlO1xuKHNoYXJlZCQ0LmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmUkMltrZXldIHx8IChzdG9yZSQyW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjIxLjEnLFxuICBtb2RlOiAncHVyZScgLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE0LTIwMjIgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknLFxuICBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4yMS4xL0xJQ0VOU0UnLFxuICBzb3VyY2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcydcbn0pO1xuXG52YXIgZ2xvYmFsJEUgPSBnbG9iYWwkUDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDMgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDU7XG52YXIgT2JqZWN0JDggPSBnbG9iYWwkRS5PYmplY3Q7IC8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG5cbnZhciB0b09iamVjdCRlID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBPYmplY3QkOChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDMoYXJndW1lbnQpKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b09iamVjdCRkID0gdG9PYmplY3QkZTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzJHMoe30uaGFzT3duUHJvcGVydHkpOyAvLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuXG52YXIgaGFzT3duUHJvcGVydHlfMSA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0JGQoaXQpLCBrZXkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJHIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlkJDIgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xudmFyIHRvU3RyaW5nJDkgPSB1bmN1cnJ5VGhpcyRyKDEuMC50b1N0cmluZyk7XG5cbnZhciB1aWQkNCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZyQ5KCsraWQkMiArIHBvc3RmaXgsIDM2KTtcbn07XG5cbnZhciBnbG9iYWwkRCA9IGdsb2JhbCRQO1xudmFyIHNoYXJlZCQzID0gc2hhcmVkJDQuZXhwb3J0cztcbnZhciBoYXNPd24kaCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdWlkJDMgPSB1aWQkNDtcbnZhciBOQVRJVkVfU1lNQk9MJDEgPSBuYXRpdmVTeW1ib2w7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSB1c2VTeW1ib2xBc1VpZDtcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUkMSA9IHNoYXJlZCQzKCd3a3MnKTtcbnZhciBTeW1ib2wkMyA9IGdsb2JhbCRELlN5bWJvbDtcbnZhciBzeW1ib2xGb3IgPSBTeW1ib2wkMyAmJiBTeW1ib2wkM1snZm9yJ107XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wkMyA6IFN5bWJvbCQzICYmIFN5bWJvbCQzLndpdGhvdXRTZXR0ZXIgfHwgdWlkJDM7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkaiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzT3duJGgoV2VsbEtub3duU3ltYm9sc1N0b3JlJDEsIG5hbWUpIHx8ICEoTkFUSVZFX1NZTUJPTCQxIHx8IHR5cGVvZiBXZWxsS25vd25TeW1ib2xzU3RvcmUkMVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAnU3ltYm9sLicgKyBuYW1lO1xuXG4gICAgaWYgKE5BVElWRV9TWU1CT0wkMSAmJiBoYXNPd24kaChTeW1ib2wkMywgbmFtZSkpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZSQxW25hbWVdID0gU3ltYm9sJDNbbmFtZV07XG4gICAgfSBlbHNlIGlmIChVU0VfU1lNQk9MX0FTX1VJRCAmJiBzeW1ib2xGb3IpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZSQxW25hbWVdID0gc3ltYm9sRm9yKGRlc2NyaXB0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlJDFbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmUkMVtuYW1lXTtcbn07XG5cbnZhciBnbG9iYWwkQyA9IGdsb2JhbCRQO1xudmFyIGNhbGwkOSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc09iamVjdCRoID0gaXNPYmplY3QkajtcbnZhciBpc1N5bWJvbCQyID0gaXNTeW1ib2wkMztcbnZhciBnZXRNZXRob2QkMiA9IGdldE1ldGhvZCQzO1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBvcmRpbmFyeVRvUHJpbWl0aXZlJDE7XG52YXIgd2VsbEtub3duU3ltYm9sJGkgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBUeXBlRXJyb3IkZyA9IGdsb2JhbCRDLlR5cGVFcnJvcjtcbnZhciBUT19QUklNSVRJVkUkMSA9IHdlbGxLbm93blN5bWJvbCRpKCd0b1ByaW1pdGl2ZScpOyAvLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxuXG52YXIgdG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0JGgoaW5wdXQpIHx8IGlzU3ltYm9sJDIoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QkMihpbnB1dCwgVE9fUFJJTUlUSVZFJDEpO1xuICB2YXIgcmVzdWx0O1xuXG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGNhbGwkOShleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0JGgocmVzdWx0KSB8fCBpc1N5bWJvbCQyKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgdGhyb3cgVHlwZUVycm9yJGcoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cblxuICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XG4gIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBwcmVmKTtcbn07XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHRvUHJpbWl0aXZlJDE7XG52YXIgaXNTeW1ib2wkMSA9IGlzU3ltYm9sJDM7IC8vIGBUb1Byb3BlcnR5S2V5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxuXG52YXIgdG9Qcm9wZXJ0eUtleSQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2wkMShrZXkpID8ga2V5IDoga2V5ICsgJyc7XG59O1xuXG52YXIgZ2xvYmFsJEIgPSBnbG9iYWwkUDtcbnZhciBpc09iamVjdCRnID0gaXNPYmplY3QkajtcbnZhciBkb2N1bWVudCQxID0gZ2xvYmFsJEIuZG9jdW1lbnQ7IC8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxuXG52YXIgRVhJU1RTJDEgPSBpc09iamVjdCRnKGRvY3VtZW50JDEpICYmIGlzT2JqZWN0JGcoZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KTtcblxudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMkMSA/IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cbnZhciBERVNDUklQVE9SUyRoID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkbyA9IGZhaWxzJHQ7XG52YXIgY3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxOyAvLyBUaGFua3MgdG8gSUU4IGZvciBpdHMgZnVubnkgZGVmaW5lUHJvcGVydHlcblxudmFyIGllOERvbURlZmluZSA9ICFERVNDUklQVE9SUyRoICYmICFmYWlscyRvKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiA3O1xuICAgIH1cbiAgfSkuYSAhPSA3O1xufSk7XG5cbnZhciBERVNDUklQVE9SUyRnID0gZGVzY3JpcHRvcnM7XG52YXIgY2FsbCQ4ID0gZnVuY3Rpb25DYWxsO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDIgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNCA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIHRvSW5kZXhlZE9iamVjdCRhID0gdG9JbmRleGVkT2JqZWN0JGI7XG52YXIgdG9Qcm9wZXJ0eUtleSQzID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyIGhhc093biRnID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBJRThfRE9NX0RFRklORSQxID0gaWU4RG9tRGVmaW5lOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG5cbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3Jcblxub2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmYgPSBERVNDUklQVE9SUyRnID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdCRhKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQzKFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUkMSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cbiAgaWYgKGhhc093biRnKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQoIWNhbGwkOChwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQyLmYsIE8sIFApLCBPW1BdKTtcbn07XG5cbnZhciBmYWlscyRuID0gZmFpbHMkdDtcbnZhciBpc0NhbGxhYmxlJGIgPSBpc0NhbGxhYmxlJGg7XG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQkMSA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2UgOiBpc0NhbGxhYmxlJGIoZGV0ZWN0aW9uKSA/IGZhaWxzJG4oZGV0ZWN0aW9uKSA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkJDEubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZCQxLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZCQxLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkJDEuUE9MWUZJTEwgPSAnUCc7XG52YXIgaXNGb3JjZWRfMSA9IGlzRm9yY2VkJDE7XG5cbnZhciB1bmN1cnJ5VGhpcyRxID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhQ2FsbGFibGUkNSA9IGFDYWxsYWJsZSQ3O1xudmFyIE5BVElWRV9CSU5EJDEgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG52YXIgYmluZCRjID0gdW5jdXJyeVRoaXMkcSh1bmN1cnJ5VGhpcyRxLmJpbmQpOyAvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcblxudmFyIGZ1bmN0aW9uQmluZENvbnRleHQgPSBmdW5jdGlvbiAoZm4sIHRoYXQpIHtcbiAgYUNhbGxhYmxlJDUoZm4pO1xuICByZXR1cm4gdGhhdCA9PT0gdW5kZWZpbmVkID8gZm4gOiBOQVRJVkVfQklORCQxID8gYmluZCRjKGZuLCB0aGF0KSA6IGZ1bmN0aW9uXG4gICAgLyogLi4uYXJncyAqL1xuICAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydHkgPSB7fTtcblxudmFyIERFU0NSSVBUT1JTJGYgPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyRtID0gZmFpbHMkdDsgLy8gVjggfiBDaHJvbWUgMzYtXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMzM0XG5cbnZhciB2OFByb3RvdHlwZURlZmluZUJ1ZyA9IERFU0NSSVBUT1JTJGYgJiYgZmFpbHMkbShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfSwgJ3Byb3RvdHlwZScsIHtcbiAgICB2YWx1ZTogNDIsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLnByb3RvdHlwZSAhPSA0Mjtcbn0pO1xuXG52YXIgZ2xvYmFsJEEgPSBnbG9iYWwkUDtcbnZhciBpc09iamVjdCRmID0gaXNPYmplY3QkajtcbnZhciBTdHJpbmckMyA9IGdsb2JhbCRBLlN0cmluZztcbnZhciBUeXBlRXJyb3IkZiA9IGdsb2JhbCRBLlR5cGVFcnJvcjsgLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxuXG52YXIgYW5PYmplY3QkZCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNPYmplY3QkZihhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgVHlwZUVycm9yJGYoU3RyaW5nJDMoYXJndW1lbnQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG59O1xuXG52YXIgZ2xvYmFsJHogPSBnbG9iYWwkUDtcbnZhciBERVNDUklQVE9SUyRlID0gZGVzY3JpcHRvcnM7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBpZThEb21EZWZpbmU7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xudmFyIGFuT2JqZWN0JGMgPSBhbk9iamVjdCRkO1xudmFyIHRvUHJvcGVydHlLZXkkMiA9IHRvUHJvcGVydHlLZXkkNDtcbnZhciBUeXBlRXJyb3IkZSA9IGdsb2JhbCR6LlR5cGVFcnJvcjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG5cbnZhciAkZGVmaW5lUHJvcGVydHkkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBFTlVNRVJBQkxFID0gJ2VudW1lcmFibGUnO1xudmFyIENPTkZJR1VSQUJMRSQxID0gJ2NvbmZpZ3VyYWJsZSc7XG52YXIgV1JJVEFCTEUgPSAnd3JpdGFibGUnOyAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5cbm9iamVjdERlZmluZVByb3BlcnR5LmYgPSBERVNDUklQVE9SUyRlID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkYyhPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMihQKTtcbiAgYW5PYmplY3QkYyhBdHRyaWJ1dGVzKTtcblxuICBpZiAodHlwZW9mIE8gPT09ICdmdW5jdGlvbicgJiYgUCA9PT0gJ3Byb3RvdHlwZScgJiYgJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzICYmIFdSSVRBQkxFIGluIEF0dHJpYnV0ZXMgJiYgIUF0dHJpYnV0ZXNbV1JJVEFCTEVdKSB7XG4gICAgdmFyIGN1cnJlbnQgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoTywgUCk7XG5cbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50W1dSSVRBQkxFXSkge1xuICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICBBdHRyaWJ1dGVzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSQxIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0NPTkZJR1VSQUJMRSQxXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFJDFdLFxuICAgICAgICBlbnVtZXJhYmxlOiBFTlVNRVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0VOVU1FUkFCTEVdIDogY3VycmVudFtFTlVNRVJBQkxFXSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAkZGVmaW5lUHJvcGVydHkkMShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkkMSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkYyhPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMihQKTtcbiAgYW5PYmplY3QkYyhBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkkMShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvciRlKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkZCA9IGRlc2NyaXB0b3JzO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDQgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMyA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2ID0gREVTQ1JJUFRPUlMkZCA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlJDQuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG52YXIgZ2xvYmFsJHkgPSBnbG9iYWwkUDtcbnZhciBhcHBseSQ1ID0gZnVuY3Rpb25BcHBseTtcbnZhciB1bmN1cnJ5VGhpcyRwID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc0NhbGxhYmxlJGEgPSBpc0NhbGxhYmxlJGg7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDcgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBpc0ZvcmNlZCA9IGlzRm9yY2VkXzE7XG52YXIgcGF0aCR3ID0gcGF0aCR5O1xudmFyIGJpbmQkYiA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcbnZhciBoYXNPd24kZiA9IGhhc093blByb3BlcnR5XzE7XG5cbnZhciB3cmFwQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoTmF0aXZlQ29uc3RydWN0b3IpIHtcbiAgdmFyIFdyYXBwZXIgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgV3JhcHBlcikge1xuICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCk7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoYSk7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoYSwgYik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoYSwgYiwgYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFwcGx5JDUoTmF0aXZlQ29uc3RydWN0b3IsIHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgV3JhcHBlci5wcm90b3R5cGUgPSBOYXRpdmVDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIHJldHVybiBXcmFwcGVyO1xufTtcbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gIG9wdGlvbnMubmFtZSAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcbiovXG5cblxudmFyIF9leHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgUFJPVE8gPSBvcHRpb25zLnByb3RvO1xuICB2YXIgbmF0aXZlU291cmNlID0gR0xPQkFMID8gZ2xvYmFsJHkgOiBTVEFUSUMgPyBnbG9iYWwkeVtUQVJHRVRdIDogKGdsb2JhbCR5W1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgdmFyIHRhcmdldCA9IEdMT0JBTCA/IHBhdGgkdyA6IHBhdGgkd1tUQVJHRVRdIHx8IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHBhdGgkdywgVEFSR0VULCB7fSlbVEFSR0VUXTtcbiAgdmFyIHRhcmdldFByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gIHZhciBGT1JDRUQsIFVTRV9OQVRJVkUsIFZJUlRVQUxfUFJPVE9UWVBFO1xuICB2YXIga2V5LCBzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHksIG5hdGl2ZVByb3BlcnR5LCByZXN1bHRQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcblxuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpOyAvLyBjb250YWlucyBpbiBuYXRpdmVcblxuICAgIFVTRV9OQVRJVkUgPSAhRk9SQ0VEICYmIG5hdGl2ZVNvdXJjZSAmJiBoYXNPd24kZihuYXRpdmVTb3VyY2UsIGtleSk7XG4gICAgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBpZiAoVVNFX05BVElWRSkgaWYgKG9wdGlvbnMubm9UYXJnZXRHZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNyhuYXRpdmVTb3VyY2UsIGtleSk7XG4gICAgICBuYXRpdmVQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgbmF0aXZlUHJvcGVydHkgPSBuYXRpdmVTb3VyY2Vba2V5XTsgLy8gZXhwb3J0IG5hdGl2ZSBvciBpbXBsZW1lbnRhdGlvblxuXG4gICAgc291cmNlUHJvcGVydHkgPSBVU0VfTkFUSVZFICYmIG5hdGl2ZVByb3BlcnR5ID8gbmF0aXZlUHJvcGVydHkgOiBzb3VyY2Vba2V5XTtcbiAgICBpZiAoVVNFX05BVElWRSAmJiB0eXBlb2YgdGFyZ2V0UHJvcGVydHkgPT0gdHlwZW9mIHNvdXJjZVByb3BlcnR5KSBjb250aW51ZTsgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcblxuICAgIGlmIChvcHRpb25zLmJpbmQgJiYgVVNFX05BVElWRSkgcmVzdWx0UHJvcGVydHkgPSBiaW5kJGIoc291cmNlUHJvcGVydHksIGdsb2JhbCR5KTsgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5ncyBpbiB0aGlzIHZlcnNpb25cbiAgICBlbHNlIGlmIChvcHRpb25zLndyYXAgJiYgVVNFX05BVElWRSkgcmVzdWx0UHJvcGVydHkgPSB3cmFwQ29uc3RydWN0b3Ioc291cmNlUHJvcGVydHkpOyAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICBlbHNlIGlmIChQUk9UTyAmJiBpc0NhbGxhYmxlJGEoc291cmNlUHJvcGVydHkpKSByZXN1bHRQcm9wZXJ0eSA9IHVuY3VycnlUaGlzJHAoc291cmNlUHJvcGVydHkpOyAvLyBkZWZhdWx0IGNhc2VcbiAgICBlbHNlIHJlc3VsdFByb3BlcnR5ID0gc291cmNlUHJvcGVydHk7IC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcblxuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgc291cmNlUHJvcGVydHkgJiYgc291cmNlUHJvcGVydHkuc2hhbSB8fCB0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNShyZXN1bHRQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG5cbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNSh0YXJnZXQsIGtleSwgcmVzdWx0UHJvcGVydHkpO1xuXG4gICAgaWYgKFBST1RPKSB7XG4gICAgICBWSVJUVUFMX1BST1RPVFlQRSA9IFRBUkdFVCArICdQcm90b3R5cGUnO1xuXG4gICAgICBpZiAoIWhhc093biRmKHBhdGgkdywgVklSVFVBTF9QUk9UT1RZUEUpKSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHBhdGgkdywgVklSVFVBTF9QUk9UT1RZUEUsIHt9KTtcbiAgICAgIH0gLy8gZXhwb3J0IHZpcnR1YWwgcHJvdG90eXBlIG1ldGhvZHNcblxuXG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNShwYXRoJHdbVklSVFVBTF9QUk9UT1RZUEVdLCBrZXksIHNvdXJjZVByb3BlcnR5KTsgLy8gZXhwb3J0IHJlYWwgcHJvdG90eXBlIG1ldGhvZHNcblxuICAgICAgaWYgKG9wdGlvbnMucmVhbCAmJiB0YXJnZXRQcm90b3R5cGUgJiYgIXRhcmdldFByb3RvdHlwZVtrZXldKSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHRhcmdldFByb3RvdHlwZSwga2V5LCBzb3VyY2VQcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciQxID0gTWF0aC5mbG9vcjsgLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIG51bWJlciA9ICthcmd1bWVudDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBzYWZlXG5cbiAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gMCA/IDAgOiAobnVtYmVyID4gMCA/IGZsb29yJDEgOiBjZWlsKShudW1iZXIpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMyA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcbnZhciBtYXgkMyA9IE1hdGgubWF4O1xudmFyIG1pbiQyID0gTWF0aC5taW47IC8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cblxudmFyIHRvQWJzb2x1dGVJbmRleCQ1ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXJPckluZmluaXR5JDMoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgkMyhpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbiQyKGludGVnZXIsIGxlbmd0aCk7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ0O1xudmFyIG1pbiQxID0gTWF0aC5taW47IC8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5cbnZhciB0b0xlbmd0aCQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4kMSh0b0ludGVnZXJPckluZmluaXR5JDIoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cbnZhciB0b0xlbmd0aCA9IHRvTGVuZ3RoJDE7IC8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG5cbnZhciBsZW5ndGhPZkFycmF5TGlrZSRkID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdG9MZW5ndGgob2JqLmxlbmd0aCk7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDkgPSB0b0luZGV4ZWRPYmplY3QkYjtcbnZhciB0b0Fic29sdXRlSW5kZXgkNCA9IHRvQWJzb2x1dGVJbmRleCQ1O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJGMgPSBsZW5ndGhPZkFycmF5TGlrZSRkOyAvLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXG52YXIgY3JlYXRlTWV0aG9kJDUgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDkoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSRjKE8pO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleCQ0KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7IC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcblxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTsgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbnZhciBhcnJheUluY2x1ZGVzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCQ1KHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZCQ1KGZhbHNlKVxufTtcblxudmFyIGhpZGRlbktleXMkNiA9IHt9O1xuXG52YXIgdW5jdXJyeVRoaXMkbyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGFzT3duJGUgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvSW5kZXhlZE9iamVjdCQ4ID0gdG9JbmRleGVkT2JqZWN0JGI7XG52YXIgaW5kZXhPZiQ0ID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xudmFyIGhpZGRlbktleXMkNSA9IGhpZGRlbktleXMkNjtcbnZhciBwdXNoJDUgPSB1bmN1cnJ5VGhpcyRvKFtdLnB1c2gpO1xuXG52YXIgb2JqZWN0S2V5c0ludGVybmFsID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkOChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcblxuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duJGUoaGlkZGVuS2V5cyQ1LCBrZXkpICYmIGhhc093biRlKE8sIGtleSkgJiYgcHVzaCQ1KHJlc3VsdCwga2V5KTsgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuXG5cbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXNPd24kZShPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5pbmRleE9mJDQocmVzdWx0LCBrZXkpIHx8IHB1c2gkNShyZXN1bHQsIGtleSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGVudW1CdWdLZXlzJDMgPSBbJ2NvbnN0cnVjdG9yJywgJ2hhc093blByb3BlcnR5JywgJ2lzUHJvdG90eXBlT2YnLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAndG9Mb2NhbGVTdHJpbmcnLCAndG9TdHJpbmcnLCAndmFsdWVPZiddO1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzJDEgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMkMiA9IGVudW1CdWdLZXlzJDM7IC8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxuXG52YXIgb2JqZWN0S2V5cyQ0ID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMkMShPLCBlbnVtQnVnS2V5cyQyKTtcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSB7fTtcblxub2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG52YXIgREVTQ1JJUFRPUlMkYyA9IGRlc2NyaXB0b3JzO1xudmFyIHVuY3VycnlUaGlzJG4gPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGNhbGwkNyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBmYWlscyRsID0gZmFpbHMkdDtcbnZhciBvYmplY3RLZXlzJDMgPSBvYmplY3RLZXlzJDQ7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDIgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIHRvT2JqZWN0JGMgPSB0b09iamVjdCRlO1xudmFyIEluZGV4ZWRPYmplY3QkMiA9IGluZGV4ZWRPYmplY3Q7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtYXNzaWduIC0tIHNhZmVcblxudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSRkID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGNvbmNhdCQ2ID0gdW5jdXJyeVRoaXMkbihbXS5jb25jYXQpOyAvLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cblxudmFyIG9iamVjdEFzc2lnbiA9ICEkYXNzaWduIHx8IGZhaWxzJGwoZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxuICBpZiAoREVTQ1JJUFRPUlMkYyAmJiAkYXNzaWduKHtcbiAgICBiOiAxXG4gIH0sICRhc3NpZ24oZGVmaW5lUHJvcGVydHkkZCh7fSwgJ2EnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5JGQodGhpcywgJ2InLCB7XG4gICAgICAgIHZhbHVlOiAzLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KSwge1xuICAgIGI6IDJcbiAgfSkpLmIgIT09IDEpIHJldHVybiB0cnVlOyAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcblxuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tc3ltYm9sIC0tIHNhZmVcblxuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbc3ltYm9sXSA9IDc7XG4gIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHtcbiAgICBCW2Nocl0gPSBjaHI7XG4gIH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbc3ltYm9sXSAhPSA3IHx8IG9iamVjdEtleXMkMygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gYWxwaGFiZXQ7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgdmFyIFQgPSB0b09iamVjdCRjKHRhcmdldCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDIuZjtcbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMS5mO1xuXG4gIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdCQyKGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQkNihvYmplY3RLZXlzJDMoUyksIGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzJDMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuXG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIHtcbiAgICAgIGtleSA9IGtleXNbaisrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMkYyB8fCBjYWxsJDcocHJvcGVydHlJc0VudW1lcmFibGUsIFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG52YXIgJCRKID0gX2V4cG9ydDtcbnZhciBhc3NpZ24kNSA9IG9iamVjdEFzc2lnbjsgLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWFzc2lnbiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuXG4kJEooe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IE9iamVjdC5hc3NpZ24gIT09IGFzc2lnbiQ1XG59LCB7XG4gIGFzc2lnbjogYXNzaWduJDVcbn0pO1xuXG52YXIgcGF0aCR2ID0gcGF0aCR5O1xudmFyIGFzc2lnbiQ0ID0gcGF0aCR2Lk9iamVjdC5hc3NpZ247XG5cbnZhciBwYXJlbnQkMWEgPSBhc3NpZ24kNDtcbnZhciBhc3NpZ24kMyA9IHBhcmVudCQxYTtcblxudmFyIGFzc2lnbiQyID0gYXNzaWduJDM7XG5cbnZhciB1bmN1cnJ5VGhpcyRtID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhcnJheVNsaWNlJDUgPSB1bmN1cnJ5VGhpcyRtKFtdLnNsaWNlKTtcblxudmFyIGdsb2JhbCR4ID0gZ2xvYmFsJFA7XG52YXIgdW5jdXJyeVRoaXMkbCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYUNhbGxhYmxlJDQgPSBhQ2FsbGFibGUkNztcbnZhciBpc09iamVjdCRlID0gaXNPYmplY3QkajtcbnZhciBoYXNPd24kZCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgYXJyYXlTbGljZSQ0ID0gYXJyYXlTbGljZSQ1O1xudmFyIE5BVElWRV9CSU5EID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xudmFyIEZ1bmN0aW9uJDIgPSBnbG9iYWwkeC5GdW5jdGlvbjtcbnZhciBjb25jYXQkNSA9IHVuY3VycnlUaGlzJGwoW10uY29uY2F0KTtcbnZhciBqb2luID0gdW5jdXJyeVRoaXMkbChbXS5qb2luKTtcbnZhciBmYWN0b3JpZXMgPSB7fTtcblxudmFyIGNvbnN0cnVjdCQ0ID0gZnVuY3Rpb24gKEMsIGFyZ3NMZW5ndGgsIGFyZ3MpIHtcbiAgaWYgKCFoYXNPd24kZChmYWN0b3JpZXMsIGFyZ3NMZW5ndGgpKSB7XG4gICAgZm9yICh2YXIgbGlzdCA9IFtdLCBpID0gMDsgaSA8IGFyZ3NMZW5ndGg7IGkrKykgbGlzdFtpXSA9ICdhWycgKyBpICsgJ10nO1xuXG4gICAgZmFjdG9yaWVzW2FyZ3NMZW5ndGhdID0gRnVuY3Rpb24kMignQyxhJywgJ3JldHVybiBuZXcgQygnICsgam9pbihsaXN0LCAnLCcpICsgJyknKTtcbiAgfVxuXG4gIHJldHVybiBmYWN0b3JpZXNbYXJnc0xlbmd0aF0oQywgYXJncyk7XG59OyAvLyBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuXG5cbnZhciBmdW5jdGlvbkJpbmQgPSBOQVRJVkVfQklORCA/IEZ1bmN0aW9uJDIuYmluZCA6IGZ1bmN0aW9uIGJpbmQodGhhdFxuLyogLCAuLi5hcmdzICovXG4pIHtcbiAgdmFyIEYgPSBhQ2FsbGFibGUkNCh0aGlzKTtcbiAgdmFyIFByb3RvdHlwZSA9IEYucHJvdG90eXBlO1xuICB2YXIgcGFydEFyZ3MgPSBhcnJheVNsaWNlJDQoYXJndW1lbnRzLCAxKTtcblxuICB2YXIgYm91bmRGdW5jdGlvbiA9IGZ1bmN0aW9uXG4gICAgLyogYXJncy4uLiAqL1xuICBib3VuZCgpIHtcbiAgICB2YXIgYXJncyA9IGNvbmNhdCQ1KHBhcnRBcmdzLCBhcnJheVNsaWNlJDQoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZEZ1bmN0aW9uID8gY29uc3RydWN0JDQoRiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogRi5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfTtcblxuICBpZiAoaXNPYmplY3QkZShQcm90b3R5cGUpKSBib3VuZEZ1bmN0aW9uLnByb3RvdHlwZSA9IFByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kRnVuY3Rpb247XG59O1xuXG52YXIgJCRJID0gX2V4cG9ydDtcbnZhciBiaW5kJGEgPSBmdW5jdGlvbkJpbmQ7IC8vIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG5cbiQkSSh7XG4gIHRhcmdldDogJ0Z1bmN0aW9uJyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogRnVuY3Rpb24uYmluZCAhPT0gYmluZCRhXG59LCB7XG4gIGJpbmQ6IGJpbmQkYVxufSk7XG5cbnZhciBwYXRoJHUgPSBwYXRoJHk7XG5cbnZhciBlbnRyeVZpcnR1YWwkbCA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUikge1xuICByZXR1cm4gcGF0aCR1W0NPTlNUUlVDVE9SICsgJ1Byb3RvdHlwZSddO1xufTtcblxudmFyIGVudHJ5VmlydHVhbCRrID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgYmluZCQ5ID0gZW50cnlWaXJ0dWFsJGsoJ0Z1bmN0aW9uJykuYmluZDtcblxudmFyIGlzUHJvdG90eXBlT2YkbCA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJGggPSBiaW5kJDk7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxudmFyIGJpbmQkOCA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuYmluZDtcbiAgcmV0dXJuIGl0ID09PSBGdW5jdGlvblByb3RvdHlwZSQxIHx8IGlzUHJvdG90eXBlT2YkbChGdW5jdGlvblByb3RvdHlwZSQxLCBpdCkgJiYgb3duID09PSBGdW5jdGlvblByb3RvdHlwZSQxLmJpbmQgPyBtZXRob2QkaCA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkMTkgPSBiaW5kJDg7XG52YXIgYmluZCQ3ID0gcGFyZW50JDE5O1xuXG52YXIgYmluZCQ2ID0gYmluZCQ3O1xuXG4vKipcclxuICogRHJhdyBhIGNpcmNsZS5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSByIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxyXG4gKi9cbmZ1bmN0aW9uIGRyYXdDaXJjbGUoY3R4LCB4LCB5LCByKSB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhIHNxdWFyZS5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSByIC0gSGFsZiBvZiB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgc3F1YXJlLlxyXG4gKi9cblxuZnVuY3Rpb24gZHJhd1NxdWFyZShjdHgsIHgsIHksIHIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgucmVjdCh4IC0gciwgeSAtIHIsIHIgKiAyLCByICogMik7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGFuIGVxdWlsYXRlcmFsIHRyaWFuZ2xlIHN0YW5kaW5nIG9uIGEgc2lkZS5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSByIC0gSGFsZiBvZiB0aGUgbGVuZ3RoIG9mIHRoZSBzaWRlcy5cclxuICogQHJlbWFya3NcclxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcXVpbGF0ZXJhbF90cmlhbmdsZVxyXG4gKi9cblxuZnVuY3Rpb24gZHJhd1RyaWFuZ2xlKGN0eCwgeCwgeSwgcikge1xuICBjdHguYmVnaW5QYXRoKCk7IC8vIHRoZSBjaGFuZ2UgaW4gcmFkaXVzIGFuZCB0aGUgb2Zmc2V0IGlzIGhlcmUgdG8gY2VudGVyIHRoZSBzaGFwZVxuXG4gIHIgKj0gMS4xNTtcbiAgeSArPSAwLjI3NSAqIHI7XG4gIHZhciBzID0gciAqIDI7XG4gIHZhciBzMiA9IHMgLyAyO1xuICB2YXIgaXIgPSBNYXRoLnNxcnQoMykgLyA2ICogczsgLy8gcmFkaXVzIG9mIGlubmVyIGNpcmNsZVxuXG4gIHZhciBoID0gTWF0aC5zcXJ0KHMgKiBzIC0gczIgKiBzMik7IC8vIGhlaWdodFxuXG4gIGN0eC5tb3ZlVG8oeCwgeSAtIChoIC0gaXIpKTtcbiAgY3R4LmxpbmVUbyh4ICsgczIsIHkgKyBpcik7XG4gIGN0eC5saW5lVG8oeCAtIHMyLCB5ICsgaXIpO1xuICBjdHgubGluZVRvKHgsIHkgLSAoaCAtIGlyKSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGFuIGVxdWlsYXRlcmFsIHRyaWFuZ2xlIHN0YW5kaW5nIG9uIGEgdmVydGV4LlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHIgLSBIYWxmIG9mIHRoZSBsZW5ndGggb2YgdGhlIHNpZGVzLlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VxdWlsYXRlcmFsX3RyaWFuZ2xlXHJcbiAqL1xuXG5mdW5jdGlvbiBkcmF3VHJpYW5nbGVEb3duKGN0eCwgeCwgeSwgcikge1xuICBjdHguYmVnaW5QYXRoKCk7IC8vIHRoZSBjaGFuZ2UgaW4gcmFkaXVzIGFuZCB0aGUgb2Zmc2V0IGlzIGhlcmUgdG8gY2VudGVyIHRoZSBzaGFwZVxuXG4gIHIgKj0gMS4xNTtcbiAgeSAtPSAwLjI3NSAqIHI7XG4gIHZhciBzID0gciAqIDI7XG4gIHZhciBzMiA9IHMgLyAyO1xuICB2YXIgaXIgPSBNYXRoLnNxcnQoMykgLyA2ICogczsgLy8gcmFkaXVzIG9mIGlubmVyIGNpcmNsZVxuXG4gIHZhciBoID0gTWF0aC5zcXJ0KHMgKiBzIC0gczIgKiBzMik7IC8vIGhlaWdodFxuXG4gIGN0eC5tb3ZlVG8oeCwgeSArIChoIC0gaXIpKTtcbiAgY3R4LmxpbmVUbyh4ICsgczIsIHkgLSBpcik7XG4gIGN0eC5saW5lVG8oeCAtIHMyLCB5IC0gaXIpO1xuICBjdHgubGluZVRvKHgsIHkgKyAoaCAtIGlyKSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGEgc3Rhci5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSByIC0gVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgc3Rhci5cclxuICovXG5cbmZ1bmN0aW9uIGRyYXdTdGFyKGN0eCwgeCwgeSwgcikge1xuICAvLyBodHRwOi8vd3d3Lmh0bWw1Y2FudmFzdHV0b3JpYWxzLmNvbS9sYWJzL2h0bWw1LWNhbnZhcy1zdGFyLXNwaW5uZXIvXG4gIGN0eC5iZWdpblBhdGgoKTsgLy8gdGhlIGNoYW5nZSBpbiByYWRpdXMgYW5kIHRoZSBvZmZzZXQgaXMgaGVyZSB0byBjZW50ZXIgdGhlIHNoYXBlXG5cbiAgciAqPSAwLjgyO1xuICB5ICs9IDAuMSAqIHI7XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAxMDsgbisrKSB7XG4gICAgdmFyIHJhZGl1cyA9IG4gJSAyID09PSAwID8gciAqIDEuMyA6IHIgKiAwLjU7XG4gICAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzICogTWF0aC5zaW4obiAqIDIgKiBNYXRoLlBJIC8gMTApLCB5IC0gcmFkaXVzICogTWF0aC5jb3MobiAqIDIgKiBNYXRoLlBJIC8gMTApKTtcbiAgfVxuXG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGEgZGlhbW9uZC5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSByIC0gSGFsZiBvZiB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZGlhbW9uZC5cclxuICogQHJlbWFya3NcclxuICogaHR0cDovL3d3dy5odG1sNWNhbnZhc3R1dG9yaWFscy5jb20vbGFicy9odG1sNS1jYW52YXMtc3Rhci1zcGlubmVyL1xyXG4gKi9cblxuZnVuY3Rpb24gZHJhd0RpYW1vbmQoY3R4LCB4LCB5LCByKSB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgcik7XG4gIGN0eC5saW5lVG8oeCArIHIsIHkpO1xuICBjdHgubGluZVRvKHgsIHkgLSByKTtcbiAgY3R4LmxpbmVUbyh4IC0gciwgeSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHcgLSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZS5cclxuICogQHBhcmFtIGggLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXHJcbiAqIEBwYXJhbSByIC0gVGhlIHJhZGl1cyBvZiB0aGUgY29ybmVycy5cclxuICogQHJlbWFya3NcclxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjU1NTEyL2hvdy10by1kcmF3LWEtcm91bmRlZC1yZWN0YW5nbGUtb24taHRtbC1jYW52YXNcclxuICovXG5cbmZ1bmN0aW9uIGRyYXdSb3VuZFJlY3QoY3R4LCB4LCB5LCB3LCBoLCByKSB7XG4gIHZhciByMmQgPSBNYXRoLlBJIC8gMTgwO1xuXG4gIGlmICh3IC0gMiAqIHIgPCAwKSB7XG4gICAgciA9IHcgLyAyO1xuICB9IC8vZW5zdXJlIHRoYXQgdGhlIHJhZGl1cyBpc24ndCB0b28gbGFyZ2UgZm9yIHhcblxuXG4gIGlmIChoIC0gMiAqIHIgPCAwKSB7XG4gICAgciA9IGggLyAyO1xuICB9IC8vZW5zdXJlIHRoYXQgdGhlIHJhZGl1cyBpc24ndCB0b28gbGFyZ2UgZm9yIHlcblxuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyh4ICsgciwgeSk7XG4gIGN0eC5saW5lVG8oeCArIHcgLSByLCB5KTtcbiAgY3R4LmFyYyh4ICsgdyAtIHIsIHkgKyByLCByLCByMmQgKiAyNzAsIHIyZCAqIDM2MCwgZmFsc2UpO1xuICBjdHgubGluZVRvKHggKyB3LCB5ICsgaCAtIHIpO1xuICBjdHguYXJjKHggKyB3IC0gciwgeSArIGggLSByLCByLCAwLCByMmQgKiA5MCwgZmFsc2UpO1xuICBjdHgubGluZVRvKHggKyByLCB5ICsgaCk7XG4gIGN0eC5hcmMoeCArIHIsIHkgKyBoIC0gciwgciwgcjJkICogOTAsIHIyZCAqIDE4MCwgZmFsc2UpO1xuICBjdHgubGluZVRvKHgsIHkgKyByKTtcbiAgY3R4LmFyYyh4ICsgciwgeSArIHIsIHIsIHIyZCAqIDE4MCwgcjJkICogMjcwLCBmYWxzZSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGFuIGVsbGlwc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gdyAtIFRoZSB3aWR0aCBvZiB0aGUgZWxsaXBzZS5cclxuICogQHBhcmFtIGggLSBUaGUgaGVpZ2h0IG9mIHRoZSBlbGxpcHNlLlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzI3OTgvaG93LXRvLWRyYXctYW4tb3ZhbC1pbi1odG1sNS1jYW52YXNcclxuICpcclxuICogUG9zdGZpeCAnX3ZpcycgYWRkZWQgdG8gZGlzY2VybiBpdCBmcm9tIHN0YW5kYXJkIG1ldGhvZCBlbGxpcHNlKCkuXHJcbiAqL1xuXG5mdW5jdGlvbiBkcmF3RWxsaXBzZShjdHgsIHgsIHksIHcsIGgpIHtcbiAgdmFyIGthcHBhID0gMC41NTIyODQ4LFxuICAgICAgb3ggPSB3IC8gMiAqIGthcHBhLFxuICAgICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgaG9yaXpvbnRhbFxuICBveSA9IGggLyAyICoga2FwcGEsXG4gICAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCB2ZXJ0aWNhbFxuICB4ZSA9IHggKyB3LFxuICAgICAgLy8geC1lbmRcbiAgeWUgPSB5ICsgaCxcbiAgICAgIC8vIHktZW5kXG4gIHhtID0geCArIHcgLyAyLFxuICAgICAgLy8geC1taWRkbGVcbiAgeW0gPSB5ICsgaCAvIDI7IC8vIHktbWlkZGxlXG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHgsIHltKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeGUsIHltICsgb3ksIHhtICsgb3gsIHllLCB4bSwgeWUpO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhbiBpc29tZXRyaWMgY3lsaW5kZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gdyAtIFRoZSB3aWR0aCBvZiB0aGUgZGF0YWJhc2UuXHJcbiAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgZGF0YWJhc2UuXHJcbiAqIEByZW1hcmtzXHJcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE3Mjc5OC9ob3ctdG8tZHJhdy1hbi1vdmFsLWluLWh0bWw1LWNhbnZhc1xyXG4gKi9cblxuZnVuY3Rpb24gZHJhd0RhdGFiYXNlKGN0eCwgeCwgeSwgdywgaCkge1xuICB2YXIgZiA9IDEgLyAzO1xuICB2YXIgd0VsbGlwc2UgPSB3O1xuICB2YXIgaEVsbGlwc2UgPSBoICogZjtcbiAgdmFyIGthcHBhID0gMC41NTIyODQ4LFxuICAgICAgb3ggPSB3RWxsaXBzZSAvIDIgKiBrYXBwYSxcbiAgICAgIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgb3kgPSBoRWxsaXBzZSAvIDIgKiBrYXBwYSxcbiAgICAgIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXG4gIHhlID0geCArIHdFbGxpcHNlLFxuICAgICAgLy8geC1lbmRcbiAgeWUgPSB5ICsgaEVsbGlwc2UsXG4gICAgICAvLyB5LWVuZFxuICB4bSA9IHggKyB3RWxsaXBzZSAvIDIsXG4gICAgICAvLyB4LW1pZGRsZVxuICB5bSA9IHkgKyBoRWxsaXBzZSAvIDIsXG4gICAgICAvLyB5LW1pZGRsZVxuICB5bWIgPSB5ICsgKGggLSBoRWxsaXBzZSAvIDIpLFxuICAgICAgLy8geS1taWRsbGUsIGJvdHRvbSBlbGxpcHNlXG4gIHllYiA9IHkgKyBoOyAvLyB5LWVuZCwgYm90dG9tIGVsbGlwc2VcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8oeGUsIHltKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeGUsIHltICsgb3ksIHhtICsgb3gsIHllLCB4bSwgeWUpO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5bSAtIG95LCB4bSAtIG94LCB5LCB4bSwgeSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuICBjdHgubGluZVRvKHhlLCB5bWIpO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4ZSwgeW1iICsgb3ksIHhtICsgb3gsIHllYiwgeG0sIHllYik7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllYiwgeCwgeW1iICsgb3ksIHgsIHltYik7XG4gIGN0eC5saW5lVG8oeCwgeW0pO1xufVxuLyoqXHJcbiAqIERyYXcgYSBkYXNoZWQgbGluZS5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgc3RhcnQgcG9zaXRpb24gb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgc3RhcnQgcG9zaXRpb24gb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHgyIC0gVGhlIGVuZCBwb3NpdGlvbiBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geTIgLSBUaGUgZW5kIHBvc2l0aW9uIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSBwYXR0ZXJuIC0gTGlzdCBvZiBsZW5ndGhzIHN0YXJ0aW5nIHdpdGggbGluZSBhbmQgdGhlbiBhbHRlcm5hdGluZyBiZXR3ZWVuIHNwYWNlIGFuZCBsaW5lLlxyXG4gKiBAYXV0aG9yIERhdmlkIEpvcmRhblxyXG4gKiBAcmVtYXJrc1xyXG4gKiBkYXRlIDIwMTItMDgtMDhcclxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NTc2NzI0L2RvdHRlZC1zdHJva2UtaW4tY2FudmFzXHJcbiAqL1xuXG5mdW5jdGlvbiBkcmF3RGFzaGVkTGluZShjdHgsIHgsIHksIHgyLCB5MiwgcGF0dGVybikge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8oeCwgeSk7XG4gIHZhciBwYXR0ZXJuTGVuZ3RoID0gcGF0dGVybi5sZW5ndGg7XG4gIHZhciBkeCA9IHgyIC0geDtcbiAgdmFyIGR5ID0geTIgLSB5O1xuICB2YXIgc2xvcGUgPSBkeSAvIGR4O1xuICB2YXIgZGlzdFJlbWFpbmluZyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIHZhciBwYXR0ZXJuSW5kZXggPSAwO1xuICB2YXIgZHJhdyA9IHRydWU7XG4gIHZhciB4U3RlcCA9IDA7XG4gIHZhciBkYXNoTGVuZ3RoID0gK3BhdHRlcm5bMF07XG5cbiAgd2hpbGUgKGRpc3RSZW1haW5pbmcgPj0gMC4xKSB7XG4gICAgZGFzaExlbmd0aCA9ICtwYXR0ZXJuW3BhdHRlcm5JbmRleCsrICUgcGF0dGVybkxlbmd0aF07XG5cbiAgICBpZiAoZGFzaExlbmd0aCA+IGRpc3RSZW1haW5pbmcpIHtcbiAgICAgIGRhc2hMZW5ndGggPSBkaXN0UmVtYWluaW5nO1xuICAgIH1cblxuICAgIHhTdGVwID0gTWF0aC5zcXJ0KGRhc2hMZW5ndGggKiBkYXNoTGVuZ3RoIC8gKDEgKyBzbG9wZSAqIHNsb3BlKSk7XG4gICAgeFN0ZXAgPSBkeCA8IDAgPyAteFN0ZXAgOiB4U3RlcDtcbiAgICB4ICs9IHhTdGVwO1xuICAgIHkgKz0gc2xvcGUgKiB4U3RlcDtcblxuICAgIGlmIChkcmF3ID09PSB0cnVlKSB7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIH1cblxuICAgIGRpc3RSZW1haW5pbmcgLT0gZGFzaExlbmd0aDtcbiAgICBkcmF3ID0gIWRyYXc7XG4gIH1cbn1cbi8qKlxyXG4gKiBEcmF3IGEgaGV4YWdvbi5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSByIC0gVGhlIHJhZGl1cyBvZiB0aGUgaGV4YWdvbi5cclxuICovXG5cbmZ1bmN0aW9uIGRyYXdIZXhhZ29uKGN0eCwgeCwgeSwgcikge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIHZhciBzaWRlcyA9IDY7XG4gIHZhciBhID0gTWF0aC5QSSAqIDIgLyBzaWRlcztcbiAgY3R4Lm1vdmVUbyh4ICsgciwgeSk7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgY3R4LmxpbmVUbyh4ICsgciAqIE1hdGguY29zKGEgKiBpKSwgeSArIHIgKiBNYXRoLnNpbihhICogaSkpO1xuICB9XG5cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxudmFyIHNoYXBlTWFwID0ge1xuICBjaXJjbGU6IGRyYXdDaXJjbGUsXG4gIGRhc2hlZExpbmU6IGRyYXdEYXNoZWRMaW5lLFxuICBkYXRhYmFzZTogZHJhd0RhdGFiYXNlLFxuICBkaWFtb25kOiBkcmF3RGlhbW9uZCxcbiAgZWxsaXBzZTogZHJhd0VsbGlwc2UsXG4gIGVsbGlwc2VfdmlzOiBkcmF3RWxsaXBzZSxcbiAgaGV4YWdvbjogZHJhd0hleGFnb24sXG4gIHJvdW5kUmVjdDogZHJhd1JvdW5kUmVjdCxcbiAgc3F1YXJlOiBkcmF3U3F1YXJlLFxuICBzdGFyOiBkcmF3U3RhcixcbiAgdHJpYW5nbGU6IGRyYXdUcmlhbmdsZSxcbiAgdHJpYW5nbGVEb3duOiBkcmF3VHJpYW5nbGVEb3duXG59O1xuLyoqXHJcbiAqIFJldHVybnMgZWl0aGVyIGN1c3RvbSBvciBuYXRpdmUgZHJhd2luZyBmdW5jdGlvbiBiYXNlIG9uIHN1cHBsaWVkIG5hbWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLiBFaXRoZXIgdGhlIG5hbWUgb2YgYVxyXG4gKiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgcHJvcGVydHkgb3IgYW4gZXhwb3J0IGZyb20gc2hhcGVzLnRzIHdpdGhvdXQgdGhlXHJcbiAqIGRyYXcgcHJlZml4LlxyXG4gKiBAcmV0dXJucyBUaGUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBmb3IgcmVuZGVyaW5nLiBJbiBjYXNlIG9mIG5hdGl2ZVxyXG4gKiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgZnVuY3Rpb24gdGhlIEFQSSBpcyBub3JtYWxpemVkIHRvXHJcbiAqIGAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIC4uLm9yaWdpbmFsQXJncykgPT4gdm9pZGAuXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRTaGFwZShuYW1lKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2hhcGVNYXAsIG5hbWUpKSB7XG4gICAgcmV0dXJuIHNoYXBlTWFwW25hbWVdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlW25hbWVdLmNhbGwoY3R4LCBhcmdzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0eWxlSW5qZWN0KGNzcywgcmVmKSB7XG4gIGlmIChyZWYgPT09IHZvaWQgMCkgcmVmID0ge307XG4gIHZhciBpbnNlcnRBdCA9IHJlZi5pbnNlcnRBdDtcblxuICBpZiAoIWNzcyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gIGlmIChpbnNlcnRBdCA9PT0gJ3RvcCcpIHtcbiAgICBpZiAoaGVhZC5maXJzdENoaWxkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIGNzc18yNDh6JDYgPSBcIi52aXMtb3ZlcmxheSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDBweDtcXG4gIHJpZ2h0OiAwcHg7XFxuICBib3R0b206IDBweDtcXG4gIGxlZnQ6IDBweDtcXG5cXG4gIC8qIE11c3QgYmUgZGlzcGxheWVkIGFib3ZlIGZvciBleGFtcGxlIHNlbGVjdGVkIFRpbWVsaW5lIGl0ZW1zICovXFxuICB6LWluZGV4OiAxMDtcXG59XFxuXFxuLnZpcy1hY3RpdmUge1xcbiAgYm94LXNoYWRvdzogMCAwIDEwcHggIzg2ZDVmODtcXG59XFxuXCI7XG5zdHlsZUluamVjdChjc3NfMjQ4eiQ2KTtcblxudmFyIGNzc18yNDh6JDUgPSBcIi8qIG92ZXJyaWRlIHNvbWUgYm9vdHN0cmFwIHN0eWxlcyBzY3Jld2luZyB1cCB0aGUgdGltZWxpbmVzIGNzcyAqL1xcblxcbi52aXMgW2NsYXNzKj1cXFwic3BhblxcXCJdIHtcXG4gIG1pbi1oZWlnaHQ6IDA7XFxuICB3aWR0aDogYXV0bztcXG59XFxuXCI7XG5zdHlsZUluamVjdChjc3NfMjQ4eiQ1KTtcblxudmFyIGNzc18yNDh6JDQgPSBcImRpdi52aXMtY29sb3ItcGlja2VyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMHB4O1xcbiAgbGVmdDogMzBweDtcXG4gIG1hcmdpbi10b3A6IC0xNDBweDtcXG4gIG1hcmdpbi1sZWZ0OiAzMHB4O1xcbiAgd2lkdGg6IDMxMHB4O1xcbiAgaGVpZ2h0OiA0NDRweDtcXG4gIHotaW5kZXg6IDE7XFxuICBwYWRkaW5nOiAxMHB4O1xcbiAgYm9yZGVyLXJhZGl1czogMTVweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgYm94LXNoYWRvdzogcmdiYSgwLCAwLCAwLCAwLjUpIDBweCAwcHggMTBweCAwcHg7XFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtYXJyb3cge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAxNDdweDtcXG4gIGxlZnQ6IDVweDtcXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1hcnJvdzo6YWZ0ZXIsXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1hcnJvdzo6YmVmb3JlIHtcXG4gIHJpZ2h0OiAxMDAlO1xcbiAgdG9wOiA1MCU7XFxuICBib3JkZXI6IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgY29udGVudDogXFxcIiBcXFwiO1xcbiAgaGVpZ2h0OiAwO1xcbiAgd2lkdGg6IDA7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1hcnJvdzphZnRlciB7XFxuICBib3JkZXItY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMCk7XFxuICBib3JkZXItcmlnaHQtY29sb3I6ICNmZmZmZmY7XFxuICBib3JkZXItd2lkdGg6IDMwcHg7XFxuICBtYXJnaW4tdG9wOiAtMzBweDtcXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1jb2xvciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogMjg5cHg7XFxuICBoZWlnaHQ6IDI4OXB4O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWJyaWdodG5lc3Mge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAzMTNweDtcXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1vcGFjaXR5IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMzUwcHg7XFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtc2VsZWN0b3Ige1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAxMzdweDtcXG4gIGxlZnQ6IDEzN3B4O1xcbiAgd2lkdGg6IDE1cHg7XFxuICBoZWlnaHQ6IDE1cHg7XFxuICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2ZmZmZmZjtcXG4gIGJhY2tncm91bmQ6ICM0YzRjNGM7IC8qIE9sZCBicm93c2VycyAqL1xcbiAgYmFja2dyb3VuZDogLW1vei1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgIzRjNGM0YyAwJSxcXG4gICAgIzU5NTk1OSAxMiUsXFxuICAgICM2NjY2NjYgMjUlLFxcbiAgICAjNDc0NzQ3IDM5JSxcXG4gICAgIzJjMmMyYyA1MCUsXFxuICAgICMwMDAwMDAgNTElLFxcbiAgICAjMTExMTExIDYwJSxcXG4gICAgIzJiMmIyYiA3NiUsXFxuICAgICMxYzFjMWMgOTElLFxcbiAgICAjMTMxMzEzIDEwMCVcXG4gICk7IC8qIEZGMy42KyAqL1xcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1ncmFkaWVudChcXG4gICAgbGluZWFyLFxcbiAgICBsZWZ0IHRvcCxcXG4gICAgbGVmdCBib3R0b20sXFxuICAgIGNvbG9yLXN0b3AoMCUsICM0YzRjNGMpLFxcbiAgICBjb2xvci1zdG9wKDEyJSwgIzU5NTk1OSksXFxuICAgIGNvbG9yLXN0b3AoMjUlLCAjNjY2NjY2KSxcXG4gICAgY29sb3Itc3RvcCgzOSUsICM0NzQ3NDcpLFxcbiAgICBjb2xvci1zdG9wKDUwJSwgIzJjMmMyYyksXFxuICAgIGNvbG9yLXN0b3AoNTElLCAjMDAwMDAwKSxcXG4gICAgY29sb3Itc3RvcCg2MCUsICMxMTExMTEpLFxcbiAgICBjb2xvci1zdG9wKDc2JSwgIzJiMmIyYiksXFxuICAgIGNvbG9yLXN0b3AoOTElLCAjMWMxYzFjKSxcXG4gICAgY29sb3Itc3RvcCgxMDAlLCAjMTMxMzEzKVxcbiAgKTsgLyogQ2hyb21lLFNhZmFyaTQrICovXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjNGM0YzRjIDAlLFxcbiAgICAjNTk1OTU5IDEyJSxcXG4gICAgIzY2NjY2NiAyNSUsXFxuICAgICM0NzQ3NDcgMzklLFxcbiAgICAjMmMyYzJjIDUwJSxcXG4gICAgIzAwMDAwMCA1MSUsXFxuICAgICMxMTExMTEgNjAlLFxcbiAgICAjMmIyYjJiIDc2JSxcXG4gICAgIzFjMWMxYyA5MSUsXFxuICAgICMxMzEzMTMgMTAwJVxcbiAgKTsgLyogQ2hyb21lMTArLFNhZmFyaTUuMSsgKi9cXG4gIGJhY2tncm91bmQ6IC1vLWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjNGM0YzRjIDAlLFxcbiAgICAjNTk1OTU5IDEyJSxcXG4gICAgIzY2NjY2NiAyNSUsXFxuICAgICM0NzQ3NDcgMzklLFxcbiAgICAjMmMyYzJjIDUwJSxcXG4gICAgIzAwMDAwMCA1MSUsXFxuICAgICMxMTExMTEgNjAlLFxcbiAgICAjMmIyYjJiIDc2JSxcXG4gICAgIzFjMWMxYyA5MSUsXFxuICAgICMxMzEzMTMgMTAwJVxcbiAgKTsgLyogT3BlcmEgMTEuMTArICovXFxuICBiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICM0YzRjNGMgMCUsXFxuICAgICM1OTU5NTkgMTIlLFxcbiAgICAjNjY2NjY2IDI1JSxcXG4gICAgIzQ3NDc0NyAzOSUsXFxuICAgICMyYzJjMmMgNTAlLFxcbiAgICAjMDAwMDAwIDUxJSxcXG4gICAgIzExMTExMSA2MCUsXFxuICAgICMyYjJiMmIgNzYlLFxcbiAgICAjMWMxYzFjIDkxJSxcXG4gICAgIzEzMTMxMyAxMDAlXFxuICApOyAvKiBJRTEwKyAqL1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxcbiAgICB0byBib3R0b20sXFxuICAgICM0YzRjNGMgMCUsXFxuICAgICM1OTU5NTkgMTIlLFxcbiAgICAjNjY2NjY2IDI1JSxcXG4gICAgIzQ3NDc0NyAzOSUsXFxuICAgICMyYzJjMmMgNTAlLFxcbiAgICAjMDAwMDAwIDUxJSxcXG4gICAgIzExMTExMSA2MCUsXFxuICAgICMyYjJiMmIgNzYlLFxcbiAgICAjMWMxYzFjIDkxJSxcXG4gICAgIzEzMTMxMyAxMDAlXFxuICApOyAvKiBXM0MgKi9cXG4gIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KCBzdGFydENvbG9yc3RyPScjNGM0YzRjJywgZW5kQ29sb3JzdHI9JyMxMzEzMTMnLEdyYWRpZW50VHlwZT0wICk7IC8qIElFNi05ICovXFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtbmV3LWNvbG9yIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAxNDBweDtcXG4gIGhlaWdodDogMjBweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4xKTtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIHRvcDogMzgwcHg7XFxuICBsZWZ0OiAxNTlweDtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgcGFkZGluZy1yaWdodDogMnB4O1xcbiAgZm9udC1zaXplOiAxMHB4O1xcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC40KTtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBsaW5lLWhlaWdodDogMjBweDtcXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1pbml0aWFsLWNvbG9yIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAxNDBweDtcXG4gIGhlaWdodDogMjBweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4xKTtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIHRvcDogMzgwcHg7XFxuICBsZWZ0OiAxMHB4O1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIHBhZGRpbmctbGVmdDogMnB4O1xcbiAgZm9udC1zaXplOiAxMHB4O1xcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC40KTtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBsaW5lLWhlaWdodDogMjBweDtcXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1sYWJlbCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogMzAwcHg7XFxuICBsZWZ0OiAxMHB4O1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWxhYmVsLnZpcy1icmlnaHRuZXNzIHtcXG4gIHRvcDogMzAwcHg7XFxufVxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGRpdi52aXMtbGFiZWwudmlzLW9wYWNpdHkge1xcbiAgdG9wOiAzMzhweDtcXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1idXR0b24ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDY4cHg7XFxuICBoZWlnaHQ6IDI1cHg7XFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGxpbmUtaGVpZ2h0OiAyNXB4O1xcbiAgdG9wOiA0MTBweDtcXG4gIGJvcmRlcjogMnB4IHNvbGlkICNkOWQ5ZDk7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjdmN2Y3O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWJ1dHRvbi52aXMtY2FuY2VsIHtcXG4gIC8qYm9yZGVyOjJweCBzb2xpZCAjZmY0ZTMzOyovXFxuICAvKmJhY2tncm91bmQtY29sb3I6ICNmZjc3NjE7Ki9cXG4gIGxlZnQ6IDVweDtcXG59XFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1idXR0b24udmlzLWxvYWQge1xcbiAgLypib3JkZXI6MnB4IHNvbGlkICNhMTUzZTY7Ki9cXG4gIC8qYmFja2dyb3VuZC1jb2xvcjogI2NiOGRmZjsqL1xcbiAgbGVmdDogODJweDtcXG59XFxuZGl2LnZpcy1jb2xvci1waWNrZXIgZGl2LnZpcy1idXR0b24udmlzLWFwcGx5IHtcXG4gIC8qYm9yZGVyOjJweCBzb2xpZCAjNDU4OGU2OyovXFxuICAvKmJhY2tncm91bmQtY29sb3I6ICM4MmI2ZmY7Ki9cXG4gIGxlZnQ6IDE1OXB4O1xcbn1cXG5kaXYudmlzLWNvbG9yLXBpY2tlciBkaXYudmlzLWJ1dHRvbi52aXMtc2F2ZSB7XFxuICAvKmJvcmRlcjoycHggc29saWQgIzQ1ZTY1NTsqL1xcbiAgLypiYWNrZ3JvdW5kLWNvbG9yOiAjNmRmZjdjOyovXFxuICBsZWZ0OiAyMzZweDtcXG59XFxuXFxuZGl2LnZpcy1jb2xvci1waWNrZXIgaW5wdXQudmlzLXJhbmdlIHtcXG4gIHdpZHRoOiAyOTBweDtcXG4gIGhlaWdodDogMjBweDtcXG59XFxuXFxuLyogVE9ETzogaXMgdGhpcyByZWR1bmRhbnQ/XFxuZGl2LnZpcy1jb2xvci1waWNrZXIgaW5wdXQudmlzLXJhbmdlLWJyaWdodG5lc3Mge1xcbiAgd2lkdGg6IDI4OXB4ICFpbXBvcnRhbnQ7XFxufVxcblxcblxcbmRpdi52aXMtY29sb3ItcGlja2VyIGlucHV0LnZpcy1zYXR1cmF0aW9uLXJhbmdlIHtcXG4gIHdpZHRoOiAyODlweCAhaW1wb3J0YW50O1xcbn0qL1xcblwiO1xuc3R5bGVJbmplY3QoY3NzXzI0OHokNCk7XG5cbnZhciBjc3NfMjQ4eiQzID0gXCJkaXYudmlzLWNvbmZpZ3VyYXRpb24ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmbG9hdDogbGVmdDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG59XFxuXFxuZGl2LnZpcy1jb25maWd1cmF0aW9uLXdyYXBwZXIge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogNzAwcHg7XFxufVxcblxcbmRpdi52aXMtY29uZmlndXJhdGlvbi13cmFwcGVyOjphZnRlciB7XFxuICBjbGVhcjogYm90aDtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbmRpdi52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLW9wdGlvbi1jb250YWluZXIge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogNDk1cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmO1xcbiAgYm9yZGVyOiAycHggc29saWQgI2Y3ZjhmYTtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIG1hcmdpbi10b3A6IDIwcHg7XFxuICBsZWZ0OiAxMHB4O1xcbiAgcGFkZGluZy1sZWZ0OiA1cHg7XFxufVxcblxcbmRpdi52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLWJ1dHRvbiB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiA0OTVweDtcXG4gIGhlaWdodDogMjVweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBsaW5lLWhlaWdodDogMjVweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmN2Y4ZmE7XFxuICBib3JkZXI6IDJweCBzb2xpZCAjY2VjZWQwO1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgbWFyZ2luLXRvcDogMjBweDtcXG4gIGxlZnQ6IDEwcHg7XFxuICBwYWRkaW5nLWxlZnQ6IDVweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIG1hcmdpbi1ib3R0b206IDMwcHg7XFxufVxcblxcbmRpdi52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLWJ1dHRvbi5ob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDU4OGU2O1xcbiAgYm9yZGVyOiAycHggc29saWQgIzIxNDM3MztcXG4gIGNvbG9yOiAjZmZmZmZmO1xcbn1cXG5cXG5kaXYudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1pdGVtIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICB3aWR0aDogNDk1cHg7XFxuICBoZWlnaHQ6IDI1cHg7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgbGluZS1oZWlnaHQ6IDI1cHg7XFxufVxcblxcbmRpdi52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLWl0ZW0udmlzLWNvbmZpZy1zMiB7XFxuICBsZWZ0OiAxMHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y3ZjhmYTtcXG4gIHBhZGRpbmctbGVmdDogNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbn1cXG5kaXYudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1pdGVtLnZpcy1jb25maWctczMge1xcbiAgbGVmdDogMjBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlNGU5ZjA7XFxuICBwYWRkaW5nLWxlZnQ6IDVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG59XFxuZGl2LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctaXRlbS52aXMtY29uZmlnLXM0IHtcXG4gIGxlZnQ6IDMwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2ZkOGU2O1xcbiAgcGFkZGluZy1sZWZ0OiA1cHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcblxcbmRpdi52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLWhlYWRlciB7XFxuICBmb250LXNpemU6IDE4cHg7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXFxuZGl2LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctbGFiZWwge1xcbiAgd2lkdGg6IDEyMHB4O1xcbiAgaGVpZ2h0OiAyNXB4O1xcbiAgbGluZS1oZWlnaHQ6IDI1cHg7XFxufVxcblxcbmRpdi52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLWxhYmVsLnZpcy1jb25maWctczMge1xcbiAgd2lkdGg6IDExMHB4O1xcbn1cXG5kaXYudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1sYWJlbC52aXMtY29uZmlnLXM0IHtcXG4gIHdpZHRoOiAxMDBweDtcXG59XFxuXFxuZGl2LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctY29sb3JCbG9jayB7XFxuICB0b3A6IDFweDtcXG4gIHdpZHRoOiAzMHB4O1xcbiAgaGVpZ2h0OiAxOXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzQ0NDQ0NDtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIHBhZGRpbmc6IDBweDtcXG4gIG1hcmdpbjogMHB4O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLWNoZWNrYm94IHtcXG4gIGxlZnQ6IC01cHg7XFxufVxcblxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2VpbnB1dCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0b3A6IC01cHg7XFxuICB3aWR0aDogNjBweDtcXG4gIC8qaGVpZ2h0OjEzcHg7Ki9cXG4gIHBhZGRpbmc6IDFweDtcXG4gIG1hcmdpbjogMDtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlIHtcXG4gIC8qcmVtb3ZlcyBkZWZhdWx0IHdlYmtpdCBzdHlsZXMqL1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcblxcbiAgLypmaXggZm9yIEZGIHVuYWJsZSB0byBhcHBseSBmb2N1cyBzdHlsZSBidWcgKi9cXG4gIGJvcmRlcjogMHB4IHNvbGlkIHdoaXRlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcXG5cXG4gIC8qcmVxdWlyZWQgZm9yIHByb3BlciB0cmFjayBzaXppbmcgaW4gRkYqL1xcbiAgd2lkdGg6IDMwMHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbn1cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlOjotd2Via2l0LXNsaWRlci1ydW5uYWJsZS10cmFjayB7XFxuICB3aWR0aDogMzAwcHg7XFxuICBoZWlnaHQ6IDVweDtcXG4gIGJhY2tncm91bmQ6ICNkZWRlZGU7IC8qIE9sZCBicm93c2VycyAqL1xcbiAgYmFja2dyb3VuZDogLW1vei1saW5lYXItZ3JhZGllbnQodG9wLCAjZGVkZWRlIDAlLCAjYzhjOGM4IDk5JSk7IC8qIEZGMy42KyAqL1xcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1ncmFkaWVudChcXG4gICAgbGluZWFyLFxcbiAgICBsZWZ0IHRvcCxcXG4gICAgbGVmdCBib3R0b20sXFxuICAgIGNvbG9yLXN0b3AoMCUsICNkZWRlZGUpLFxcbiAgICBjb2xvci1zdG9wKDk5JSwgI2M4YzhjOClcXG4gICk7IC8qIENocm9tZSxTYWZhcmk0KyAqL1xcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgI2RlZGVkZSAwJSxcXG4gICAgI2M4YzhjOCA5OSVcXG4gICk7IC8qIENocm9tZTEwKyxTYWZhcmk1LjErICovXFxuICBiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgI2RlZGVkZSAwJSxcXG4gICAgI2M4YzhjOCA5OSVcXG4gICk7IC8qIE9wZXJhIDExLjEwKyAqL1xcbiAgYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICNkZWRlZGUgMCUsICNjOGM4YzggOTklKTsgLyogSUUxMCsgKi9cXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sICNkZWRlZGUgMCUsICNjOGM4YzggOTklKTsgLyogVzNDICovXFxuICBmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudCggc3RhcnRDb2xvcnN0cj0nI2RlZGVkZScsIGVuZENvbG9yc3RyPScjYzhjOGM4JyxHcmFkaWVudFR5cGU9MCApOyAvKiBJRTYtOSAqL1xcblxcbiAgYm9yZGVyOiAxcHggc29saWQgIzk5OTk5OTtcXG4gIGJveC1zaGFkb3c6ICNhYWFhYWEgMHB4IDBweCAzcHggMHB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbn1cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlOjotd2Via2l0LXNsaWRlci10aHVtYiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjMTQzMzRiO1xcbiAgaGVpZ2h0OiAxN3B4O1xcbiAgd2lkdGg6IDE3cHg7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBiYWNrZ3JvdW5kOiAjMzg3NmMyOyAvKiBPbGQgYnJvd3NlcnMgKi9cXG4gIGJhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgIzM4NzZjMiAwJSwgIzM4NTM4MCAxMDAlKTsgLyogRkYzLjYrICovXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWdyYWRpZW50KFxcbiAgICBsaW5lYXIsXFxuICAgIGxlZnQgdG9wLFxcbiAgICBsZWZ0IGJvdHRvbSxcXG4gICAgY29sb3Itc3RvcCgwJSwgIzM4NzZjMiksXFxuICAgIGNvbG9yLXN0b3AoMTAwJSwgIzM4NTM4MClcXG4gICk7IC8qIENocm9tZSxTYWZhcmk0KyAqL1xcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgIzM4NzZjMiAwJSxcXG4gICAgIzM4NTM4MCAxMDAlXFxuICApOyAvKiBDaHJvbWUxMCssU2FmYXJpNS4xKyAqL1xcbiAgYmFja2dyb3VuZDogLW8tbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICMzODc2YzIgMCUsXFxuICAgICMzODUzODAgMTAwJVxcbiAgKTsgLyogT3BlcmEgMTEuMTArICovXFxuICBiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgIzM4NzZjMiAwJSwgIzM4NTM4MCAxMDAlKTsgLyogSUUxMCsgKi9cXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sICMzODc2YzIgMCUsICMzODUzODAgMTAwJSk7IC8qIFczQyAqL1xcbiAgZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoIHN0YXJ0Q29sb3JzdHI9JyMzODc2YzInLCBlbmRDb2xvcnN0cj0nIzM4NTM4MCcsR3JhZGllbnRUeXBlPTAgKTsgLyogSUU2LTkgKi9cXG4gIGJveC1zaGFkb3c6ICMxMTE5MjcgMHB4IDBweCAxcHggMHB4O1xcbiAgbWFyZ2luLXRvcDogLTdweDtcXG59XFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZTpmb2N1cyB7XFxuICBvdXRsaW5lOiBub25lO1xcbn1cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlOmZvY3VzOjotd2Via2l0LXNsaWRlci1ydW5uYWJsZS10cmFjayB7XFxuICBiYWNrZ3JvdW5kOiAjOWQ5ZDlkOyAvKiBPbGQgYnJvd3NlcnMgKi9cXG4gIGJhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgIzlkOWQ5ZCAwJSwgI2M4YzhjOCA5OSUpOyAvKiBGRjMuNisgKi9cXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtZ3JhZGllbnQoXFxuICAgIGxpbmVhcixcXG4gICAgbGVmdCB0b3AsXFxuICAgIGxlZnQgYm90dG9tLFxcbiAgICBjb2xvci1zdG9wKDAlLCAjOWQ5ZDlkKSxcXG4gICAgY29sb3Itc3RvcCg5OSUsICNjOGM4YzgpXFxuICApOyAvKiBDaHJvbWUsU2FmYXJpNCsgKi9cXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICM5ZDlkOWQgMCUsXFxuICAgICNjOGM4YzggOTklXFxuICApOyAvKiBDaHJvbWUxMCssU2FmYXJpNS4xKyAqL1xcbiAgYmFja2dyb3VuZDogLW8tbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICM5ZDlkOWQgMCUsXFxuICAgICNjOGM4YzggOTklXFxuICApOyAvKiBPcGVyYSAxMS4xMCsgKi9cXG4gIGJhY2tncm91bmQ6IC1tcy1saW5lYXItZ3JhZGllbnQodG9wLCAjOWQ5ZDlkIDAlLCAjYzhjOGM4IDk5JSk7IC8qIElFMTArICovXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCAjOWQ5ZDlkIDAlLCAjYzhjOGM4IDk5JSk7IC8qIFczQyAqL1xcbiAgZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoIHN0YXJ0Q29sb3JzdHI9JyM5ZDlkOWQnLCBlbmRDb2xvcnN0cj0nI2M4YzhjOCcsR3JhZGllbnRUeXBlPTAgKTsgLyogSUU2LTkgKi9cXG59XFxuXFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZTo6LW1vei1yYW5nZS10cmFjayB7XFxuICB3aWR0aDogMzAwcHg7XFxuICBoZWlnaHQ6IDEwcHg7XFxuICBiYWNrZ3JvdW5kOiAjZGVkZWRlOyAvKiBPbGQgYnJvd3NlcnMgKi9cXG4gIGJhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgI2RlZGVkZSAwJSwgI2M4YzhjOCA5OSUpOyAvKiBGRjMuNisgKi9cXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtZ3JhZGllbnQoXFxuICAgIGxpbmVhcixcXG4gICAgbGVmdCB0b3AsXFxuICAgIGxlZnQgYm90dG9tLFxcbiAgICBjb2xvci1zdG9wKDAlLCAjZGVkZWRlKSxcXG4gICAgY29sb3Itc3RvcCg5OSUsICNjOGM4YzgpXFxuICApOyAvKiBDaHJvbWUsU2FmYXJpNCsgKi9cXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICNkZWRlZGUgMCUsXFxuICAgICNjOGM4YzggOTklXFxuICApOyAvKiBDaHJvbWUxMCssU2FmYXJpNS4xKyAqL1xcbiAgYmFja2dyb3VuZDogLW8tbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICNkZWRlZGUgMCUsXFxuICAgICNjOGM4YzggOTklXFxuICApOyAvKiBPcGVyYSAxMS4xMCsgKi9cXG4gIGJhY2tncm91bmQ6IC1tcy1saW5lYXItZ3JhZGllbnQodG9wLCAjZGVkZWRlIDAlLCAjYzhjOGM4IDk5JSk7IC8qIElFMTArICovXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCAjZGVkZWRlIDAlLCAjYzhjOGM4IDk5JSk7IC8qIFczQyAqL1xcbiAgZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoIHN0YXJ0Q29sb3JzdHI9JyNkZWRlZGUnLCBlbmRDb2xvcnN0cj0nI2M4YzhjOCcsR3JhZGllbnRUeXBlPTAgKTsgLyogSUU2LTkgKi9cXG5cXG4gIGJvcmRlcjogMXB4IHNvbGlkICM5OTk5OTk7XFxuICBib3gtc2hhZG93OiAjYWFhYWFhIDBweCAwcHggM3B4IDBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG59XFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZTo6LW1vei1yYW5nZS10aHVtYiB7XFxuICBib3JkZXI6IG5vbmU7XFxuICBoZWlnaHQ6IDE2cHg7XFxuICB3aWR0aDogMTZweDtcXG5cXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIGJhY2tncm91bmQ6ICMzODUzODA7XFxufVxcblxcbi8qaGlkZSB0aGUgb3V0bGluZSBiZWhpbmQgdGhlIGJvcmRlciovXFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZTotbW96LWZvY3VzcmluZyB7XFxuICBvdXRsaW5lOiAxcHggc29saWQgd2hpdGU7XFxuICBvdXRsaW5lLW9mZnNldDogLTFweDtcXG59XFxuXFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZTo6LW1zLXRyYWNrIHtcXG4gIHdpZHRoOiAzMDBweDtcXG4gIGhlaWdodDogNXB4O1xcblxcbiAgLypyZW1vdmUgYmcgY29sb3VyIGZyb20gdGhlIHRyYWNrLCB3ZSdsbCB1c2UgbXMtZmlsbC1sb3dlciBhbmQgbXMtZmlsbC11cHBlciBpbnN0ZWFkICovXFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG5cXG4gIC8qbGVhdmUgcm9vbSBmb3IgdGhlIGxhcmdlciB0aHVtYiB0byBvdmVyZmxvdyB3aXRoIGEgdHJhbnNwYXJlbnQgYm9yZGVyICovXFxuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXdpZHRoOiA2cHggMDtcXG5cXG4gIC8qcmVtb3ZlIGRlZmF1bHQgdGljayBtYXJrcyovXFxuICBjb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcbmlucHV0LnZpcy1jb25maWd1cmF0aW9uLnZpcy1jb25maWctcmFuZ2U6Oi1tcy1maWxsLWxvd2VyIHtcXG4gIGJhY2tncm91bmQ6ICM3Nzc7XFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbn1cXG5pbnB1dC52aXMtY29uZmlndXJhdGlvbi52aXMtY29uZmlnLXJhbmdlOjotbXMtZmlsbC11cHBlciB7XFxuICBiYWNrZ3JvdW5kOiAjZGRkO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG59XFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZTo6LW1zLXRodW1iIHtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGhlaWdodDogMTZweDtcXG4gIHdpZHRoOiAxNnB4O1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgYmFja2dyb3VuZDogIzM4NTM4MDtcXG59XFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZTpmb2N1czo6LW1zLWZpbGwtbG93ZXIge1xcbiAgYmFja2dyb3VuZDogIzg4ODtcXG59XFxuaW5wdXQudmlzLWNvbmZpZ3VyYXRpb24udmlzLWNvbmZpZy1yYW5nZTpmb2N1czo6LW1zLWZpbGwtdXBwZXIge1xcbiAgYmFja2dyb3VuZDogI2NjYztcXG59XFxuXFxuLnZpcy1jb25maWd1cmF0aW9uLXBvcHVwIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJhY2tncm91bmQ6IHJnYmEoNTcsIDc2LCA4OSwgMC44NSk7XFxuICBib3JkZXI6IDJweCBzb2xpZCAjZjJmYWZmO1xcbiAgbGluZS1oZWlnaHQ6IDMwcHg7XFxuICBoZWlnaHQ6IDMwcHg7XFxuICB3aWR0aDogMTUwcHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBjb2xvcjogI2ZmZmZmZjtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzIGVhc2UtaW4tb3V0O1xcbiAgLW1vei10cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MgZWFzZS1pbi1vdXQ7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MgZWFzZS1pbi1vdXQ7XFxufVxcbi52aXMtY29uZmlndXJhdGlvbi1wb3B1cDphZnRlcixcXG4udmlzLWNvbmZpZ3VyYXRpb24tcG9wdXA6YmVmb3JlIHtcXG4gIGxlZnQ6IDEwMCU7XFxuICB0b3A6IDUwJTtcXG4gIGJvcmRlcjogc29saWQgdHJhbnNwYXJlbnQ7XFxuICBjb250ZW50OiBcXFwiIFxcXCI7XFxuICBoZWlnaHQ6IDA7XFxuICB3aWR0aDogMDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4udmlzLWNvbmZpZ3VyYXRpb24tcG9wdXA6YWZ0ZXIge1xcbiAgYm9yZGVyLWNvbG9yOiByZ2JhKDEzNiwgMTgzLCAyMTMsIDApO1xcbiAgYm9yZGVyLWxlZnQtY29sb3I6IHJnYmEoNTcsIDc2LCA4OSwgMC44NSk7XFxuICBib3JkZXItd2lkdGg6IDhweDtcXG4gIG1hcmdpbi10b3A6IC04cHg7XFxufVxcbi52aXMtY29uZmlndXJhdGlvbi1wb3B1cDpiZWZvcmUge1xcbiAgYm9yZGVyLWNvbG9yOiByZ2JhKDE5NCwgMjI1LCAyNDUsIDApO1xcbiAgYm9yZGVyLWxlZnQtY29sb3I6ICNmMmZhZmY7XFxuICBib3JkZXItd2lkdGg6IDEycHg7XFxuICBtYXJnaW4tdG9wOiAtMTJweDtcXG59XFxuXCI7XG5zdHlsZUluamVjdChjc3NfMjQ4eiQzKTtcblxudmFyIGNzc18yNDh6JDIgPSBcImRpdi52aXMtdG9vbHRpcCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICBwYWRkaW5nOiA1cHg7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcblxcbiAgZm9udC1mYW1pbHk6IHZlcmRhbmE7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBjb2xvcjogIzAwMDAwMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmNWY0ZWQ7XFxuXFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDNweDtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzgwODA3NDtcXG5cXG4gIGJveC1zaGFkb3c6IDNweCAzcHggMTBweCByZ2JhKDAsIDAsIDAsIDAuMik7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG5cXG4gIHotaW5kZXg6IDU7XFxufVxcblwiO1xuc3R5bGVJbmplY3QoY3NzXzI0OHokMik7XG5cbnZhciBjb21wb25lbnRFbWl0dGVyID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgLyoqXHJcbiAgICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICAgKi9cbiAge1xuICAgIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcbiAgfVxuICAvKipcclxuICAgKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICAgKlxyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICAgIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xuICB9XG4gIC8qKlxyXG4gICAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqIEBhcGkgcHJpdmF0ZVxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1peGluKG9iaikge1xuICAgIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgLyoqXHJcbiAgICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAgICogQHJldHVybiB7RW1pdHRlcn1cclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xuXG5cbiAgRW1pdHRlci5wcm90b3R5cGUub24gPSBFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pLnB1c2goZm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICAgKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXG5cblxuICBFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgb24uZm4gPSBmbjtcbiAgICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAgICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gICAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cblxuXG4gIEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307IC8vIGFsbFxuXG4gICAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIHNwZWNpZmljIGV2ZW50XG5cblxuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpczsgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuXG4gICAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG5cblxuICAgIHZhciBjYjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYiA9IGNhbGxiYWNrc1tpXTtcblxuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBSZW1vdmUgZXZlbnQgc3BlY2lmaWMgYXJyYXlzIGZvciBldmVudCB0eXBlcyB0aGF0IG5vXG4gICAgLy8gb25lIGlzIHN1YnNjcmliZWQgZm9yIHRvIGF2b2lkIG1lbW9yeSBsZWFrLlxuXG5cbiAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAgICogQHJldHVybiB7RW1pdHRlcn1cclxuICAgKi9cblxuXG4gIEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxuICAgICAgICBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xuXG5cbiAgRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xuICB9O1xuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXG5cblxuICBFbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gISF0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xuICB9O1xufSkoY29tcG9uZW50RW1pdHRlcik7XG5cbnZhciBFbWl0dGVyID0gY29tcG9uZW50RW1pdHRlci5leHBvcnRzO1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGggPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBUT19TVFJJTkdfVEFHJDMgPSB3ZWxsS25vd25TeW1ib2wkaCgndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0JDIgPSB7fTtcbnRlc3QkMltUT19TVFJJTkdfVEFHJDNdID0gJ3onO1xudmFyIHRvU3RyaW5nVGFnU3VwcG9ydCA9IFN0cmluZyh0ZXN0JDIpID09PSAnW29iamVjdCB6XSc7XG5cbnZhciBnbG9iYWwkdyA9IGdsb2JhbCRQO1xudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCQyID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xudmFyIGlzQ2FsbGFibGUkOSA9IGlzQ2FsbGFibGUkaDtcbnZhciBjbGFzc29mUmF3ID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCRnID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgVE9fU1RSSU5HX1RBRyQyID0gd2VsbEtub3duU3ltYm9sJGcoJ3RvU3RyaW5nVGFnJyk7XG52YXIgT2JqZWN0JDcgPSBnbG9iYWwkdy5PYmplY3Q7IC8vIEVTMyB3cm9uZyBoZXJlXG5cbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gYXJndW1lbnRzO1xufSgpKSA9PSAnQXJndW1lbnRzJzsgLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcblxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxufTsgLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxuXG5cbnZhciBjbGFzc29mJGUgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQkMiA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCcgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9IE9iamVjdCQ3KGl0KSwgVE9fU1RSSU5HX1RBRyQyKSkgPT0gJ3N0cmluZycgPyB0YWcgLy8gYnVpbHRpblRhZyBjYXNlXG4gIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgaXNDYWxsYWJsZSQ5KE8uY2FsbGVlKSA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcblxudmFyIGdsb2JhbCR2ID0gZ2xvYmFsJFA7XG52YXIgY2xhc3NvZiRkID0gY2xhc3NvZiRlO1xudmFyIFN0cmluZyQyID0gZ2xvYmFsJHYuU3RyaW5nO1xuXG52YXIgdG9TdHJpbmckOCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoY2xhc3NvZiRkKGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuIFN0cmluZyQyKGFyZ3VtZW50KTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRrID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b0ludGVnZXJPckluZmluaXR5JDEgPSB0b0ludGVnZXJPckluZmluaXR5JDQ7XG52YXIgdG9TdHJpbmckNyA9IHRvU3RyaW5nJDg7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1O1xudmFyIGNoYXJBdCQzID0gdW5jdXJyeVRoaXMkaygnJy5jaGFyQXQpO1xudmFyIGNoYXJDb2RlQXQkMSA9IHVuY3VycnlUaGlzJGsoJycuY2hhckNvZGVBdCk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcyRrKCcnLnNsaWNlKTtcblxudmFyIGNyZWF0ZU1ldGhvZCQ0ID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gdG9TdHJpbmckNyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIoJHRoaXMpKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXJPckluZmluaXR5JDEocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBjaGFyQ29kZUF0JDEoUywgcG9zaXRpb24pO1xuICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemUgfHwgKHNlY29uZCA9IGNoYXJDb2RlQXQkMShTLCBwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkYgPyBDT05WRVJUX1RPX1NUUklORyA/IGNoYXJBdCQzKFMsIHBvc2l0aW9uKSA6IGZpcnN0IDogQ09OVkVSVF9UT19TVFJJTkcgPyBzdHJpbmdTbGljZShTLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAyKSA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG52YXIgc3RyaW5nTXVsdGlieXRlID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZCQ0KGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuYXRgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kJDQodHJ1ZSlcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRqID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc0NhbGxhYmxlJDggPSBpc0NhbGxhYmxlJGg7XG52YXIgc3RvcmUkMSA9IHNoYXJlZFN0b3JlO1xudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyRqKEZ1bmN0aW9uLnRvU3RyaW5nKTsgLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGBjb3JlLWpzQDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuXG5pZiAoIWlzQ2FsbGFibGUkOChzdG9yZSQxLmluc3BlY3RTb3VyY2UpKSB7XG4gIHN0b3JlJDEuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcbiAgfTtcbn1cblxudmFyIGluc3BlY3RTb3VyY2UkMiA9IHN0b3JlJDEuaW5zcGVjdFNvdXJjZTtcblxudmFyIGdsb2JhbCR1ID0gZ2xvYmFsJFA7XG52YXIgaXNDYWxsYWJsZSQ3ID0gaXNDYWxsYWJsZSRoO1xudmFyIGluc3BlY3RTb3VyY2UkMSA9IGluc3BlY3RTb3VyY2UkMjtcbnZhciBXZWFrTWFwJDEgPSBnbG9iYWwkdS5XZWFrTWFwO1xudmFyIG5hdGl2ZVdlYWtNYXAgPSBpc0NhbGxhYmxlJDcoV2Vha01hcCQxKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZSQxKFdlYWtNYXAkMSkpO1xuXG52YXIgc2hhcmVkJDIgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIHVpZCQyID0gdWlkJDQ7XG52YXIga2V5cyQ3ID0gc2hhcmVkJDIoJ2tleXMnKTtcblxudmFyIHNoYXJlZEtleSQ0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5cyQ3W2tleV0gfHwgKGtleXMkN1trZXldID0gdWlkJDIoa2V5KSk7XG59O1xuXG52YXIgTkFUSVZFX1dFQUtfTUFQJDEgPSBuYXRpdmVXZWFrTWFwO1xudmFyIGdsb2JhbCR0ID0gZ2xvYmFsJFA7XG52YXIgdW5jdXJyeVRoaXMkaSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNPYmplY3QkZCA9IGlzT2JqZWN0JGo7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcbnZhciBoYXNPd24kYyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgc2hhcmVkJDEgPSBzaGFyZWRTdG9yZTtcbnZhciBzaGFyZWRLZXkkMyA9IHNoYXJlZEtleSQ0O1xudmFyIGhpZGRlbktleXMkNCA9IGhpZGRlbktleXMkNjtcbnZhciBPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCA9ICdPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCc7XG52YXIgVHlwZUVycm9yJGQgPSBnbG9iYWwkdC5UeXBlRXJyb3I7XG52YXIgV2Vha01hcCA9IGdsb2JhbCR0LldlYWtNYXA7XG52YXIgc2V0JDMsIGdldCQ2LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0JDYoaXQpIDogc2V0JDMoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuXG4gICAgaWYgKCFpc09iamVjdCRkKGl0KSB8fCAoc3RhdGUgPSBnZXQkNihpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvciRkKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVAkMSB8fCBzaGFyZWQkMS5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQkMS5zdGF0ZSB8fCAoc2hhcmVkJDEuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgdmFyIHdtZ2V0ID0gdW5jdXJyeVRoaXMkaShzdG9yZS5nZXQpO1xuICB2YXIgd21oYXMgPSB1bmN1cnJ5VGhpcyRpKHN0b3JlLmhhcyk7XG4gIHZhciB3bXNldCA9IHVuY3VycnlUaGlzJGkoc3RvcmUuc2V0KTtcblxuICBzZXQkMyA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvciRkKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG5cbiAgZ2V0JDYgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcblxuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSQzKCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzJDRbU1RBVEVdID0gdHJ1ZTtcblxuICBzZXQkMyA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoaGFzT3duJGMoaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvciRkKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNChpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG5cbiAgZ2V0JDYgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJGMoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuXG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24kYyhpdCwgU1RBVEUpO1xuICB9O1xufVxuXG52YXIgaW50ZXJuYWxTdGF0ZSA9IHtcbiAgc2V0OiBzZXQkMyxcbiAgZ2V0OiBnZXQkNixcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuXG52YXIgREVTQ1JJUFRPUlMkYiA9IGRlc2NyaXB0b3JzO1xudmFyIGhhc093biRiID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuXG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTJGIgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBFWElTVFMgPSBoYXNPd24kYihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKTsgLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xuXG52YXIgUFJPUEVSID0gRVhJU1RTICYmIGZ1bmN0aW9uIHNvbWV0aGluZygpIHtcbiAgLyogZW1wdHkgKi9cbn0ubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG5cbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyRiIHx8IERFU0NSSVBUT1JTJGIgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKS5jb25maWd1cmFibGUpO1xudmFyIGZ1bmN0aW9uTmFtZSA9IHtcbiAgRVhJU1RTOiBFWElTVFMsXG4gIFBST1BFUjogUFJPUEVSLFxuICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRVxufTtcblxudmFyIG9iamVjdERlZmluZVByb3BlcnRpZXMgPSB7fTtcblxudmFyIERFU0NSSVBUT1JTJGEgPSBkZXNjcmlwdG9ycztcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBhbk9iamVjdCRiID0gYW5PYmplY3QkZDtcbnZhciB0b0luZGV4ZWRPYmplY3QkNyA9IHRvSW5kZXhlZE9iamVjdCRiO1xudmFyIG9iamVjdEtleXMkMiA9IG9iamVjdEtleXMkNDsgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5cbm9iamVjdERlZmluZVByb3BlcnRpZXMuZiA9IERFU0NSSVBUT1JTJGEgJiYgIVY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QkYihPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0JDcoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyQyKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG5cbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzLmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgcHJvcHNba2V5XSk7XG5cbiAgcmV0dXJuIE87XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ2ID0gZ2V0QnVpbHRJbiQ5O1xudmFyIGh0bWwkMSA9IGdldEJ1aWx0SW4kNignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG52YXIgYW5PYmplY3QkYSA9IGFuT2JqZWN0JGQ7XG52YXIgZGVmaW5lUHJvcGVydGllc01vZHVsZSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbnZhciBlbnVtQnVnS2V5cyQxID0gZW51bUJ1Z0tleXMkMztcbnZhciBoaWRkZW5LZXlzJDMgPSBoaWRkZW5LZXlzJDY7XG52YXIgaHRtbCA9IGh0bWwkMTtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMTtcbnZhciBzaGFyZWRLZXkkMiA9IHNoYXJlZEtleSQ0O1xudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSQxID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8kMSA9IHNoYXJlZEtleSQyKCdJRV9QUk9UTycpO1xuXG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgLyogZW1wdHkgKi9cbn07XG5cbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTsgLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcblxuXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcblxuICByZXR1cm4gdGVtcDtcbn07IC8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcblxuXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcblxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07IC8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xuXG5cbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG5cbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLyogaWdub3JlICovXG4gIH1cblxuICBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5kb21haW4gJiYgYWN0aXZlWERvY3VtZW50ID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxuICA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpIDogTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcblxuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMkMS5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRSQxXVtlbnVtQnVnS2V5cyQxW2xlbmd0aF1dO1xuXG4gIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5cbmhpZGRlbktleXMkM1tJRV9QUk9UTyQxXSA9IHRydWU7IC8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuXG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEUkMV0gPSBhbk9iamVjdCRhKE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEUkMV0gPSBudWxsOyAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG5cbiAgICByZXN1bHRbSUVfUFJPVE8kMV0gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG5cbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXNNb2R1bGUkMS5mKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgZmFpbHMkayA9IGZhaWxzJHQ7XG52YXIgY29ycmVjdFByb3RvdHlwZUdldHRlciA9ICFmYWlscyRrKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG5cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxudmFyIGdsb2JhbCRzID0gZ2xvYmFsJFA7XG52YXIgaGFzT3duJGEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkaDtcbnZhciB0b09iamVjdCRiID0gdG9PYmplY3QkZTtcbnZhciBzaGFyZWRLZXkkMSA9IHNoYXJlZEtleSQ0O1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiQxID0gY29ycmVjdFByb3RvdHlwZUdldHRlcjtcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSQxKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdCQ2ID0gZ2xvYmFsJHMuT2JqZWN0O1xudmFyIE9iamVjdFByb3RvdHlwZSQyID0gT2JqZWN0JDYucHJvdG90eXBlOyAvLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG5cbnZhciBvYmplY3RHZXRQcm90b3R5cGVPZiA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiQxID8gT2JqZWN0JDYuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QkYihPKTtcbiAgaWYgKGhhc093biRhKG9iamVjdCwgSUVfUFJPVE8pKSByZXR1cm4gb2JqZWN0W0lFX1BST1RPXTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuXG4gIGlmIChpc0NhbGxhYmxlJDYoY29uc3RydWN0b3IpICYmIG9iamVjdCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBPYmplY3QkNiA/IE9iamVjdFByb3RvdHlwZSQyIDogbnVsbDtcbn07XG5cbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xuXG52YXIgcmVkZWZpbmUkNCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbnVtZXJhYmxlKSB0YXJnZXRba2V5XSA9IHZhbHVlO2Vsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDModGFyZ2V0LCBrZXksIHZhbHVlKTtcbn07XG5cbnZhciBmYWlscyRqID0gZmFpbHMkdDtcbnZhciBpc0NhbGxhYmxlJDUgPSBpc0NhbGxhYmxlJGg7XG52YXIgY3JlYXRlJGEgPSBvYmplY3RDcmVhdGU7XG52YXIgZ2V0UHJvdG90eXBlT2YkOCA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIHJlZGVmaW5lJDMgPSByZWRlZmluZSQ0O1xudmFyIHdlbGxLbm93blN5bWJvbCRmID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgSVRFUkFUT1IkNiA9IHdlbGxLbm93blN5bWJvbCRmKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSA9IGZhbHNlOyAvLyBgJUl0ZXJhdG9yUHJvdG90eXBlJWAgb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSQxLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7IC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuXG4gIGlmICghKCduZXh0JyBpbiBhcnJheUl0ZXJhdG9yKSkgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gdHJ1ZTtlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiQ4KGdldFByb3RvdHlwZU9mJDgoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSBJdGVyYXRvclByb3RvdHlwZSQxID09IHVuZGVmaW5lZCB8fCBmYWlscyRqKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTsgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG5cbiAgcmV0dXJuIEl0ZXJhdG9yUHJvdG90eXBlJDFbSVRFUkFUT1IkNl0uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcbn0pO1xuaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSB7fTtlbHNlIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSBjcmVhdGUkYShJdGVyYXRvclByb3RvdHlwZSQxKTsgLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtQEBpdGVyYXRvclxuXG5pZiAoIWlzQ2FsbGFibGUkNShJdGVyYXRvclByb3RvdHlwZSQxW0lURVJBVE9SJDZdKSkge1xuICByZWRlZmluZSQzKEl0ZXJhdG9yUHJvdG90eXBlJDEsIElURVJBVE9SJDYsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG59XG5cbnZhciBpdGVyYXRvcnNDb3JlID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUkMSxcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxXG59O1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUJDEgPSB0b1N0cmluZ1RhZ1N1cHBvcnQ7XG52YXIgY2xhc3NvZiRjID0gY2xhc3NvZiRlOyAvLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcblxudmFyIG9iamVjdFRvU3RyaW5nID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUJDEgPyB7fS50b1N0cmluZyA6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YkYyh0aGlzKSArICddJztcbn07XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSB0b1N0cmluZ1RhZ1N1cHBvcnQ7XG52YXIgZGVmaW5lUHJvcGVydHkkYyA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcbnZhciBoYXNPd24kOSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdG9TdHJpbmckNiA9IG9iamVjdFRvU3RyaW5nO1xudmFyIHdlbGxLbm93blN5bWJvbCRlID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgVE9fU1RSSU5HX1RBRyQxID0gd2VsbEtub3duU3ltYm9sJGUoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBzZXRUb1N0cmluZ1RhZyQ1ID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQywgU0VUX01FVEhPRCkge1xuICBpZiAoaXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gU1RBVElDID8gaXQgOiBpdC5wcm90b3R5cGU7XG5cbiAgICBpZiAoIWhhc093biQ5KHRhcmdldCwgVE9fU1RSSU5HX1RBRyQxKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkkYyh0YXJnZXQsIFRPX1NUUklOR19UQUckMSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBUQUdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChTRVRfTUVUSE9EICYmICFUT19TVFJJTkdfVEFHX1NVUFBPUlQpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyKHRhcmdldCwgJ3RvU3RyaW5nJywgdG9TdHJpbmckNik7XG4gICAgfVxuICB9XG59O1xuXG52YXIgaXRlcmF0b3JzID0ge307XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IGl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlJDkgPSBvYmplY3RDcmVhdGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciBzZXRUb1N0cmluZ1RhZyQ0ID0gc2V0VG9TdHJpbmdUYWckNTtcbnZhciBJdGVyYXRvcnMkNSA9IGl0ZXJhdG9ycztcblxudmFyIHJldHVyblRoaXMkMSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIEVOVU1FUkFCTEVfTkVYVCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUkOShJdGVyYXRvclByb3RvdHlwZSwge1xuICAgIG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyKCshRU5VTUVSQUJMRV9ORVhULCBuZXh0KVxuICB9KTtcbiAgc2V0VG9TdHJpbmdUYWckNChJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSwgdHJ1ZSk7XG4gIEl0ZXJhdG9ycyQ1W1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcyQxO1xuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3Rvcjtcbn07XG5cbnZhciBnbG9iYWwkciA9IGdsb2JhbCRQO1xudmFyIGlzQ2FsbGFibGUkNCA9IGlzQ2FsbGFibGUkaDtcbnZhciBTdHJpbmckMSA9IGdsb2JhbCRyLlN0cmluZztcbnZhciBUeXBlRXJyb3IkYyA9IGdsb2JhbCRyLlR5cGVFcnJvcjtcblxudmFyIGFQb3NzaWJsZVByb3RvdHlwZSQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnQgPT0gJ29iamVjdCcgfHwgaXNDYWxsYWJsZSQ0KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBUeXBlRXJyb3IkYyhcIkNhbid0IHNldCBcIiArIFN0cmluZyQxKGFyZ3VtZW50KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cbnZhciB1bmN1cnJ5VGhpcyRoID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhbk9iamVjdCQ5ID0gYW5PYmplY3QkZDtcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSBhUG9zc2libGVQcm90b3R5cGUkMTsgLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LXNldHByb3RvdHlwZW9mIC0tIHNhZmVcblxudmFyIG9iamVjdFNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG5cbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gICAgc2V0dGVyID0gdW5jdXJyeVRoaXMkaChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQpO1xuICAgIHNldHRlcih0ZXN0LCBbXSk7XG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIGFuT2JqZWN0JDkoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlcihPLCBwcm90byk7ZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcblxudmFyICQkSCA9IF9leHBvcnQ7XG52YXIgY2FsbCQ2ID0gZnVuY3Rpb25DYWxsO1xudmFyIEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxO1xudmFyIGdldFByb3RvdHlwZU9mJDcgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBzZXRUb1N0cmluZ1RhZyQzID0gc2V0VG9TdHJpbmdUYWckNTtcbnZhciByZWRlZmluZSQyID0gcmVkZWZpbmUkNDtcbnZhciB3ZWxsS25vd25TeW1ib2wkZCA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIEl0ZXJhdG9ycyQ0ID0gaXRlcmF0b3JzO1xudmFyIEl0ZXJhdG9yc0NvcmUgPSBpdGVyYXRvcnNDb3JlO1xudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FJDEgPSBGdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgSVRFUkFUT1IkNSA9IHdlbGxLbm93blN5bWJvbCRkKCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIGRlZmluZUl0ZXJhdG9yJDMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG5cbiAgICBzd2l0Y2ggKEtJTkQpIHtcbiAgICAgIGNhc2UgS0VZUzpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpO1xuICAgICAgICB9O1xuXG4gICAgICBjYXNlIFZBTFVFUzpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7XG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgRU5UUklFUzpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDVdIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ10gfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcbiAgdmFyIGRlZmF1bHRJdGVyYXRvciA9ICFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcbiAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7IC8vIGZpeCBuYXRpdmVcblxuICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcbiAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiQ3KGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcblxuICAgIGlmIChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcblxuXG4gICAgICBzZXRUb1N0cmluZ1RhZyQzKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBJdGVyYXRvcnMkNFtUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gICAgfVxuICB9IC8vIGZpeCBBcnJheS5wcm90b3R5cGUueyB2YWx1ZXMsIEBAaXRlcmF0b3IgfS5uYW1lIGluIFY4IC8gRkZcblxuXG4gIGlmIChQUk9QRVJfRlVOQ1RJT05fTkFNRSQxICYmIERFRkFVTFQgPT0gVkFMVUVTICYmIG5hdGl2ZUl0ZXJhdG9yICYmIG5hdGl2ZUl0ZXJhdG9yLm5hbWUgIT09IFZBTFVFUykge1xuICAgIHtcbiAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG5cbiAgICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIGNhbGwkNihuYXRpdmVJdGVyYXRvciwgdGhpcyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG5cblxuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgIHJlZGVmaW5lJDIoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJCRIKHtcbiAgICAgIHRhcmdldDogTkFNRSxcbiAgICAgIHByb3RvOiB0cnVlLFxuICAgICAgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRVxuICAgIH0sIG1ldGhvZHMpO1xuICB9IC8vIGRlZmluZSBpdGVyYXRvclxuXG5cbiAgaWYgKChGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDVdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcbiAgICByZWRlZmluZSQyKEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiQ1LCBkZWZhdWx0SXRlcmF0b3IsIHtcbiAgICAgIG5hbWU6IERFRkFVTFRcbiAgICB9KTtcbiAgfVxuXG4gIEl0ZXJhdG9ycyQ0W05BTUVdID0gZGVmYXVsdEl0ZXJhdG9yO1xuICByZXR1cm4gbWV0aG9kcztcbn07XG5cbnZhciBjaGFyQXQkMiA9IHN0cmluZ011bHRpYnl0ZS5jaGFyQXQ7XG52YXIgdG9TdHJpbmckNSA9IHRvU3RyaW5nJDg7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1ID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBkZWZpbmVJdGVyYXRvciQyID0gZGVmaW5lSXRlcmF0b3IkMztcbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUkMiA9IEludGVybmFsU3RhdGVNb2R1bGUkNS5nZXR0ZXJGb3IoU1RSSU5HX0lURVJBVE9SKTsgLy8gYFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLUBAaXRlcmF0b3JcblxuZGVmaW5lSXRlcmF0b3IkMihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQ1KHRoaXMsIHtcbiAgICB0eXBlOiBTVFJJTkdfSVRFUkFUT1IsXG4gICAgc3RyaW5nOiB0b1N0cmluZyQ1KGl0ZXJhdGVkKSxcbiAgICBpbmRleDogMFxuICB9KTsgLy8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDIodGhpcyk7XG4gIHZhciBzdHJpbmcgPSBzdGF0ZS5zdHJpbmc7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4O1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBzdHJpbmcubGVuZ3RoKSByZXR1cm4ge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgZG9uZTogdHJ1ZVxuICB9O1xuICBwb2ludCA9IGNoYXJBdCQyKHN0cmluZywgaW5kZXgpO1xuICBzdGF0ZS5pbmRleCArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHBvaW50LFxuICAgIGRvbmU6IGZhbHNlXG4gIH07XG59KTtcblxudmFyIGNhbGwkNSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhbk9iamVjdCQ4ID0gYW5PYmplY3QkZDtcbnZhciBnZXRNZXRob2QkMSA9IGdldE1ldGhvZCQzO1xuXG52YXIgaXRlcmF0b3JDbG9zZSQyID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBraW5kLCB2YWx1ZSkge1xuICB2YXIgaW5uZXJSZXN1bHQsIGlubmVyRXJyb3I7XG4gIGFuT2JqZWN0JDgoaXRlcmF0b3IpO1xuXG4gIHRyeSB7XG4gICAgaW5uZXJSZXN1bHQgPSBnZXRNZXRob2QkMShpdGVyYXRvciwgJ3JldHVybicpO1xuXG4gICAgaWYgKCFpbm5lclJlc3VsdCkge1xuICAgICAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlubmVyUmVzdWx0ID0gY2FsbCQ1KGlubmVyUmVzdWx0LCBpdGVyYXRvcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW5uZXJFcnJvciA9IHRydWU7XG4gICAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiAgfVxuXG4gIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgaWYgKGlubmVyRXJyb3IpIHRocm93IGlubmVyUmVzdWx0O1xuICBhbk9iamVjdCQ4KGlubmVyUmVzdWx0KTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGFuT2JqZWN0JDcgPSBhbk9iamVjdCRkO1xudmFyIGl0ZXJhdG9yQ2xvc2UkMSA9IGl0ZXJhdG9yQ2xvc2UkMjsgLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxuXG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyQxID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0JDcodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaXRlcmF0b3JDbG9zZSQxKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gIH1cbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkYyA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIEl0ZXJhdG9ycyQzID0gaXRlcmF0b3JzO1xudmFyIElURVJBVE9SJDQgPSB3ZWxsS25vd25TeW1ib2wkYygnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvdHlwZSRpID0gQXJyYXkucHJvdG90eXBlOyAvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG5cbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzJDMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlJGlbSVRFUkFUT1IkNF0gPT09IGl0KTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRnID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyRpID0gZmFpbHMkdDtcbnZhciBpc0NhbGxhYmxlJDMgPSBpc0NhbGxhYmxlJGg7XG52YXIgY2xhc3NvZiRiID0gY2xhc3NvZiRlO1xudmFyIGdldEJ1aWx0SW4kNSA9IGdldEJ1aWx0SW4kOTtcbnZhciBpbnNwZWN0U291cmNlID0gaW5zcGVjdFNvdXJjZSQyO1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgLyogZW1wdHkgKi9cbn07XG5cbnZhciBlbXB0eSA9IFtdO1xudmFyIGNvbnN0cnVjdCQzID0gZ2V0QnVpbHRJbiQ1KCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xudmFyIGNvbnN0cnVjdG9yUmVnRXhwID0gL15cXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxiLztcbnZhciBleGVjJDIgPSB1bmN1cnJ5VGhpcyRnKGNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMpO1xudmFyIElOQ09SUkVDVF9UT19TVFJJTkcgPSAhY29uc3RydWN0b3JSZWdFeHAuZXhlYyhub29wKTtcblxudmFyIGlzQ29uc3RydWN0b3JNb2Rlcm4gPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZSQzKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgY29uc3RydWN0JDMobm9vcCwgZW1wdHksIGFyZ3VtZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBpc0NvbnN0cnVjdG9yTGVnYWN5ID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUkMyhhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKGNsYXNzb2YkYihhcmd1bWVudCkpIHtcbiAgICBjYXNlICdBc3luY0Z1bmN0aW9uJzpcbiAgICBjYXNlICdHZW5lcmF0b3JGdW5jdGlvbic6XG4gICAgY2FzZSAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbic6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIHdlIGNhbid0IGNoZWNrIC5wcm90b3R5cGUgc2luY2UgY29uc3RydWN0b3JzIHByb2R1Y2VkIGJ5IC5iaW5kIGhhdmVuJ3QgaXRcbiAgICAvLyBgRnVuY3Rpb24jdG9TdHJpbmdgIHRocm93cyBvbiBzb21lIGJ1aWx0LWl0IGZ1bmN0aW9uIGluIHNvbWUgbGVnYWN5IGVuZ2luZXNcbiAgICAvLyAoZm9yIGV4YW1wbGUsIGBET01RdWFkYCBhbmQgc2ltaWxhciBpbiBGRjQxLSlcbiAgICByZXR1cm4gSU5DT1JSRUNUX1RPX1NUUklORyB8fCAhIWV4ZWMkMihjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZShhcmd1bWVudCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5pc0NvbnN0cnVjdG9yTGVnYWN5LnNoYW0gPSB0cnVlOyAvLyBgSXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3JcblxudmFyIGlzQ29uc3RydWN0b3IkNCA9ICFjb25zdHJ1Y3QkMyB8fCBmYWlscyRpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxlZDtcbiAgcmV0dXJuIGlzQ29uc3RydWN0b3JNb2Rlcm4oaXNDb25zdHJ1Y3Rvck1vZGVybi5jYWxsKSB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihPYmplY3QpIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsZWQgPSB0cnVlO1xuICB9KSB8fCBjYWxsZWQ7XG59KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuO1xuXG52YXIgdG9Qcm9wZXJ0eUtleSQxID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xuXG52YXIgY3JlYXRlUHJvcGVydHkkNiA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQxKGtleSk7XG4gIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIGRlZmluZVByb3BlcnR5TW9kdWxlJDIuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSgwLCB2YWx1ZSkpO2Vsc2Ugb2JqZWN0W3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xufTtcblxudmFyIGNsYXNzb2YkYSA9IGNsYXNzb2YkZTtcbnZhciBnZXRNZXRob2QgPSBnZXRNZXRob2QkMztcbnZhciBJdGVyYXRvcnMkMiA9IGl0ZXJhdG9ycztcbnZhciB3ZWxsS25vd25TeW1ib2wkYiA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIElURVJBVE9SJDMgPSB3ZWxsS25vd25TeW1ib2wkYignaXRlcmF0b3InKTtcblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDggPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGdldE1ldGhvZChpdCwgSVRFUkFUT1IkMykgfHwgZ2V0TWV0aG9kKGl0LCAnQEBpdGVyYXRvcicpIHx8IEl0ZXJhdG9ycyQyW2NsYXNzb2YkYShpdCldO1xufTtcblxudmFyIGdsb2JhbCRxID0gZ2xvYmFsJFA7XG52YXIgY2FsbCQ0ID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDYWxsYWJsZSQzID0gYUNhbGxhYmxlJDc7XG52YXIgYW5PYmplY3QkNiA9IGFuT2JqZWN0JGQ7XG52YXIgdHJ5VG9TdHJpbmckMiA9IHRyeVRvU3RyaW5nJDQ7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkNyA9IGdldEl0ZXJhdG9yTWV0aG9kJDg7XG52YXIgVHlwZUVycm9yJGIgPSBnbG9iYWwkcS5UeXBlRXJyb3I7XG5cbnZhciBnZXRJdGVyYXRvciQ3ID0gZnVuY3Rpb24gKGFyZ3VtZW50LCB1c2luZ0l0ZXJhdG9yKSB7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZ2V0SXRlcmF0b3JNZXRob2QkNyhhcmd1bWVudCkgOiB1c2luZ0l0ZXJhdG9yO1xuICBpZiAoYUNhbGxhYmxlJDMoaXRlcmF0b3JNZXRob2QpKSByZXR1cm4gYW5PYmplY3QkNihjYWxsJDQoaXRlcmF0b3JNZXRob2QsIGFyZ3VtZW50KSk7XG4gIHRocm93IFR5cGVFcnJvciRiKHRyeVRvU3RyaW5nJDIoYXJndW1lbnQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbn07XG5cbnZhciBnbG9iYWwkcCA9IGdsb2JhbCRQO1xudmFyIGJpbmQkNSA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgY2FsbCQzID0gZnVuY3Rpb25DYWxsO1xudmFyIHRvT2JqZWN0JGEgPSB0b09iamVjdCRlO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nJDE7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDEgPSBpc0FycmF5SXRlcmF0b3JNZXRob2QkMjtcbnZhciBpc0NvbnN0cnVjdG9yJDMgPSBpc0NvbnN0cnVjdG9yJDQ7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkYiA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG52YXIgY3JlYXRlUHJvcGVydHkkNSA9IGNyZWF0ZVByb3BlcnR5JDY7XG52YXIgZ2V0SXRlcmF0b3IkNiA9IGdldEl0ZXJhdG9yJDc7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkNiA9IGdldEl0ZXJhdG9yTWV0aG9kJDg7XG52YXIgQXJyYXkkNSA9IGdsb2JhbCRwLkFycmF5OyAvLyBgQXJyYXkuZnJvbWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cblxudmFyIGFycmF5RnJvbSA9IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlXG4vKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovXG4pIHtcbiAgdmFyIE8gPSB0b09iamVjdCRhKGFycmF5TGlrZSk7XG4gIHZhciBJU19DT05TVFJVQ1RPUiA9IGlzQ29uc3RydWN0b3IkMyh0aGlzKTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBtYXBmbiA9IGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgaWYgKG1hcHBpbmcpIG1hcGZuID0gYmluZCQ1KG1hcGZuLCBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QkNihPKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvciwgbmV4dCwgdmFsdWU7IC8vIGlmIHRoZSB0YXJnZXQgaXMgbm90IGl0ZXJhYmxlIG9yIGl0J3MgYW4gYXJyYXkgd2l0aCB0aGUgZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBhIHNpbXBsZSBjYXNlXG5cbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICYmICEodGhpcyA9PSBBcnJheSQ1ICYmIGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxKGl0ZXJhdG9yTWV0aG9kKSkpIHtcbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yJDYoTywgaXRlcmF0b3JNZXRob2QpO1xuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgIHJlc3VsdCA9IElTX0NPTlNUUlVDVE9SID8gbmV3IHRoaXMoKSA6IFtdO1xuXG4gICAgZm9yICg7ICEoc3RlcCA9IGNhbGwkMyhuZXh0LCBpdGVyYXRvcikpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgIHZhbHVlID0gbWFwcGluZyA/IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWU7XG4gICAgICBjcmVhdGVQcm9wZXJ0eSQ1KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkYihPKTtcbiAgICByZXN1bHQgPSBJU19DT05TVFJVQ1RPUiA/IG5ldyB0aGlzKGxlbmd0aCkgOiBBcnJheSQ1KGxlbmd0aCk7XG5cbiAgICBmb3IgKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIHZhbHVlID0gbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5JDUocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkYSA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIElURVJBVE9SJDIgPSB3ZWxsS25vd25TeW1ib2wkYSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogISFjYWxsZWQrK1xuICAgICAgfTtcbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBpdGVyYXRvcldpdGhSZXR1cm5bSVRFUkFUT1IkMl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1mcm9tLCBuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cblxuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkge1xuICAgIHRocm93IDI7XG4gIH0pO1xufSBjYXRjaCAoZXJyb3IpIHtcbiAgLyogZW1wdHkgKi9cbn1cblxudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuXG4gICAgb2JqZWN0W0lURVJBVE9SJDJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuXG4gIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcbn07XG5cbnZhciAkJEcgPSBfZXhwb3J0O1xudmFyIGZyb20kNiA9IGFycmF5RnJvbTtcbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMTtcbnZhciBJTkNPUlJFQ1RfSVRFUkFUSU9OID0gIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWZyb20gLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgQXJyYXkuZnJvbShpdGVyYWJsZSk7XG59KTsgLy8gYEFycmF5LmZyb21gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5mcm9tXG5cbiQkRyh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiBJTkNPUlJFQ1RfSVRFUkFUSU9OXG59LCB7XG4gIGZyb206IGZyb20kNlxufSk7XG5cbnZhciBwYXRoJHQgPSBwYXRoJHk7XG52YXIgZnJvbSQ1ID0gcGF0aCR0LkFycmF5LmZyb207XG5cbnZhciBwYXJlbnQkMTggPSBmcm9tJDU7XG52YXIgZnJvbSQ0ID0gcGFyZW50JDE4O1xuXG52YXIgZnJvbSQzID0gZnJvbSQ0O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDYgPSB0b0luZGV4ZWRPYmplY3QkYjtcbnZhciBJdGVyYXRvcnMkMSA9IGl0ZXJhdG9ycztcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDQgPSBpbnRlcm5hbFN0YXRlO1xub2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBkZWZpbmVJdGVyYXRvciQxID0gZGVmaW5lSXRlcmF0b3IkMztcbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQ0ID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0LnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDQuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTsgLy8gYEFycmF5LnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmVudHJpZXNcbi8vIGBBcnJheS5wcm90b3R5cGUua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5rZXlzXG4vLyBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS52YWx1ZXNcbi8vIGBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEBpdGVyYXRvclxuLy8gYENyZWF0ZUFycmF5SXRlcmF0b3JgIGludGVybmFsIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVhcnJheWl0ZXJhdG9yXG5cbmRlZmluZUl0ZXJhdG9yJDEoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlJDQodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0JDYoaXRlcmF0ZWQpLFxuICAgIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLFxuICAgIC8vIG5leHQgaW5kZXhcbiAgICBraW5kOiBraW5kIC8vIGtpbmRcblxuICB9KTsgLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDEodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcblxuICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgZG9uZTogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7XG4gICAgdmFsdWU6IGluZGV4LFxuICAgIGRvbmU6IGZhbHNlXG4gIH07XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4ge1xuICAgIHZhbHVlOiB0YXJnZXRbaW5kZXhdLFxuICAgIGRvbmU6IGZhbHNlXG4gIH07XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sXG4gICAgZG9uZTogZmFsc2VcbiAgfTtcbn0sICd2YWx1ZXMnKTsgLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxuXG5JdGVyYXRvcnMkMS5Bcmd1bWVudHMgPSBJdGVyYXRvcnMkMS5BcnJheTsgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkNSA9IGdldEl0ZXJhdG9yTWV0aG9kJDg7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2RfMSA9IGdldEl0ZXJhdG9yTWV0aG9kJDU7XG5cbi8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcblxudmFyIGRvbUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IDAsXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gIENTU1ZhbHVlTGlzdDogMCxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gIERPTVJlY3RMaXN0OiAwLFxuICBET01TdHJpbmdMaXN0OiAwLFxuICBET01Ub2tlbkxpc3Q6IDEsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuICBGaWxlTGlzdDogMCxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gIEhUTUxDb2xsZWN0aW9uOiAwLFxuICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICBNZWRpYUxpc3Q6IDAsXG4gIE1pbWVUeXBlQXJyYXk6IDAsXG4gIE5hbWVkTm9kZU1hcDogMCxcbiAgTm9kZUxpc3Q6IDEsXG4gIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gIFBsdWdpbjogMCxcbiAgUGx1Z2luQXJyYXk6IDAsXG4gIFNWR0xlbmd0aExpc3Q6IDAsXG4gIFNWR051bWJlckxpc3Q6IDAsXG4gIFNWR1BhdGhTZWdMaXN0OiAwLFxuICBTVkdQb2ludExpc3Q6IDAsXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxuICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuICBUZXh0VHJhY2tMaXN0OiAwLFxuICBUb3VjaExpc3Q6IDBcbn07XG5cbnZhciBET01JdGVyYWJsZXMkNCA9IGRvbUl0ZXJhYmxlcztcbnZhciBnbG9iYWwkbyA9IGdsb2JhbCRQO1xudmFyIGNsYXNzb2YkOSA9IGNsYXNzb2YkZTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xudmFyIEl0ZXJhdG9ycyA9IGl0ZXJhdG9ycztcbnZhciB3ZWxsS25vd25TeW1ib2wkOSA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2wkOSgndG9TdHJpbmdUYWcnKTtcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcyQ0KSB7XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsJG9bQ09MTEVDVElPTl9OQU1FXTtcbiAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuXG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlICYmIGNsYXNzb2YkOShDb2xsZWN0aW9uUHJvdG90eXBlKSAhPT0gVE9fU1RSSU5HX1RBRykge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKENvbGxlY3Rpb25Qcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIENPTExFQ1RJT05fTkFNRSk7XG4gIH1cblxuICBJdGVyYXRvcnNbQ09MTEVDVElPTl9OQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn1cblxudmFyIHBhcmVudCQxNyA9IGdldEl0ZXJhdG9yTWV0aG9kXzE7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkNCA9IHBhcmVudCQxNztcblxudmFyIHBhcmVudCQxNiA9IGdldEl0ZXJhdG9yTWV0aG9kJDQ7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMyA9IHBhcmVudCQxNjtcblxudmFyIHBhcmVudCQxNSA9IGdldEl0ZXJhdG9yTWV0aG9kJDM7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMiA9IHBhcmVudCQxNTtcblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDEgPSBnZXRJdGVyYXRvck1ldGhvZCQyO1xuXG52YXIgY2xhc3NvZiQ4ID0gY2xhc3NvZlJhdyQxOyAvLyBgSXNBcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1pc2FycmF5IC0tIHNhZmVcblxudmFyIGlzQXJyYXkkZCA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmd1bWVudCkge1xuICByZXR1cm4gY2xhc3NvZiQ4KGFyZ3VtZW50KSA9PSAnQXJyYXknO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5TmFtZXMgPSB7fTtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IG9iamVjdEtleXNJbnRlcm5hbDtcbnZhciBlbnVtQnVnS2V5cyA9IGVudW1CdWdLZXlzJDM7XG52YXIgaGlkZGVuS2V5cyQyID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7IC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxuXG5vYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzJDIpO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbCA9IHt9O1xuXG52YXIgZ2xvYmFsJG4gPSBnbG9iYWwkUDtcbnZhciB0b0Fic29sdXRlSW5kZXgkMyA9IHRvQWJzb2x1dGVJbmRleCQ1O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJGEgPSBsZW5ndGhPZkFycmF5TGlrZSRkO1xudmFyIGNyZWF0ZVByb3BlcnR5JDQgPSBjcmVhdGVQcm9wZXJ0eSQ2O1xudmFyIEFycmF5JDQgPSBnbG9iYWwkbi5BcnJheTtcbnZhciBtYXgkMiA9IE1hdGgubWF4O1xuXG52YXIgYXJyYXlTbGljZVNpbXBsZSA9IGZ1bmN0aW9uIChPLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSRhKE8pO1xuICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleCQzKHN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4JDMoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gIHZhciByZXN1bHQgPSBBcnJheSQ0KG1heCQyKGZpbiAtIGssIDApKTtcblxuICBmb3IgKHZhciBuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGNyZWF0ZVByb3BlcnR5JDQocmVzdWx0LCBuLCBPW2tdKTtcblxuICByZXN1bHQubGVuZ3RoID0gbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmUgKi9cbnZhciBjbGFzc29mJDcgPSBjbGFzc29mUmF3JDE7XG52YXIgdG9JbmRleGVkT2JqZWN0JDUgPSB0b0luZGV4ZWRPYmplY3QkYjtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mO1xudmFyIGFycmF5U2xpY2UkMyA9IGFycmF5U2xpY2VTaW1wbGU7XG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eU5hbWVzJDEoaXQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBhcnJheVNsaWNlJDMod2luZG93TmFtZXMpO1xuICB9XG59OyAvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG5cblxub2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiBjbGFzc29mJDcoaXQpID09ICdXaW5kb3cnID8gZ2V0V2luZG93TmFtZXMoaXQpIDogJGdldE93blByb3BlcnR5TmFtZXMkMSh0b0luZGV4ZWRPYmplY3QkNShpdCkpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbFdyYXBwZWQgPSB7fTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ4ID0gd2VsbEtub3duU3ltYm9sJGo7XG53ZWxsS25vd25TeW1ib2xXcmFwcGVkLmYgPSB3ZWxsS25vd25TeW1ib2wkODtcblxudmFyIHBhdGgkcyA9IHBhdGgkeTtcbnZhciBoYXNPd24kOCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSQxID0gd2VsbEtub3duU3ltYm9sV3JhcHBlZDtcbnZhciBkZWZpbmVQcm9wZXJ0eSRiID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRsID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgdmFyIFN5bWJvbCA9IHBhdGgkcy5TeW1ib2wgfHwgKHBhdGgkcy5TeW1ib2wgPSB7fSk7XG4gIGlmICghaGFzT3duJDgoU3ltYm9sLCBOQU1FKSkgZGVmaW5lUHJvcGVydHkkYihTeW1ib2wsIE5BTUUsIHtcbiAgICB2YWx1ZTogd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSQxLmYoTkFNRSlcbiAgfSk7XG59O1xuXG52YXIgZ2xvYmFsJG0gPSBnbG9iYWwkUDtcbnZhciBpc0FycmF5JGMgPSBpc0FycmF5JGQ7XG52YXIgaXNDb25zdHJ1Y3RvciQyID0gaXNDb25zdHJ1Y3RvciQ0O1xudmFyIGlzT2JqZWN0JGMgPSBpc09iamVjdCRqO1xudmFyIHdlbGxLbm93blN5bWJvbCQ3ID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgU1BFQ0lFUyQzID0gd2VsbEtub3duU3ltYm9sJDcoJ3NwZWNpZXMnKTtcbnZhciBBcnJheSQzID0gZ2xvYmFsJG0uQXJyYXk7IC8vIGEgcGFydCBvZiBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5cbnZhciBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXkpIHtcbiAgdmFyIEM7XG5cbiAgaWYgKGlzQXJyYXkkYyhvcmlnaW5hbEFycmF5KSkge1xuICAgIEMgPSBvcmlnaW5hbEFycmF5LmNvbnN0cnVjdG9yOyAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuXG4gICAgaWYgKGlzQ29uc3RydWN0b3IkMihDKSAmJiAoQyA9PT0gQXJyYXkkMyB8fCBpc0FycmF5JGMoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtlbHNlIGlmIChpc09iamVjdCRjKEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTJDNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5JDMgOiBDO1xufTtcblxudmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yID0gYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IkMTsgLy8gYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxuXG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlJDQgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKGFycmF5U3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsQXJyYXkpKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTtcbn07XG5cbnZhciBiaW5kJDQgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIHVuY3VycnlUaGlzJGYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIEluZGV4ZWRPYmplY3QkMSA9IGluZGV4ZWRPYmplY3Q7XG52YXIgdG9PYmplY3QkOSA9IHRvT2JqZWN0JGU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkOSA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlJDMgPSBhcnJheVNwZWNpZXNDcmVhdGUkNDtcbnZhciBwdXNoJDQgPSB1bmN1cnJ5VGhpcyRmKFtdLnB1c2gpOyAvLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXgsIGZpbHRlclJlamVjdCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cbnZhciBjcmVhdGVNZXRob2QkMyA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgSVNfRklMVEVSX1JFSkVDVCA9IFRZUEUgPT0gNztcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQsIHNwZWNpZmljQ3JlYXRlKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCQ5KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QkMShPKTtcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQkNChjYWxsYmFja2ZuLCB0aGF0KTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkOShzZWxmKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjcmVhdGUgPSBzcGVjaWZpY0NyZWF0ZSB8fCBhcnJheVNwZWNpZXNDcmVhdGUkMztcbiAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSIHx8IElTX0ZJTFRFUl9SRUpFQ1QgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSwgcmVzdWx0O1xuXG4gICAgZm9yICg7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcblxuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgdGFyZ2V0W2luZGV4XSA9IHJlc3VsdDsgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgLy8gc29tZVxuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIC8vIGZpbmRcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAvLyBmaW5kSW5kZXhcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHB1c2gkNCh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAvLyBldmVyeVxuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcHVzaCQ0KHRhcmdldCwgdmFsdWUpO1xuICAgICAgICAgIC8vIGZpbHRlclJlamVjdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHRhcmdldDtcbiAgfTtcbn07XG5cbnZhciBhcnJheUl0ZXJhdGlvbiA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuICBmb3JFYWNoOiBjcmVhdGVNZXRob2QkMygwKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbiAgbWFwOiBjcmVhdGVNZXRob2QkMygxKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgZmlsdGVyOiBjcmVhdGVNZXRob2QkMygyKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuICBzb21lOiBjcmVhdGVNZXRob2QkMygzKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG4gIGV2ZXJ5OiBjcmVhdGVNZXRob2QkMyg0KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICBmaW5kOiBjcmVhdGVNZXRob2QkMyg1KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcbiAgZmluZEluZGV4OiBjcmVhdGVNZXRob2QkMyg2KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJSZWplY3RgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hcnJheS1maWx0ZXJpbmdcbiAgZmlsdGVyUmVqZWN0OiBjcmVhdGVNZXRob2QkMyg3KVxufTtcblxudmFyICQkRiA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJGwgPSBnbG9iYWwkUDtcbnZhciBnZXRCdWlsdEluJDQgPSBnZXRCdWlsdEluJDk7XG52YXIgYXBwbHkkNCA9IGZ1bmN0aW9uQXBwbHk7XG52YXIgY2FsbCQyID0gZnVuY3Rpb25DYWxsO1xudmFyIHVuY3VycnlUaGlzJGUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIERFU0NSSVBUT1JTJDkgPSBkZXNjcmlwdG9ycztcbnZhciBOQVRJVkVfU1lNQk9MID0gbmF0aXZlU3ltYm9sO1xudmFyIGZhaWxzJGggPSBmYWlscyR0O1xudmFyIGhhc093biQ3ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc0FycmF5JGIgPSBpc0FycmF5JGQ7XG52YXIgaXNDYWxsYWJsZSQyID0gaXNDYWxsYWJsZSRoO1xudmFyIGlzT2JqZWN0JGIgPSBpc09iamVjdCRqO1xudmFyIGlzUHJvdG90eXBlT2YkayA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgaXNTeW1ib2wgPSBpc1N5bWJvbCQzO1xudmFyIGFuT2JqZWN0JDUgPSBhbk9iamVjdCRkO1xudmFyIHRvT2JqZWN0JDggPSB0b09iamVjdCRlO1xudmFyIHRvSW5kZXhlZE9iamVjdCQ0ID0gdG9JbmRleGVkT2JqZWN0JGI7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkkNDtcbnZhciAkdG9TdHJpbmcgPSB0b1N0cmluZyQ4O1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIG5hdGl2ZU9iamVjdENyZWF0ZSA9IG9iamVjdENyZWF0ZTtcbnZhciBvYmplY3RLZXlzJDEgPSBvYmplY3RLZXlzJDQ7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSQyID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWw7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDIgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0aWVzO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgYXJyYXlTbGljZSQyID0gYXJyYXlTbGljZSQ1O1xudmFyIHJlZGVmaW5lJDEgPSByZWRlZmluZSQ0O1xudmFyIHNoYXJlZCA9IHNoYXJlZCQ0LmV4cG9ydHM7XG52YXIgc2hhcmVkS2V5ID0gc2hhcmVkS2V5JDQ7XG52YXIgaGlkZGVuS2V5cyQxID0gaGlkZGVuS2V5cyQ2O1xudmFyIHVpZCQxID0gdWlkJDQ7XG52YXIgd2VsbEtub3duU3ltYm9sJDYgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gd2VsbEtub3duU3ltYm9sV3JhcHBlZDtcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkayA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsO1xudmFyIHNldFRvU3RyaW5nVGFnJDIgPSBzZXRUb1N0cmluZ1RhZyQ1O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMyA9IGludGVybmFsU3RhdGU7XG52YXIgJGZvckVhY2gkMSA9IGFycmF5SXRlcmF0aW9uLmZvckVhY2g7XG52YXIgSElEREVOID0gc2hhcmVkS2V5KCdoaWRkZW4nKTtcbnZhciBTWU1CT0wgPSAnU3ltYm9sJztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2wkNigndG9QcmltaXRpdmUnKTtcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDMgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDMuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDMuZ2V0dGVyRm9yKFNZTUJPTCk7XG52YXIgT2JqZWN0UHJvdG90eXBlJDEgPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciAkU3ltYm9sID0gZ2xvYmFsJGwuU3ltYm9sO1xudmFyIFN5bWJvbFByb3RvdHlwZSA9ICRTeW1ib2wgJiYgJFN5bWJvbFtQUk9UT1RZUEVdO1xudmFyIFR5cGVFcnJvciRhID0gZ2xvYmFsJGwuVHlwZUVycm9yO1xudmFyIFFPYmplY3QgPSBnbG9iYWwkbC5RT2JqZWN0O1xudmFyICRzdHJpbmdpZnkkMSA9IGdldEJ1aWx0SW4kNCgnSlNPTicsICdzdHJpbmdpZnknKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSQyLmY7XG52YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxLmY7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbnZhciBwdXNoJDMgPSB1bmN1cnJ5VGhpcyRlKFtdLnB1c2gpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90b3R5cGVTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3RyaW5nLXRvLXN5bWJvbC1yZWdpc3RyeScpO1xudmFyIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC10by1zdHJpbmctcmVnaXN0cnknKTtcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpOyAvLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcblxudmFyIFVTRV9TRVRURVIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkOyAvLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcblxudmFyIHNldFN5bWJvbERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyQ5ICYmIGZhaWxzJGgoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0Q3JlYXRlKG5hdGl2ZURlZmluZVByb3BlcnR5KHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYScsIHtcbiAgICAgICAgdmFsdWU6IDdcbiAgICAgIH0pLmE7XG4gICAgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoTywgUCwgQXR0cmlidXRlcykge1xuICB2YXIgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKE9iamVjdFByb3RvdHlwZSQxLCBQKTtcbiAgaWYgKE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpIGRlbGV0ZSBPYmplY3RQcm90b3R5cGUkMVtQXTtcbiAgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG5cbiAgaWYgKE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IgJiYgTyAhPT0gT2JqZWN0UHJvdG90eXBlJDEpIHtcbiAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPYmplY3RQcm90b3R5cGUkMSwgUCwgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcik7XG4gIH1cbn0gOiBuYXRpdmVEZWZpbmVQcm9wZXJ0eTtcblxudmFyIHdyYXAkMSA9IGZ1bmN0aW9uICh0YWcsIGRlc2NyaXB0aW9uKSB7XG4gIHZhciBzeW1ib2wgPSBBbGxTeW1ib2xzW3RhZ10gPSBuYXRpdmVPYmplY3RDcmVhdGUoU3ltYm9sUHJvdG90eXBlKTtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQzKHN5bWJvbCwge1xuICAgIHR5cGU6IFNZTUJPTCxcbiAgICB0YWc6IHRhZyxcbiAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb25cbiAgfSk7XG4gIGlmICghREVTQ1JJUFRPUlMkOSkgc3ltYm9sLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBpZiAoTyA9PT0gT2JqZWN0UHJvdG90eXBlJDEpICRkZWZpbmVQcm9wZXJ0eShPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBQLCBBdHRyaWJ1dGVzKTtcbiAgYW5PYmplY3QkNShPKTtcbiAgdmFyIGtleSA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0JDUoQXR0cmlidXRlcyk7XG5cbiAgaWYgKGhhc093biQ3KEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUF0dHJpYnV0ZXMuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXNPd24kNyhPLCBISURERU4pKSBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBISURERU4sIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB7fSkpO1xuICAgICAgT1tISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzT3duJDcoTywgSElEREVOKSAmJiBPW0hJRERFTl1ba2V5XSkgT1tISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSBuYXRpdmVPYmplY3RDcmVhdGUoQXR0cmlidXRlcywge1xuICAgICAgICBlbnVtZXJhYmxlOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgZmFsc2UpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0U3ltYm9sRGVzY3JpcHRvcihPLCBrZXksIEF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIGtleSwgQXR0cmlidXRlcyk7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QkNShPKTtcbiAgdmFyIHByb3BlcnRpZXMgPSB0b0luZGV4ZWRPYmplY3QkNChQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzJDEocHJvcGVydGllcykuY29uY2F0KCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMocHJvcGVydGllcykpO1xuICAkZm9yRWFjaCQxKGtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIURFU0NSSVBUT1JTJDkgfHwgY2FsbCQyKCRwcm9wZXJ0eUlzRW51bWVyYWJsZSQxLCBwcm9wZXJ0aWVzLCBrZXkpKSAkZGVmaW5lUHJvcGVydHkoTywga2V5LCBwcm9wZXJ0aWVzW2tleV0pO1xuICB9KTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyBuYXRpdmVPYmplY3RDcmVhdGUoTykgOiAkZGVmaW5lUHJvcGVydGllcyhuYXRpdmVPYmplY3RDcmVhdGUoTyksIFByb3BlcnRpZXMpO1xufTtcblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSQxID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgUCA9IHRvUHJvcGVydHlLZXkoVik7XG4gIHZhciBlbnVtZXJhYmxlID0gY2FsbCQyKG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLCB0aGlzLCBQKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSQxICYmIGhhc093biQ3KEFsbFN5bWJvbHMsIFApICYmICFoYXNPd24kNyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBQKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gZW51bWVyYWJsZSB8fCAhaGFzT3duJDcodGhpcywgUCkgfHwgIWhhc093biQ3KEFsbFN5bWJvbHMsIFApIHx8IGhhc093biQ3KHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW1BdID8gZW51bWVyYWJsZSA6IHRydWU7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIHZhciBpdCA9IHRvSW5kZXhlZE9iamVjdCQ0KE8pO1xuICB2YXIga2V5ID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90b3R5cGUkMSAmJiBoYXNPd24kNyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXNPd24kNyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBkZXNjcmlwdG9yID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoaXQsIGtleSk7XG5cbiAgaWYgKGRlc2NyaXB0b3IgJiYgaGFzT3duJDcoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhc093biQ3KGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIHtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyh0b0luZGV4ZWRPYmplY3QkNChPKSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgJGZvckVhY2gkMShuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaGFzT3duJDcoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzT3duJDcoaGlkZGVuS2V5cyQxLCBrZXkpKSBwdXNoJDMocmVzdWx0LCBrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pIHtcbiAgdmFyIElTX09CSkVDVF9QUk9UT1RZUEUgPSBPID09PSBPYmplY3RQcm90b3R5cGUkMTtcbiAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyhJU19PQkpFQ1RfUFJPVE9UWVBFID8gT2JqZWN0UHJvdG90eXBlU3ltYm9scyA6IHRvSW5kZXhlZE9iamVjdCQ0KE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaCQxKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGhhc093biQ3KEFsbFN5bWJvbHMsIGtleSkgJiYgKCFJU19PQkpFQ1RfUFJPVE9UWVBFIHx8IGhhc093biQ3KE9iamVjdFByb3RvdHlwZSQxLCBrZXkpKSkge1xuICAgICAgcHVzaCQzKHJlc3VsdCwgQWxsU3ltYm9sc1trZXldKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTsgLy8gYFN5bWJvbGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLWNvbnN0cnVjdG9yXG5cblxuaWYgKCFOQVRJVkVfU1lNQk9MKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKGlzUHJvdG90eXBlT2YkayhTeW1ib2xQcm90b3R5cGUsIHRoaXMpKSB0aHJvdyBUeXBlRXJyb3IkYSgnU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gIWFyZ3VtZW50cy5sZW5ndGggfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiAkdG9TdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgdGFnID0gdWlkJDEoZGVzY3JpcHRpb24pO1xuXG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSQxKSBjYWxsJDIoc2V0dGVyLCBPYmplY3RQcm90b3R5cGVTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzT3duJDcodGhpcywgSElEREVOKSAmJiBoYXNPd24kNyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjcmlwdG9yKHRoaXMsIHRhZywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG4gICAgfTtcblxuICAgIGlmIChERVNDUklQVE9SUyQ5ICYmIFVTRV9TRVRURVIpIHNldFN5bWJvbERlc2NyaXB0b3IoT2JqZWN0UHJvdG90eXBlJDEsIHRhZywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgc2V0OiBzZXR0ZXJcbiAgICB9KTtcbiAgICByZXR1cm4gd3JhcCQxKHRhZywgZGVzY3JpcHRpb24pO1xuICB9O1xuXG4gIFN5bWJvbFByb3RvdHlwZSA9ICRTeW1ib2xbUFJPVE9UWVBFXTtcbiAgcmVkZWZpbmUkMShTeW1ib2xQcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnRhZztcbiAgfSk7XG4gIHJlZGVmaW5lJDEoJFN5bWJvbCwgJ3dpdGhvdXRTZXR0ZXInLCBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gd3JhcCQxKHVpZCQxKGRlc2NyaXB0aW9uKSwgZGVzY3JpcHRpb24pO1xuICB9KTtcbiAgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZSQxO1xuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIGRlZmluZVByb3BlcnRpZXNNb2R1bGUuZiA9ICRkZWZpbmVQcm9wZXJ0aWVzO1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUkMi5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSQyLmYgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwJDEod2VsbEtub3duU3ltYm9sJDYobmFtZSksIG5hbWUpO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUyQ5KSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtU3ltYm9sLWRlc2NyaXB0aW9uXG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoU3ltYm9sUHJvdG90eXBlLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5kZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4kJEYoe1xuICBnbG9iYWw6IHRydWUsXG4gIHdyYXA6IHRydWUsXG4gIGZvcmNlZDogIU5BVElWRV9TWU1CT0wsXG4gIHNoYW06ICFOQVRJVkVfU1lNQk9MXG59LCB7XG4gIFN5bWJvbDogJFN5bWJvbFxufSk7XG4kZm9yRWFjaCQxKG9iamVjdEtleXMkMShXZWxsS25vd25TeW1ib2xzU3RvcmUpLCBmdW5jdGlvbiAobmFtZSkge1xuICBkZWZpbmVXZWxsS25vd25TeW1ib2wkayhuYW1lKTtcbn0pO1xuJCRGKHtcbiAgdGFyZ2V0OiBTWU1CT0wsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogIU5BVElWRV9TWU1CT0xcbn0sIHtcbiAgLy8gYFN5bWJvbC5mb3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5mb3JcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgc3RyaW5nID0gJHRvU3RyaW5nKGtleSk7XG4gICAgaWYgKGhhc093biQ3KFN0cmluZ1RvU3ltYm9sUmVnaXN0cnksIHN0cmluZykpIHJldHVybiBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ107XG4gICAgdmFyIHN5bWJvbCA9ICRTeW1ib2woc3RyaW5nKTtcbiAgICBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ10gPSBzeW1ib2w7XG4gICAgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1ib2xdID0gc3RyaW5nO1xuICAgIHJldHVybiBzeW1ib2w7XG4gIH0sXG4gIC8vIGBTeW1ib2wua2V5Rm9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wua2V5Zm9yXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yJGEoc3ltICsgJyBpcyBub3QgYSBzeW1ib2wnKTtcbiAgICBpZiAoaGFzT3duJDcoU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSwgc3ltKSkgcmV0dXJuIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnlbc3ltXTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgVVNFX1NFVFRFUiA9IHRydWU7XG4gIH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkge1xuICAgIFVTRV9TRVRURVIgPSBmYWxzZTtcbiAgfVxufSk7XG4kJEYoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLFxuICBzaGFtOiAhREVTQ1JJUFRPUlMkOVxufSwge1xuICAvLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG59KTtcbiQkRih7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogIU5BVElWRV9TWU1CT0xcbn0sIHtcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eXN5bWJvbHNcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTsgLy8gQ2hyb21lIDM4IGFuZCAzOSBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgZmFpbHMgb24gcHJpbWl0aXZlc1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xuXG4kJEYoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IGZhaWxzJGgoZnVuY3Rpb24gKCkge1xuICAgIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxLmYoMSk7XG4gIH0pXG59LCB7XG4gIGdldE93blByb3BlcnR5U3ltYm9sczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gICAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxLmYodG9PYmplY3QkOChpdCkpO1xuICB9XG59KTsgLy8gYEpTT04uc3RyaW5naWZ5YCBtZXRob2QgYmVoYXZpb3Igd2l0aCBzeW1ib2xzXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG5cbmlmICgkc3RyaW5naWZ5JDEpIHtcbiAgdmFyIEZPUkNFRF9KU09OX1NUUklOR0lGWSA9ICFOQVRJVkVfU1lNQk9MIHx8IGZhaWxzJGgoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzeW1ib2wgPSAkU3ltYm9sKCk7IC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG5cbiAgICByZXR1cm4gJHN0cmluZ2lmeSQxKFtzeW1ib2xdKSAhPSAnW251bGxdJyAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgICB8fCAkc3RyaW5naWZ5JDEoe1xuICAgICAgYTogc3ltYm9sXG4gICAgfSkgIT0gJ3t9JyAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICAgIHx8ICRzdHJpbmdpZnkkMShPYmplY3Qoc3ltYm9sKSkgIT0gJ3t9JztcbiAgfSk7XG4gICQkRih7XG4gICAgdGFyZ2V0OiAnSlNPTicsXG4gICAgc3RhdDogdHJ1ZSxcbiAgICBmb3JjZWQ6IEZPUkNFRF9KU09OX1NUUklOR0lGWVxuICB9LCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UkMihhcmd1bWVudHMpO1xuICAgICAgdmFyICRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgICAgaWYgKCFpc09iamVjdCRiKHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG5cbiAgICAgIGlmICghaXNBcnJheSRiKHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNDYWxsYWJsZSQyKCRyZXBsYWNlcikpIHZhbHVlID0gY2FsbCQyKCRyZXBsYWNlciwgdGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgICAgcmV0dXJuIGFwcGx5JDQoJHN0cmluZ2lmeSQxLCBudWxsLCBhcmdzKTtcbiAgICB9XG4gIH0pO1xufSAvLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3ByaW1pdGl2ZVxuXG5cbmlmICghU3ltYm9sUHJvdG90eXBlW1RPX1BSSU1JVElWRV0pIHtcbiAgdmFyIHZhbHVlT2YgPSBTeW1ib2xQcm90b3R5cGUudmFsdWVPZjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciAubGVuZ3RoXG5cbiAgcmVkZWZpbmUkMShTeW1ib2xQcm90b3R5cGUsIFRPX1BSSU1JVElWRSwgZnVuY3Rpb24gKGhpbnQpIHtcbiAgICAvLyBUT0RPOiBpbXByb3ZlIGhpbnQgbG9naWNcbiAgICByZXR1cm4gY2FsbCQyKHZhbHVlT2YsIHRoaXMpO1xuICB9KTtcbn0gLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11gIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZ1xuXG5cbnNldFRvU3RyaW5nVGFnJDIoJFN5bWJvbCwgU1lNQk9MKTtcbmhpZGRlbktleXMkMVtISURERU5dID0gdHJ1ZTtcblxudmFyIHBhdGgkciA9IHBhdGgkeTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMkMiA9IHBhdGgkci5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG52YXIgcGFyZW50JDE0ID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzJDI7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzJDEgPSBwYXJlbnQkMTQ7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMkMTtcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ2ID0ge2V4cG9ydHM6IHt9fTtcblxudmFyICQkRSA9IF9leHBvcnQ7XG52YXIgZmFpbHMkZyA9IGZhaWxzJHQ7XG52YXIgdG9JbmRleGVkT2JqZWN0JDMgPSB0b0luZGV4ZWRPYmplY3QkYjtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBERVNDUklQVE9SUyQ4ID0gZGVzY3JpcHRvcnM7XG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyQ0ID0gZmFpbHMkZyhmdW5jdGlvbiAoKSB7XG4gIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcigxKTtcbn0pO1xudmFyIEZPUkNFRCQ2ID0gIURFU0NSSVBUT1JTJDggfHwgRkFJTFNfT05fUFJJTUlUSVZFUyQ0OyAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcblxuJCRFKHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiBGT1JDRUQkNixcbiAgc2hhbTogIURFU0NSSVBUT1JTJDhcbn0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JbmRleGVkT2JqZWN0JDMoaXQpLCBrZXkpO1xuICB9XG59KTtcblxudmFyIHBhdGgkcSA9IHBhdGgkeTtcbnZhciBPYmplY3QkNSA9IHBhdGgkcS5PYmplY3Q7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNSA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ2LmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICByZXR1cm4gT2JqZWN0JDUuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpO1xufTtcblxuaWYgKE9iamVjdCQ1LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5zaGFtKSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNS5zaGFtID0gdHJ1ZTtcblxudmFyIHBhcmVudCQxMyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ2LmV4cG9ydHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDQgPSBwYXJlbnQkMTM7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ0O1xuXG52YXIgZ2V0QnVpbHRJbiQzID0gZ2V0QnVpbHRJbiQ5O1xudmFyIHVuY3VycnlUaGlzJGQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUkMSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGFuT2JqZWN0JDQgPSBhbk9iamVjdCRkO1xudmFyIGNvbmNhdCQ0ID0gdW5jdXJyeVRoaXMkZChbXS5jb25jYXQpOyAvLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5cbnZhciBvd25LZXlzJGEgPSBnZXRCdWlsdEluJDMoJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlJDEuZihhbk9iamVjdCQ0KGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdCQ0KGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cbnZhciAkJEQgPSBfZXhwb3J0O1xudmFyIERFU0NSSVBUT1JTJDcgPSBkZXNjcmlwdG9ycztcbnZhciBvd25LZXlzJDkgPSBvd25LZXlzJGE7XG52YXIgdG9JbmRleGVkT2JqZWN0JDIgPSB0b0luZGV4ZWRPYmplY3QkYjtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUkMSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBjcmVhdGVQcm9wZXJ0eSQzID0gY3JlYXRlUHJvcGVydHkkNjsgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcblxuJCREKHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgc2hhbTogIURFU0NSSVBUT1JTJDdcbn0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQyKG9iamVjdCk7XG4gICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSQxLmY7XG4gICAgdmFyIGtleXMgPSBvd25LZXlzJDkoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGtleSwgZGVzY3JpcHRvcjtcblxuICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIGtleSA9IGtleXNbaW5kZXgrK10pO1xuICAgICAgaWYgKGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkkMyhyZXN1bHQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnZhciBwYXRoJHAgPSBwYXRoJHk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyQyID0gcGF0aCRwLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xuXG52YXIgcGFyZW50JDEyID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyQyO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMkMSA9IHBhcmVudCQxMjtcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDE7XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzJDQgPSB7ZXhwb3J0czoge319O1xuXG52YXIgJCRDID0gX2V4cG9ydDtcbnZhciBERVNDUklQVE9SUyQ2ID0gZGVzY3JpcHRvcnM7XG52YXIgZGVmaW5lUHJvcGVydGllcyQzID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcy5mOyAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcblxuJCRDKHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyAhPT0gZGVmaW5lUHJvcGVydGllcyQzLFxuICBzaGFtOiAhREVTQ1JJUFRPUlMkNlxufSwge1xuICBkZWZpbmVQcm9wZXJ0aWVzOiBkZWZpbmVQcm9wZXJ0aWVzJDNcbn0pO1xuXG52YXIgcGF0aCRvID0gcGF0aCR5O1xudmFyIE9iamVjdCQ0ID0gcGF0aCRvLk9iamVjdDtcblxudmFyIGRlZmluZVByb3BlcnRpZXMkMiA9IGRlZmluZVByb3BlcnRpZXMkNC5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhULCBEKSB7XG4gIHJldHVybiBPYmplY3QkNC5kZWZpbmVQcm9wZXJ0aWVzKFQsIEQpO1xufTtcblxuaWYgKE9iamVjdCQ0LmRlZmluZVByb3BlcnRpZXMuc2hhbSkgZGVmaW5lUHJvcGVydGllcyQyLnNoYW0gPSB0cnVlO1xuXG52YXIgcGFyZW50JDExID0gZGVmaW5lUHJvcGVydGllcyQ0LmV4cG9ydHM7XG52YXIgZGVmaW5lUHJvcGVydGllcyQxID0gcGFyZW50JDExO1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGRlZmluZVByb3BlcnRpZXMkMTtcblxudmFyIGRlZmluZVByb3BlcnR5JGEgPSB7ZXhwb3J0czoge319O1xuXG52YXIgJCRCID0gX2V4cG9ydDtcbnZhciBERVNDUklQVE9SUyQ1ID0gZGVzY3JpcHRvcnM7XG52YXIgZGVmaW5lUHJvcGVydHkkOSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7IC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuXG4kJEIoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gZGVmaW5lUHJvcGVydHkkOSxcbiAgc2hhbTogIURFU0NSSVBUT1JTJDVcbn0sIHtcbiAgZGVmaW5lUHJvcGVydHk6IGRlZmluZVByb3BlcnR5JDlcbn0pO1xuXG52YXIgcGF0aCRuID0gcGF0aCR5O1xudmFyIE9iamVjdCQzID0gcGF0aCRuLk9iamVjdDtcblxudmFyIGRlZmluZVByb3BlcnR5JDggPSBkZWZpbmVQcm9wZXJ0eSRhLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7XG4gIHJldHVybiBPYmplY3QkMy5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cbmlmIChPYmplY3QkMy5kZWZpbmVQcm9wZXJ0eS5zaGFtKSBkZWZpbmVQcm9wZXJ0eSQ4LnNoYW0gPSB0cnVlO1xuXG52YXIgcGFyZW50JDEwID0gZGVmaW5lUHJvcGVydHkkYS5leHBvcnRzO1xudmFyIGRlZmluZVByb3BlcnR5JDcgPSBwYXJlbnQkMTA7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQ2ID0gZGVmaW5lUHJvcGVydHkkNztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxudmFyIHBhcmVudCQkID0gZGVmaW5lUHJvcGVydHkkNztcbnZhciBkZWZpbmVQcm9wZXJ0eSQ1ID0gcGFyZW50JCQ7XG5cbnZhciBwYXJlbnQkXyA9IGRlZmluZVByb3BlcnR5JDU7XG52YXIgZGVmaW5lUHJvcGVydHkkNCA9IHBhcmVudCRfO1xuXG52YXIgZGVmaW5lUHJvcGVydHkkMyA9IGRlZmluZVByb3BlcnR5JDQ7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgZGVmaW5lUHJvcGVydHkkMyh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG5cbiAgZGVmaW5lUHJvcGVydHkkMyhDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcblxuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQzKG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxudmFyICQkQSA9IF9leHBvcnQ7XG52YXIgaXNBcnJheSRhID0gaXNBcnJheSRkOyAvLyBgQXJyYXkuaXNBcnJheWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmlzYXJyYXlcblxuJCRBKHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBzdGF0OiB0cnVlXG59LCB7XG4gIGlzQXJyYXk6IGlzQXJyYXkkYVxufSk7XG5cbnZhciBwYXRoJG0gPSBwYXRoJHk7XG52YXIgaXNBcnJheSQ5ID0gcGF0aCRtLkFycmF5LmlzQXJyYXk7XG5cbnZhciBwYXJlbnQkWiA9IGlzQXJyYXkkOTtcbnZhciBpc0FycmF5JDggPSBwYXJlbnQkWjtcblxudmFyIHBhcmVudCRZID0gaXNBcnJheSQ4O1xudmFyIGlzQXJyYXkkNyA9IHBhcmVudCRZO1xuXG52YXIgcGFyZW50JFggPSBpc0FycmF5JDc7XG52YXIgaXNBcnJheSQ2ID0gcGFyZW50JFg7XG5cbnZhciBpc0FycmF5JDUgPSBpc0FycmF5JDY7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKGlzQXJyYXkkNShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG52YXIgZmFpbHMkZiA9IGZhaWxzJHQ7XG52YXIgd2VsbEtub3duU3ltYm9sJDUgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBWOF9WRVJTSU9OJDEgPSBlbmdpbmVWOFZlcnNpb247XG52YXIgU1BFQ0lFUyQyID0gd2VsbEtub3duU3ltYm9sJDUoJ3NwZWNpZXMnKTtcblxudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNSA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICAvLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3N1xuICByZXR1cm4gVjhfVkVSU0lPTiQxID49IDUxIHx8ICFmYWlscyRmKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBhcnJheS5jb25zdHJ1Y3RvciA9IHt9O1xuXG4gICAgY29uc3RydWN0b3JbU1BFQ0lFUyQyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvbzogMVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGFycmF5W01FVEhPRF9OQU1FXShCb29sZWFuKS5mb28gIT09IDE7XG4gIH0pO1xufTtcblxudmFyICQkeiA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJGsgPSBnbG9iYWwkUDtcbnZhciBmYWlscyRlID0gZmFpbHMkdDtcbnZhciBpc0FycmF5JDQgPSBpc0FycmF5JGQ7XG52YXIgaXNPYmplY3QkYSA9IGlzT2JqZWN0JGo7XG52YXIgdG9PYmplY3QkNyA9IHRvT2JqZWN0JGU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkOCA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG52YXIgY3JlYXRlUHJvcGVydHkkMiA9IGNyZWF0ZVByb3BlcnR5JDY7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlJDIgPSBhcnJheVNwZWNpZXNDcmVhdGUkNDtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDU7XG52YXIgd2VsbEtub3duU3ltYm9sJDQgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBWOF9WRVJTSU9OID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gd2VsbEtub3duU3ltYm9sJDQoJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIkMSA9IDB4MUZGRkZGRkZGRkZGRkY7XG52YXIgTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEID0gJ01heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZCc7XG52YXIgVHlwZUVycm9yJDkgPSBnbG9iYWwkay5UeXBlRXJyb3I7IC8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcblxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgPSBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyRlKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIGFycmF5W0lTX0NPTkNBVF9TUFJFQURBQkxFXSA9IGZhbHNlO1xuICByZXR1cm4gYXJyYXkuY29uY2F0KClbMF0gIT09IGFycmF5O1xufSk7XG52YXIgU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ0KCdjb25jYXQnKTtcblxudmFyIGlzQ29uY2F0U3ByZWFkYWJsZSA9IGZ1bmN0aW9uIChPKSB7XG4gIGlmICghaXNPYmplY3QkYShPKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgc3ByZWFkYWJsZSA9IE9bSVNfQ09OQ0FUX1NQUkVBREFCTEVdO1xuICByZXR1cm4gc3ByZWFkYWJsZSAhPT0gdW5kZWZpbmVkID8gISFzcHJlYWRhYmxlIDogaXNBcnJheSQ0KE8pO1xufTtcblxudmFyIEZPUkNFRCQ1ID0gIUlTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgfHwgIVNQRUNJRVNfU1VQUE9SVDsgLy8gYEFycmF5LnByb3RvdHlwZS5jb25jYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuY29uY2F0XG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAaXNDb25jYXRTcHJlYWRhYmxlIGFuZCBAQHNwZWNpZXNcblxuJCR6KHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiBGT1JDRUQkNVxufSwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdChhcmcpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0JDcodGhpcyk7XG4gICAgdmFyIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUkMihPLCAwKTtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGksIGssIGxlbmd0aCwgbGVuLCBFO1xuXG4gICAgZm9yIChpID0gLTEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgRSA9IGkgPT09IC0xID8gTyA6IGFyZ3VtZW50c1tpXTtcblxuICAgICAgaWYgKGlzQ29uY2F0U3ByZWFkYWJsZShFKSkge1xuICAgICAgICBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZSQ4KEUpO1xuICAgICAgICBpZiAobiArIGxlbiA+IE1BWF9TQUZFX0lOVEVHRVIkMSkgdGhyb3cgVHlwZUVycm9yJDkoTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEKTtcblxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyssIG4rKykgaWYgKGsgaW4gRSkgY3JlYXRlUHJvcGVydHkkMihBLCBuLCBFW2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuID49IE1BWF9TQUZFX0lOVEVHRVIkMSkgdGhyb3cgVHlwZUVycm9yJDkoTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEKTtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkkMihBLCBuKyssIEUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEEubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkaiA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5hc3luY2l0ZXJhdG9yXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCRqKCdhc3luY0l0ZXJhdG9yJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkaSA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLmhhc0luc3RhbmNlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuaGFzaW5zdGFuY2VcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGkoJ2hhc0luc3RhbmNlJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkaCA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmlzY29uY2F0c3ByZWFkYWJsZVxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkaCgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkZyA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLml0ZXJhdG9yYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuaXRlcmF0b3JcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGcoJ2l0ZXJhdG9yJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkZiA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLm1hdGNoYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wubWF0Y2hcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGYoJ21hdGNoJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkZSA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLm1hdGNoQWxsYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wubWF0Y2hhbGxcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGUoJ21hdGNoQWxsJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkZCA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLnJlcGxhY2VgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5yZXBsYWNlXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCRkKCdyZXBsYWNlJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkYyA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLnNlYXJjaGAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnNlYXJjaFxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkYygnc2VhcmNoJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkYiA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLnNwZWNpZXNgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5zcGVjaWVzXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCRiKCdzcGVjaWVzJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkYSA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLnNwbGl0YCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuc3BsaXRcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGEoJ3NwbGl0Jyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkOSA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLnRvUHJpbWl0aXZlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wudG9wcmltaXRpdmVcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJDkoJ3RvUHJpbWl0aXZlJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkOCA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wudG9zdHJpbmd0YWdcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJDgoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkNyA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLnVuc2NvcGFibGVzYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wudW5zY29wYWJsZXNcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJDcoJ3Vuc2NvcGFibGVzJyk7XG5cbnZhciBnbG9iYWwkaiA9IGdsb2JhbCRQO1xudmFyIHNldFRvU3RyaW5nVGFnJDEgPSBzZXRUb1N0cmluZ1RhZyQ1OyAvLyBKU09OW0BAdG9TdHJpbmdUYWddIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24tQEB0b3N0cmluZ3RhZ1xuXG5zZXRUb1N0cmluZ1RhZyQxKGdsb2JhbCRqLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cbnZhciBwYXRoJGwgPSBwYXRoJHk7XG52YXIgc3ltYm9sJDUgPSBwYXRoJGwuU3ltYm9sO1xuXG52YXIgcGFyZW50JFcgPSBzeW1ib2wkNTtcbnZhciBzeW1ib2wkNCA9IHBhcmVudCRXO1xuXG52YXIgcGFyZW50JFYgPSBzeW1ib2wkNDtcbnZhciBzeW1ib2wkMyA9IHBhcmVudCRWO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDYgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5hc3luY0Rpc3Bvc2VgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC11c2luZy1zdGF0ZW1lbnRcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJDYoJ2FzeW5jRGlzcG9zZScpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDUgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDsgLy8gYFN5bWJvbC5kaXNwb3NlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtdXNpbmctc3RhdGVtZW50XG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCQ1KCdkaXNwb3NlJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkNCA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLm1hdGNoZXJgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wYXR0ZXJuLW1hdGNoaW5nXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCQ0KCdtYXRjaGVyJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkMyA9IGRlZmluZVdlbGxLbm93blN5bWJvbCRsOyAvLyBgU3ltYm9sLm1ldGFkYXRhYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZGVjb3JhdG9yc1xuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkMygnbWV0YWRhdGEnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQyID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wub2JzZXJ2YWJsZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sJDIoJ29ic2VydmFibGUnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQxID0gZGVmaW5lV2VsbEtub3duU3ltYm9sJGw7IC8vIGBTeW1ib2wucGF0dGVybk1hdGNoYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcGF0dGVybi1tYXRjaGluZ1xuXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkMSgncGF0dGVybk1hdGNoJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSBkZWZpbmVXZWxsS25vd25TeW1ib2wkbDtcbmRlZmluZVdlbGxLbm93blN5bWJvbCgncmVwbGFjZUFsbCcpO1xuXG52YXIgcGFyZW50JFUgPSBzeW1ib2wkMzsgLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG5cbnZhciBzeW1ib2wkMiA9IHBhcmVudCRVO1xuXG52YXIgc3ltYm9sJDEgPSBzeW1ib2wkMjtcblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2Ygc3ltYm9sJDEgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShhcnIpIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG52YXIgJCR5ID0gX2V4cG9ydDtcbnZhciBnbG9iYWwkaSA9IGdsb2JhbCRQO1xudmFyIGlzQXJyYXkkMyA9IGlzQXJyYXkkZDtcbnZhciBpc0NvbnN0cnVjdG9yJDEgPSBpc0NvbnN0cnVjdG9yJDQ7XG52YXIgaXNPYmplY3QkOSA9IGlzT2JqZWN0JGo7XG52YXIgdG9BYnNvbHV0ZUluZGV4JDIgPSB0b0Fic29sdXRlSW5kZXgkNTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ3ID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbnZhciB0b0luZGV4ZWRPYmplY3QkMSA9IHRvSW5kZXhlZE9iamVjdCRiO1xudmFyIGNyZWF0ZVByb3BlcnR5JDEgPSBjcmVhdGVQcm9wZXJ0eSQ2O1xudmFyIHdlbGxLbm93blN5bWJvbCQzID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQzID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ1O1xudmFyIHVuJFNsaWNlID0gYXJyYXlTbGljZSQ1O1xudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQkMyA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMygnc2xpY2UnKTtcbnZhciBTUEVDSUVTJDEgPSB3ZWxsS25vd25TeW1ib2wkMygnc3BlY2llcycpO1xudmFyIEFycmF5JDIgPSBnbG9iYWwkaS5BcnJheTtcbnZhciBtYXgkMSA9IE1hdGgubWF4OyAvLyBgQXJyYXkucHJvdG90eXBlLnNsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNsaWNlXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG5cbiQkeSh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQkM1xufSwge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDEodGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDcoTyk7XG4gICAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgkMihzdGFydCwgbGVuZ3RoKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4JDIoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7IC8vIGlubGluZSBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBmb3IgdXNhZ2UgbmF0aXZlIGBBcnJheSNzbGljZWAgd2hlcmUgaXQncyBwb3NzaWJsZVxuXG4gICAgdmFyIENvbnN0cnVjdG9yLCByZXN1bHQsIG47XG5cbiAgICBpZiAoaXNBcnJheSQzKE8pKSB7XG4gICAgICBDb25zdHJ1Y3RvciA9IE8uY29uc3RydWN0b3I7IC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG5cbiAgICAgIGlmIChpc0NvbnN0cnVjdG9yJDEoQ29uc3RydWN0b3IpICYmIChDb25zdHJ1Y3RvciA9PT0gQXJyYXkkMiB8fCBpc0FycmF5JDMoQ29uc3RydWN0b3IucHJvdG90eXBlKSkpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0JDkoQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3JbU1BFQ0lFUyQxXTtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBudWxsKSBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBBcnJheSQyIHx8IENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuJFNsaWNlKE8sIGssIGZpbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gbmV3IChDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkID8gQXJyYXkkMiA6IENvbnN0cnVjdG9yKShtYXgkMShmaW4gLSBrLCAwKSk7XG5cbiAgICBmb3IgKG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgaWYgKGsgaW4gTykgY3JlYXRlUHJvcGVydHkkMShyZXN1bHQsIG4sIE9ba10pO1xuXG4gICAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkaiA9IGVudHJ5VmlydHVhbCRsO1xudmFyIHNsaWNlJDYgPSBlbnRyeVZpcnR1YWwkaignQXJyYXknKS5zbGljZTtcblxudmFyIGlzUHJvdG90eXBlT2YkaiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJGcgPSBzbGljZSQ2O1xudmFyIEFycmF5UHJvdG90eXBlJGggPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBzbGljZSQ1ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5zbGljZTtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRoIHx8IGlzUHJvdG90eXBlT2YkaihBcnJheVByb3RvdHlwZSRoLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRoLnNsaWNlID8gbWV0aG9kJGcgOiBvd247XG59O1xuXG52YXIgcGFyZW50JFQgPSBzbGljZSQ1O1xudmFyIHNsaWNlJDQgPSBwYXJlbnQkVDtcblxudmFyIHBhcmVudCRTID0gc2xpY2UkNDtcbnZhciBzbGljZSQzID0gcGFyZW50JFM7XG5cbnZhciBwYXJlbnQkUiA9IHNsaWNlJDM7XG52YXIgc2xpY2UkMiA9IHBhcmVudCRSO1xuXG52YXIgc2xpY2UkMSA9IHNsaWNlJDI7XG5cbnZhciBwYXJlbnQkUSA9IGZyb20kNDtcbnZhciBmcm9tJDIgPSBwYXJlbnQkUTtcblxudmFyIHBhcmVudCRQID0gZnJvbSQyO1xudmFyIGZyb20kMSA9IHBhcmVudCRQO1xuXG52YXIgZnJvbSA9IGZyb20kMTtcblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkOShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ5KG8sIG1pbkxlbikge1xuICB2YXIgX2NvbnRleHQ7XG5cbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDkobywgbWluTGVuKTtcblxuICB2YXIgbiA9IHNsaWNlJDEoX2NvbnRleHQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQsIDgsIC0xKTtcblxuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbnZhciBXcmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gd2VsbEtub3duU3ltYm9sV3JhcHBlZDtcbnZhciBpdGVyYXRvciQ1ID0gV3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mKCdpdGVyYXRvcicpO1xuXG52YXIgcGFyZW50JE8gPSBpdGVyYXRvciQ1O1xudmFyIGl0ZXJhdG9yJDQgPSBwYXJlbnQkTztcblxudmFyIHBhcmVudCROID0gaXRlcmF0b3IkNDtcbnZhciBpdGVyYXRvciQzID0gcGFyZW50JE47XG5cbnZhciBwYXJlbnQkTSA9IGl0ZXJhdG9yJDM7XG52YXIgaXRlcmF0b3IkMiA9IHBhcmVudCRNO1xuXG52YXIgaXRlcmF0b3IkMSA9IGl0ZXJhdG9yJDI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygc3ltYm9sJDEgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgaXRlcmF0b3IkMSA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygc3ltYm9sJDEgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBzeW1ib2wkMSAmJiBvYmogIT09IHN5bWJvbCQxLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9LCBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKGlzQXJyYXkkNShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkOShhcnIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBzeW1ib2wkMSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKGl0ZXIpICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIGZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkOShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG52YXIgc3ltYm9sID0gc3ltYm9sJDQ7XG5cbnZhciBlbnRyeVZpcnR1YWwkaSA9IGVudHJ5VmlydHVhbCRsO1xudmFyIGNvbmNhdCQzID0gZW50cnlWaXJ0dWFsJGkoJ0FycmF5JykuY29uY2F0O1xuXG52YXIgaXNQcm90b3R5cGVPZiRpID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkZiA9IGNvbmNhdCQzO1xudmFyIEFycmF5UHJvdG90eXBlJGcgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBjb25jYXQkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuY29uY2F0O1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGcgfHwgaXNQcm90b3R5cGVPZiRpKEFycmF5UHJvdG90eXBlJGcsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGcuY29uY2F0ID8gbWV0aG9kJGYgOiBvd247XG59O1xuXG52YXIgcGFyZW50JEwgPSBjb25jYXQkMjtcbnZhciBjb25jYXQkMSA9IHBhcmVudCRMO1xuXG52YXIgY29uY2F0ID0gY29uY2F0JDE7XG5cbnZhciBzbGljZSA9IHNsaWNlJDQ7XG5cbnZhciAkJHggPSBfZXhwb3J0O1xudmFyIG93bktleXMkOCA9IG93bktleXMkYTsgLy8gYFJlZmxlY3Qub3duS2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZmxlY3Qub3dua2V5c1xuXG4kJHgoe1xuICB0YXJnZXQ6ICdSZWZsZWN0JyxcbiAgc3RhdDogdHJ1ZVxufSwge1xuICBvd25LZXlzOiBvd25LZXlzJDhcbn0pO1xuXG52YXIgcGF0aCRrID0gcGF0aCR5O1xudmFyIG93bktleXMkNyA9IHBhdGgkay5SZWZsZWN0Lm93bktleXM7XG5cbnZhciBwYXJlbnQkSyA9IG93bktleXMkNztcbnZhciBvd25LZXlzJDYgPSBwYXJlbnQkSztcblxudmFyIG93bktleXMkNSA9IG93bktleXMkNjtcblxudmFyIGlzQXJyYXkkMiA9IGlzQXJyYXkkODtcblxudmFyICQkdyA9IF9leHBvcnQ7XG52YXIgJG1hcCA9IGFycmF5SXRlcmF0aW9uLm1hcDtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDIgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDU7XG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCQyID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQyKCdtYXAnKTsgLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xuXG4kJHcoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUJDJcbn0sIHtcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmblxuICAvKiAsIHRoaXNBcmcgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCRoID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgbWFwJDYgPSBlbnRyeVZpcnR1YWwkaCgnQXJyYXknKS5tYXA7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGggPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCRlID0gbWFwJDY7XG52YXIgQXJyYXlQcm90b3R5cGUkZiA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIG1hcCQ1ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5tYXA7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkZiB8fCBpc1Byb3RvdHlwZU9mJGgoQXJyYXlQcm90b3R5cGUkZiwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkZi5tYXAgPyBtZXRob2QkZSA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkSiA9IG1hcCQ1O1xudmFyIG1hcCQ0ID0gcGFyZW50JEo7XG5cbnZhciBtYXAkMyA9IG1hcCQ0O1xuXG52YXIgJCR2ID0gX2V4cG9ydDtcbnZhciB0b09iamVjdCQ2ID0gdG9PYmplY3QkZTtcbnZhciBuYXRpdmVLZXlzID0gb2JqZWN0S2V5cyQ0O1xudmFyIGZhaWxzJGQgPSBmYWlscyR0O1xudmFyIEZBSUxTX09OX1BSSU1JVElWRVMkMyA9IGZhaWxzJGQoZnVuY3Rpb24gKCkge1xuICBuYXRpdmVLZXlzKDEpO1xufSk7IC8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG5cbiQkdih7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUyQzXG59LCB7XG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyh0b09iamVjdCQ2KGl0KSk7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCRqID0gcGF0aCR5O1xudmFyIGtleXMkNiA9IHBhdGgkai5PYmplY3Qua2V5cztcblxudmFyIHBhcmVudCRJID0ga2V5cyQ2O1xudmFyIGtleXMkNSA9IHBhcmVudCRJO1xuXG52YXIga2V5cyQ0ID0ga2V5cyQ1O1xuXG52YXIgJCR1ID0gX2V4cG9ydDtcbnZhciBnbG9iYWwkaCA9IGdsb2JhbCRQO1xudmFyIHVuY3VycnlUaGlzJGMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIERhdGUkMSA9IGdsb2JhbCRoLkRhdGU7XG52YXIgZ2V0VGltZSA9IHVuY3VycnlUaGlzJGMoRGF0ZSQxLnByb3RvdHlwZS5nZXRUaW1lKTsgLy8gYERhdGUubm93YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZGF0ZS5ub3dcblxuJCR1KHtcbiAgdGFyZ2V0OiAnRGF0ZScsXG4gIHN0YXQ6IHRydWVcbn0sIHtcbiAgbm93OiBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIGdldFRpbWUobmV3IERhdGUkMSgpKTtcbiAgfVxufSk7XG5cbnZhciBwYXRoJGkgPSBwYXRoJHk7XG52YXIgbm93JDMgPSBwYXRoJGkuRGF0ZS5ub3c7XG5cbnZhciBwYXJlbnQkSCA9IG5vdyQzO1xudmFyIG5vdyQyID0gcGFyZW50JEg7XG5cbnZhciBub3ckMSA9IG5vdyQyO1xuXG52YXIgZmFpbHMkYyA9IGZhaWxzJHQ7XG5cbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDYgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUsIGFyZ3VtZW50KSB7XG4gIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyRjKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSwgMSk7XG4gIH0pO1xufTtcblxudmFyICRmb3JFYWNoID0gYXJyYXlJdGVyYXRpb24uZm9yRWFjaDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDUgPSBhcnJheU1ldGhvZElzU3RyaWN0JDY7XG52YXIgU1RSSUNUX01FVEhPRCQ1ID0gYXJyYXlNZXRob2RJc1N0cmljdCQ1KCdmb3JFYWNoJyk7IC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG5cbnZhciBhcnJheUZvckVhY2ggPSAhU1RSSUNUX01FVEhPRCQ1ID8gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuXG4vKiAsIHRoaXNBcmcgKi9cbikge1xuICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWZvcmVhY2ggLS0gc2FmZVxufSA6IFtdLmZvckVhY2g7XG5cbnZhciAkJHQgPSBfZXhwb3J0O1xudmFyIGZvckVhY2gkNiA9IGFycmF5Rm9yRWFjaDsgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1wcm90b3R5cGUtZm9yZWFjaCAtLSBzYWZlXG5cbiQkdCh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogW10uZm9yRWFjaCAhPSBmb3JFYWNoJDZcbn0sIHtcbiAgZm9yRWFjaDogZm9yRWFjaCQ2XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCRnID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgZm9yRWFjaCQ1ID0gZW50cnlWaXJ0dWFsJGcoJ0FycmF5JykuZm9yRWFjaDtcblxudmFyIHBhcmVudCRHID0gZm9yRWFjaCQ1O1xudmFyIGZvckVhY2gkNCA9IHBhcmVudCRHO1xuXG52YXIgY2xhc3NvZiQ2ID0gY2xhc3NvZiRlO1xudmFyIGhhc093biQ2ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc1Byb3RvdHlwZU9mJGcgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCRkID0gZm9yRWFjaCQ0O1xudmFyIEFycmF5UHJvdG90eXBlJGUgPSBBcnJheS5wcm90b3R5cGU7XG52YXIgRE9NSXRlcmFibGVzJDMgPSB7XG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgTm9kZUxpc3Q6IHRydWVcbn07XG5cbnZhciBmb3JFYWNoJDMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmZvckVhY2g7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkZSB8fCBpc1Byb3RvdHlwZU9mJGcoQXJyYXlQcm90b3R5cGUkZSwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkZS5mb3JFYWNoIHx8IGhhc093biQ2KERPTUl0ZXJhYmxlcyQzLCBjbGFzc29mJDYoaXQpKSA/IG1ldGhvZCRkIDogb3duO1xufTtcblxudmFyIGZvckVhY2gkMiA9IGZvckVhY2gkMztcblxudmFyICQkcyA9IF9leHBvcnQ7XG52YXIgdW5jdXJyeVRoaXMkYiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNBcnJheSQxID0gaXNBcnJheSRkO1xudmFyIHVuJFJldmVyc2UgPSB1bmN1cnJ5VGhpcyRiKFtdLnJldmVyc2UpO1xudmFyIHRlc3QkMSA9IFsxLCAyXTsgLy8gYEFycmF5LnByb3RvdHlwZS5yZXZlcnNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJldmVyc2Vcbi8vIGZpeCBmb3IgU2FmYXJpIDEyLjAgYnVnXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg4Nzk0XG5cbiQkcyh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogU3RyaW5nKHRlc3QkMSkgPT09IFN0cmluZyh0ZXN0JDEucmV2ZXJzZSgpKVxufSwge1xuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnbiAtLSBkaXJ0eSBoYWNrXG4gICAgaWYgKGlzQXJyYXkkMSh0aGlzKSkgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gdW4kUmV2ZXJzZSh0aGlzKTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkZiA9IGVudHJ5VmlydHVhbCRsO1xudmFyIHJldmVyc2UkMyA9IGVudHJ5VmlydHVhbCRmKCdBcnJheScpLnJldmVyc2U7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGYgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCRjID0gcmV2ZXJzZSQzO1xudmFyIEFycmF5UHJvdG90eXBlJGQgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciByZXZlcnNlJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnJldmVyc2U7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkZCB8fCBpc1Byb3RvdHlwZU9mJGYoQXJyYXlQcm90b3R5cGUkZCwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkZC5yZXZlcnNlID8gbWV0aG9kJGMgOiBvd247XG59O1xuXG52YXIgcGFyZW50JEYgPSByZXZlcnNlJDI7XG52YXIgcmV2ZXJzZSQxID0gcGFyZW50JEY7XG5cbnZhciByZXZlcnNlID0gcmV2ZXJzZSQxO1xuXG52YXIgJCRyID0gX2V4cG9ydDtcbnZhciBnbG9iYWwkZyA9IGdsb2JhbCRQO1xudmFyIHRvQWJzb2x1dGVJbmRleCQxID0gdG9BYnNvbHV0ZUluZGV4JDU7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ2ID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbnZhciB0b09iamVjdCQ1ID0gdG9PYmplY3QkZTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUkMSA9IGFycmF5U3BlY2llc0NyZWF0ZSQ0O1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gY3JlYXRlUHJvcGVydHkkNjtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDEgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDU7XG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCQxID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQxKCdzcGxpY2UnKTtcbnZhciBUeXBlRXJyb3IkOCA9IGdsb2JhbCRnLlR5cGVFcnJvcjtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjtcbnZhciBNQVhJTVVNX0FMTE9XRURfTEVOR1RIX0VYQ0VFREVEID0gJ01heGltdW0gYWxsb3dlZCBsZW5ndGggZXhjZWVkZWQnOyAvLyBgQXJyYXkucHJvdG90eXBlLnNwbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zcGxpY2Vcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG5cbiQkcih7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQkMVxufSwge1xuICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnRcbiAgLyogLCAuLi5pdGVtcyAqL1xuICApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0JDUodGhpcyk7XG4gICAgdmFyIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlJDYoTyk7XG4gICAgdmFyIGFjdHVhbFN0YXJ0ID0gdG9BYnNvbHV0ZUluZGV4JDEoc3RhcnQsIGxlbik7XG4gICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGluc2VydENvdW50LCBhY3R1YWxEZWxldGVDb3VudCwgQSwgaywgZnJvbSwgdG87XG5cbiAgICBpZiAoYXJndW1lbnRzTGVuZ3RoID09PSAwKSB7XG4gICAgICBpbnNlcnRDb3VudCA9IGFjdHVhbERlbGV0ZUNvdW50ID0gMDtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c0xlbmd0aCA9PT0gMSkge1xuICAgICAgaW5zZXJ0Q291bnQgPSAwO1xuICAgICAgYWN0dWFsRGVsZXRlQ291bnQgPSBsZW4gLSBhY3R1YWxTdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zZXJ0Q291bnQgPSBhcmd1bWVudHNMZW5ndGggLSAyO1xuICAgICAgYWN0dWFsRGVsZXRlQ291bnQgPSBtaW4obWF4KHRvSW50ZWdlck9ySW5maW5pdHkoZGVsZXRlQ291bnQpLCAwKSwgbGVuIC0gYWN0dWFsU3RhcnQpO1xuICAgIH1cblxuICAgIGlmIChsZW4gKyBpbnNlcnRDb3VudCAtIGFjdHVhbERlbGV0ZUNvdW50ID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDgoTUFYSU1VTV9BTExPV0VEX0xFTkdUSF9FWENFRURFRCk7XG4gICAgfVxuXG4gICAgQSA9IGFycmF5U3BlY2llc0NyZWF0ZSQxKE8sIGFjdHVhbERlbGV0ZUNvdW50KTtcblxuICAgIGZvciAoayA9IDA7IGsgPCBhY3R1YWxEZWxldGVDb3VudDsgaysrKSB7XG4gICAgICBmcm9tID0gYWN0dWFsU3RhcnQgKyBrO1xuICAgICAgaWYgKGZyb20gaW4gTykgY3JlYXRlUHJvcGVydHkoQSwgaywgT1tmcm9tXSk7XG4gICAgfVxuXG4gICAgQS5sZW5ndGggPSBhY3R1YWxEZWxldGVDb3VudDtcblxuICAgIGlmIChpbnNlcnRDb3VudCA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICBmb3IgKGsgPSBhY3R1YWxTdGFydDsgayA8IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50OyBrKyspIHtcbiAgICAgICAgZnJvbSA9IGsgKyBhY3R1YWxEZWxldGVDb3VudDtcbiAgICAgICAgdG8gPSBrICsgaW5zZXJ0Q291bnQ7XG4gICAgICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChrID0gbGVuOyBrID4gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpbnNlcnRDb3VudDsgay0tKSBkZWxldGUgT1trIC0gMV07XG4gICAgfSBlbHNlIGlmIChpbnNlcnRDb3VudCA+IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICBmb3IgKGsgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDsgayA+IGFjdHVhbFN0YXJ0OyBrLS0pIHtcbiAgICAgICAgZnJvbSA9IGsgKyBhY3R1YWxEZWxldGVDb3VudCAtIDE7XG4gICAgICAgIHRvID0gayArIGluc2VydENvdW50IC0gMTtcbiAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO2Vsc2UgZGVsZXRlIE9bdG9dO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoayA9IDA7IGsgPCBpbnNlcnRDb3VudDsgaysrKSB7XG4gICAgICBPW2sgKyBhY3R1YWxTdGFydF0gPSBhcmd1bWVudHNbayArIDJdO1xuICAgIH1cblxuICAgIE8ubGVuZ3RoID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpbnNlcnRDb3VudDtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkZSA9IGVudHJ5VmlydHVhbCRsO1xudmFyIHNwbGljZSQ0ID0gZW50cnlWaXJ0dWFsJGUoJ0FycmF5Jykuc3BsaWNlO1xuXG52YXIgaXNQcm90b3R5cGVPZiRlID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkYiA9IHNwbGljZSQ0O1xudmFyIEFycmF5UHJvdG90eXBlJGMgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBzcGxpY2UkMyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuc3BsaWNlO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGMgfHwgaXNQcm90b3R5cGVPZiRlKEFycmF5UHJvdG90eXBlJGMsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGMuc3BsaWNlID8gbWV0aG9kJGIgOiBvd247XG59O1xuXG52YXIgcGFyZW50JEUgPSBzcGxpY2UkMztcbnZhciBzcGxpY2UkMiA9IHBhcmVudCRFO1xuXG52YXIgc3BsaWNlJDEgPSBzcGxpY2UkMjtcblxudmFyICQkcSA9IF9leHBvcnQ7XG52YXIgJGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcy5pbmNsdWRlcztcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG5cbiQkcSh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWVcbn0sIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsXG4gIC8qICwgZnJvbUluZGV4ID0gMCAqL1xuICApIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pOyAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5cbnZhciBlbnRyeVZpcnR1YWwkZCA9IGVudHJ5VmlydHVhbCRsO1xudmFyIGluY2x1ZGVzJDQgPSBlbnRyeVZpcnR1YWwkZCgnQXJyYXknKS5pbmNsdWRlcztcblxudmFyIGlzT2JqZWN0JDggPSBpc09iamVjdCRqO1xudmFyIGNsYXNzb2YkNSA9IGNsYXNzb2ZSYXckMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkMiA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIE1BVENIJDEgPSB3ZWxsS25vd25TeW1ib2wkMignbWF0Y2gnKTsgLy8gYElzUmVnRXhwYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNyZWdleHBcblxudmFyIGlzUmVnZXhwID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0JDgoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSCQxXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjbGFzc29mJDUoaXQpID09ICdSZWdFeHAnKTtcbn07XG5cbnZhciBnbG9iYWwkZiA9IGdsb2JhbCRQO1xudmFyIGlzUmVnRXhwID0gaXNSZWdleHA7XG52YXIgVHlwZUVycm9yJDcgPSBnbG9iYWwkZi5UeXBlRXJyb3I7XG5cbnZhciBub3RBUmVnZXhwID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1JlZ0V4cChpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IkNyhcIlRoZSBtZXRob2QgZG9lc24ndCBhY2NlcHQgcmVndWxhciBleHByZXNzaW9uc1wiKTtcbiAgfVxuXG4gIHJldHVybiBpdDtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkMSA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sJDEoJ21hdGNoJyk7XG5cbnZhciBjb3JyZWN0SXNSZWdleHBMb2dpYyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICB2YXIgcmVnZXhwID0gLy4vO1xuXG4gIHRyeSB7XG4gICAgJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgIHRyeSB7XG4gICAgICByZWdleHBbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAvKiBlbXB0eSAqL1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciAkJHAgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJGEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIG5vdEFSZWdFeHAgPSBub3RBUmVnZXhwO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcbnZhciB0b1N0cmluZyQ0ID0gdG9TdHJpbmckODtcbnZhciBjb3JyZWN0SXNSZWdFeHBMb2dpYyA9IGNvcnJlY3RJc1JlZ2V4cExvZ2ljO1xudmFyIHN0cmluZ0luZGV4T2YgPSB1bmN1cnJ5VGhpcyRhKCcnLmluZGV4T2YpOyAvLyBgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNcblxuJCRwKHtcbiAgdGFyZ2V0OiAnU3RyaW5nJyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogIWNvcnJlY3RJc1JlZ0V4cExvZ2ljKCdpbmNsdWRlcycpXG59LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmdcbiAgLyogLCBwb3NpdGlvbiA9IDAgKi9cbiAgKSB7XG4gICAgcmV0dXJuICEhfnN0cmluZ0luZGV4T2YodG9TdHJpbmckNChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEodGhpcykpLCB0b1N0cmluZyQ0KG5vdEFSZWdFeHAoc2VhcmNoU3RyaW5nKSksIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkYyA9IGVudHJ5VmlydHVhbCRsO1xudmFyIGluY2x1ZGVzJDMgPSBlbnRyeVZpcnR1YWwkYygnU3RyaW5nJykuaW5jbHVkZXM7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGQgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIGFycmF5TWV0aG9kID0gaW5jbHVkZXMkNDtcbnZhciBzdHJpbmdNZXRob2QgPSBpbmNsdWRlcyQzO1xudmFyIEFycmF5UHJvdG90eXBlJGIgPSBBcnJheS5wcm90b3R5cGU7XG52YXIgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcblxudmFyIGluY2x1ZGVzJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmluY2x1ZGVzO1xuICBpZiAoaXQgPT09IEFycmF5UHJvdG90eXBlJGIgfHwgaXNQcm90b3R5cGVPZiRkKEFycmF5UHJvdG90eXBlJGIsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGIuaW5jbHVkZXMpIHJldHVybiBhcnJheU1ldGhvZDtcblxuICBpZiAodHlwZW9mIGl0ID09ICdzdHJpbmcnIHx8IGl0ID09PSBTdHJpbmdQcm90b3R5cGUgfHwgaXNQcm90b3R5cGVPZiRkKFN0cmluZ1Byb3RvdHlwZSwgaXQpICYmIG93biA9PT0gU3RyaW5nUHJvdG90eXBlLmluY2x1ZGVzKSB7XG4gICAgcmV0dXJuIHN0cmluZ01ldGhvZDtcbiAgfVxuXG4gIHJldHVybiBvd247XG59O1xuXG52YXIgcGFyZW50JEQgPSBpbmNsdWRlcyQyO1xudmFyIGluY2x1ZGVzJDEgPSBwYXJlbnQkRDtcblxudmFyIGluY2x1ZGVzID0gaW5jbHVkZXMkMTtcblxudmFyICQkbyA9IF9leHBvcnQ7XG52YXIgZmFpbHMkYiA9IGZhaWxzJHQ7XG52YXIgdG9PYmplY3QkNCA9IHRvT2JqZWN0JGU7XG52YXIgbmF0aXZlR2V0UHJvdG90eXBlT2YgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSBjb3JyZWN0UHJvdG90eXBlR2V0dGVyO1xudmFyIEZBSUxTX09OX1BSSU1JVElWRVMkMiA9IGZhaWxzJGIoZnVuY3Rpb24gKCkge1xuICBuYXRpdmVHZXRQcm90b3R5cGVPZigxKTtcbn0pOyAvLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG5cbiQkbyh7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUyQyLFxuICBzaGFtOiAhQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSXG59LCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiBuYXRpdmVHZXRQcm90b3R5cGVPZih0b09iamVjdCQ0KGl0KSk7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCRoID0gcGF0aCR5O1xudmFyIGdldFByb3RvdHlwZU9mJDYgPSBwYXRoJGguT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgcGFyZW50JEMgPSBnZXRQcm90b3R5cGVPZiQ2O1xudmFyIGdldFByb3RvdHlwZU9mJDUgPSBwYXJlbnQkQztcblxudmFyIGdldFByb3RvdHlwZU9mJDQgPSBnZXRQcm90b3R5cGVPZiQ1O1xuXG52YXIgJCRuID0gX2V4cG9ydDtcbnZhciAkZmlsdGVyID0gYXJyYXlJdGVyYXRpb24uZmlsdGVyO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDU7XG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ2ZpbHRlcicpOyAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG5cbiQkbih7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlRcbn0sIHtcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmblxuICAvKiAsIHRoaXNBcmcgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCRiID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgZmlsdGVyJDMgPSBlbnRyeVZpcnR1YWwkYignQXJyYXknKS5maWx0ZXI7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGMgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCRhID0gZmlsdGVyJDM7XG52YXIgQXJyYXlQcm90b3R5cGUkYSA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIGZpbHRlciQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5maWx0ZXI7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkYSB8fCBpc1Byb3RvdHlwZU9mJGMoQXJyYXlQcm90b3R5cGUkYSwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkYS5maWx0ZXIgPyBtZXRob2QkYSA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkQiA9IGZpbHRlciQyO1xudmFyIGZpbHRlciQxID0gcGFyZW50JEI7XG5cbnZhciBmaWx0ZXIgPSBmaWx0ZXIkMTtcblxudmFyIERFU0NSSVBUT1JTJDQgPSBkZXNjcmlwdG9ycztcbnZhciB1bmN1cnJ5VGhpcyQ5ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBvYmplY3RLZXlzID0gb2JqZWN0S2V5cyQ0O1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHRvSW5kZXhlZE9iamVjdCRiO1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlLmY7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSB1bmN1cnJ5VGhpcyQ5KCRwcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG52YXIgcHVzaCQyID0gdW5jdXJyeVRoaXMkOShbXS5wdXNoKTsgLy8gYE9iamVjdC57IGVudHJpZXMsIHZhbHVlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cbnZhciBjcmVhdGVNZXRob2QkMiA9IGZ1bmN0aW9uIChUT19FTlRSSUVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChpdCk7XG4gICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKE8pO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXk7XG5cbiAgICB3aGlsZSAobGVuZ3RoID4gaSkge1xuICAgICAga2V5ID0ga2V5c1tpKytdO1xuXG4gICAgICBpZiAoIURFU0NSSVBUT1JTJDQgfHwgcHJvcGVydHlJc0VudW1lcmFibGUoTywga2V5KSkge1xuICAgICAgICBwdXNoJDIocmVzdWx0LCBUT19FTlRSSUVTID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cbnZhciBvYmplY3RUb0FycmF5ID0ge1xuICAvLyBgT2JqZWN0LmVudHJpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5lbnRyaWVzXG4gIGVudHJpZXM6IGNyZWF0ZU1ldGhvZCQyKHRydWUpLFxuICAvLyBgT2JqZWN0LnZhbHVlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnZhbHVlc1xuICB2YWx1ZXM6IGNyZWF0ZU1ldGhvZCQyKGZhbHNlKVxufTtcblxudmFyICQkbSA9IF9leHBvcnQ7XG52YXIgJHZhbHVlcyA9IG9iamVjdFRvQXJyYXkudmFsdWVzOyAvLyBgT2JqZWN0LnZhbHVlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC52YWx1ZXNcblxuJCRtKHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZVxufSwge1xuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhPKSB7XG4gICAgcmV0dXJuICR2YWx1ZXMoTyk7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCRnID0gcGF0aCR5O1xucGF0aCRnLk9iamVjdC52YWx1ZXM7XG5cbnZhciB3aGl0ZXNwYWNlcyQ0ID0gJ1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MjAwMFxcdTIwMDFcXHUyMDAyJyArICdcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG5cbnZhciB1bmN1cnJ5VGhpcyQ4ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1O1xudmFyIHRvU3RyaW5nJDMgPSB0b1N0cmluZyQ4O1xudmFyIHdoaXRlc3BhY2VzJDMgPSB3aGl0ZXNwYWNlcyQ0O1xudmFyIHJlcGxhY2UkMSA9IHVuY3VycnlUaGlzJDgoJycucmVwbGFjZSk7XG52YXIgd2hpdGVzcGFjZSA9ICdbJyArIHdoaXRlc3BhY2VzJDMgKyAnXSc7XG52YXIgbHRyaW0gPSBSZWdFeHAoJ14nICsgd2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKicpO1xudmFyIHJ0cmltID0gUmVnRXhwKHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyokJyk7IC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbSwgdHJpbVN0YXJ0LCB0cmltRW5kLCB0cmltTGVmdCwgdHJpbVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblxudmFyIGNyZWF0ZU1ldGhvZCQxID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcykge1xuICAgIHZhciBzdHJpbmcgPSB0b1N0cmluZyQzKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHJlcGxhY2UkMShzdHJpbmcsIGx0cmltLCAnJyk7XG4gICAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSByZXBsYWNlJDEoc3RyaW5nLCBydHJpbSwgJycpO1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH07XG59O1xuXG52YXIgc3RyaW5nVHJpbSA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltTGVmdCwgdHJpbVN0YXJ0IH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1zdGFydFxuICBzdGFydDogY3JlYXRlTWV0aG9kJDEoMSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbVJpZ2h0LCB0cmltRW5kIH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1lbmRcbiAgZW5kOiBjcmVhdGVNZXRob2QkMSgyKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltXG4gIHRyaW06IGNyZWF0ZU1ldGhvZCQxKDMpXG59O1xuXG52YXIgZ2xvYmFsJGUgPSBnbG9iYWwkUDtcbnZhciBmYWlscyRhID0gZmFpbHMkdDtcbnZhciB1bmN1cnJ5VGhpcyQ3ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b1N0cmluZyQyID0gdG9TdHJpbmckODtcbnZhciB0cmltJDEgPSBzdHJpbmdUcmltLnRyaW07XG52YXIgd2hpdGVzcGFjZXMkMiA9IHdoaXRlc3BhY2VzJDQ7XG52YXIgJHBhcnNlSW50JDEgPSBnbG9iYWwkZS5wYXJzZUludDtcbnZhciBTeW1ib2wkMiA9IGdsb2JhbCRlLlN5bWJvbDtcbnZhciBJVEVSQVRPUiQxID0gU3ltYm9sJDIgJiYgU3ltYm9sJDIuaXRlcmF0b3I7XG52YXIgaGV4ID0gL15bKy1dPzB4L2k7XG52YXIgZXhlYyQxID0gdW5jdXJyeVRoaXMkNyhoZXguZXhlYyk7XG52YXIgRk9SQ0VEJDQgPSAkcGFyc2VJbnQkMSh3aGl0ZXNwYWNlcyQyICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50JDEod2hpdGVzcGFjZXMkMiArICcweDE2JykgIT09IDIyIC8vIE1TIEVkZ2UgMTgtIGJyb2tlbiB3aXRoIGJveGVkIHN5bWJvbHNcbnx8IElURVJBVE9SJDEgJiYgIWZhaWxzJGEoZnVuY3Rpb24gKCkge1xuICAkcGFyc2VJbnQkMShPYmplY3QoSVRFUkFUT1IkMSkpO1xufSk7IC8vIGBwYXJzZUludGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXBhcnNlaW50LXN0cmluZy1yYWRpeFxuXG52YXIgbnVtYmVyUGFyc2VJbnQgPSBGT1JDRUQkNCA/IGZ1bmN0aW9uIHBhcnNlSW50KHN0cmluZywgcmFkaXgpIHtcbiAgdmFyIFMgPSB0cmltJDEodG9TdHJpbmckMihzdHJpbmcpKTtcbiAgcmV0dXJuICRwYXJzZUludCQxKFMsIHJhZGl4ID4+PiAwIHx8IChleGVjJDEoaGV4LCBTKSA/IDE2IDogMTApKTtcbn0gOiAkcGFyc2VJbnQkMTtcblxudmFyICQkbCA9IF9leHBvcnQ7XG52YXIgJHBhcnNlSW50ID0gbnVtYmVyUGFyc2VJbnQ7IC8vIGBwYXJzZUludGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXBhcnNlaW50LXN0cmluZy1yYWRpeFxuXG4kJGwoe1xuICBnbG9iYWw6IHRydWUsXG4gIGZvcmNlZDogcGFyc2VJbnQgIT0gJHBhcnNlSW50XG59LCB7XG4gIHBhcnNlSW50OiAkcGFyc2VJbnRcbn0pO1xuXG52YXIgcGF0aCRmID0gcGF0aCR5O1xudmFyIF9wYXJzZUludCQyID0gcGF0aCRmLnBhcnNlSW50O1xuXG52YXIgcGFyZW50JEEgPSBfcGFyc2VJbnQkMjtcbnZhciBfcGFyc2VJbnQkMSA9IHBhcmVudCRBO1xuXG52YXIgX3BhcnNlSW50ID0gX3BhcnNlSW50JDE7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLWFycmF5LXByb3RvdHlwZS1pbmRleG9mIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cblxudmFyICQkayA9IF9leHBvcnQ7XG52YXIgdW5jdXJyeVRoaXMkNiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgJEluZGV4T2YgPSBhcnJheUluY2x1ZGVzLmluZGV4T2Y7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCQ0ID0gYXJyYXlNZXRob2RJc1N0cmljdCQ2O1xudmFyIHVuJEluZGV4T2YgPSB1bmN1cnJ5VGhpcyQ2KFtdLmluZGV4T2YpO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAhIXVuJEluZGV4T2YgJiYgMSAvIHVuJEluZGV4T2YoWzFdLCAxLCAtMCkgPCAwO1xudmFyIFNUUklDVF9NRVRIT0QkNCA9IGFycmF5TWV0aG9kSXNTdHJpY3QkNCgnaW5kZXhPZicpOyAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuXG4kJGsoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IE5FR0FUSVZFX1pFUk8gfHwgIVNUUklDVF9NRVRIT0QkNFxufSwge1xuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnRcbiAgLyogLCBmcm9tSW5kZXggPSAwICovXG4gICkge1xuICAgIHZhciBmcm9tSW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVSTyAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgPyB1biRJbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkgfHwgMCA6ICRJbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJGEgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBpbmRleE9mJDMgPSBlbnRyeVZpcnR1YWwkYSgnQXJyYXknKS5pbmRleE9mO1xuXG52YXIgaXNQcm90b3R5cGVPZiRiID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkOSA9IGluZGV4T2YkMztcbnZhciBBcnJheVByb3RvdHlwZSQ5ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgaW5kZXhPZiQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5pbmRleE9mO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDkgfHwgaXNQcm90b3R5cGVPZiRiKEFycmF5UHJvdG90eXBlJDksIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDkuaW5kZXhPZiA/IG1ldGhvZCQ5IDogb3duO1xufTtcblxudmFyIHBhcmVudCR6ID0gaW5kZXhPZiQyO1xudmFyIGluZGV4T2YkMSA9IHBhcmVudCR6O1xuXG52YXIgaW5kZXhPZiA9IGluZGV4T2YkMTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gZnVuY3Rpb25OYW1lLlBST1BFUjtcbnZhciBmYWlscyQ5ID0gZmFpbHMkdDtcbnZhciB3aGl0ZXNwYWNlcyQxID0gd2hpdGVzcGFjZXMkNDtcbnZhciBub24gPSAnXFx1MjAwQlxcdTAwODVcXHUxODBFJzsgLy8gY2hlY2sgdGhhdCBhIG1ldGhvZCB3b3JrcyB3aXRoIHRoZSBjb3JyZWN0IGxpc3Rcbi8vIG9mIHdoaXRlc3BhY2VzIGFuZCBoYXMgYSBjb3JyZWN0IG5hbWVcblxudmFyIHN0cmluZ1RyaW1Gb3JjZWQgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgcmV0dXJuIGZhaWxzJDkoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXdoaXRlc3BhY2VzJDFbTUVUSE9EX05BTUVdKCkgfHwgbm9uW01FVEhPRF9OQU1FXSgpICE9PSBub24gfHwgUFJPUEVSX0ZVTkNUSU9OX05BTUUgJiYgd2hpdGVzcGFjZXMkMVtNRVRIT0RfTkFNRV0ubmFtZSAhPT0gTUVUSE9EX05BTUU7XG4gIH0pO1xufTtcblxudmFyICQkaiA9IF9leHBvcnQ7XG52YXIgJHRyaW0gPSBzdHJpbmdUcmltLnRyaW07XG52YXIgZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCA9IHN0cmluZ1RyaW1Gb3JjZWQ7IC8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cblxuJCRqKHtcbiAgdGFyZ2V0OiAnU3RyaW5nJyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCgndHJpbScpXG59LCB7XG4gIHRyaW06IGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCQ5ID0gZW50cnlWaXJ0dWFsJGw7XG5lbnRyeVZpcnR1YWwkOSgnU3RyaW5nJykudHJpbTtcblxudmFyICQkaSA9IF9leHBvcnQ7XG52YXIgREVTQ1JJUFRPUlMkMyA9IGRlc2NyaXB0b3JzO1xudmFyIGNyZWF0ZSQ4ID0gb2JqZWN0Q3JlYXRlOyAvLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcblxuJCRpKHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgc2hhbTogIURFU0NSSVBUT1JTJDNcbn0sIHtcbiAgY3JlYXRlOiBjcmVhdGUkOFxufSk7XG5cbnZhciBwYXRoJGUgPSBwYXRoJHk7XG52YXIgT2JqZWN0JDIgPSBwYXRoJGUuT2JqZWN0O1xuXG52YXIgY3JlYXRlJDcgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCkge1xuICByZXR1cm4gT2JqZWN0JDIuY3JlYXRlKFAsIEQpO1xufTtcblxudmFyIHBhcmVudCR5ID0gY3JlYXRlJDc7XG52YXIgY3JlYXRlJDYgPSBwYXJlbnQkeTtcblxudmFyIGNyZWF0ZSQ1ID0gY3JlYXRlJDY7XG5cbnZhciAkJGggPSBfZXhwb3J0O1xudmFyIGdsb2JhbCRkID0gZ2xvYmFsJFA7XG52YXIgZ2V0QnVpbHRJbiQyID0gZ2V0QnVpbHRJbiQ5O1xudmFyIGFwcGx5JDMgPSBmdW5jdGlvbkFwcGx5O1xudmFyIHVuY3VycnlUaGlzJDUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJDggPSBmYWlscyR0O1xudmFyIEFycmF5JDEgPSBnbG9iYWwkZC5BcnJheTtcbnZhciAkc3RyaW5naWZ5ID0gZ2V0QnVpbHRJbiQyKCdKU09OJywgJ3N0cmluZ2lmeScpO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcyQ1KC8uLy5leGVjKTtcbnZhciBjaGFyQXQkMSA9IHVuY3VycnlUaGlzJDUoJycuY2hhckF0KTtcbnZhciBjaGFyQ29kZUF0ID0gdW5jdXJyeVRoaXMkNSgnJy5jaGFyQ29kZUF0KTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMkNSgnJy5yZXBsYWNlKTtcbnZhciBudW1iZXJUb1N0cmluZyA9IHVuY3VycnlUaGlzJDUoMS4wLnRvU3RyaW5nKTtcbnZhciB0ZXN0ZXIgPSAvW1xcdUQ4MDAtXFx1REZGRl0vZztcbnZhciBsb3cgPSAvXltcXHVEODAwLVxcdURCRkZdJC87XG52YXIgaGkgPSAvXltcXHVEQzAwLVxcdURGRkZdJC87XG5cbnZhciBmaXggPSBmdW5jdGlvbiAobWF0Y2gsIG9mZnNldCwgc3RyaW5nKSB7XG4gIHZhciBwcmV2ID0gY2hhckF0JDEoc3RyaW5nLCBvZmZzZXQgLSAxKTtcbiAgdmFyIG5leHQgPSBjaGFyQXQkMShzdHJpbmcsIG9mZnNldCArIDEpO1xuXG4gIGlmIChleGVjKGxvdywgbWF0Y2gpICYmICFleGVjKGhpLCBuZXh0KSB8fCBleGVjKGhpLCBtYXRjaCkgJiYgIWV4ZWMobG93LCBwcmV2KSkge1xuICAgIHJldHVybiAnXFxcXHUnICsgbnVtYmVyVG9TdHJpbmcoY2hhckNvZGVBdChtYXRjaCwgMCksIDE2KTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn07XG5cbnZhciBGT1JDRUQkMyA9IGZhaWxzJDgoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHN0cmluZ2lmeSgnXFx1REYwNlxcdUQ4MzQnKSAhPT0gJ1wiXFxcXHVkZjA2XFxcXHVkODM0XCInIHx8ICRzdHJpbmdpZnkoJ1xcdURFQUQnKSAhPT0gJ1wiXFxcXHVkZWFkXCInO1xufSk7XG5cbmlmICgkc3RyaW5naWZ5KSB7XG4gIC8vIGBKU09OLnN0cmluZ2lmeWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtanNvbi5zdHJpbmdpZnlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtd2VsbC1mb3JtZWQtc3RyaW5naWZ5XG4gICQkaCh7XG4gICAgdGFyZ2V0OiAnSlNPTicsXG4gICAgc3RhdDogdHJ1ZSxcbiAgICBmb3JjZWQ6IEZPUkNFRCQzXG4gIH0sIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0LCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5JDEobCk7IGkgPCBsOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIHZhciByZXN1bHQgPSBhcHBseSQzKCRzdHJpbmdpZnksIG51bGwsIGFyZ3MpO1xuICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT0gJ3N0cmluZycgPyByZXBsYWNlKHJlc3VsdCwgdGVzdGVyLCBmaXgpIDogcmVzdWx0O1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBwYXRoJGQgPSBwYXRoJHk7XG52YXIgYXBwbHkkMiA9IGZ1bmN0aW9uQXBwbHk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1qc29uIC0tIHNhZmVcblxuaWYgKCFwYXRoJGQuSlNPTikgcGF0aCRkLkpTT04gPSB7XG4gIHN0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnlcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG5cbnZhciBzdHJpbmdpZnkkMyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gIHJldHVybiBhcHBseSQyKHBhdGgkZC5KU09OLnN0cmluZ2lmeSwgbnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBwYXJlbnQkeCA9IHN0cmluZ2lmeSQzO1xudmFyIHN0cmluZ2lmeSQyID0gcGFyZW50JHg7XG5cbnZhciBzdHJpbmdpZnkkMSA9IHN0cmluZ2lmeSQyO1xuXG52YXIgZ2xvYmFsJGMgPSBnbG9iYWwkUDtcbnZhciBUeXBlRXJyb3IkNiA9IGdsb2JhbCRjLlR5cGVFcnJvcjtcblxudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEgPSBmdW5jdGlvbiAocGFzc2VkLCByZXF1aXJlZCkge1xuICBpZiAocGFzc2VkIDwgcmVxdWlyZWQpIHRocm93IFR5cGVFcnJvciQ2KCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICByZXR1cm4gcGFzc2VkO1xufTtcblxudmFyICQkZyA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJGIgPSBnbG9iYWwkUDtcbnZhciBhcHBseSQxID0gZnVuY3Rpb25BcHBseTtcbnZhciBpc0NhbGxhYmxlJDEgPSBpc0NhbGxhYmxlJGg7XG52YXIgdXNlckFnZW50JDIgPSBlbmdpbmVVc2VyQWdlbnQ7XG52YXIgYXJyYXlTbGljZSQxID0gYXJyYXlTbGljZSQ1O1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMTtcbnZhciBNU0lFID0gL01TSUUgLlxcLi8udGVzdCh1c2VyQWdlbnQkMik7IC8vIDwtIGRpcnR5IGllOS0gY2hlY2tcblxudmFyIEZ1bmN0aW9uJDEgPSBnbG9iYWwkYi5GdW5jdGlvbjtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaGFuZGxlciwgdGltZW91dFxuICAvKiAsIC4uLmFyZ3VtZW50cyAqL1xuICApIHtcbiAgICB2YXIgYm91bmRBcmdzID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSkgPiAyO1xuICAgIHZhciBmbiA9IGlzQ2FsbGFibGUkMShoYW5kbGVyKSA/IGhhbmRsZXIgOiBGdW5jdGlvbiQxKGhhbmRsZXIpO1xuICAgIHZhciBhcmdzID0gYm91bmRBcmdzID8gYXJyYXlTbGljZSQxKGFyZ3VtZW50cywgMikgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHNjaGVkdWxlcihib3VuZEFyZ3MgPyBmdW5jdGlvbiAoKSB7XG4gICAgICBhcHBseSQxKGZuLCB0aGlzLCBhcmdzKTtcbiAgICB9IDogZm4sIHRpbWVvdXQpO1xuICB9O1xufTsgLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCN0aW1lcnNcblxuXG4kJGcoe1xuICBnbG9iYWw6IHRydWUsXG4gIGJpbmQ6IHRydWUsXG4gIGZvcmNlZDogTVNJRVxufSwge1xuICAvLyBgc2V0VGltZW91dGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3RpbWVycy1hbmQtdXNlci1wcm9tcHRzLmh0bWwjZG9tLXNldHRpbWVvdXRcbiAgc2V0VGltZW91dDogd3JhcChnbG9iYWwkYi5zZXRUaW1lb3V0KSxcbiAgLy8gYHNldEludGVydmFsYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCNkb20tc2V0aW50ZXJ2YWxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsJGIuc2V0SW50ZXJ2YWwpXG59KTtcblxudmFyIHBhdGgkYyA9IHBhdGgkeTtcbnZhciBzZXRUaW1lb3V0JDIgPSBwYXRoJGMuc2V0VGltZW91dDtcblxudmFyIHNldFRpbWVvdXQkMSA9IHNldFRpbWVvdXQkMjtcblxudmFyIHRvT2JqZWN0JDMgPSB0b09iamVjdCRlO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHRvQWJzb2x1dGVJbmRleCQ1O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDUgPSBsZW5ndGhPZkFycmF5TGlrZSRkOyAvLyBgQXJyYXkucHJvdG90eXBlLmZpbGxgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsbFxuXG52YXIgYXJyYXlGaWxsID0gZnVuY3Rpb24gZmlsbCh2YWx1ZVxuLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi9cbikge1xuICB2YXIgTyA9IHRvT2JqZWN0JDModGhpcyk7XG4gIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ1KE8pO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpO1xuXG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuXG4gIHJldHVybiBPO1xufTtcblxudmFyICQkZiA9IF9leHBvcnQ7XG52YXIgZmlsbCQ0ID0gYXJyYXlGaWxsO1xuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsbFxuXG4kJGYoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlXG59LCB7XG4gIGZpbGw6IGZpbGwkNFxufSk7IC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcblxudmFyIGVudHJ5VmlydHVhbCQ4ID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgZmlsbCQzID0gZW50cnlWaXJ0dWFsJDgoJ0FycmF5JykuZmlsbDtcblxudmFyIGlzUHJvdG90eXBlT2YkYSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDggPSBmaWxsJDM7XG52YXIgQXJyYXlQcm90b3R5cGUkOCA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIGZpbGwkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuZmlsbDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ4IHx8IGlzUHJvdG90eXBlT2YkYShBcnJheVByb3RvdHlwZSQ4LCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQ4LmZpbGwgPyBtZXRob2QkOCA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkdyA9IGZpbGwkMjtcbnZhciBmaWxsJDEgPSBwYXJlbnQkdztcblxudmFyIGZpbGwgPSBmaWxsJDE7XG5cbi8qISBIYW1tZXIuSlMgLSB2Mi4wLjE3LXJjIC0gMjAxOS0xMi0xNlxuICogaHR0cDovL25hdmVyLmdpdGh1Yi5pby9lZ2pzXG4gKlxuICogRm9ya2VkIEJ5IE5hdmVyIGVnanNcbiAqIENvcHlyaWdodCAoYykgaGFtbWVyanNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkJDEoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0c190b19hc3NpZ25cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICovXG5cblxudmFyIGFzc2lnbjtcblxuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG5cbiAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn0gZWxzZSB7XG4gIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG59XG5cbnZhciBhc3NpZ24kMSA9IGFzc2lnbjtcbnZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnTW96JywgJ01TJywgJ21zJywgJ28nXTtcbnZhciBURVNUX0VMRU1FTlQgPSB0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyB7XG4gIHN0eWxlOiB7fVxufSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xudmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xudmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICBhYnMkMSA9IE1hdGguYWJzO1xudmFyIG5vdyA9IERhdGUubm93O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IHRoZSBwcmVmaXhlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gcHJlZml4ZWRcbiAqL1xuXG5mdW5jdGlvbiBwcmVmaXhlZChvYmosIHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXg7XG4gIHZhciBwcm9wO1xuICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XG4gICAgcHJlZml4ID0gVkVORE9SX1BSRUZJWEVTW2ldO1xuICAgIHByb3AgPSBwcmVmaXggPyBwcmVmaXggKyBjYW1lbFByb3AgOiBwcm9wZXJ0eTtcblxuICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jLCBuby1uZXN0ZWQtdGVybmFyeSAqL1xuXG5cbnZhciB3aW47XG5cbmlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIC8vIHdpbmRvdyBpcyB1bmRlZmluZWQgaW4gbm9kZS5qc1xuICB3aW4gPSB7fTtcbn0gZWxzZSB7XG4gIHdpbiA9IHdpbmRvdztcbn1cblxudmFyIFBSRUZJWEVEX1RPVUNIX0FDVElPTiA9IHByZWZpeGVkKFRFU1RfRUxFTUVOVC5zdHlsZSwgJ3RvdWNoQWN0aW9uJyk7XG52YXIgTkFUSVZFX1RPVUNIX0FDVElPTiA9IFBSRUZJWEVEX1RPVUNIX0FDVElPTiAhPT0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBnZXRUb3VjaEFjdGlvblByb3BzKCkge1xuICBpZiAoIU5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdG91Y2hNYXAgPSB7fTtcbiAgdmFyIGNzc1N1cHBvcnRzID0gd2luLkNTUyAmJiB3aW4uQ1NTLnN1cHBvcnRzO1xuICBbJ2F1dG8nLCAnbWFuaXB1bGF0aW9uJywgJ3Bhbi15JywgJ3Bhbi14JywgJ3Bhbi14IHBhbi15JywgJ25vbmUnXS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyBJZiBjc3Muc3VwcG9ydHMgaXMgbm90IHN1cHBvcnRlZCBidXQgdGhlcmUgaXMgbmF0aXZlIHRvdWNoLWFjdGlvbiBhc3N1bWUgaXQgc3VwcG9ydHNcbiAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgcmV0dXJuIHRvdWNoTWFwW3ZhbF0gPSBjc3NTdXBwb3J0cyA/IHdpbi5DU1Muc3VwcG9ydHMoJ3RvdWNoLWFjdGlvbicsIHZhbCkgOiB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHRvdWNoTWFwO1xufVxuXG52YXIgVE9VQ0hfQUNUSU9OX0NPTVBVVEUgPSAnY29tcHV0ZSc7XG52YXIgVE9VQ0hfQUNUSU9OX0FVVE8gPSAnYXV0byc7XG52YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcblxudmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWCA9ICdwYW4teCc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcbnZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xudmFyIE1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaTtcbnZhciBTVVBQT1JUX1RPVUNIID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbik7XG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbiwgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG52YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbnZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xudmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG52YXIgQ09NUFVURV9JTlRFUlZBTCA9IDI1O1xudmFyIElOUFVUX1NUQVJUID0gMTtcbnZhciBJTlBVVF9NT1ZFID0gMjtcbnZhciBJTlBVVF9FTkQgPSA0O1xudmFyIElOUFVUX0NBTkNFTCA9IDg7XG52YXIgRElSRUNUSU9OX05PTkUgPSAxO1xudmFyIERJUkVDVElPTl9MRUZUID0gMjtcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xudmFyIERJUkVDVElPTl9VUCA9IDg7XG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcbnZhciBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9MRUZUIHwgRElSRUNUSU9OX1JJR0hUO1xudmFyIERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9VUCB8IERJUkVDVElPTl9ET1dOO1xudmFyIERJUkVDVElPTl9BTEwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTDtcbnZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG52YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcbi8qKlxuICogQHByaXZhdGVcbiAqIHdhbGsgb2JqZWN0cyBhbmQgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgdmFyIGk7XG5cbiAgaWYgKCFvYmopIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICBvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gVFlQRV9GVU5DVElPTikge1xuICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuXG5cbmZ1bmN0aW9uIGluU3RyKHN0ciwgZmluZCkge1xuICByZXR1cm4gc3RyLmluZGV4T2YoZmluZCkgPiAtMTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5cblxuZnVuY3Rpb24gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucykge1xuICAvLyBub25lXG4gIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gIH1cblxuICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKTsgLy8gaWYgYm90aCBwYW4teCBhbmQgcGFuLXkgYXJlIHNldCAoZGlmZmVyZW50IHJlY29nbml6ZXJzXG4gIC8vIGZvciBkaWZmZXJlbnQgZGlyZWN0aW9ucywgZS5nLiBob3Jpem9udGFsIHBhbiBidXQgdmVydGljYWwgc3dpcGU/KVxuICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgLy8gcmVjb2duaXplcnMgd2lsbCB3b3JrLCBzaW5jZSB0aGUgYnJvd3NlciB3b3VsZCBoYW5kbGUgYWxsIHBhbm5pbmdcblxuICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICB9IC8vIHBhbi14IE9SIHBhbi15XG5cblxuICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XG4gIH0gLy8gbWFuaXB1bGF0aW9uXG5cblxuICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcbiAgfVxuXG4gIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBUb3VjaEFjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRvdWNoQWN0aW9uKG1hbmFnZXIsIHZhbHVlKSB7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLnNldCh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gVG91Y2hBY3Rpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyBmaW5kIG91dCB0aGUgdG91Y2gtYWN0aW9uIGJ5IHRoZSBldmVudCBoYW5kbGVyc1xuICAgIGlmICh2YWx1ZSA9PT0gVE9VQ0hfQUNUSU9OX0NPTVBVVEUpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5jb21wdXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04gJiYgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUgJiYgVE9VQ0hfQUNUSU9OX01BUFt2YWx1ZV0pIHtcbiAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGp1c3QgcmUtc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZVxuICAgKi9cblxuXG4gIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHZhbHVlXG4gICAqL1xuXG5cbiAgX3Byb3RvLmNvbXB1dGUgPSBmdW5jdGlvbiBjb21wdXRlKCkge1xuICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgZWFjaCh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsIGZ1bmN0aW9uIChyZWNvZ25pemVyKSB7XG4gICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xuICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucy5qb2luKCcgJykpO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uIGVhY2ggaW5wdXQgY3ljbGUgYW5kIHByb3ZpZGVzIHRoZSBwcmV2ZW50aW5nIG9mIHRoZSBicm93c2VyIGJlaGF2aW9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cblxuXG4gIF9wcm90by5wcmV2ZW50RGVmYXVsdHMgPSBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdHMoaW5wdXQpIHtcbiAgICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQub2Zmc2V0RGlyZWN0aW9uOyAvLyBpZiB0aGUgdG91Y2ggYWN0aW9uIGRpZCBwcmV2ZW50ZWQgb25jZSB0aGlzIHNlc3Npb25cblxuICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1ldO1xuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1hdO1xuXG4gICAgaWYgKGhhc05vbmUpIHtcbiAgICAgIC8vIGRvIG5vdCBwcmV2ZW50IGRlZmF1bHRzIGlmIHRoaXMgaXMgYSB0YXAgZ2VzdHVyZVxuICAgICAgdmFyIGlzVGFwUG9pbnRlciA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gMTtcbiAgICAgIHZhciBpc1RhcE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCAyO1xuICAgICAgdmFyIGlzVGFwVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgMjUwO1xuXG4gICAgICBpZiAoaXNUYXBQb2ludGVyICYmIGlzVGFwTW92ZW1lbnQgJiYgaXNUYXBUb3VjaFRpbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgIC8vIGBwYW4teCBwYW4teWAgbWVhbnMgYnJvd3NlciBoYW5kbGVzIGFsbCBzY3JvbGxpbmcvcGFubmluZywgZG8gbm90IHByZXZlbnRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaGFzTm9uZSB8fCBoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMIHx8IGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2ZW50U3JjKHNyY0V2ZW50KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XG4gICAqL1xuXG5cbiAgX3Byb3RvLnByZXZlbnRTcmMgPSBmdW5jdGlvbiBwcmV2ZW50U3JjKHNyY0V2ZW50KSB7XG4gICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcbiAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIHJldHVybiBUb3VjaEFjdGlvbjtcbn0oKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAqIEBtZXRob2QgaGFzUGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gKi9cblxuXG5mdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcbiAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoOyAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuXG4gIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRYKSxcbiAgICAgIHk6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFkpXG4gICAgfTtcbiAgfVxuXG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwO1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBwb2ludGVyc0xlbmd0aCkge1xuICAgIHggKz0gcG9pbnRlcnNbaV0uY2xpZW50WDtcbiAgICB5ICs9IHBvaW50ZXJzW2ldLmNsaWVudFk7XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxuICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcbiAgfTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gKi9cblxuXG5mdW5jdGlvbiBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCkge1xuICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgLy8gd2Ugb25seSBuZWVkIGNsaWVudFhZIGZvciB0aGUgY2FsY3VsYXRpb25zXG4gIHZhciBwb2ludGVycyA9IFtdO1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBpbnB1dC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICBwb2ludGVyc1tpXSA9IHtcbiAgICAgIGNsaWVudFg6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFgpLFxuICAgICAgY2xpZW50WTogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WSlcbiAgICB9O1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGltZVN0YW1wOiBub3coKSxcbiAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgY2VudGVyOiBnZXRDZW50ZXIocG9pbnRlcnMpLFxuICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gIH07XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtPYmplY3R9IHAxIHt4LCB5fVxuICogQHBhcmFtIHtPYmplY3R9IHAyIHt4LCB5fVxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgfVxuXG4gIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dO1xuICB2YXIgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMVxuICogQHBhcmFtIHtPYmplY3R9IHAyXG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICBwcm9wcyA9IFBST1BTX1hZO1xuICB9XG5cbiAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV07XG4gIHZhciB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xuICB9XG5cbiAgaWYgKGFicyQxKHgpID49IGFicyQxKHkpKSB7XG4gICAgcmV0dXJuIHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gIH1cblxuICByZXR1cm4geSA8IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlcjsgLy8gbGV0IHsgb2Zmc2V0RGVsdGE6b2Zmc2V0ID0ge30sIHByZXZEZWx0YSA9IHt9LCBwcmV2SW5wdXQgPSB7fSB9ID0gc2Vzc2lvbjtcbiAgLy8ganNjcyB0aHJvd2luZyBlcnJvciBvbiBkZWZhbHV0IGRlc3RydWN0dXJlZCB2YWx1ZXMgYW5kIHdpdGhvdXQgZGVmYXVsdHMgdGVzdHMgZmFpbFxuXG4gIHZhciBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xuICB2YXIgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgfHwge307XG4gIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcblxuICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSA9IHtcbiAgICAgIHg6IHByZXZJbnB1dC5kZWx0YVggfHwgMCxcbiAgICAgIHk6IHByZXZJbnB1dC5kZWx0YVkgfHwgMFxuICAgIH07XG4gICAgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSA9IHtcbiAgICAgIHg6IGNlbnRlci54LFxuICAgICAgeTogY2VudGVyLnlcbiAgICB9O1xuICB9XG5cbiAgaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XG4gIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIHgsIHkpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4IC8gZGVsdGFUaW1lIHx8IDAsXG4gICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gIH07XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvciBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogbm8gc2NhbGUgaXMgMSwgYW5kIGdvZXMgZG93biB0byAwIHdoZW4gcGluY2hlZCB0b2dldGhlciwgYW5kIGJpZ2dlciB3aGVuIHBpbmNoZWQgb3V0XG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICovXG5cblxuZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0sIFBST1BTX0NMSUVOVF9YWSkgKyBnZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCkge1xuICB2YXIgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0O1xuICB2YXIgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXA7XG4gIHZhciB2ZWxvY2l0eTtcbiAgdmFyIHZlbG9jaXR5WDtcbiAgdmFyIHZlbG9jaXR5WTtcbiAgdmFyIGRpcmVjdGlvbjtcblxuICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9PSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHZhciBkZWx0YVggPSBpbnB1dC5kZWx0YVggLSBsYXN0LmRlbHRhWDtcbiAgICB2YXIgZGVsdGFZID0gaW5wdXQuZGVsdGFZIC0gbGFzdC5kZWx0YVk7XG4gICAgdmFyIHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICB2ZWxvY2l0eVggPSB2Lng7XG4gICAgdmVsb2NpdHlZID0gdi55O1xuICAgIHZlbG9jaXR5ID0gYWJzJDEodi54KSA+IGFicyQxKHYueSkgPyB2LnggOiB2Lnk7XG4gICAgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKTtcbiAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcbiAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XG4gICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XG4gICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XG4gICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gIH1cblxuICBpbnB1dC52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XG4gIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xufVxuLyoqXG4qIEBwcml2YXRlXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cblxuXG5mdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XG4gIHZhciBzZXNzaW9uID0gbWFuYWdlci5zZXNzaW9uO1xuICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoOyAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG5cbiAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICBzZXNzaW9uLmZpcnN0SW5wdXQgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gIH0gLy8gdG8gY29tcHV0ZSBzY2FsZSBhbmQgcm90YXRpb24gd2UgbmVlZCB0byBzdG9yZSB0aGUgbXVsdGlwbGUgdG91Y2hlc1xuXG5cbiAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gIH1cblxuICB2YXIgZmlyc3RJbnB1dCA9IHNlc3Npb24uZmlyc3RJbnB1dCxcbiAgICAgIGZpcnN0TXVsdGlwbGUgPSBzZXNzaW9uLmZpcnN0TXVsdGlwbGU7XG4gIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcbiAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlciA9IGdldENlbnRlcihwb2ludGVycyk7XG4gIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICBpbnB1dC5kZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBmaXJzdElucHV0LnRpbWVTdGFtcDtcbiAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gIGlucHV0LmRpc3RhbmNlID0gZ2V0RGlzdGFuY2Uob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gIGlucHV0Lm9mZnNldERpcmVjdGlvbiA9IGdldERpcmVjdGlvbihpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gIHZhciBvdmVyYWxsVmVsb2NpdHkgPSBnZXRWZWxvY2l0eShpbnB1dC5kZWx0YVRpbWUsIGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WCA9IG92ZXJhbGxWZWxvY2l0eS54O1xuICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZID0gb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gIGlucHV0Lm92ZXJhbGxWZWxvY2l0eSA9IGFicyQxKG92ZXJhbGxWZWxvY2l0eS54KSA+IGFicyQxKG92ZXJhbGxWZWxvY2l0eS55KSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XG4gIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG4gIGlucHV0Lm1heFBvaW50ZXJzID0gIXNlc3Npb24ucHJldklucHV0ID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogaW5wdXQucG9pbnRlcnMubGVuZ3RoID4gc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycztcbiAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTsgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcblxuICB2YXIgdGFyZ2V0ID0gbWFuYWdlci5lbGVtZW50O1xuICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgdmFyIHNyY0V2ZW50VGFyZ2V0O1xuXG4gIGlmIChzcmNFdmVudC5jb21wb3NlZFBhdGgpIHtcbiAgICBzcmNFdmVudFRhcmdldCA9IHNyY0V2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICB9IGVsc2UgaWYgKHNyY0V2ZW50LnBhdGgpIHtcbiAgICBzcmNFdmVudFRhcmdldCA9IHNyY0V2ZW50LnBhdGhbMF07XG4gIH0gZWxzZSB7XG4gICAgc3JjRXZlbnRUYXJnZXQgPSBzcmNFdmVudC50YXJnZXQ7XG4gIH1cblxuICBpZiAoaGFzUGFyZW50KHNyY0V2ZW50VGFyZ2V0LCB0YXJnZXQpKSB7XG4gICAgdGFyZ2V0ID0gc3JjRXZlbnRUYXJnZXQ7XG4gIH1cblxuICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5cblxuZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgdmFyIHBvaW50ZXJzTGVuID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoO1xuICB2YXIgY2hhbmdlZFBvaW50ZXJzTGVuID0gaW5wdXQuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aDtcbiAgdmFyIGlzRmlyc3QgPSBldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMDtcbiAgdmFyIGlzRmluYWwgPSBldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiBwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMDtcbiAgaW5wdXQuaXNGaXJzdCA9ICEhaXNGaXJzdDtcbiAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICBpZiAoaXNGaXJzdCkge1xuICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICB9IC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuXG5cbiAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlOyAvLyBjb21wdXRlIHNjYWxlLCByb3RhdGlvbiBldGNcblxuICBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KTsgLy8gZW1pdCBzZWNyZXQgZXZlbnRcblxuICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcbiAgbWFuYWdlci5yZWNvZ25pemUoaW5wdXQpO1xuICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICovXG5cblxuZnVuY3Rpb24gc3BsaXRTdHIoc3RyKSB7XG4gIHJldHVybiBzdHIudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogYWRkRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IHRoZSB3aW5kb3cgb2JqZWN0IG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICovXG5cblxuZnVuY3Rpb24gZ2V0V2luZG93Rm9yRWxlbWVudChlbGVtZW50KSB7XG4gIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93IHx8IHdpbmRvdztcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDsgLy8gc21hbGxlciB3cmFwcGVyIGFyb3VuZCB0aGUgaGFuZGxlciwgZm9yIHRoZSBzY29wZSBhbmQgdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG1hbmFnZXIsXG4gICAgLy8gc28gd2hlbiBkaXNhYmxlZCB0aGUgaW5wdXQgZXZlbnRzIGFyZSBjb21wbGV0ZWx5IGJ5cGFzc2VkLlxuXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgKiBAdmlydHVhbFxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBJbnB1dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKCkge307XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICovXG5cblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIHRoaXMuZXZUYXJnZXQgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB1bmJpbmQgdGhlIGV2ZW50c1xuICAgKi9cblxuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLmV2RWwgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgdGhpcy5ldlRhcmdldCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2V2luICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgfTtcblxuICByZXR1cm4gSW5wdXQ7XG59KCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gKi9cblxuXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gIGlmIChzcmMuaW5kZXhPZiAmJiAhZmluZEJ5S2V5KSB7XG4gICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgaWYgKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kIHx8ICFmaW5kQnlLZXkgJiYgc3JjW2ldID09PSBmaW5kKSB7XG4gICAgICAgIC8vIGRvIG5vdCB1c2UgPT09IGhlcmUsIHRlc3QgZmFpbHNcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cbn1cblxudmFyIFBPSU5URVJfSU5QVVRfTUFQID0ge1xuICBwb2ludGVyZG93bjogSU5QVVRfU1RBUlQsXG4gIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICBwb2ludGVydXA6IElOUFVUX0VORCxcbiAgcG9pbnRlcmNhbmNlbDogSU5QVVRfQ0FOQ0VMLFxuICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbn07IC8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG5cbnZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAzOiBJTlBVVF9UWVBFX1BFTixcbiAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG5cbn07XG52YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJzsgLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5cbmlmICh3aW4uTVNQb2ludGVyRXZlbnQgJiYgIXdpbi5Qb2ludGVyRXZlbnQpIHtcbiAgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdNU1BvaW50ZXJEb3duJztcbiAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxuXG52YXIgUG9pbnRlckV2ZW50SW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbnB1dCkge1xuICBfaW5oZXJpdHNMb29zZShQb2ludGVyRXZlbnRJbnB1dCwgX0lucHV0KTtcblxuICBmdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgcHJvdG8gPSBQb2ludGVyRXZlbnRJbnB1dC5wcm90b3R5cGU7XG4gICAgcHJvdG8uZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgcHJvdG8uZXZXaW4gPSBQT0lOVEVSX1dJTkRPV19FVkVOVFM7XG4gICAgX3RoaXMgPSBfSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0b3JlID0gX3RoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXYpIHtcbiAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgIHZhciByZW1vdmVQb2ludGVyID0gZmFsc2U7XG4gICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XG4gICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xuICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuICAgIHZhciBpc1RvdWNoID0gcG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfVE9VQ0g7IC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG5cbiAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpOyAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG5cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcbiAgICB9IC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxuXG5cbiAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG5cblxuICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgcG9pbnRlcnM6IHN0b3JlLFxuICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG5cbiAgICBpZiAocmVtb3ZlUG9pbnRlcikge1xuICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXG4gICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQb2ludGVyRXZlbnRJbnB1dDtcbn0oSW5wdXQpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogY29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gcmVhbCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAqL1xuXG5cbmZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgIHZhciB2YWwgPSBrZXkgPyBzcmNbaV1ba2V5XSA6IHNyY1tpXTtcblxuICAgIGlmIChpbkFycmF5KHZhbHVlcywgdmFsKSA8IDApIHtcbiAgICAgIHJlc3VsdHMucHVzaChzcmNbaV0pO1xuICAgIH1cblxuICAgIHZhbHVlc1tpXSA9IHZhbDtcbiAgICBpKys7XG4gIH1cblxuICBpZiAoc29ydCkge1xuICAgIGlmICgha2V5KSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG52YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xuICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xudmFyIFRPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogTXVsdGktdXNlciB0b3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG52YXIgVG91Y2hJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lucHV0KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRvdWNoSW5wdXQsIF9JbnB1dCk7XG5cbiAgZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBUb3VjaElucHV0LnByb3RvdHlwZS5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgX3RoaXMgPSBfSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnRhcmdldElkcyA9IHt9OyAvLyB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUb3VjaElucHV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXYpIHtcbiAgICB2YXIgdHlwZSA9IFRPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcbiAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUb3VjaElucHV0O1xufShJbnB1dCk7XG5cbmZ1bmN0aW9uIGdldFRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgdmFyIGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7IC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG5cbiAgaWYgKHR5cGUgJiAoSU5QVVRfU1RBUlQgfCBJTlBVVF9NT1ZFKSAmJiBhbGxUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHRhcmdldElkc1thbGxUb3VjaGVzWzBdLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICByZXR1cm4gW2FsbFRvdWNoZXMsIGFsbFRvdWNoZXNdO1xuICB9XG5cbiAgdmFyIGk7XG4gIHZhciB0YXJnZXRUb3VjaGVzO1xuICB2YXIgY2hhbmdlZFRvdWNoZXMgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcbiAgdmFyIGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW107XG4gIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDsgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuXG4gIHRhcmdldFRvdWNoZXMgPSBhbGxUb3VjaGVzLmZpbHRlcihmdW5jdGlvbiAodG91Y2gpIHtcbiAgICByZXR1cm4gaGFzUGFyZW50KHRvdWNoLnRhcmdldCwgdGFyZ2V0KTtcbiAgfSk7IC8vIGNvbGxlY3QgdG91Y2hlc1xuXG4gIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfSAvLyBmaWx0ZXIgY2hhbmdlZCB0b3VjaGVzIHRvIG9ubHkgY29udGFpbiB0b3VjaGVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3RlZCB0YXJnZXQgaWRzXG5cblxuICBpID0gMDtcblxuICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xuICAgIH0gLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcblxuXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgZGVsZXRlIHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXTtcbiAgICB9XG5cbiAgICBpKys7XG4gIH1cblxuICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBbLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSwgY2hhbmdlZFRhcmdldFRvdWNoZXNdO1xufVxuXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICBtb3VzZW1vdmU6IElOUFVUX01PVkUsXG4gIG1vdXNldXA6IElOUFVUX0VORFxufTtcbnZhciBNT1VTRV9FTEVNRU5UX0VWRU5UUyA9ICdtb3VzZWRvd24nO1xudmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogTW91c2UgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIE1vdXNlSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbnB1dCkge1xuICBfaW5oZXJpdHNMb29zZShNb3VzZUlucHV0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHByb3RvID0gTW91c2VJbnB1dC5wcm90b3R5cGU7XG4gICAgcHJvdG8uZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgIHByb3RvLmV2V2luID0gTU9VU0VfV0lORE9XX0VWRU5UUztcbiAgICBfdGhpcyA9IF9JbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gTW91c2VJbnB1dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTsgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG5cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9NT1ZFICYmIGV2LndoaWNoICE9PSAxKSB7XG4gICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XG4gICAgfSAvLyBtb3VzZSBtdXN0IGJlIGRvd25cblxuXG4gICAgaWYgKCF0aGlzLnByZXNzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1vdXNlSW5wdXQ7XG59KElucHV0KTtcbi8qKlxuICogQHByaXZhdGVcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICpcbiAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG5cbnZhciBERURVUF9USU1FT1VUID0gMjUwMDtcbnZhciBERURVUF9ESVNUQU5DRSA9IDI1O1xuXG5mdW5jdGlvbiBzZXRMYXN0VG91Y2goZXZlbnREYXRhKSB7XG4gIHZhciBfZXZlbnREYXRhJGNoYW5nZWRQb2kgPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzLFxuICAgICAgdG91Y2ggPSBfZXZlbnREYXRhJGNoYW5nZWRQb2lbMF07XG5cbiAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMucHJpbWFyeVRvdWNoKSB7XG4gICAgdmFyIGxhc3RUb3VjaCA9IHtcbiAgICAgIHg6IHRvdWNoLmNsaWVudFgsXG4gICAgICB5OiB0b3VjaC5jbGllbnRZXG4gICAgfTtcbiAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICB0aGlzLmxhc3RUb3VjaGVzLnB1c2gobGFzdFRvdWNoKTtcblxuICAgIHZhciByZW1vdmVMYXN0VG91Y2ggPSBmdW5jdGlvbiByZW1vdmVMYXN0VG91Y2goKSB7XG4gICAgICB2YXIgaSA9IGx0cy5pbmRleE9mKGxhc3RUb3VjaCk7XG5cbiAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgbHRzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2V0VGltZW91dChyZW1vdmVMYXN0VG91Y2gsIERFRFVQX1RJTUVPVVQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdLmlkZW50aWZpZXI7XG4gICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgdmFyIHggPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WDtcbiAgdmFyIHkgPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFzdFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdCA9IHRoaXMubGFzdFRvdWNoZXNbaV07XG4gICAgdmFyIGR4ID0gTWF0aC5hYnMoeCAtIHQueCk7XG4gICAgdmFyIGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG5cbiAgICBpZiAoZHggPD0gREVEVVBfRElTVEFOQ0UgJiYgZHkgPD0gREVEVVBfRElTVEFOQ0UpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFRvdWNoTW91c2VJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBUb3VjaE1vdXNlSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbnB1dCkge1xuICAgIF9pbmhlcml0c0xvb3NlKFRvdWNoTW91c2VJbnB1dCwgX0lucHV0KTtcblxuICAgIGZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dChfbWFuYWdlciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX3RoaXMgPSBfSW5wdXQuY2FsbCh0aGlzLCBfbWFuYWdlciwgY2FsbGJhY2spIHx8IHRoaXM7XG5cbiAgICAgIF90aGlzLmhhbmRsZXIgPSBmdW5jdGlvbiAobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKSB7XG4gICAgICAgIHZhciBpc1RvdWNoID0gaW5wdXREYXRhLnBvaW50ZXJUeXBlID09PSBJTlBVVF9UWVBFX1RPVUNIO1xuICAgICAgICB2YXIgaXNNb3VzZSA9IGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PT0gSU5QVVRfVFlQRV9NT1VTRTtcblxuICAgICAgICBpZiAoaXNNb3VzZSAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyB3aGVuIHdlJ3JlIGluIGEgdG91Y2ggZXZlbnQsIHJlY29yZCB0b3VjaGVzIHRvICBkZS1kdXBlIHN5bnRoZXRpYyBtb3VzZSBldmVudFxuXG5cbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICByZWNvcmRUb3VjaGVzLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZCQxKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQkMShfdGhpcykpLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91c2UgJiYgaXNTeW50aGV0aWNFdmVudC5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQkMShfYXNzZXJ0VGhpc0luaXRpYWxpemVkJDEoX3RoaXMpKSwgaW5wdXREYXRhKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KF90aGlzLm1hbmFnZXIsIF90aGlzLmhhbmRsZXIpO1xuICAgICAgX3RoaXMubW91c2UgPSBuZXcgTW91c2VJbnB1dChfdGhpcy5tYW5hZ2VyLCBfdGhpcy5oYW5kbGVyKTtcbiAgICAgIF90aGlzLnByaW1hcnlUb3VjaCA9IG51bGw7XG4gICAgICBfdGhpcy5sYXN0VG91Y2hlcyA9IFtdO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IFRvdWNoTW91c2VJbnB1dC5wcm90b3R5cGU7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuXG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy50b3VjaC5kZXN0cm95KCk7XG4gICAgICB0aGlzLm1vdXNlLmRlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvdWNoTW91c2VJbnB1dDtcbiAgfShJbnB1dCk7XG5cbiAgcmV0dXJuIFRvdWNoTW91c2VJbnB1dDtcbn0oKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcbiAgdmFyIFR5cGU7IC8vIGxldCBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgdmFyIGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcblxuICBpZiAoaW5wdXRDbGFzcykge1xuICAgIFR5cGUgPSBpbnB1dENsYXNzO1xuICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICBUeXBlID0gUG9pbnRlckV2ZW50SW5wdXQ7XG4gIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgVHlwZSA9IFRvdWNoSW5wdXQ7XG4gIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICBUeXBlID0gTW91c2VJbnB1dDtcbiAgfSBlbHNlIHtcbiAgICBUeXBlID0gVG91Y2hNb3VzZUlucHV0O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUeXBlKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaW52b2tlQXJyYXlBcmcoYXJnLCBmbiwgY29udGV4dCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgZWFjaChhcmcsIGNvbnRleHRbZm5dLCBjb250ZXh0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbnZhciBTVEFURV9CRUdBTiA9IDI7XG52YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XG52YXIgU1RBVEVfRU5ERUQgPSA4O1xudmFyIFNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9FTkRFRDtcbnZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcbnZhciBTVEFURV9GQUlMRUQgPSAzMjtcbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCBhIHVuaXF1ZSBpZFxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcbiAqL1xuXG52YXIgX3VuaXF1ZUlkID0gMTtcblxuZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG4gIHJldHVybiBfdW5pcXVlSWQrKztcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gIHZhciBtYW5hZ2VyID0gcmVjb2duaXplci5tYW5hZ2VyO1xuXG4gIGlmIChtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XG4gIH1cblxuICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gKiBAcGFyYW0ge2NvbnN0YW50fSBzdGF0ZVxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgIHJldHVybiAnY2FuY2VsJztcbiAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgIHJldHVybiAnbW92ZSc7XG4gIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAqXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICpcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gKlxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICogICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZWNvZ25pemVyXG4gKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuXG52YXIgUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICBlbmFibGU6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcbiAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsOyAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1JlY29nbml6ZXJ9XG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICAgIGFzc2lnbiQxKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7IC8vIGFsc28gdXBkYXRlIHRoZSB0b3VjaEFjdGlvbiwgaW4gY2FzZSBzb21ldGhpbmcgY2hhbmdlZCBhYm91dCB0aGUgZGlyZWN0aW9ucy9lbmFibGVkIHN0YXRlXG5cbiAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlY29nbml6ZVdpdGggPSBmdW5jdGlvbiByZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcbiAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG5cbiAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZHJvcCB0aGUgc2ltdWx0YW5lb3VzIGxpbmsuIGl0IGRvZXNudCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAqL1xuXG5cbiAgX3Byb3RvLmRyb3BSZWNvZ25pemVXaXRoID0gZnVuY3Rpb24gZHJvcFJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJlY29nbml6ZXIgY2FuIG9ubHkgcnVuIHdoZW4gYW4gb3RoZXIgaXMgZmFpbGluZ1xuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5yZXF1aXJlRmFpbHVyZSA9IGZ1bmN0aW9uIHJlcXVpcmVGYWlsdXJlKG90aGVyUmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgcmVxdWlyZUZhaWwgPSB0aGlzLnJlcXVpcmVGYWlsO1xuICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcblxuICAgIGlmIChpbkFycmF5KHJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpID09PSAtMSkge1xuICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xuICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5kcm9wUmVxdWlyZUZhaWx1cmUgPSBmdW5jdGlvbiBkcm9wUmVxdWlyZUZhaWx1cmUob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgdmFyIGluZGV4ID0gaW5BcnJheSh0aGlzLnJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpO1xuXG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgX3Byb3RvLmhhc1JlcXVpcmVGYWlsdXJlcyA9IGZ1bmN0aW9uIGhhc1JlcXVpcmVGYWlsdXJlcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaWYgdGhlIHJlY29nbml6ZXIgY2FuIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cblxuXG4gIF9wcm90by5jYW5SZWNvZ25pemVXaXRoID0gZnVuY3Rpb24gY2FuUmVjb2duaXplV2l0aChvdGhlclJlY29nbml6ZXIpIHtcbiAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogWW91IHNob3VsZCB1c2UgYHRyeUVtaXRgIGluc3RlYWQgb2YgYGVtaXRgIGRpcmVjdGx5IHRvIGNoZWNrXG4gICAqIHRoYXQgYWxsIHRoZSBuZWVkZWQgcmVjb2duaXplcnMgaGFzIGZhaWxlZCBiZWZvcmUgZW1pdHRpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cblxuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoZXZlbnQsIGlucHV0KTtcbiAgICB9IC8vICdwYW5zdGFydCcgYW5kICdwYW5tb3ZlJ1xuXG5cbiAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xuICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgIH1cblxuICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50KTsgLy8gc2ltcGxlICdldmVudE5hbWUnIGV2ZW50c1xuXG4gICAgaWYgKGlucHV0LmFkZGl0aW9uYWxFdmVudCkge1xuICAgICAgLy8gYWRkaXRpb25hbCBldmVudChwYW5sZWZ0LCBwYW5yaWdodCwgcGluY2hpbiwgcGluY2hvdXQuLi4pXG4gICAgICBlbWl0KGlucHV0LmFkZGl0aW9uYWxFdmVudCk7XG4gICAgfSAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxuXG5cbiAgICBpZiAoc3RhdGUgPj0gU1RBVEVfRU5ERUQpIHtcbiAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBDaGVjayB0aGF0IGFsbCB0aGUgcmVxdWlyZSBmYWlsdXJlIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQsXG4gICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG5cblxuICBfcHJvdG8udHJ5RW1pdCA9IGZ1bmN0aW9uIHRyeUVtaXQoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5jYW5FbWl0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoaW5wdXQpO1xuICAgIH0gLy8gaXQncyBmYWlsaW5nIGFueXdheVxuXG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY2FuIHdlIGVtaXQ/XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuXG4gIF9wcm90by5jYW5FbWl0ID0gZnVuY3Rpb24gY2FuRW1pdCgpIHtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XG4gICAgICBpZiAoISh0aGlzLnJlcXVpcmVGYWlsW2ldLnN0YXRlICYgKFNUQVRFX0ZBSUxFRCB8IFNUQVRFX1BPU1NJQkxFKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB1cGRhdGUgdGhlIHJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgKi9cblxuXG4gIF9wcm90by5yZWNvZ25pemUgPSBmdW5jdGlvbiByZWNvZ25pemUoaW5wdXREYXRhKSB7XG4gICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcbiAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xuICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGFzc2lnbiQxKHt9LCBpbnB1dERhdGEpOyAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cblxuICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyByZXNldCB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxuXG5cbiAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9SRUNPR05JWkVEIHwgU1RBVEVfQ0FOQ0VMTEVEIHwgU1RBVEVfRkFJTEVEKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSB0aGlzLnByb2Nlc3MoaW5wdXREYXRhQ2xvbmUpOyAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAvLyBzbyB0cmlnZ2VyIGFuIGV2ZW50XG5cbiAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgIHRoaXMudHJ5RW1pdChpbnB1dERhdGFDbG9uZSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcbiAgICogQHZpcnR1YWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgKiBAcmV0dXJucyB7Y29uc3RhbnR9IFNUQVRFXG4gICAqL1xuXG4gIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhpbnB1dERhdGEpIHt9O1xuICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICogQHZpcnR1YWxcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cblxuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge307XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXG4gICAqIEB2aXJ0dWFsXG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7fTtcblxuICByZXR1cm4gUmVjb2duaXplcjtcbn0oKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIEEgdGFwIGlzIHJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXG4gKiBiZXR3ZWVuIHRoZSBnaXZlbiBpbnRlcnZhbCBhbmQgcG9zaXRpb24uIFRoZSBkZWxheSBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVjb2duaXplIG11bHRpLXRhcHMgd2l0aG91dCBmaXJpbmdcbiAqIGEgc2luZ2xlIHRhcC5cbiAqXG4gKiBUaGUgZXZlbnREYXRhIGZyb20gdGhlIGVtaXR0ZWQgZXZlbnQgY29udGFpbnMgdGhlIHByb3BlcnR5IGB0YXBDb3VudGAsIHdoaWNoIGNvbnRhaW5zIHRoZSBhbW91bnQgb2ZcbiAqIG11bHRpLXRhcHMgYmVpbmcgcmVjb2duaXplZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5cblxudmFyIFRhcFJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRhcFJlY29nbml6ZXIsIF9SZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBUYXBSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgIGV2ZW50OiAndGFwJyxcbiAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgdGFwczogMSxcbiAgICAgIGludGVydmFsOiAzMDAsXG4gICAgICAvLyBtYXggdGltZSBiZXR3ZWVuIHRoZSBtdWx0aS10YXAgdGFwc1xuICAgICAgdGltZTogMjUwLFxuICAgICAgLy8gbWF4IHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgZG93biAobGlrZSBmaW5nZXIgb24gdGhlIHNjcmVlbilcbiAgICAgIHRocmVzaG9sZDogOSxcbiAgICAgIC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgICBwb3NUaHJlc2hvbGQ6IDEwXG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7IC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcblxuICAgIF90aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgX3RoaXMucENlbnRlciA9IGZhbHNlO1xuICAgIF90aGlzLl90aW1lciA9IG51bGw7XG4gICAgX3RoaXMuX2lucHV0ID0gbnVsbDtcbiAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRhcFJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XG4gIH07XG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGlucHV0KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgdmFyIHZhbGlkVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgb3B0aW9ucy50aW1lO1xuICAgIHRoaXMucmVzZXQoKTtcblxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiB0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgIH0gLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG5cblxuICAgIGlmICh2YWxpZE1vdmVtZW50ICYmIHZhbGlkVG91Y2hUaW1lICYmIHZhbGlkUG9pbnRlcnMpIHtcbiAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT09IElOUFVUX0VORCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyBpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCA6IHRydWU7XG4gICAgICB2YXIgdmFsaWRNdWx0aVRhcCA9ICF0aGlzLnBDZW50ZXIgfHwgZ2V0RGlzdGFuY2UodGhpcy5wQ2VudGVyLCBpbnB1dC5jZW50ZXIpIDwgb3B0aW9ucy5wb3NUaHJlc2hvbGQ7XG4gICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xuXG4gICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7IC8vIGlmIHRhcCBjb3VudCBtYXRjaGVzIHdlIGhhdmUgcmVjb2duaXplZCBpdCxcbiAgICAgIC8vIGVsc2UgaXQgaGFzIGJlZ2FuIHJlY29nbml6aW5nLi4uXG5cbiAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG5cbiAgICAgIGlmICh0YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XG4gICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxuICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCkpIHtcbiAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcblxuICAgICAgICAgICAgX3RoaXMyLnRyeUVtaXQoKTtcbiAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsKTtcbiAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICB9O1xuXG4gIF9wcm90by5mYWlsVGltZW91dCA9IGZ1bmN0aW9uIGZhaWxUaW1lb3V0KCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICB9LCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgfTtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGFwUmVjb2duaXplcjtcbn0oUmVjb2duaXplcik7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuXG5cbnZhciBBdHRyUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoQXR0clJlY29nbml6ZXIsIF9SZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBBdHRyUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBfUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFVzZWQgdG8gY2hlY2sgaWYgaXQgdGhlIHJlY29nbml6ZXIgcmVjZWl2ZXMgdmFsaWQgaW5wdXQsIGxpa2UgaW5wdXQuZGlzdGFuY2UgPiAxMC5cbiAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmVjb2duaXplZFxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBBdHRyUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICB2YXIgb3B0aW9uUG9pbnRlcnMgPSB0aGlzLm9wdGlvbnMucG9pbnRlcnM7XG4gICAgcmV0dXJuIG9wdGlvblBvaW50ZXJzID09PSAwIHx8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9uUG9pbnRlcnM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBQcm9jZXNzIHRoZSBpbnB1dCBhbmQgcmV0dXJuIHRoZSBzdGF0ZSBmb3IgdGhlIHJlY29nbml6ZXJcbiAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKiBAcmV0dXJucyB7Kn0gU3RhdGVcbiAgICovXG5cblxuICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXQpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG4gICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XG4gICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTsgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuXG4gICAgaWYgKGlzUmVjb2duaXplZCAmJiAoZXZlbnRUeXBlICYgSU5QVVRfQ0FOQ0VMIHx8ICFpc1ZhbGlkKSkge1xuICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0FOQ0VMTEVEO1xuICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfRU5ERUQ7XG4gICAgICB9IGVsc2UgaWYgKCEoc3RhdGUgJiBTVEFURV9CRUdBTikpIHtcbiAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DSEFOR0VEO1xuICAgIH1cblxuICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gIH07XG5cbiAgcmV0dXJuIEF0dHJSZWNvZ25pemVyO1xufShSZWNvZ25pemVyKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICogQHBhcmFtIHtjb25zdGFudH0gZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xuICBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fRE9XTikge1xuICAgIHJldHVybiAnZG93bic7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fVVApIHtcbiAgICByZXR1cm4gJ3VwJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUKSB7XG4gICAgcmV0dXJuICdsZWZ0JztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9SSUdIVCkge1xuICAgIHJldHVybiAncmlnaHQnO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUGFuXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBhbmQgbW92ZWQgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5cblxudmFyIFBhblJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BdHRyUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShQYW5SZWNvZ25pemVyLCBfQXR0clJlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIFBhblJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9BdHRyUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgIGV2ZW50OiAncGFuJyxcbiAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0FMTFxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICAgIF90aGlzLnBYID0gbnVsbDtcbiAgICBfdGhpcy5wWSA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBhblJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgIHZhciBhY3Rpb25zID0gW107XG5cbiAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1kpO1xuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb25zO1xuICB9O1xuXG4gIF9wcm90by5kaXJlY3Rpb25UZXN0ID0gZnVuY3Rpb24gZGlyZWN0aW9uVGVzdChpbnB1dCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XG4gICAgdmFyIGRpc3RhbmNlID0gaW5wdXQuZGlzdGFuY2U7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcbiAgICB2YXIgeSA9IGlucHV0LmRlbHRhWTsgLy8gbG9jayB0byBheGlzP1xuXG4gICAgaWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4gICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICBkaXJlY3Rpb24gPSB4ID09PSAwID8gRElSRUNUSU9OX05PTkUgOiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICBoYXNNb3ZlZCA9IHggIT09IHRoaXMucFg7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFYKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IHkgPT09IDAgPyBESVJFQ1RJT05fTk9ORSA6IHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgIGhhc01vdmVkID0geSAhPT0gdGhpcy5wWTtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgfTtcblxuICBfcHJvdG8uYXR0clRlc3QgPSBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKCAvLyByZXBsYWNlIHdpdGggYSBzdXBlciBjYWxsXG4gICAgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKTtcbiAgfTtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICB0aGlzLnBYID0gaW5wdXQuZGVsdGFYO1xuICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xuXG4gICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gUGFuUmVjb2duaXplcjtcbn0oQXR0clJlY29nbml6ZXIpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogU3dpcGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZpbmcgZmFzdCAodmVsb2NpdHkpLCB3aXRoIGVub3VnaCBkaXN0YW5jZSBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cblxuXG52YXIgU3dpcGVSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXR0clJlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3dpcGVSZWNvZ25pemVyLCBfQXR0clJlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIFN3aXBlUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3N3aXBlJyxcbiAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3dpcGVSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gUGFuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG91Y2hBY3Rpb24uY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uYXR0clRlc3QgPSBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgIHZhciB2ZWxvY2l0eTtcblxuICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eTtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVg7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WTtcbiAgICB9XG5cbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiYgaW5wdXQuZGlzdGFuY2UgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkICYmIGlucHV0Lm1heFBvaW50ZXJzID09PSB0aGlzLm9wdGlvbnMucG9pbnRlcnMgJiYgYWJzJDEodmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgfTtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0Lm9mZnNldERpcmVjdGlvbik7XG5cbiAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICB9XG5cbiAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gU3dpcGVSZWNvZ25pemVyO1xufShBdHRyUmVjb2duaXplcik7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBQaW5jaFxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXJzIGFyZSBtb3ZpbmcgdG93YXJkICh6b29tLWluKSBvciBhd2F5IGZyb20gZWFjaCBvdGhlciAoem9vbS1vdXQpLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5cblxudmFyIFBpbmNoUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBpbmNoUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICdwaW5jaCcsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICBwb2ludGVyczogMlxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBpbmNoUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gIH07XG5cbiAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiAoTWF0aC5hYnMoaW5wdXQuc2NhbGUgLSAxKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgfTtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgIHZhciBpbk91dCA9IGlucHV0LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JztcbiAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0O1xuICAgIH1cblxuICAgIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gUGluY2hSZWNvZ25pemVyO1xufShBdHRyUmVjb2duaXplcik7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBSb3RhdGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVyIGFyZSBtb3ZpbmcgaW4gYSBjaXJjdWxhciBtb3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cblxuXG52YXIgUm90YXRlUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJvdGF0ZVJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gUm90YXRlUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICBwb2ludGVyczogMlxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJvdGF0ZVJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICB9O1xuXG4gIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgfTtcblxuICByZXR1cm4gUm90YXRlUmVjb2duaXplcjtcbn0oQXR0clJlY29nbml6ZXIpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogUHJlc3NcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGZvciB4IG1zIHdpdGhvdXQgYW55IG1vdmVtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cblxuXG52YXIgUHJlc3NSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShQcmVzc1JlY29nbml6ZXIsIF9SZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBQcmVzc1JlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICdwcmVzcycsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIHRpbWU6IDI1MSxcbiAgICAgIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXG4gICAgICB0aHJlc2hvbGQ6IDlcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgICBfdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIF90aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFByZXNzUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gIH07XG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGlucHV0KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcbiAgICB0aGlzLl9pbnB1dCA9IGlucHV0OyAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcblxuICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCBpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcblxuICAgICAgICBfdGhpczIudHJ5RW1pdCgpO1xuICAgICAgfSwgb3B0aW9ucy50aW1lKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICB9O1xuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlucHV0ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgXCJ1cFwiLCBpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQcmVzc1JlY29nbml6ZXI7XG59KFJlY29nbml6ZXIpO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRvbUV2ZW50czogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgKiBXaGVuIHNldCB0byBgY29tcHV0ZWAgaXQgd2lsbCBtYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IHZhbHVlIGJhc2VkIG9uIHRoZSBhZGRlZCByZWNvZ25pemVycy5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgKi9cbiAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZW5hYmxlOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAqIENoYW5nZSB0aGUgcGFyZW50IGlucHV0IHRhcmdldCBlbGVtZW50LlxuICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cbiAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBpbnB1dENsYXNzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgKiBBZGQgdGhlbSB0byB0aGlzIG1ldGhvZCBhbmQgdGhleSB3aWxsIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIuXG4gICAqIEBuYW1lc3BhY2VcbiAgICovXG4gIGNzc1Byb3BzOiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgKi9cbiAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgKi9cbiAgICB0b3VjaFNlbGVjdDogXCJub25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIERpc2FibGVzIHRoZSBkZWZhdWx0IGNhbGxvdXQgc2hvd24gd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQuXG4gICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICogYSBjYWxsb3V0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsuIFRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBkaXNhYmxlIHRoYXQgY2FsbG91dC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAqL1xuICAgIHRvdWNoQ2FsbG91dDogXCJub25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgY29udGVudFpvb21pbmc6IFwibm9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgKi9cbiAgICB1c2VyRHJhZzogXCJub25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG4gICAgICogY2xpY2thYmxlIGVsZW1lbnQgaW4gaU9TLiBUaGlzIHByb3BlcnR5IG9iZXlzIHRoZSBhbHBoYSB2YWx1ZSwgaWYgc3BlY2lmaWVkLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ3JnYmEoMCwwLDAsMCknXG4gICAgICovXG4gICAgdGFwSGlnaGxpZ2h0Q29sb3I6IFwicmdiYSgwLDAsMCwwKVwiXG4gIH1cbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAqIFdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlciB0aGVzZSB3aWxsIGJlIHNraXBwZWQuXG4gKiBUaGlzIGlzIHNlcGFyYXRlZCB3aXRoIG90aGVyIGRlZmF1bHRzIGJlY2F1c2Ugb2YgdHJlZS1zaGFraW5nLlxuICogQHR5cGUge0FycmF5fVxuICovXG5cbnZhciBwcmVzZXQgPSBbW1JvdGF0ZVJlY29nbml6ZXIsIHtcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtQaW5jaFJlY29nbml6ZXIsIHtcbiAgZW5hYmxlOiBmYWxzZVxufSwgWydyb3RhdGUnXV0sIFtTd2lwZVJlY29nbml6ZXIsIHtcbiAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTFxufV0sIFtQYW5SZWNvZ25pemVyLCB7XG4gIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUxcbn0sIFsnc3dpcGUnXV0sIFtUYXBSZWNvZ25pemVyXSwgW1RhcFJlY29nbml6ZXIsIHtcbiAgZXZlbnQ6ICdkb3VibGV0YXAnLFxuICB0YXBzOiAyXG59LCBbJ3RhcCddXSwgW1ByZXNzUmVjb2duaXplcl1dO1xudmFyIFNUT1AgPSAxO1xudmFyIEZPUkNFRF9TVE9QID0gMjtcbi8qKlxuICogQHByaXZhdGVcbiAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gKi9cblxuZnVuY3Rpb24gdG9nZ2xlQ3NzUHJvcHMobWFuYWdlciwgYWRkKSB7XG4gIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuXG4gIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwcm9wO1xuICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgcHJvcCA9IHByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpO1xuXG4gICAgaWYgKGFkZCkge1xuICAgICAgbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSA9IGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdIHx8IFwiXCI7XG4gICAgfVxuICB9KTtcblxuICBpZiAoIWFkZCkge1xuICAgIG1hbmFnZXIub2xkQ3NzUHJvcHMgPSB7fTtcbiAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogdHJpZ2dlciBkb20gZXZlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICB2YXIgZ2VzdHVyZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgZ2VzdHVyZUV2ZW50LmluaXRFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gIGdlc3R1cmVFdmVudC5nZXN0dXJlID0gZGF0YTtcbiAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xufVxuLyoqXG4qIEBwcml2YXRlXG4gKiBNYW5hZ2VyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWFuYWdlcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbiQxKHt9LCBkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgcmVjb2duaXplciA9IF90aGlzLmFkZChuZXcgaXRlbVswXShpdGVtWzFdKSk7XG5cbiAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gTWFuYWdlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XG4gICAgYXNzaWduJDEodGhpcy5vcHRpb25zLCBvcHRpb25zKTsgLy8gT3B0aW9ucyB0aGF0IG5lZWQgYSBsaXR0bGUgbW9yZSBzZXR1cFxuXG4gICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcbiAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5wdXRUYXJnZXQpIHtcbiAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuaW5wdXQudGFyZ2V0ID0gb3B0aW9ucy5pbnB1dFRhcmdldDtcbiAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgKiBUaGlzIHNlc3Npb24gd2lsbCBiZSBkaXNjYXJkZWQsIHdoZW4gYSBuZXcgW2lucHV0XXN0YXJ0IGV2ZW50IGlzIGZpcmVkLlxuICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAqL1xuXG5cbiAgX3Byb3RvLnN0b3AgPSBmdW5jdGlvbiBzdG9wKGZvcmNlKSB7XG4gICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJ1biB0aGUgcmVjb2duaXplcnMhXG4gICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcbiAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICovXG5cblxuICBfcHJvdG8ucmVjb2duaXplID0gZnVuY3Rpb24gcmVjb2duaXplKGlucHV0RGF0YSkge1xuICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuXG4gICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gcnVuIHRoZSB0b3VjaC1hY3Rpb24gcG9seWZpbGxcblxuXG4gICAgdGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHMoaW5wdXREYXRhKTtcbiAgICB2YXIgcmVjb2duaXplcjtcbiAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzOyAvLyB0aGlzIGhvbGRzIHRoZSByZWNvZ25pemVyIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxuXG4gICAgdmFyIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXI7IC8vIHJlc2V0IHdoZW4gdGhlIGxhc3QgcmVjb2duaXplciBpcyByZWNvZ25pemVkXG4gICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXG5cbiAgICBpZiAoIWN1clJlY29nbml6ZXIgfHwgY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICAgIGN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgcmVjb2duaXplcnMubGVuZ3RoKSB7XG4gICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07IC8vIGZpbmQgb3V0IGlmIHdlIGFyZSBhbGxvd2VkIHRyeSB0byByZWNvZ25pemUgdGhlIGlucHV0IGZvciB0aGlzIG9uZS5cbiAgICAgIC8vIDEuICAgYWxsb3cgaWYgdGhlIHNlc3Npb24gaXMgTk9UIGZvcmNlZCBzdG9wcGVkIChzZWUgdGhlIC5zdG9wKCkgbWV0aG9kKVxuICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXG4gICAgICAvLyAgICAgIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgIC8vIDMuICAgYWxsb3cgaWYgdGhlIHJlY29nbml6ZXIgaXMgYWxsb3dlZCB0byBydW4gc2ltdWx0YW5lb3VzIHdpdGggdGhlIGN1cnJlbnQgcmVjb2duaXplZCByZWNvZ25pemVyLlxuICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXG5cbiAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxuICAgICAgIWN1clJlY29nbml6ZXIgfHwgcmVjb2duaXplciA9PT0gY3VyUmVjb2duaXplciB8fCAvLyAyXG4gICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7XG4gICAgICAgIC8vIDNcbiAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemUoaW5wdXREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY29nbml6ZXIucmVzZXQoKTtcbiAgICAgIH0gLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuXG5cbiAgICAgIGlmICghY3VyUmVjb2duaXplciAmJiByZWNvZ25pemVyLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEKSkge1xuICAgICAgICBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgICBjdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cbiAgICovXG5cblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KHJlY29nbml6ZXIpIHtcbiAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFJlY29nbml6ZXIpIHtcbiAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH1cblxuICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVjb2duaXplcnNbaV0ub3B0aW9ucy5ldmVudCA9PT0gcmVjb2duaXplcikge1xuICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZSBhZGQgYSByZWNvZ25pemVyIHRvIHRoZSBtYW5hZ2VyXG4gICAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE1hbmFnZXJ9XG4gICAqL1xuXG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChyZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsIFwiYWRkXCIsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIHJlbW92ZSBleGlzdGluZ1xuXG5cbiAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuXG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICB0aGlzLnJlbW92ZShleGlzdGluZyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nbml6ZXIpO1xuICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG4gICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgKi9cblxuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUocmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCBcInJlbW92ZVwiLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldFJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTsgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcblxuICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgdmFyIGluZGV4ID0gaW5BcnJheShyZWNvZ25pemVycywgdGFyZ2V0UmVjb2duaXplcik7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGJpbmQgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICovXG5cblxuICBfcHJvdG8ub24gPSBmdW5jdGlvbiBvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQgfHwgaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlIHVuYmluZCBldmVudCwgbGVhdmUgZW1pdCBibGFuayB0byByZW1vdmUgYWxsIGhhbmRsZXJzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICovXG5cblxuICBfcHJvdG8ub2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50cywgaGFuZGxlcikge1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVyc1tldmVudF0gJiYgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGUgZW1pdCBldmVudCB0byB0aGUgbGlzdGVuZXJzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cblxuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgZGF0YSkge1xuICAgIC8vIHdlIGFsc28gd2FudCB0byB0cmlnZ2VyIGRvbSBldmVudHNcbiAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICB9IC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxuXG5cbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuXG4gICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGF0YS50eXBlID0gZXZlbnQ7XG5cbiAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgICBpKys7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXG4gICAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XG4gICAqL1xuXG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIE1hbmFnZXI7XG59KCk7XG5cbnZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xuICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xudmFyIFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xudmFyIFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcbi8qKlxuICogQHByaXZhdGVcbiAqIFRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbnZhciBTaW5nbGVUb3VjaElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW5wdXQpIHtcbiAgX2luaGVyaXRzTG9vc2UoU2luZ2xlVG91Y2hJbnB1dCwgX0lucHV0KTtcblxuICBmdW5jdGlvbiBTaW5nbGVUb3VjaElucHV0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBwcm90byA9IFNpbmdsZVRvdWNoSW5wdXQucHJvdG90eXBlO1xuICAgIHByb3RvLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgcHJvdG8uZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICBfdGhpcyA9IF9JbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTaW5nbGVUb3VjaElucHV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXYpIHtcbiAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07IC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cblxuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTsgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxuXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTaW5nbGVUb3VjaElucHV0O1xufShJbnB1dCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgdmFyIGFsbCA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiB3cmFwIGEgbWV0aG9kIHdpdGggYSBkZXByZWNhdGlvbiB3YXJuaW5nIGFuZCBzdGFjayB0cmFjZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgdGhlIHN1cHBsaWVkIG1ldGhvZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShtZXRob2QsIG5hbWUsIG1lc3NhZ2UpIHtcbiAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9IFwiREVQUkVDQVRFRCBNRVRIT0Q6IFwiICsgbmFtZSArIFwiXFxuXCIgKyBtZXNzYWdlICsgXCIgQVQgXFxuXCI7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSBuZXcgRXJyb3IoJ2dldC1zdGFjay10cmFjZScpO1xuICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJykucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKS5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSwgJ3thbm9ueW1vdXN9KClAJykgOiAnVW5rbm93biBTdGFjayBUcmFjZSc7XG4gICAgdmFyIGxvZyA9IHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS53YXJuIHx8IHdpbmRvdy5jb25zb2xlLmxvZyk7XG5cbiAgICBpZiAobG9nKSB7XG4gICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlPWZhbHNlXVxuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG5cblxudmFyIGV4dGVuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoZGVzdCwgc3JjLCBtZXJnZSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgaWYgKCFtZXJnZSB8fCBtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgfVxuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIG1lcmdlIHRoZSB2YWx1ZXMgZnJvbSBzcmMgaW4gdGhlIGRlc3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBkZXN0IHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuIGJ5IHNyY1xuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xuXG52YXIgbWVyZ2UkMiA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoZGVzdCwgc3JjKSB7XG4gIHJldHVybiBleHRlbmQoZGVzdCwgc3JjLCB0cnVlKTtcbn0sICdtZXJnZScsICdVc2UgYGFzc2lnbmAuJyk7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gKi9cblxuZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xuICB2YXIgYmFzZVAgPSBiYXNlLnByb3RvdHlwZTtcbiAgdmFyIGNoaWxkUDtcbiAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gIGNoaWxkUC5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICBhc3NpZ24kMShjaGlsZFAsIHByb3BlcnRpZXMpO1xuICB9XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBzaW1wbGUgZnVuY3Rpb24gYmluZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cblxuXG5mdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBTaW1wbGUgd2F5IHRvIGNyZWF0ZSBhIG1hbmFnZXIgd2l0aCBhIGRlZmF1bHQgc2V0IG9mIHJlY29nbml6ZXJzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgSGFtbWVyJDIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgSGFtbWVyID1cbiAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQGNvbnN0IHtzdHJpbmd9XG4gICAgKi9cbiAgZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIF9leHRlbmRzKHtcbiAgICAgIHJlY29nbml6ZXJzOiBwcmVzZXQuY29uY2F0KClcbiAgICB9LCBvcHRpb25zKSk7XG4gIH07XG5cbiAgSGFtbWVyLlZFUlNJT04gPSBcIjIuMC4xNy1yY1wiO1xuICBIYW1tZXIuRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9BTEw7XG4gIEhhbW1lci5ESVJFQ1RJT05fRE9XTiA9IERJUkVDVElPTl9ET1dOO1xuICBIYW1tZXIuRElSRUNUSU9OX0xFRlQgPSBESVJFQ1RJT05fTEVGVDtcbiAgSGFtbWVyLkRJUkVDVElPTl9SSUdIVCA9IERJUkVDVElPTl9SSUdIVDtcbiAgSGFtbWVyLkRJUkVDVElPTl9VUCA9IERJUkVDVElPTl9VUDtcbiAgSGFtbWVyLkRJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0hPUklaT05UQUw7XG4gIEhhbW1lci5ESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVkVSVElDQUw7XG4gIEhhbW1lci5ESVJFQ1RJT05fTk9ORSA9IERJUkVDVElPTl9OT05FO1xuICBIYW1tZXIuRElSRUNUSU9OX0RPV04gPSBESVJFQ1RJT05fRE9XTjtcbiAgSGFtbWVyLklOUFVUX1NUQVJUID0gSU5QVVRfU1RBUlQ7XG4gIEhhbW1lci5JTlBVVF9NT1ZFID0gSU5QVVRfTU9WRTtcbiAgSGFtbWVyLklOUFVUX0VORCA9IElOUFVUX0VORDtcbiAgSGFtbWVyLklOUFVUX0NBTkNFTCA9IElOUFVUX0NBTkNFTDtcbiAgSGFtbWVyLlNUQVRFX1BPU1NJQkxFID0gU1RBVEVfUE9TU0lCTEU7XG4gIEhhbW1lci5TVEFURV9CRUdBTiA9IFNUQVRFX0JFR0FOO1xuICBIYW1tZXIuU1RBVEVfQ0hBTkdFRCA9IFNUQVRFX0NIQU5HRUQ7XG4gIEhhbW1lci5TVEFURV9FTkRFRCA9IFNUQVRFX0VOREVEO1xuICBIYW1tZXIuU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gIEhhbW1lci5TVEFURV9DQU5DRUxMRUQgPSBTVEFURV9DQU5DRUxMRUQ7XG4gIEhhbW1lci5TVEFURV9GQUlMRUQgPSBTVEFURV9GQUlMRUQ7XG4gIEhhbW1lci5NYW5hZ2VyID0gTWFuYWdlcjtcbiAgSGFtbWVyLklucHV0ID0gSW5wdXQ7XG4gIEhhbW1lci5Ub3VjaEFjdGlvbiA9IFRvdWNoQWN0aW9uO1xuICBIYW1tZXIuVG91Y2hJbnB1dCA9IFRvdWNoSW5wdXQ7XG4gIEhhbW1lci5Nb3VzZUlucHV0ID0gTW91c2VJbnB1dDtcbiAgSGFtbWVyLlBvaW50ZXJFdmVudElucHV0ID0gUG9pbnRlckV2ZW50SW5wdXQ7XG4gIEhhbW1lci5Ub3VjaE1vdXNlSW5wdXQgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gIEhhbW1lci5TaW5nbGVUb3VjaElucHV0ID0gU2luZ2xlVG91Y2hJbnB1dDtcbiAgSGFtbWVyLlJlY29nbml6ZXIgPSBSZWNvZ25pemVyO1xuICBIYW1tZXIuQXR0clJlY29nbml6ZXIgPSBBdHRyUmVjb2duaXplcjtcbiAgSGFtbWVyLlRhcCA9IFRhcFJlY29nbml6ZXI7XG4gIEhhbW1lci5QYW4gPSBQYW5SZWNvZ25pemVyO1xuICBIYW1tZXIuU3dpcGUgPSBTd2lwZVJlY29nbml6ZXI7XG4gIEhhbW1lci5QaW5jaCA9IFBpbmNoUmVjb2duaXplcjtcbiAgSGFtbWVyLlJvdGF0ZSA9IFJvdGF0ZVJlY29nbml6ZXI7XG4gIEhhbW1lci5QcmVzcyA9IFByZXNzUmVjb2duaXplcjtcbiAgSGFtbWVyLm9uID0gYWRkRXZlbnRMaXN0ZW5lcnM7XG4gIEhhbW1lci5vZmYgPSByZW1vdmVFdmVudExpc3RlbmVycztcbiAgSGFtbWVyLmVhY2ggPSBlYWNoO1xuICBIYW1tZXIubWVyZ2UgPSBtZXJnZSQyO1xuICBIYW1tZXIuZXh0ZW5kID0gZXh0ZW5kO1xuICBIYW1tZXIuYmluZEZuID0gYmluZEZuO1xuICBIYW1tZXIuYXNzaWduID0gYXNzaWduJDE7XG4gIEhhbW1lci5pbmhlcml0ID0gaW5oZXJpdDtcbiAgSGFtbWVyLmJpbmRGbiA9IGJpbmRGbjtcbiAgSGFtbWVyLnByZWZpeGVkID0gcHJlZml4ZWQ7XG4gIEhhbW1lci50b0FycmF5ID0gdG9BcnJheTtcbiAgSGFtbWVyLmluQXJyYXkgPSBpbkFycmF5O1xuICBIYW1tZXIudW5pcXVlQXJyYXkgPSB1bmlxdWVBcnJheTtcbiAgSGFtbWVyLnNwbGl0U3RyID0gc3BsaXRTdHI7XG4gIEhhbW1lci5ib29sT3JGbiA9IGJvb2xPckZuO1xuICBIYW1tZXIuaGFzUGFyZW50ID0gaGFzUGFyZW50O1xuICBIYW1tZXIuYWRkRXZlbnRMaXN0ZW5lcnMgPSBhZGRFdmVudExpc3RlbmVycztcbiAgSGFtbWVyLnJlbW92ZUV2ZW50TGlzdGVuZXJzID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnM7XG4gIEhhbW1lci5kZWZhdWx0cyA9IGFzc2lnbiQxKHt9LCBkZWZhdWx0cywge1xuICAgIHByZXNldDogcHJlc2V0XG4gIH0pO1xuICByZXR1cm4gSGFtbWVyO1xufSgpOyAvLyAgc3R5bGUgbG9hZGVyIGJ1dCBieSBzY3JpcHQgdGFnLCBub3QgYnkgdGhlIGxvYWRlci5cbnZhciBSZWFsSGFtbWVyID0gSGFtbWVyJDI7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDgobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIHN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChpc0FycmF5JDIobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDgobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkOChvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0MjE7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ4KG8sIG1pbkxlbik7IHZhciBuID0gc2xpY2UoX2NvbnRleHQyMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDIxLCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tJDMobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkOChvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDgoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG4vKipcclxuICogVXNlIHRoaXMgc3ltYm9sIHRvIGRlbGV0ZSBwcm9wZXJpZXMgaW4gZGVlcE9iamVjdEFzc2lnbi5cclxuICovXG5cbnZhciBERUxFVEUgPSBzeW1ib2woXCJERUxFVEVcIik7XG4vKipcclxuICogUHVyZSB2ZXJzaW9uIG9mIGRlZXBPYmplY3RBc3NpZ24sIGl0IGRvZXNuJ3QgbW9kaWZ5IGFueSBvZiBpdCdzIGFyZ3VtZW50cy5cclxuICpcclxuICogQHBhcmFtIGJhc2UgLSBUaGUgYmFzZSBvYmplY3QgdGhhdCBmdWxsZmlscyB0aGUgd2hvbGUgaW50ZXJmYWNlIFQuXHJcbiAqIEBwYXJhbSB1cGRhdGVzIC0gVXBkYXRlcyB0aGF0IG1heSBjaGFuZ2Ugb3IgZGVsZXRlIHByb3BzLlxyXG4gKiBAcmV0dXJucyBBIGJyYW5kIG5ldyBpbnN0YW5jZSB3aXRoIGFsbCB0aGUgc3VwcGxpZWQgb2JqZWN0cyBkZWVwbHkgbWVyZ2VkLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBwdXJlRGVlcE9iamVjdEFzc2lnbihiYXNlKSB7XG4gIHZhciBfY29udGV4dDtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdXBkYXRlcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdXBkYXRlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZGVlcE9iamVjdEFzc2lnbi5hcHBseSh2b2lkIDAsIGNvbmNhdChfY29udGV4dCA9IFt7fSwgYmFzZV0pLmNhbGwoX2NvbnRleHQsIHVwZGF0ZXMpKTtcbn1cbi8qKlxyXG4gKiBEZWVwIHZlcnNpb24gb2Ygb2JqZWN0IGFzc2lnbiB3aXRoIGFkZGl0aW9uYWwgZGVsZXRpbmcgYnkgdGhlIERFTEVURSBzeW1ib2wuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZXMgLSBPYmplY3RzIHRvIGJlIGRlZXBseSBtZXJnZWQuXHJcbiAqIEByZXR1cm5zIFRoZSBmaXJzdCBvYmplY3QgZnJvbSB2YWx1ZXMuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRlZXBPYmplY3RBc3NpZ24oKSB7XG4gIHZhciBtZXJnZWQgPSBkZWVwT2JqZWN0QXNzaWduTm9uZW50cnkuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICBzdHJpcERlbGV0ZShtZXJnZWQpO1xuICByZXR1cm4gbWVyZ2VkO1xufVxuLyoqXHJcbiAqIERlZXAgdmVyc2lvbiBvZiBvYmplY3QgYXNzaWduIHdpdGggYWRkaXRpb25hbCBkZWxldGluZyBieSB0aGUgREVMRVRFIHN5bWJvbC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBkb2Vzbid0IHN0cmlwIHRoZSBERUxFVEUgc3ltYm9scyBzbyB0aGV5IG1heSBlbmQgdXAgaW4gdGhlIGZpbmFsIG9iamVjdC5cclxuICogQHBhcmFtIHZhbHVlcyAtIE9iamVjdHMgdG8gYmUgZGVlcGx5IG1lcmdlZC5cclxuICogQHJldHVybnMgVGhlIGZpcnN0IG9iamVjdCBmcm9tIHZhbHVlcy5cclxuICovXG5cblxuZnVuY3Rpb24gZGVlcE9iamVjdEFzc2lnbk5vbmVudHJ5KCkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIHZhbHVlc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgaWYgKHZhbHVlcy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIHZhbHVlc1swXTtcbiAgfSBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID4gMikge1xuICAgIHZhciBfY29udGV4dDI7XG5cbiAgICByZXR1cm4gZGVlcE9iamVjdEFzc2lnbk5vbmVudHJ5LmFwcGx5KHZvaWQgMCwgY29uY2F0KF9jb250ZXh0MiA9IFtkZWVwT2JqZWN0QXNzaWduKHZhbHVlc1swXSwgdmFsdWVzWzFdKV0pLmNhbGwoX2NvbnRleHQyLCBfdG9Db25zdW1hYmxlQXJyYXkoc2xpY2UodmFsdWVzKS5jYWxsKHZhbHVlcywgMikpKSk7XG4gIH1cblxuICB2YXIgYSA9IHZhbHVlc1swXTtcbiAgdmFyIGIgPSB2YWx1ZXNbMV07XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDgob3duS2V5cyQ1KGIpKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBwcm9wID0gX3N0ZXAudmFsdWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChiLCBwcm9wKSkgO2Vsc2UgaWYgKGJbcHJvcF0gPT09IERFTEVURSkge1xuICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgIH0gZWxzZSBpZiAoYVtwcm9wXSAhPT0gbnVsbCAmJiBiW3Byb3BdICE9PSBudWxsICYmIF90eXBlb2YoYVtwcm9wXSkgPT09IFwib2JqZWN0XCIgJiYgX3R5cGVvZihiW3Byb3BdKSA9PT0gXCJvYmplY3RcIiAmJiAhaXNBcnJheSQyKGFbcHJvcF0pICYmICFpc0FycmF5JDIoYltwcm9wXSkpIHtcbiAgICAgICAgYVtwcm9wXSA9IGRlZXBPYmplY3RBc3NpZ25Ob25lbnRyeShhW3Byb3BdLCBiW3Byb3BdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFbcHJvcF0gPSBjbG9uZShiW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuXG4gIHJldHVybiBhO1xufVxuLyoqXHJcbiAqIERlZXAgY2xvbmUgZ2l2ZW4gb2JqZWN0IG9yIGFycmF5LiBJbiBjYXNlIG9mIHByaW1pdGl2ZSBzaW1wbHkgcmV0dXJuLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSAtIEFueXRoaW5nLlxyXG4gKiBAcmV0dXJucyBEZWVwIGNsb25lZCBvYmplY3QvYXJyYXkgb3IgdW5jaGFuZ2VkIGEuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgaWYgKGlzQXJyYXkkMihhKSkge1xuICAgIHJldHVybiBtYXAkMyhhKS5jYWxsKGEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNsb25lKHZhbHVlKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChfdHlwZW9mKGEpID09PSBcIm9iamVjdFwiICYmIGEgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZGVlcE9iamVjdEFzc2lnbk5vbmVudHJ5KHt9LCBhKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYTtcbiAgfVxufVxuLyoqXHJcbiAqIFN0cmlwIERFTEVURSBmcm9tIGdpdmVuIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIGEgLSBPYmplY3Qgd2hpY2ggbWF5IGNvbnRhaW4gREVMRVRFIGJ1dCB3b24ndCBhZnRlciB0aGlzIGlzIGV4ZWN1dGVkLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdHJpcERlbGV0ZShhKSB7XG4gIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0ga2V5cyQ0KGEpOyBfaSA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgcHJvcCA9IF9PYmplY3Qka2V5c1tfaV07XG5cbiAgICBpZiAoYVtwcm9wXSA9PT0gREVMRVRFKSB7XG4gICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2YoYVtwcm9wXSkgPT09IFwib2JqZWN0XCIgJiYgYVtwcm9wXSAhPT0gbnVsbCkge1xuICAgICAgc3RyaXBEZWxldGUoYVtwcm9wXSk7XG4gICAgfVxuICB9XG59XG4vKipcclxuICogU2VlZGFibGUsIGZhc3QgYW5kIHJlYXNvbmFibHkgZ29vZCAobm90IGNyeXB0byBidXQgbW9yZSB0aGFuIG9rYXkgZm9yIG91clxyXG4gKiBuZWVkcykgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIEFkYXB0ZWQgZnJvbSB7QGxpbmsgaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTEwNDI5MTAwNzM2L2h0dHA6Ly9iYWFnb2UuY29tOjgwL2VuL1JhbmRvbU11c2luZ3MvamF2YXNjcmlwdH0uXHJcbiAqIE9yaWdpbmFsIGFsZ29yaXRobSBjcmVhdGVkIGJ5IEpvaGFubmVzIEJhYWfDuGUgXFw8YmFhZ29lXFxAYmFhZ29lLmNvbVxcPiBpbiAyMDEwLlxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZSBhIHNlZWRlZCBwc2V1ZG8gcmFuZG9tIGdlbmVyYXRvciBiYXNlZCBvbiBBbGVhIGJ5IEpvaGFubmVzIEJhYWfDuGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzZWVkIC0gQWxsIHN1cHBsaWVkIGFyZ3VtZW50cyB3aWxsIGJlIHVzZWQgYXMgYSBzZWVkLiBJbiBjYXNlIG5vdGhpbmdcclxuICogaXMgc3VwcGxpZWQgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWQgdG8gc2VlZCB0aGUgZ2VuZXJhdG9yLlxyXG4gKiBAcmV0dXJucyBBIHJlYWR5IHRvIHVzZSBzZWVkZWQgZ2VuZXJhdG9yLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBBbGVhKCkge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHNlZWQgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBzZWVkW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4gQWxlYUltcGxlbWVudGF0aW9uKHNlZWQubGVuZ3RoID8gc2VlZCA6IFtub3ckMSgpXSk7XG59XG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgW1tBbGVhXV0gd2l0aG91dCB1c2VyIGlucHV0IHZhbGlkYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBzZWVkIC0gVGhlIGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gc2VlZCB0aGUgZ2VuZXJhdG9yLlxyXG4gKiBAcmV0dXJucyBBIHJlYWR5IHRvIHVzZSBzZWVkZWQgZ2VuZXJhdG9yLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBBbGVhSW1wbGVtZW50YXRpb24oc2VlZCkge1xuICB2YXIgX21hc2hTZWVkID0gbWFzaFNlZWQoc2VlZCksXG4gICAgICBfbWFzaFNlZWQyID0gX3NsaWNlZFRvQXJyYXkoX21hc2hTZWVkLCAzKSxcbiAgICAgIHMwID0gX21hc2hTZWVkMlswXSxcbiAgICAgIHMxID0gX21hc2hTZWVkMlsxXSxcbiAgICAgIHMyID0gX21hc2hTZWVkMlsyXTtcblxuICB2YXIgYyA9IDE7XG5cbiAgdmFyIHJhbmRvbSA9IGZ1bmN0aW9uIHJhbmRvbSgpIHtcbiAgICB2YXIgdCA9IDIwOTE2MzkgKiBzMCArIGMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuXG4gICAgczAgPSBzMTtcbiAgICBzMSA9IHMyO1xuICAgIHJldHVybiBzMiA9IHQgLSAoYyA9IHQgfCAwKTtcbiAgfTtcblxuICByYW5kb20udWludDMyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICB9OyAvLyAyXjMyXG5cblxuICByYW5kb20uZnJhY3Q1MyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmFuZG9tKCkgKyAocmFuZG9tKCkgKiAweDIwMDAwMCB8IDApICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjtcbiAgfTsgLy8gMl4tNTNcblxuXG4gIHJhbmRvbS5hbGdvcml0aG0gPSBcIkFsZWFcIjtcbiAgcmFuZG9tLnNlZWQgPSBzZWVkO1xuICByYW5kb20udmVyc2lvbiA9IFwiMC45XCI7XG4gIHJldHVybiByYW5kb207XG59XG4vKipcclxuICogVHVybiBhcmJpdHJhcnkgZGF0YSBpbnRvIHZhbHVlcyBbW0FsZWFJbXBsZW1lbnRhdGlvbl1dIGNhbiB1c2UgdG8gZ2VuZXJhdGVcclxuICogcmFuZG9tIG51bWJlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBzZWVkIC0gQXJiaXRyYXJ5IGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIHNlZWQuXHJcbiAqIEByZXR1cm5zIFRocmVlIG51bWJlcnMgdG8gdXNlIGFzIGluaXRpYWwgdmFsdWVzIGZvciBbW0FsZWFJbXBsZW1lbnRhdGlvbl1dLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBtYXNoU2VlZCgpIHtcbiAgdmFyIG1hc2ggPSBNYXNoKCk7XG4gIHZhciBzMCA9IG1hc2goXCIgXCIpO1xuICB2YXIgczEgPSBtYXNoKFwiIFwiKTtcbiAgdmFyIHMyID0gbWFzaChcIiBcIik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBzMCAtPSBtYXNoKGkgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpXSk7XG5cbiAgICBpZiAoczAgPCAwKSB7XG4gICAgICBzMCArPSAxO1xuICAgIH1cblxuICAgIHMxIC09IG1hc2goaSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2ldKTtcblxuICAgIGlmIChzMSA8IDApIHtcbiAgICAgIHMxICs9IDE7XG4gICAgfVxuXG4gICAgczIgLT0gbWFzaChpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV0pO1xuXG4gICAgaWYgKHMyIDwgMCkge1xuICAgICAgczIgKz0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW3MwLCBzMSwgczJdO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtYXNoIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIG5vbnB1cmUgZnVuY3Rpb24gdGhhdCB0YWtlcyBhcmJpdHJhcnkgW1tNYXNoYWJsZV1dIGRhdGEgYW5kIHR1cm5zXHJcbiAqIHRoZW0gaW50byBudW1iZXJzLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBNYXNoKCkge1xuICB2YXIgbiA9IDB4ZWZjODI0OWQ7XG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzdHJpbmcgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgbiArPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIGggKj0gbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7IC8vIDJeMzJcbiAgICB9XG5cbiAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgfTtcbn1cbi8qKlxuICogU2V0dXAgYSBtb2NrIGhhbW1lci5qcyBvYmplY3QsIGZvciB1bml0IHRlc3RpbmcuXG4gKlxuICogSW5zcGlyYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS91YmVyL2RlY2suZ2wvcHVsbC82NThcbiAqXG4gKiBAcmV0dXJucyB7e29uOiBub29wLCBvZmY6IG5vb3AsIGRlc3Ryb3k6IG5vb3AsIGVtaXQ6IG5vb3AsIGdldDogZ2V0fX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGhhbW1lck1vY2soKSB7XG4gIHZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4gIHJldHVybiB7XG4gICAgb246IG5vb3AsXG4gICAgb2ZmOiBub29wLFxuICAgIGRlc3Ryb3k6IG5vb3AsXG4gICAgZW1pdDogbm9vcCxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNldDogbm9vcFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBIYW1tZXIkMSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuSGFtbWVyIHx8IFJlYWxIYW1tZXIgOiBmdW5jdGlvbiAoKSB7XG4gIC8vIGhhbW1lci5qcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBhIGJyb3dzZXIsIG5vdCBpbiBub2RlLmpzLiBSZXBsYWNpbmcgaXQgd2l0aCBhIG1vY2sgb2JqZWN0LlxuICByZXR1cm4gaGFtbWVyTW9jaygpO1xufTtcbi8qKlxuICogVHVybiBhbiBlbGVtZW50IGludG8gYW4gY2xpY2tUb1VzZSBlbGVtZW50LlxuICogV2hlbiBub3QgYWN0aXZlLCB0aGUgZWxlbWVudCBoYXMgYSB0cmFuc3BhcmVudCBvdmVybGF5LiBXaGVuIHRoZSBvdmVybGF5IGlzXG4gKiBjbGlja2VkLCB0aGUgbW9kZSBpcyBjaGFuZ2VkIHRvIGFjdGl2ZS5cbiAqIFdoZW4gYWN0aXZlLCB0aGUgZWxlbWVudCBpcyBkaXNwbGF5ZWQgd2l0aCBhIGJsdWUgYm9yZGVyIGFyb3VuZCBpdCwgYW5kXG4gKiB0aGUgaW50ZXJhY3RpdmUgY29udGVudHMgb2YgdGhlIGVsZW1lbnQgY2FuIGJlIHVzZWQuIFdoZW4gY2xpY2tlZCBvdXRzaWRlXG4gKiB0aGUgZWxlbWVudCwgdGhlIGVsZW1lbnRzIG1vZGUgaXMgY2hhbmdlZCB0byBpbmFjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lclxuICogQGNsYXNzIEFjdGl2YXRvclxuICovXG5cbmZ1bmN0aW9uIEFjdGl2YXRvciQxKGNvbnRhaW5lcikge1xuICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgX2NvbnRleHQzO1xuXG4gIHRoaXMuX2NsZWFudXBRdWV1ZSA9IFtdO1xuICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLl9kb20gPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgb3ZlcmxheTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICB9O1xuXG4gIHRoaXMuX2RvbS5vdmVybGF5LmNsYXNzTGlzdC5hZGQoXCJ2aXMtb3ZlcmxheVwiKTtcblxuICB0aGlzLl9kb20uY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2RvbS5vdmVybGF5KTtcblxuICB0aGlzLl9jbGVhbnVwUXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuX2RvbS5vdmVybGF5LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX3RoaXMuX2RvbS5vdmVybGF5KTtcbiAgfSk7XG5cbiAgdmFyIGhhbW1lciA9IEhhbW1lciQxKHRoaXMuX2RvbS5vdmVybGF5KTtcbiAgaGFtbWVyLm9uKFwidGFwXCIsIGJpbmQkNihfY29udGV4dDMgPSB0aGlzLl9vblRhcE92ZXJsYXkpLmNhbGwoX2NvbnRleHQzLCB0aGlzKSk7XG5cbiAgdGhpcy5fY2xlYW51cFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGhhbW1lci5kZXN0cm95KCk7IC8vIEZJWE1FOiBjbGVhbmluZyB1cCBoYW1tZXIgaW5zdGFuY2VzIGRvZXNuJ3Qgd29yayAoVGltZWxpbmUgbm90IHJlbW92ZWRcbiAgICAvLyBmcm9tIG1lbW9yeSlcbiAgfSk7IC8vIGJsb2NrIGFsbCB0b3VjaCBldmVudHMgKGV4Y2VwdCB0YXApXG5cblxuICB2YXIgZXZlbnRzID0gW1widGFwXCIsIFwiZG91YmxldGFwXCIsIFwicHJlc3NcIiwgXCJwaW5jaFwiLCBcInBhblwiLCBcInBhbnN0YXJ0XCIsIFwicGFubW92ZVwiLCBcInBhbmVuZFwiXTtcblxuICBmb3JFYWNoJDIoZXZlbnRzKS5jYWxsKGV2ZW50cywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaGFtbWVyLm9uKGV2ZW50LCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuICB9KTsgLy8gYXR0YWNoIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHdpbmRvdywgaW4gb3JkZXIgdG8gZGVhY3RpdmF0ZSB3aGVuIGNsaWNraW5nIG91dHNpZGUgdGhlIHRpbWVsaW5lXG5cblxuICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgIHRoaXMuX29uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghX2hhc1BhcmVudChldmVudC50YXJnZXQsIGNvbnRhaW5lcikpIHtcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9vbkNsaWNrKTtcblxuICAgIHRoaXMuX2NsZWFudXBRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF90aGlzLl9vbkNsaWNrKTtcbiAgICB9KTtcbiAgfSAvLyBwcmVwYXJlIGVzY2FwZSBrZXkgbGlzdGVuZXIgZm9yIGRlYWN0aXZhdGluZyB3aGVuIGFjdGl2ZVxuXG5cbiAgdGhpcy5fZXNjTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoXCJrZXlcIiBpbiBldmVudCA/IGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIiA6IGV2ZW50LmtleUNvZGUgPT09IDI3XG4gICAgLyogdGhlIGtleUNvZGUgaXMgZm9yIElFMTEgKi9cbiAgICApIHtcbiAgICAgIF90aGlzLmRlYWN0aXZhdGUoKTtcbiAgICB9XG4gIH07XG59IC8vIHR1cm4gaW50byBhbiBldmVudCBlbWl0dGVyXG5cblxuRW1pdHRlcihBY3RpdmF0b3IkMS5wcm90b3R5cGUpOyAvLyBUaGUgY3VycmVudGx5IGFjdGl2ZSBhY3RpdmF0b3JcblxuQWN0aXZhdG9yJDEuY3VycmVudCA9IG51bGw7XG4vKipcbiAqIERlc3Ryb3kgdGhlIGFjdGl2YXRvci4gQ2xlYW5zIHVwIGFsbCBjcmVhdGVkIERPTSBhbmQgZXZlbnQgbGlzdGVuZXJzXG4gKi9cblxuQWN0aXZhdG9yJDEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfY29udGV4dDQsIF9jb250ZXh0NTtcblxuICB0aGlzLmRlYWN0aXZhdGUoKTtcblxuICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDgocmV2ZXJzZShfY29udGV4dDQgPSBzcGxpY2UkMShfY29udGV4dDUgPSB0aGlzLl9jbGVhbnVwUXVldWUpLmNhbGwoX2NvbnRleHQ1LCAwKSkuY2FsbChfY29udGV4dDQpKSxcbiAgICAgIF9zdGVwMjtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBfc3RlcDIudmFsdWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMi5mKCk7XG4gIH1cbn07XG4vKipcbiAqIEFjdGl2YXRlIHRoZSBlbGVtZW50XG4gKiBPdmVybGF5IGlzIGhpZGRlbiwgZWxlbWVudCBpcyBkZWNvcmF0ZWQgd2l0aCBhIGJsdWUgc2hhZG93IGJvcmRlclxuICovXG5cblxuQWN0aXZhdG9yJDEucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyB3ZSBhbGxvdyBvbmx5IG9uZSBhY3RpdmUgYWN0aXZhdG9yIGF0IGEgdGltZVxuICBpZiAoQWN0aXZhdG9yJDEuY3VycmVudCkge1xuICAgIEFjdGl2YXRvciQxLmN1cnJlbnQuZGVhY3RpdmF0ZSgpO1xuICB9XG5cbiAgQWN0aXZhdG9yJDEuY3VycmVudCA9IHRoaXM7XG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5fZG9tLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG4gIHRoaXMuX2RvbS5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInZpcy1hY3RpdmVcIik7XG5cbiAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB0aGlzLmVtaXQoXCJhY3RpdmF0ZVwiKTsgLy8gdWdseSBoYWNrOiBiaW5kIEVTQyBhZnRlciBlbWl0dGluZyB0aGUgZXZlbnRzLCBhcyB0aGUgTmV0d29yayByZWJpbmRzIGFsbFxuICAvLyBrZXlib2FyZCBldmVudHMgb24gYSAnY2hhbmdlJyBldmVudFxuXG4gIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fZXNjTGlzdGVuZXIpO1xufTtcbi8qKlxuICogRGVhY3RpdmF0ZSB0aGUgZWxlbWVudFxuICogT3ZlcmxheSBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIHRoZSBlbGVtZW50XG4gKi9cblxuXG5BY3RpdmF0b3IkMS5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgdGhpcy5fZG9tLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblxuICB0aGlzLl9kb20uY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJ2aXMtYWN0aXZlXCIpO1xuXG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fZXNjTGlzdGVuZXIpO1xuICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gIHRoaXMuZW1pdChcImRlYWN0aXZhdGVcIik7XG59O1xuLyoqXG4gKiBIYW5kbGUgYSB0YXAgZXZlbnQ6IGFjdGl2YXRlIHRoZSBjb250YWluZXJcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5BY3RpdmF0b3IkMS5wcm90b3R5cGUuX29uVGFwT3ZlcmxheSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBhY3RpdmF0ZSB0aGUgY29udGFpbmVyXG4gIHRoaXMuYWN0aXZhdGUoKTtcbiAgZXZlbnQuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIHRoZSByZXF1ZXN0ZWQgcGFyZW50IGVsZW1lbnQgc29tZXdoZXJlIGluXG4gKiBpdHMgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBwYXJlbnQgaXMgZm91bmQgc29tZXdoZXJlIGluIHRoZVxuICogICAgICAgICAgICAgICAgICAgIGNoYWluIG9mIHBhcmVudCBub2Rlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBfaGFzUGFyZW50KGVsZW1lbnQsIHBhcmVudCkge1xuICB3aGlsZSAoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50ID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIHV0aWxpdHkgZnVuY3Rpb25zXG5cbnZhciBmdWxsSGV4UkUgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pO1xudmFyIHNob3J0SGV4UkUgPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pO1xudmFyIHJnYlJFID0gL15yZ2JcXCggKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqLCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICosICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKlxcKSQvaTtcbnZhciByZ2JhUkUgPSAvXnJnYmFcXCggKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqLCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICosICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKihbMDFdfDA/XFwuXFxkKykgKlxcKSQvaTtcbi8qKlxyXG4gKiBSZW1vdmUgZXZlcnl0aGluZyBpbiB0aGUgRE9NIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIERPTW9iamVjdCAtIE5vZGUgd2hvc2UgY2hpbGQgbm9kZXMgd2lsbCBiZSByZWN1cnNpdmVseSBkZWxldGVkLlxyXG4gKi9cblxuXG5mdW5jdGlvbiByZWN1cnNpdmVET01EZWxldGUoRE9Nb2JqZWN0KSB7XG4gIGlmIChET01vYmplY3QpIHtcbiAgICB3aGlsZSAoRE9Nb2JqZWN0Lmhhc0NoaWxkTm9kZXMoKSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIGNoaWxkID0gRE9Nb2JqZWN0LmZpcnN0Q2hpbGQ7XG5cbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICByZWN1cnNpdmVET01EZWxldGUoY2hpbGQpO1xuICAgICAgICBET01vYmplY3QucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIElucHV0IHZhbHVlIG9mIHVua25vd24gdHlwZS5cclxuICogQHJldHVybnMgVHJ1ZSBpZiBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn1cbi8qKlxyXG4gKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgb2JqZWN0IChub3QgcHJpbWl0aXZlIG9yIG51bGwpLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBJbnB1dCB2YWx1ZSBvZiB1bmtub3duIHR5cGUuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgbm90IG51bGwgb2JqZWN0LCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0JDcodmFsdWUpIHtcbiAgcmV0dXJuIF90eXBlb2YodmFsdWUpID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxuLyoqXHJcbiAqIENvcHkgcHJvcGVydHkgZnJvbSBiIHRvIGEgaWYgcHJvcGVydHkgcHJlc2VudCBpbiBhLlxyXG4gKiBJZiBwcm9wZXJ0eSBpbiBiIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwsIGRlbGV0ZSBpdCBpZiBgYWxsb3dEZWxldGlvbmAgc2V0LlxyXG4gKlxyXG4gKiBJbnRlcm5hbCBoZWxwZXIgcm91dGluZSwgc2hvdWxkIG5vdCBiZSBleHBvcnRlZC4gTm90IGFkZGVkIHRvIGBleHBvcnRzYCBmb3IgdGhhdCByZWFzb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gVGFyZ2V0IG9iamVjdC5cclxuICogQHBhcmFtIGIgLSBTb3VyY2Ugb2JqZWN0LlxyXG4gKiBAcGFyYW0gcHJvcCAtIE5hbWUgb2YgcHJvcGVydHkgdG8gY29weSBmcm9tIGIgdG8gYS5cclxuICogQHBhcmFtIGFsbG93RGVsZXRpb24gLSBJZiB0cnVlLCBkZWxldGUgcHJvcGVydHkgaW4gYSBpZiBleHBsaWNpdGx5IHNldCB0byBudWxsIGluIGIuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKSB7XG4gIHZhciBkb0RlbGV0aW9uID0gZmFsc2U7XG5cbiAgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICBkb0RlbGV0aW9uID0gYltwcm9wXSA9PT0gbnVsbCAmJiBhW3Byb3BdICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoZG9EZWxldGlvbikge1xuICAgIGRlbGV0ZSBhW3Byb3BdO1xuICB9IGVsc2Uge1xuICAgIGFbcHJvcF0gPSBiW3Byb3BdOyAvLyBSZW1lbWJlciwgdGhpcyBpcyBhIHJlZmVyZW5jZSBjb3B5IVxuICB9XG59XG4vKipcclxuICogRmlsbCBhbiBvYmplY3Qgd2l0aCBhIHBvc3NpYmx5IHBhcnRpYWxseSBkZWZpbmVkIG90aGVyIG9iamVjdC5cclxuICpcclxuICogT25seSBjb3BpZXMgdmFsdWVzIGZvciB0aGUgcHJvcGVydGllcyBhbHJlYWR5IHByZXNlbnQgaW4gYS5cclxuICogVGhhdCBtZWFucyBhbiBvYmplY3QgaXMgbm90IGNyZWF0ZWQgb24gYSBwcm9wZXJ0eSBpZiBvbmx5IHRoZSBiIG9iamVjdCBoYXMgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gVGhlIG9iamVjdCB0aGF0IHdpbGwgaGF2ZSBpdCdzIHByb3BlcnRpZXMgdXBkYXRlZC5cclxuICogQHBhcmFtIGIgLSBUaGUgb2JqZWN0IHdpdGggcHJvcGVydHkgdXBkYXRlcy5cclxuICogQHBhcmFtIGFsbG93RGVsZXRpb24gLSBJZiB0cnVlLCBkZWxldGUgcHJvcGVydGllcyBpbiBhIHRoYXQgYXJlIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgaW4gYi5cclxuICovXG5cblxuZnVuY3Rpb24gZmlsbElmRGVmaW5lZChhLCBiKSB7XG4gIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiBpdGVyYXRpb24gb2YgcHJvcGVydGllcyBvZiBhXG4gIC8vIE5PVEU6IHByb3RvdHlwZSBwcm9wZXJ0aWVzIGl0ZXJhdGVkIG92ZXIgYXMgd2VsbFxuICBmb3IgKHZhciBwcm9wIGluIGEpIHtcbiAgICBpZiAoYltwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYltwcm9wXSA9PT0gbnVsbCB8fCBfdHlwZW9mKGJbcHJvcF0pICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIE5vdGU6IHR5cGVvZiBudWxsID09PSAnb2JqZWN0J1xuICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYVByb3AgPSBhW3Byb3BdO1xuICAgICAgICB2YXIgYlByb3AgPSBiW3Byb3BdO1xuXG4gICAgICAgIGlmIChpc09iamVjdCQ3KGFQcm9wKSAmJiBpc09iamVjdCQ3KGJQcm9wKSkge1xuICAgICAgICAgIGZpbGxJZkRlZmluZWQoYVByb3AsIGJQcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHNlbGVjdGVkIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXHJcbiAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFByZXZpb3VzIHZlcnNpb24gb2YgdGhpcyByb3V0aW5lIGltcGxpZWQgdGhhdCBtdWx0aXBsZSBzb3VyY2Ugb2JqZWN0cyBjb3VsZFxyXG4gKiBiZSB1c2VkOyBob3dldmVyLCB0aGUgaW1wbGVtZW50YXRpb24gd2FzICoqd3JvbmcqKi4gU2luY2UgbXVsdGlwbGUgKFxcPjEpXHJcbiAqIHNvdXJjZXMgd2VyZW4ndCB1c2VkIGFueXdoZXJlIGluIHRoZSBgdmlzLmpzYCBjb2RlLCB0aGlzIGhhcyBiZWVuIHJlbW92ZWRcclxuICogQHBhcmFtIHByb3BzIC0gTmFtZXMgb2YgZmlyc3QtbGV2ZWwgcHJvcGVydGllcyB0byBjb3B5IG92ZXIuXHJcbiAqIEBwYXJhbSBhIC0gVGFyZ2V0IG9iamVjdC5cclxuICogQHBhcmFtIGIgLSBTb3VyY2Ugb2JqZWN0LlxyXG4gKiBAcGFyYW0gYWxsb3dEZWxldGlvbiAtIElmIHRydWUsIGRlbGV0ZSBwcm9wZXJ0eSBpbiBhIGlmIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgaW4gYi5cclxuICogQHJldHVybnMgQXJndW1lbnQgYS5cclxuICovXG5cblxuZnVuY3Rpb24gc2VsZWN0aXZlRGVlcEV4dGVuZChwcm9wcywgYSwgYikge1xuICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIEFycmF5cyB0byBkZWVwRXh0ZW5kXG4gIGlmIChpc0FycmF5JDIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmRcIik7XG4gIH1cblxuICBmb3IgKHZhciBwID0gMDsgcCA8IHByb3BzLmxlbmd0aDsgcCsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1twXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcHJvcCkpIHtcbiAgICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYVtwcm9wXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgIGRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSwgZmFsc2UsIGFsbG93RGVsZXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0FycmF5JDIoYltwcm9wXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhO1xufVxuLyoqXHJcbiAqIEV4dGVuZCBvYmplY3QgYGFgIHdpdGggcHJvcGVydGllcyBvZiBvYmplY3QgYGJgLCBpZ25vcmluZyBwcm9wZXJ0aWVzIHdoaWNoXHJcbiAqIGFyZSBleHBsaWNpdGx5IHNwZWNpZmllZCB0byBiZSBleGNsdWRlZC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhlIHByb3BlcnRpZXMgb2YgYGJgIGFyZSBjb25zaWRlcmVkIGZvciBjb3B5aW5nLiBQcm9wZXJ0aWVzIHdoaWNoIGFyZVxyXG4gKiB0aGVtc2VsdmVzIG9iamVjdHMgYXJlIGFyZSBhbHNvIGV4dGVuZGVkLiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkXHJcbiAqIHZhbHVlcyBhcmUgY29waWVkLlxyXG4gKiBAcGFyYW0gcHJvcHNUb0V4Y2x1ZGUgLSBOYW1lcyBvZiBwcm9wZXJ0aWVzIHdoaWNoIHNob3VsZCAqbm90KiBiZSBjb3BpZWQuXHJcbiAqIEBwYXJhbSBhIC0gT2JqZWN0IHRvIGV4dGVuZC5cclxuICogQHBhcmFtIGIgLSBPYmplY3QgdG8gdGFrZSBwcm9wZXJ0aWVzIGZyb20gZm9yIGV4dGVuc2lvbi5cclxuICogQHBhcmFtIGFsbG93RGVsZXRpb24gLSBJZiB0cnVlLCBkZWxldGUgcHJvcGVydGllcyBpbiBhIHRoYXQgYXJlIGV4cGxpY2l0bHlcclxuICogc2V0IHRvIG51bGwgaW4gYi5cclxuICogQHJldHVybnMgQXJndW1lbnQgYS5cclxuICovXG5cblxuZnVuY3Rpb24gc2VsZWN0aXZlTm90RGVlcEV4dGVuZChwcm9wc1RvRXhjbHVkZSwgYSwgYikge1xuICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIEFycmF5cyB0byBkZWVwRXh0ZW5kXG4gIC8vIE5PVEU6IGFycmF5IHByb3BlcnRpZXMgaGF2ZSBhbiBlbHNlLWJlbG93OyBhcHBhcmVudGx5LCB0aGVyZSBpcyBhIHByb2JsZW0gaGVyZS5cbiAgaWYgKGlzQXJyYXkkMihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZFwiKTtcbiAgfVxuXG4gIGZvciAodmFyIHByb3AgaW4gYikge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHByb3ApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIEhhbmRsZSBsb2NhbCBwcm9wZXJ0aWVzIG9ubHlcblxuXG4gICAgaWYgKGluY2x1ZGVzKHByb3BzVG9FeGNsdWRlKS5jYWxsKHByb3BzVG9FeGNsdWRlLCBwcm9wKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBJbiBleGNsdXNpb24gbGlzdCwgc2tpcFxuXG5cbiAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYVtwcm9wXSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoYVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIGRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSk7IC8vIE5PVEU6IGFsbG93RGVsZXRpb24gbm90IHByb3BhZ2F0ZWQhXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0FycmF5JDIoYltwcm9wXSkpIHtcbiAgICAgIGFbcHJvcF0gPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiW3Byb3BdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFbcHJvcF0ucHVzaChiW3Byb3BdW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhO1xufVxuLyoqXHJcbiAqIERlZXAgZXh0ZW5kIGFuIG9iamVjdCBhIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gVGFyZ2V0IG9iamVjdC5cclxuICogQHBhcmFtIGIgLSBTb3VyY2Ugb2JqZWN0LlxyXG4gKiBAcGFyYW0gcHJvdG9FeHRlbmQgLSBJZiB0cnVlLCB0aGUgcHJvdG90eXBlIHZhbHVlcyB3aWxsIGFsc28gYmUgZXh0ZW5kZWQuXHJcbiAqIChUaGF0IGlzIHRoZSBvcHRpb25zIG9iamVjdHMgdGhhdCBpbmhlcml0IGZyb20gb3RoZXJzIHdpbGwgYWxzbyBnZXQgdGhlXHJcbiAqIGluaGVyaXRlZCBvcHRpb25zKS5cclxuICogQHBhcmFtIGFsbG93RGVsZXRpb24gLSBJZiB0cnVlLCB0aGUgdmFsdWVzIG9mIGZpZWxkcyB0aGF0IGFyZSBudWxsIHdpbGwgYmUgZGVsZXRlZC5cclxuICogQHJldHVybnMgQXJndW1lbnQgYS5cclxuICovXG5cblxuZnVuY3Rpb24gZGVlcEV4dGVuZChhLCBiKSB7XG4gIHZhciBwcm90b0V4dGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICBmb3IgKHZhciBwcm9wIGluIGIpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHByb3ApIHx8IHByb3RvRXh0ZW5kID09PSB0cnVlKSB7XG4gICAgICBpZiAoX3R5cGVvZihiW3Byb3BdKSA9PT0gXCJvYmplY3RcIiAmJiBiW3Byb3BdICE9PSBudWxsICYmIGdldFByb3RvdHlwZU9mJDQoYltwcm9wXSkgPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFbcHJvcF0gPSBkZWVwRXh0ZW5kKHt9LCBiW3Byb3BdLCBwcm90b0V4dGVuZCk7IC8vIE5PVEU6IGFsbG93RGVsZXRpb24gbm90IHByb3BhZ2F0ZWQhXG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihhW3Byb3BdKSA9PT0gXCJvYmplY3RcIiAmJiBhW3Byb3BdICE9PSBudWxsICYmIGdldFByb3RvdHlwZU9mJDQoYVtwcm9wXSkgPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICBkZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIHByb3RvRXh0ZW5kKTsgLy8gTk9URTogYWxsb3dEZWxldGlvbiBub3QgcHJvcGFnYXRlZCFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSQyKGJbcHJvcF0pKSB7XG4gICAgICAgIHZhciBfY29udGV4dDY7XG5cbiAgICAgICAgYVtwcm9wXSA9IHNsaWNlKF9jb250ZXh0NiA9IGJbcHJvcF0pLmNhbGwoX2NvbnRleHQ2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYTtcbn1cbi8qKlxyXG4gKiBVc2VkIHRvIGV4dGVuZCBhbiBhcnJheSBhbmQgY29weSBpdC4gVGhpcyBpcyB1c2VkIHRvIHByb3BhZ2F0ZSBwYXRocyByZWN1cnNpdmVseS5cclxuICpcclxuICogQHBhcmFtIGFyciAtIEZpcnN0IHBhcnQuXHJcbiAqIEBwYXJhbSBuZXdWYWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBhYWRkZWQgaW50byB0aGUgYXJyYXkuXHJcbiAqIEByZXR1cm5zIEEgbmV3IGFycmF5IHdpdGggYWxsIGl0ZW1zIGZyb20gYXJyIGFuZCBuZXdWYWx1ZSAod2hpY2ggaXMgbGFzdCkuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHlBbmRFeHRlbmRBcnJheShhcnIsIG5ld1ZhbHVlKSB7XG4gIHZhciBfY29udGV4dDc7XG5cbiAgcmV0dXJuIGNvbmNhdChfY29udGV4dDcgPSBbXSkuY2FsbChfY29udGV4dDcsIF90b0NvbnN1bWFibGVBcnJheShhcnIpLCBbbmV3VmFsdWVdKTtcbn1cbi8qKlxyXG4gKiBVc2VkIHRvIGV4dGVuZCBhbiBhcnJheSBhbmQgY29weSBpdC4gVGhpcyBpcyB1c2VkIHRvIHByb3BhZ2F0ZSBwYXRocyByZWN1cnNpdmVseS5cclxuICpcclxuICogQHBhcmFtIGFyciAtIFRoZSBhcnJheSB0byBiZSBjb3BpZWQuXHJcbiAqIEByZXR1cm5zIFNoYWxsb3cgY29weSBvZiBhcnIuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHlBcnJheShhcnIpIHtcbiAgcmV0dXJuIHNsaWNlKGFycikuY2FsbChhcnIpO1xufVxuLyoqXHJcbiAqIFJldHJpZXZlIHRoZSBhYnNvbHV0ZSBsZWZ0IHZhbHVlIG9mIGEgRE9NIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBlbGVtIC0gQSBkb20gZWxlbWVudCwgZm9yIGV4YW1wbGUgYSBkaXYuXHJcbiAqIEByZXR1cm5zIFRoZSBhYnNvbHV0ZSBsZWZ0IHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudCBpbiB0aGUgYnJvd3NlciBwYWdlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZUxlZnQoZWxlbSkge1xuICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xufVxuLyoqXHJcbiAqIFJldHJpZXZlIHRoZSBhYnNvbHV0ZSB0b3AgdmFsdWUgb2YgYSBET00gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIGVsZW0gLSBBIGRvbSBlbGVtZW50LCBmb3IgZXhhbXBsZSBhIGRpdi5cclxuICogQHJldHVybnMgVGhlIGFic29sdXRlIHRvcCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnQgaW4gdGhlIGJyb3dzZXIgcGFnZS5cclxuICovXG5cblxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVUb3AoZWxlbSkge1xuICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG59XG4vKipcclxuICogRm9yIGVhY2ggbWV0aG9kIGZvciBib3RoIGFycmF5cyBhbmQgb2JqZWN0cy5cclxuICogSW4gY2FzZSBvZiBhbiBhcnJheSwgdGhlIGJ1aWx0LWluIEFycmF5LmZvckVhY2goKSBpcyBhcHBsaWVkICgqKk5vLCBpdCdzIG5vdCEqKikuXHJcbiAqIEluIGNhc2Ugb2YgYW4gT2JqZWN0LCB0aGUgbWV0aG9kIGxvb3BzIG92ZXIgYWxsIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIG9iamVjdCAtIEFuIE9iamVjdCBvciBBcnJheSB0byBiZSBpdGVyYXRlZCBvdmVyLlxyXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSBBcnJheS5mb3JFYWNoLWxpa2UgY2FsbGJhY2suXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvckVhY2gkMShvYmplY3QsIGNhbGxiYWNrKSB7XG4gIGlmIChpc0FycmF5JDIob2JqZWN0KSkge1xuICAgIC8vIGFycmF5XG4gICAgdmFyIGxlbiA9IG9iamVjdC5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjayhvYmplY3RbaV0sIGksIG9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIG9iamVjdFxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcclxuICogQWRkIGFuZCBldmVudCBsaXN0ZW5lci4gV29ya3MgZm9yIGFsbCBicm93c2Vycy5cclxuICpcclxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBiaW5kIHRoZSBldmVudCBsaXN0ZW5lciB0by5cclxuICogQHBhcmFtIGFjdGlvbiAtIFNhbWUgYXMgRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGFjdGlvbiwg4oCULCDigJQpLlxyXG4gKiBAcGFyYW0gbGlzdGVuZXIgLSBTYW1lIGFzIEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcijigJQsIGxpc3RlbmVyLCDigJQpLlxyXG4gKiBAcGFyYW0gdXNlQ2FwdHVyZSAtIFNhbWUgYXMgRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKOKAlCwg4oCULCB1c2VDYXB0dXJlKS5cclxuICovXG5cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB2YXIgX2NvbnRleHQ4O1xuXG4gICAgaWYgKHVzZUNhcHR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdXNlQ2FwdHVyZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24gPT09IFwibW91c2V3aGVlbFwiICYmIGluY2x1ZGVzKF9jb250ZXh0OCA9IG5hdmlnYXRvci51c2VyQWdlbnQpLmNhbGwoX2NvbnRleHQ4LCBcIkZpcmVmb3hcIikpIHtcbiAgICAgIGFjdGlvbiA9IFwiRE9NTW91c2VTY3JvbGxcIjsgLy8gRm9yIEZpcmVmb3hcbiAgICB9XG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQFRPRE86IElFIHR5cGVzPyBEb2VzIGFueW9uZSBjYXJlP1xuICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoXCJvblwiICsgYWN0aW9uLCBsaXN0ZW5lcik7IC8vIElFIGJyb3dzZXJzXG4gIH1cbn1cbi8qKlxyXG4gKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBhbiBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIGJpbmQgdGhlIGV2ZW50IGxpc3RlbmVyIHRvLlxyXG4gKiBAcGFyYW0gYWN0aW9uIC0gU2FtZSBhcyBFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoYWN0aW9uLCDigJQsIOKAlCkuXHJcbiAqIEBwYXJhbSBsaXN0ZW5lciAtIFNhbWUgYXMgRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKOKAlCwgbGlzdGVuZXIsIOKAlCkuXHJcbiAqIEBwYXJhbSB1c2VDYXB0dXJlIC0gU2FtZSBhcyBFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIo4oCULCDigJQsIHVzZUNhcHR1cmUpLlxyXG4gKi9cblxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsZW1lbnQsIGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIHZhciBfY29udGV4dDk7XG5cbiAgICAvLyBub24tSUUgYnJvd3NlcnNcbiAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB1c2VDYXB0dXJlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbiA9PT0gXCJtb3VzZXdoZWVsXCIgJiYgaW5jbHVkZXMoX2NvbnRleHQ5ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCkuY2FsbChfY29udGV4dDksIFwiRmlyZWZveFwiKSkge1xuICAgICAgYWN0aW9uID0gXCJET01Nb3VzZVNjcm9sbFwiOyAvLyBGb3IgRmlyZWZveFxuICAgIH1cblxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBAVE9ETzogSUUgdHlwZXM/IERvZXMgYW55b25lIGNhcmU/XG4gICAgZWxlbWVudC5kZXRhY2hFdmVudChcIm9uXCIgKyBhY3Rpb24sIGxpc3RlbmVyKTsgLy8gSUUgYnJvd3NlcnNcbiAgfVxufVxuLyoqXHJcbiAqIENvbnZlcnQgaGV4IGNvbG9yIHN0cmluZyBpbnRvIFJHQiBjb2xvciBvYmplY3QuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIHtAbGluayBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU2MjM4MzgvcmdiLXRvLWhleC1hbmQtaGV4LXRvLXJnYn1cclxuICogQHBhcmFtIGhleCAtIEhleCBjb2xvciBzdHJpbmcgKDMgb3IgNiBkaWdpdHMsIHdpdGggb3Igd2l0aG91dCAjKS5cclxuICogQHJldHVybnMgUkdCIGNvbG9yIG9iamVjdC5cclxuICovXG5cbmZ1bmN0aW9uIGhleFRvUkdCKGhleCkge1xuICB2YXIgcmVzdWx0O1xuXG4gIHN3aXRjaCAoaGV4Lmxlbmd0aCkge1xuICAgIGNhc2UgMzpcbiAgICBjYXNlIDQ6XG4gICAgICByZXN1bHQgPSBzaG9ydEhleFJFLmV4ZWMoaGV4KTtcbiAgICAgIHJldHVybiByZXN1bHQgPyB7XG4gICAgICAgIHI6IF9wYXJzZUludChyZXN1bHRbMV0gKyByZXN1bHRbMV0sIDE2KSxcbiAgICAgICAgZzogX3BhcnNlSW50KHJlc3VsdFsyXSArIHJlc3VsdFsyXSwgMTYpLFxuICAgICAgICBiOiBfcGFyc2VJbnQocmVzdWx0WzNdICsgcmVzdWx0WzNdLCAxNilcbiAgICAgIH0gOiBudWxsO1xuXG4gICAgY2FzZSA2OlxuICAgIGNhc2UgNzpcbiAgICAgIHJlc3VsdCA9IGZ1bGxIZXhSRS5leGVjKGhleCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID8ge1xuICAgICAgICByOiBfcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksXG4gICAgICAgIGc6IF9wYXJzZUludChyZXN1bHRbMl0sIDE2KSxcbiAgICAgICAgYjogX3BhcnNlSW50KHJlc3VsdFszXSwgMTYpXG4gICAgICB9IDogbnVsbDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgc3RyaW5nIGNvbG9yIGluIGhleCBvciBSR0IgZm9ybWF0IGFuZCBhZGRzIHRoZSBvcGFjaXR5LCBSR0JBIGlzIHBhc3NlZCB0aHJvdWdoIHVuY2hhbmdlZC5cclxuICpcclxuICogQHBhcmFtIGNvbG9yIC0gVGhlIGNvbG9yIHN0cmluZyAoaGV4LCBSR0IsIFJHQkEpLlxyXG4gKiBAcGFyYW0gb3BhY2l0eSAtIFRoZSBuZXcgb3BhY2l0eS5cclxuICogQHJldHVybnMgUkdCQSBzdHJpbmcsIGZvciBleGFtcGxlICdyZ2JhKDI1NSwgMCwgMTI3LCAwLjMpJy5cclxuICovXG5cblxuZnVuY3Rpb24gb3ZlcnJpZGVPcGFjaXR5KGNvbG9yLCBvcGFjaXR5KSB7XG4gIGlmIChpbmNsdWRlcyhjb2xvcikuY2FsbChjb2xvciwgXCJyZ2JhXCIpKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9IGVsc2UgaWYgKGluY2x1ZGVzKGNvbG9yKS5jYWxsKGNvbG9yLCBcInJnYlwiKSkge1xuICAgIHZhciByZ2IgPSBjb2xvci5zdWJzdHIoaW5kZXhPZihjb2xvcikuY2FsbChjb2xvciwgXCIoXCIpICsgMSkucmVwbGFjZShcIilcIiwgXCJcIikuc3BsaXQoXCIsXCIpO1xuICAgIHJldHVybiBcInJnYmEoXCIgKyByZ2JbMF0gKyBcIixcIiArIHJnYlsxXSArIFwiLFwiICsgcmdiWzJdICsgXCIsXCIgKyBvcGFjaXR5ICsgXCIpXCI7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9yZ2IgPSBoZXhUb1JHQihjb2xvcik7XG5cbiAgICBpZiAoX3JnYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcInJnYmEoXCIgKyBfcmdiLnIgKyBcIixcIiArIF9yZ2IuZyArIFwiLFwiICsgX3JnYi5iICsgXCIsXCIgKyBvcGFjaXR5ICsgXCIpXCI7XG4gICAgfVxuICB9XG59XG4vKipcclxuICogQ29udmVydCBSR0IgXFw8MCwgMjU1XFw+IGludG8gaGV4IGNvbG9yIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHJlZCAtIFJlZCBjaGFubmVsLlxyXG4gKiBAcGFyYW0gZ3JlZW4gLSBHcmVlbiBjaGFubmVsLlxyXG4gKiBAcGFyYW0gYmx1ZSAtIEJsdWUgY2hhbm5lbC5cclxuICogQHJldHVybnMgSGV4IGNvbG9yIHN0cmluZyAoZm9yIGV4YW1wbGU6ICcjMGFjZGMwJykuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIFJHQlRvSGV4KHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgdmFyIF9jb250ZXh0MTA7XG5cbiAgcmV0dXJuIFwiI1wiICsgc2xpY2UoX2NvbnRleHQxMCA9ICgoMSA8PCAyNCkgKyAocmVkIDw8IDE2KSArIChncmVlbiA8PCA4KSArIGJsdWUpLnRvU3RyaW5nKDE2KSkuY2FsbChfY29udGV4dDEwLCAxKTtcbn1cbi8qKlxyXG4gKiBQYXJzZSBhIGNvbG9yIHByb3BlcnR5IGludG8gYW4gb2JqZWN0IHdpdGggYm9yZGVyLCBiYWNrZ3JvdW5kLCBhbmQgaGlnaGxpZ2h0IGNvbG9ycy5cclxuICpcclxuICogQHBhcmFtIGlucHV0Q29sb3IgLSBTaG9ydGhhbmQgY29sb3Igc3RyaW5nIG9yIGlucHV0IGNvbG9yIG9iamVjdC5cclxuICogQHBhcmFtIGRlZmF1bHRDb2xvciAtIEZ1bGwgY29sb3Igb2JqZWN0IHRvIGZpbGwgaW4gbWlzc2luZyB2YWx1ZXMgaW4gaW5wdXRDb2xvci5cclxuICogQHJldHVybnMgQ29sb3Igb2JqZWN0LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUNvbG9yKGlucHV0Q29sb3IsIGRlZmF1bHRDb2xvcikge1xuICBpZiAoaXNTdHJpbmcoaW5wdXRDb2xvcikpIHtcbiAgICB2YXIgY29sb3JTdHIgPSBpbnB1dENvbG9yO1xuXG4gICAgaWYgKGlzVmFsaWRSR0IoY29sb3JTdHIpKSB7XG4gICAgICB2YXIgX2NvbnRleHQxMTtcblxuICAgICAgdmFyIHJnYiA9IG1hcCQzKF9jb250ZXh0MTEgPSBjb2xvclN0ci5zdWJzdHIoNCkuc3Vic3RyKDAsIGNvbG9yU3RyLmxlbmd0aCAtIDUpLnNwbGl0KFwiLFwiKSkuY2FsbChfY29udGV4dDExLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9wYXJzZUludCh2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgY29sb3JTdHIgPSBSR0JUb0hleChyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdKTtcbiAgICB9XG5cbiAgICBpZiAoaXNWYWxpZEhleChjb2xvclN0cikgPT09IHRydWUpIHtcbiAgICAgIHZhciBoc3YgPSBoZXhUb0hTVihjb2xvclN0cik7XG4gICAgICB2YXIgbGlnaHRlckNvbG9ySFNWID0ge1xuICAgICAgICBoOiBoc3YuaCxcbiAgICAgICAgczogaHN2LnMgKiAwLjgsXG4gICAgICAgIHY6IE1hdGgubWluKDEsIGhzdi52ICogMS4wMilcbiAgICAgIH07XG4gICAgICB2YXIgZGFya2VyQ29sb3JIU1YgPSB7XG4gICAgICAgIGg6IGhzdi5oLFxuICAgICAgICBzOiBNYXRoLm1pbigxLCBoc3YucyAqIDEuMjUpLFxuICAgICAgICB2OiBoc3YudiAqIDAuOFxuICAgICAgfTtcbiAgICAgIHZhciBkYXJrZXJDb2xvckhleCA9IEhTVlRvSGV4KGRhcmtlckNvbG9ySFNWLmgsIGRhcmtlckNvbG9ySFNWLnMsIGRhcmtlckNvbG9ySFNWLnYpO1xuICAgICAgdmFyIGxpZ2h0ZXJDb2xvckhleCA9IEhTVlRvSGV4KGxpZ2h0ZXJDb2xvckhTVi5oLCBsaWdodGVyQ29sb3JIU1YucywgbGlnaHRlckNvbG9ySFNWLnYpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3JTdHIsXG4gICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXgsXG4gICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGxpZ2h0ZXJDb2xvckhleCxcbiAgICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4XG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogbGlnaHRlckNvbG9ySGV4LFxuICAgICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXhcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3JTdHIsXG4gICAgICAgIGJvcmRlcjogY29sb3JTdHIsXG4gICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yU3RyLFxuICAgICAgICAgIGJvcmRlcjogY29sb3JTdHJcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvclN0cixcbiAgICAgICAgICBib3JkZXI6IGNvbG9yU3RyXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZWZhdWx0Q29sb3IpIHtcbiAgICAgIHZhciBjb2xvciA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5iYWNrZ3JvdW5kIHx8IGRlZmF1bHRDb2xvci5iYWNrZ3JvdW5kLFxuICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuYm9yZGVyIHx8IGRlZmF1bHRDb2xvci5ib3JkZXIsXG4gICAgICAgIGhpZ2hsaWdodDogaXNTdHJpbmcoaW5wdXRDb2xvci5oaWdobGlnaHQpID8ge1xuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5oaWdobGlnaHQsXG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5oaWdobGlnaHRcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhpZ2hsaWdodCAmJiBpbnB1dENvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIHx8IGRlZmF1bHRDb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCxcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaGlnaGxpZ2h0ICYmIGlucHV0Q29sb3IuaGlnaGxpZ2h0LmJvcmRlciB8fCBkZWZhdWx0Q29sb3IuaGlnaGxpZ2h0LmJvcmRlclxuICAgICAgICB9LFxuICAgICAgICBob3ZlcjogaXNTdHJpbmcoaW5wdXRDb2xvci5ob3ZlcikgPyB7XG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhvdmVyLFxuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaG92ZXJcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaG92ZXIgJiYgaW5wdXRDb2xvci5ob3Zlci5ib3JkZXIgfHwgZGVmYXVsdENvbG9yLmhvdmVyLmJvcmRlcixcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhvdmVyICYmIGlucHV0Q29sb3IuaG92ZXIuYmFja2dyb3VuZCB8fCBkZWZhdWx0Q29sb3IuaG92ZXIuYmFja2dyb3VuZFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NvbG9yID0ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmJhY2tncm91bmQgfHwgdW5kZWZpbmVkLFxuICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuYm9yZGVyIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgaGlnaGxpZ2h0OiBpc1N0cmluZyhpbnB1dENvbG9yLmhpZ2hsaWdodCkgPyB7XG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhpZ2hsaWdodCxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhpZ2hsaWdodFxuICAgICAgICB9IDoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaGlnaGxpZ2h0ICYmIGlucHV0Q29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5oaWdobGlnaHQgJiYgaW5wdXRDb2xvci5oaWdobGlnaHQuYm9yZGVyIHx8IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBob3ZlcjogaXNTdHJpbmcoaW5wdXRDb2xvci5ob3ZlcikgPyB7XG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhvdmVyLFxuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaG92ZXJcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaG92ZXIgJiYgaW5wdXRDb2xvci5ob3Zlci5ib3JkZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaG92ZXIgJiYgaW5wdXRDb2xvci5ob3Zlci5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9jb2xvcjtcbiAgICB9XG4gIH1cbn1cbi8qKlxyXG4gKiBDb252ZXJ0IFJHQiBcXDwwLCAyNTVcXD4gaW50byBIU1Ygb2JqZWN0LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiB7QGxpbmsgaHR0cDovL3d3dy5qYXZhc2NyaXB0ZXIubmV0L2ZhcS9yZ2IyaHN2Lmh0bX1cclxuICogQHBhcmFtIHJlZCAtIFJlZCBjaGFubmVsLlxyXG4gKiBAcGFyYW0gZ3JlZW4gLSBHcmVlbiBjaGFubmVsLlxyXG4gKiBAcGFyYW0gYmx1ZSAtIEJsdWUgY2hhbm5lbC5cclxuICogQHJldHVybnMgSFNWIGNvbG9yIG9iamVjdC5cclxuICovXG5cblxuZnVuY3Rpb24gUkdCVG9IU1YocmVkLCBncmVlbiwgYmx1ZSkge1xuICByZWQgPSByZWQgLyAyNTU7XG4gIGdyZWVuID0gZ3JlZW4gLyAyNTU7XG4gIGJsdWUgPSBibHVlIC8gMjU1O1xuICB2YXIgbWluUkdCID0gTWF0aC5taW4ocmVkLCBNYXRoLm1pbihncmVlbiwgYmx1ZSkpO1xuICB2YXIgbWF4UkdCID0gTWF0aC5tYXgocmVkLCBNYXRoLm1heChncmVlbiwgYmx1ZSkpOyAvLyBCbGFjay1ncmF5LXdoaXRlXG5cbiAgaWYgKG1pblJHQiA9PT0gbWF4UkdCKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGg6IDAsXG4gICAgICBzOiAwLFxuICAgICAgdjogbWluUkdCXG4gICAgfTtcbiAgfSAvLyBDb2xvcnMgb3RoZXIgdGhhbiBibGFjay1ncmF5LXdoaXRlOlxuXG5cbiAgdmFyIGQgPSByZWQgPT09IG1pblJHQiA/IGdyZWVuIC0gYmx1ZSA6IGJsdWUgPT09IG1pblJHQiA/IHJlZCAtIGdyZWVuIDogYmx1ZSAtIHJlZDtcbiAgdmFyIGggPSByZWQgPT09IG1pblJHQiA/IDMgOiBibHVlID09PSBtaW5SR0IgPyAxIDogNTtcbiAgdmFyIGh1ZSA9IDYwICogKGggLSBkIC8gKG1heFJHQiAtIG1pblJHQikpIC8gMzYwO1xuICB2YXIgc2F0dXJhdGlvbiA9IChtYXhSR0IgLSBtaW5SR0IpIC8gbWF4UkdCO1xuICB2YXIgdmFsdWUgPSBtYXhSR0I7XG4gIHJldHVybiB7XG4gICAgaDogaHVlLFxuICAgIHM6IHNhdHVyYXRpb24sXG4gICAgdjogdmFsdWVcbiAgfTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0IEhTViBcXDwwLCAxXFw+IGludG8gUkdCIGNvbG9yIG9iamVjdC5cclxuICpcclxuICogQHJlbWFya3NcclxuICoge0BsaW5rIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21qaWphY2tzb24vNTMxMTI1Nn1cclxuICogQHBhcmFtIGggLSBIdWUuXHJcbiAqIEBwYXJhbSBzIC0gU2F0dXJhdGlvbi5cclxuICogQHBhcmFtIHYgLSBWYWx1ZS5cclxuICogQHJldHVybnMgUkdCIGNvbG9yIG9iamVjdC5cclxuICovXG5cblxuZnVuY3Rpb24gSFNWVG9SR0IoaCwgcywgdikge1xuICB2YXIgcjtcbiAgdmFyIGc7XG4gIHZhciBiO1xuICB2YXIgaSA9IE1hdGguZmxvb3IoaCAqIDYpO1xuICB2YXIgZiA9IGggKiA2IC0gaTtcbiAgdmFyIHAgPSB2ICogKDEgLSBzKTtcbiAgdmFyIHEgPSB2ICogKDEgLSBmICogcyk7XG4gIHZhciB0ID0gdiAqICgxIC0gKDEgLSBmKSAqIHMpO1xuXG4gIHN3aXRjaCAoaSAlIDYpIHtcbiAgICBjYXNlIDA6XG4gICAgICByID0gdiwgZyA9IHQsIGIgPSBwO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDE6XG4gICAgICByID0gcSwgZyA9IHYsIGIgPSBwO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICByID0gcCwgZyA9IHYsIGIgPSB0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDM6XG4gICAgICByID0gcCwgZyA9IHEsIGIgPSB2O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDQ6XG4gICAgICByID0gdCwgZyA9IHAsIGIgPSB2O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDU6XG4gICAgICByID0gdiwgZyA9IHAsIGIgPSBxO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHI6IE1hdGguZmxvb3IociAqIDI1NSksXG4gICAgZzogTWF0aC5mbG9vcihnICogMjU1KSxcbiAgICBiOiBNYXRoLmZsb29yKGIgKiAyNTUpXG4gIH07XG59XG4vKipcclxuICogQ29udmVydCBIU1YgXFw8MCwgMVxcPiBpbnRvIGhleCBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBoIC0gSHVlLlxyXG4gKiBAcGFyYW0gcyAtIFNhdHVyYXRpb24uXHJcbiAqIEBwYXJhbSB2IC0gVmFsdWUuXHJcbiAqIEByZXR1cm5zIEhleCBjb2xvciBzdHJpbmcuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIEhTVlRvSGV4KGgsIHMsIHYpIHtcbiAgdmFyIHJnYiA9IEhTVlRvUkdCKGgsIHMsIHYpO1xuICByZXR1cm4gUkdCVG9IZXgocmdiLnIsIHJnYi5nLCByZ2IuYik7XG59XG4vKipcclxuICogQ29udmVydCBoZXggY29sb3Igc3RyaW5nIGludG8gSFNWIFxcPDAsIDFcXD4uXHJcbiAqXHJcbiAqIEBwYXJhbSBoZXggLSBIZXggY29sb3Igc3RyaW5nLlxyXG4gKiBAcmV0dXJucyBIU1YgY29sb3Igb2JqZWN0LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBoZXhUb0hTVihoZXgpIHtcbiAgdmFyIHJnYiA9IGhleFRvUkdCKGhleCk7XG5cbiAgaWYgKCFyZ2IpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ1wiLmNvbmNhdChoZXgsIFwiJyBpcyBub3QgYSB2YWxpZCBjb2xvci5cIikpO1xuICB9XG5cbiAgcmV0dXJuIFJHQlRvSFNWKHJnYi5yLCByZ2IuZywgcmdiLmIpO1xufVxuLyoqXHJcbiAqIFZhbGlkYXRlIGhleCBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBoZXggLSBVbmtub3duIHN0cmluZyB0aGF0IG1heSBjb250YWluIGEgY29sb3IuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHN0cmluZyBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkSGV4KGhleCkge1xuICB2YXIgaXNPayA9IC8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaS50ZXN0KGhleCk7XG4gIHJldHVybiBpc09rO1xufVxuLyoqXHJcbiAqIFZhbGlkYXRlIFJHQiBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSByZ2IgLSBVbmtub3duIHN0cmluZyB0aGF0IG1heSBjb250YWluIGEgY29sb3IuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHN0cmluZyBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkUkdCKHJnYikge1xuICByZXR1cm4gcmdiUkUudGVzdChyZ2IpO1xufVxuLyoqXHJcbiAqIFZhbGlkYXRlIFJHQkEgY29sb3Igc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmdiYSAtIFVua25vd24gc3RyaW5nIHRoYXQgbWF5IGNvbnRhaW4gYSBjb2xvci5cclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRSR0JBKHJnYmEpIHtcbiAgcmV0dXJuIHJnYmFSRS50ZXN0KHJnYmEpO1xufVxuLyoqXHJcbiAqIFRoaXMgcmVjdXJzaXZlbHkgcmVkaXJlY3RzIHRoZSBwcm90b3R5cGUgb2YgSlNPTiBvYmplY3RzIHRvIHRoZSByZWZlcmVuY2VPYmplY3QuXHJcbiAqIFRoaXMgaXMgdXNlZCBmb3IgZGVmYXVsdCBvcHRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmZXJlbmNlT2JqZWN0IC0gVGhlIG9yaWdpbmFsIG9iamVjdC5cclxuICogQHJldHVybnMgVGhlIEVsZW1lbnQgaWYgdGhlIHJlZmVyZW5jZU9iamVjdCBpcyBhbiBFbGVtZW50LCBvciBhIG5ldyBvYmplY3QgaW5oZXJpdGluZyBmcm9tIHRoZSByZWZlcmVuY2VPYmplY3QuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGJyaWRnZU9iamVjdChyZWZlcmVuY2VPYmplY3QpIHtcbiAgaWYgKHJlZmVyZW5jZU9iamVjdCA9PT0gbnVsbCB8fCBfdHlwZW9mKHJlZmVyZW5jZU9iamVjdCkgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChyZWZlcmVuY2VPYmplY3QgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgLy8gQXZvaWQgYnJpZGdpbmcgRE9NIG9iamVjdHNcbiAgICByZXR1cm4gcmVmZXJlbmNlT2JqZWN0O1xuICB9XG5cbiAgdmFyIG9iamVjdFRvID0gY3JlYXRlJDUocmVmZXJlbmNlT2JqZWN0KTtcblxuICBmb3IgKHZhciBpIGluIHJlZmVyZW5jZU9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVmZXJlbmNlT2JqZWN0LCBpKSkge1xuICAgICAgaWYgKF90eXBlb2YocmVmZXJlbmNlT2JqZWN0W2ldKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG9iamVjdFRvW2ldID0gYnJpZGdlT2JqZWN0KHJlZmVyZW5jZU9iamVjdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdFRvO1xufVxuLyoqXHJcbiAqIFRoaXMgaXMgdXNlZCB0byBzZXQgdGhlIG9wdGlvbnMgb2Ygc3Vib2JqZWN0cyBpbiB0aGUgb3B0aW9ucyBvYmplY3QuXHJcbiAqXHJcbiAqIEEgcmVxdWlyZW1lbnQgb2YgdGhlc2Ugc3Vib2JqZWN0cyBpcyB0aGF0IHRoZXkgaGF2ZSBhbiAnZW5hYmxlZCcgZWxlbWVudFxyXG4gKiB3aGljaCBpcyBvcHRpb25hbCBmb3IgdGhlIHVzZXIgYnV0IG1hbmRhdG9yeSBmb3IgdGhlIHByb2dyYW0uXHJcbiAqXHJcbiAqIFRoZSBhZGRlZCB2YWx1ZSBoZXJlIG9mIHRoZSBtZXJnZSBpcyB0aGF0IG9wdGlvbiAnZW5hYmxlZCcgaXMgc2V0IGFzIHJlcXVpcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gbWVyZ2VUYXJnZXQgLSBFaXRoZXIgdGhpcy5vcHRpb25zIG9yIHRoZSBvcHRpb25zIHVzZWQgZm9yIHRoZSBncm91cHMuXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cclxuICogQHBhcmFtIG9wdGlvbiAtIE9wdGlvbiBrZXkgaW4gdGhlIG9wdGlvbnMgYXJndW1lbnQuXHJcbiAqIEBwYXJhbSBnbG9iYWxPcHRpb25zIC0gR2xvYmFsIG9wdGlvbnMsIHBhc3NlZCBpbiB0byBkZXRlcm1pbmUgdmFsdWUgb2Ygb3B0aW9uICdlbmFibGVkJy5cclxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG1lcmdlVGFyZ2V0LCBvcHRpb25zLCBvcHRpb24pIHtcbiAgdmFyIGdsb2JhbE9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gIC8vIExvY2FsIGhlbHBlcnNcbiAgdmFyIGlzUHJlc2VudCA9IGZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHZhciBpc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgX3R5cGVvZihvYmopID09PSBcIm9iamVjdFwiO1xuICB9OyAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ0OTEyODcvMTIyMzUzMVxuXG5cbiAgdmFyIGlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIGZvciAodmFyIHggaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgeCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9OyAvLyBHdWFyZHNcblxuXG4gIGlmICghaXNPYmplY3QobWVyZ2VUYXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG1lcmdlVGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICB9XG5cbiAgaWYgKCFpc09iamVjdChvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICB9XG5cbiAgaWYgKCFpc1ByZXNlbnQob3B0aW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBvcHRpb24gbXVzdCBoYXZlIGEgdmFsdWVcIik7XG4gIH1cblxuICBpZiAoIWlzT2JqZWN0KGdsb2JhbE9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGdsb2JhbE9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIH0gLy9cbiAgLy8gQWN0dWFsIG1lcmdlIHJvdXRpbmUsIHNlcGFyYXRlZCBmcm9tIG1haW4gbG9naWNcbiAgLy8gT25seSBhIHNpbmdsZSBsZXZlbCBvZiBvcHRpb25zIGlzIG1lcmdlZC4gRGVlcGVyIGxldmVscyBhcmUgcmVmJ2QuIFRoaXMgbWF5IGFjdHVhbGx5IGJlIGFuIGlzc3VlLlxuICAvL1xuXG5cbiAgdmFyIGRvTWVyZ2UgPSBmdW5jdGlvbiBkb01lcmdlKHRhcmdldCwgb3B0aW9ucywgb3B0aW9uKSB7XG4gICAgaWYgKCFpc09iamVjdCh0YXJnZXRbb3B0aW9uXSkpIHtcbiAgICAgIHRhcmdldFtvcHRpb25dID0ge307XG4gICAgfVxuXG4gICAgdmFyIHNyYyA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICB2YXIgZHN0ID0gdGFyZ2V0W29wdGlvbl07XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHNyYykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHByb3ApKSB7XG4gICAgICAgIGRzdFtwcm9wXSA9IHNyY1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIExvY2FsIGluaXRpYWxpemF0aW9uXG5cblxuICB2YXIgc3JjT3B0aW9uID0gb3B0aW9uc1tvcHRpb25dO1xuICB2YXIgZ2xvYmFsUGFzc2VkID0gaXNPYmplY3QoZ2xvYmFsT3B0aW9ucykgJiYgIWlzRW1wdHkoZ2xvYmFsT3B0aW9ucyk7XG4gIHZhciBnbG9iYWxPcHRpb24gPSBnbG9iYWxQYXNzZWQgPyBnbG9iYWxPcHRpb25zW29wdGlvbl0gOiB1bmRlZmluZWQ7XG4gIHZhciBnbG9iYWxFbmFibGVkID0gZ2xvYmFsT3B0aW9uID8gZ2xvYmFsT3B0aW9uLmVuYWJsZWQgOiB1bmRlZmluZWQ7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIE1haW4gcm91dGluZVxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGlmIChzcmNPcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjsgLy8gTm90aGluZyB0byBkb1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzcmNPcHRpb24gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgaWYgKCFpc09iamVjdChtZXJnZVRhcmdldFtvcHRpb25dKSkge1xuICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXSA9IHt9O1xuICAgIH1cblxuICAgIG1lcmdlVGFyZ2V0W29wdGlvbl0uZW5hYmxlZCA9IHNyY09wdGlvbjtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3JjT3B0aW9uID09PSBudWxsICYmICFpc09iamVjdChtZXJnZVRhcmdldFtvcHRpb25dKSkge1xuICAgIC8vIElmIHBvc3NpYmxlLCBleHBsaWNpdCBjb3B5IGZyb20gZ2xvYmFsc1xuICAgIGlmIChpc1ByZXNlbnQoZ2xvYmFsT3B0aW9uKSkge1xuICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXSA9IGNyZWF0ZSQ1KGdsb2JhbE9wdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjsgLy8gTm90aGluZyB0byBkb1xuICAgIH1cbiAgfVxuXG4gIGlmICghaXNPYmplY3Qoc3JjT3B0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfSAvL1xuICAvLyBFbnN1cmUgdGhhdCAnZW5hYmxlZCcgaXMgcHJvcGVybHkgc2V0LiBJdCBpcyByZXF1aXJlZCBpbnRlcm5hbGx5XG4gIC8vIE5vdGUgdGhhdCB0aGUgdmFsdWUgZnJvbSBvcHRpb25zIHdpbGwgYWx3YXlzIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgdmFsdWVcbiAgLy9cblxuXG4gIHZhciBlbmFibGVkID0gdHJ1ZTsgLy8gZGVmYXVsdCB2YWx1ZVxuXG4gIGlmIChzcmNPcHRpb24uZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5hYmxlZCA9IHNyY09wdGlvbi5lbmFibGVkO1xuICB9IGVsc2Uge1xuICAgIC8vIFRha2UgZnJvbSBnbG9iYWxzLCBpZiBwcmVzZW50XG4gICAgaWYgKGdsb2JhbEVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5hYmxlZCA9IGdsb2JhbE9wdGlvbi5lbmFibGVkO1xuICAgIH1cbiAgfVxuXG4gIGRvTWVyZ2UobWVyZ2VUYXJnZXQsIG9wdGlvbnMsIG9wdGlvbik7XG4gIG1lcmdlVGFyZ2V0W29wdGlvbl0uZW5hYmxlZCA9IGVuYWJsZWQ7XG59XG4vKlxyXG4gKiBFYXNpbmcgRnVuY3Rpb25zLlxyXG4gKiBPbmx5IGNvbnNpZGVyaW5nIHRoZSB0IHZhbHVlIGZvciB0aGUgcmFuZ2UgWzAsIDFdID0+IFswLCAxXS5cclxuICpcclxuICogSW5zcGlyYXRpb246IGZyb20gaHR0cDovL2dpem1hLmNvbS9lYXNpbmcvXHJcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2dyZS8xNjUwMjk0XHJcbiAqL1xuXG5cbnZhciBlYXNpbmdGdW5jdGlvbnMgPSB7XG4gIC8qKlxyXG4gICAqIFByb3ZpZGVzIG5vIGVhc2luZyBhbmQgbm8gYWNjZWxlcmF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgbGluZWFyOiBmdW5jdGlvbiBsaW5lYXIodCkge1xuICAgIHJldHVybiB0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgZnJvbSB6ZXJvIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluUXVhZDogZnVuY3Rpb24gZWFzZUluUXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIERlY2VsZXJhdGUgdG8gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiBlYXNlT3V0UXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgKiAoMiAtIHQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24gZWFzZUluT3V0UXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIGZyb20gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJbkN1YmljOiBmdW5jdGlvbiBlYXNlSW5DdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWNlbGVyYXRlIHRvIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uIGVhc2VPdXRDdWJpYyh0KSB7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiBlYXNlSW5PdXRDdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyA0ICogdCAqIHQgKiB0IDogKHQgLSAxKSAqICgyICogdCAtIDIpICogKDIgKiB0IC0gMikgKyAxO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgZnJvbSB6ZXJvIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uIGVhc2VJblF1YXJ0KHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWNlbGVyYXRlIHRvIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uIGVhc2VPdXRRdWFydCh0KSB7XG4gICAgcmV0dXJuIDEgLSAtLXQgKiB0ICogdCAqIHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24gZWFzZUluT3V0UXVhcnQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gOCAqIHQgKiB0ICogdCAqIHQgOiAxIC0gOCAqIC0tdCAqIHQgKiB0ICogdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIGZyb20gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJblF1aW50OiBmdW5jdGlvbiBlYXNlSW5RdWludCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIERlY2VsZXJhdGUgdG8gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VPdXRRdWludDogZnVuY3Rpb24gZWFzZU91dFF1aW50KHQpIHtcbiAgICByZXR1cm4gMSArIC0tdCAqIHQgKiB0ICogdCAqIHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlSW5PdXRRdWludDogZnVuY3Rpb24gZWFzZUluT3V0UXVpbnQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gMTYgKiB0ICogdCAqIHQgKiB0ICogdCA6IDEgKyAxNiAqIC0tdCAqIHQgKiB0ICogdCAqIHQ7XG4gIH1cbn07XG4vLyBJdCB3b3JrcyBvbmx5IGZvciBzaW5nbGUgcHJvcGVydHkgb2JqZWN0cyxcbi8vIG90aGVyd2lzZSBpdCBjb21iaW5lcyBhbGwgb2YgdGhlIHR5cGVzIGluIGEgdW5pb24uXG4vLyBleHBvcnQgZnVuY3Rpb24gdG9wTW9zdDxLMSBleHRlbmRzIHN0cmluZywgVjE+IChcbi8vICAgcGlsZTogUmVjb3JkPEsxLCB1bmRlZmluZWQgfCBWMT5bXSxcbi8vICAgYWNjZXNzb3JzOiBLMSB8IFtLMV1cbi8vICk6IHVuZGVmaW5lZCB8IFYxXG4vLyBleHBvcnQgZnVuY3Rpb24gdG9wTW9zdDxLMSBleHRlbmRzIHN0cmluZywgSzIgZXh0ZW5kcyBzdHJpbmcsIFYxLCBWMj4gKFxuLy8gICBwaWxlOiBSZWNvcmQ8SzEsIHVuZGVmaW5lZCB8IFYxIHwgUmVjb3JkPEsyLCB1bmRlZmluZWQgfCBWMj4+W10sXG4vLyAgIGFjY2Vzc29yczogW0sxLCBLMl1cbi8vICk6IHVuZGVmaW5lZCB8IFYxIHwgVjJcbi8vIGV4cG9ydCBmdW5jdGlvbiB0b3BNb3N0PEsxIGV4dGVuZHMgc3RyaW5nLCBLMiBleHRlbmRzIHN0cmluZywgSzMgZXh0ZW5kcyBzdHJpbmcsIFYxLCBWMiwgVjM+IChcbi8vICAgcGlsZTogUmVjb3JkPEsxLCB1bmRlZmluZWQgfCBWMSB8IFJlY29yZDxLMiwgdW5kZWZpbmVkIHwgVjIgfCBSZWNvcmQ8SzMsIHVuZGVmaW5lZCB8IFYzPj4+W10sXG4vLyAgIGFjY2Vzc29yczogW0sxLCBLMiwgSzNdXG4vLyApOiB1bmRlZmluZWQgfCBWMSB8IFYyIHwgVjNcblxuLyoqXHJcbiAqIEdldCB0aGUgdG9wIG1vc3QgcHJvcGVydHkgdmFsdWUgZnJvbSBhIHBpbGUgb2Ygb2JqZWN0cy5cclxuICpcclxuICogQHBhcmFtIHBpbGUgLSBBcnJheSBvZiBvYmplY3RzLCBubyByZXF1aXJlZCBmb3JtYXQuXHJcbiAqIEBwYXJhbSBhY2Nlc3NvcnMgLSBBcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cclxuICogRm9yIGV4YW1wbGUgYG9iamVjdFsnZm9vJ11bJ2JhciddYCDihpIgYFsnZm9vJywgJ2JhciddYC5cclxuICogQHJldHVybnMgVmFsdWUgb2YgdGhlIHByb3BlcnR5IHdpdGggZ2l2ZW4gYWNjZXNzb3JzIHBhdGggZnJvbSB0aGUgZmlyc3QgcGlsZSBpdGVtIHdoZXJlIGl0J3Mgbm90IHVuZGVmaW5lZC5cclxuICovXG5cblxuZnVuY3Rpb24gdG9wTW9zdChwaWxlLCBhY2Nlc3NvcnMpIHtcbiAgdmFyIGNhbmRpZGF0ZTtcblxuICBpZiAoIWlzQXJyYXkkMihhY2Nlc3NvcnMpKSB7XG4gICAgYWNjZXNzb3JzID0gW2FjY2Vzc29yc107XG4gIH1cblxuICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDgocGlsZSksXG4gICAgICBfc3RlcDM7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgdmFyIG1lbWJlciA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICBjYW5kaWRhdGUgPSBtZW1iZXJbYWNjZXNzb3JzWzBdXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFjY2Vzc29ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZVthY2Nlc3NvcnNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjMuZigpO1xuICB9XG5cbiAgcmV0dXJuIGNhbmRpZGF0ZTtcbn1cblxudmFyIGh0bWxDb2xvcnMgPSB7XG4gIGJsYWNrOiBcIiMwMDAwMDBcIixcbiAgbmF2eTogXCIjMDAwMDgwXCIsXG4gIGRhcmtibHVlOiBcIiMwMDAwOEJcIixcbiAgbWVkaXVtYmx1ZTogXCIjMDAwMENEXCIsXG4gIGJsdWU6IFwiIzAwMDBGRlwiLFxuICBkYXJrZ3JlZW46IFwiIzAwNjQwMFwiLFxuICBncmVlbjogXCIjMDA4MDAwXCIsXG4gIHRlYWw6IFwiIzAwODA4MFwiLFxuICBkYXJrY3lhbjogXCIjMDA4QjhCXCIsXG4gIGRlZXBza3libHVlOiBcIiMwMEJGRkZcIixcbiAgZGFya3R1cnF1b2lzZTogXCIjMDBDRUQxXCIsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiBcIiMwMEZBOUFcIixcbiAgbGltZTogXCIjMDBGRjAwXCIsXG4gIHNwcmluZ2dyZWVuOiBcIiMwMEZGN0ZcIixcbiAgYXF1YTogXCIjMDBGRkZGXCIsXG4gIGN5YW46IFwiIzAwRkZGRlwiLFxuICBtaWRuaWdodGJsdWU6IFwiIzE5MTk3MFwiLFxuICBkb2RnZXJibHVlOiBcIiMxRTkwRkZcIixcbiAgbGlnaHRzZWFncmVlbjogXCIjMjBCMkFBXCIsXG4gIGZvcmVzdGdyZWVuOiBcIiMyMjhCMjJcIixcbiAgc2VhZ3JlZW46IFwiIzJFOEI1N1wiLFxuICBkYXJrc2xhdGVncmF5OiBcIiMyRjRGNEZcIixcbiAgbGltZWdyZWVuOiBcIiMzMkNEMzJcIixcbiAgbWVkaXVtc2VhZ3JlZW46IFwiIzNDQjM3MVwiLFxuICB0dXJxdW9pc2U6IFwiIzQwRTBEMFwiLFxuICByb3lhbGJsdWU6IFwiIzQxNjlFMVwiLFxuICBzdGVlbGJsdWU6IFwiIzQ2ODJCNFwiLFxuICBkYXJrc2xhdGVibHVlOiBcIiM0ODNEOEJcIixcbiAgbWVkaXVtdHVycXVvaXNlOiBcIiM0OEQxQ0NcIixcbiAgaW5kaWdvOiBcIiM0QjAwODJcIixcbiAgZGFya29saXZlZ3JlZW46IFwiIzU1NkIyRlwiLFxuICBjYWRldGJsdWU6IFwiIzVGOUVBMFwiLFxuICBjb3JuZmxvd2VyYmx1ZTogXCIjNjQ5NUVEXCIsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFwiIzY2Q0RBQVwiLFxuICBkaW1ncmF5OiBcIiM2OTY5NjlcIixcbiAgc2xhdGVibHVlOiBcIiM2QTVBQ0RcIixcbiAgb2xpdmVkcmFiOiBcIiM2QjhFMjNcIixcbiAgc2xhdGVncmF5OiBcIiM3MDgwOTBcIixcbiAgbGlnaHRzbGF0ZWdyYXk6IFwiIzc3ODg5OVwiLFxuICBtZWRpdW1zbGF0ZWJsdWU6IFwiIzdCNjhFRVwiLFxuICBsYXduZ3JlZW46IFwiIzdDRkMwMFwiLFxuICBjaGFydHJldXNlOiBcIiM3RkZGMDBcIixcbiAgYXF1YW1hcmluZTogXCIjN0ZGRkQ0XCIsXG4gIG1hcm9vbjogXCIjODAwMDAwXCIsXG4gIHB1cnBsZTogXCIjODAwMDgwXCIsXG4gIG9saXZlOiBcIiM4MDgwMDBcIixcbiAgZ3JheTogXCIjODA4MDgwXCIsXG4gIHNreWJsdWU6IFwiIzg3Q0VFQlwiLFxuICBsaWdodHNreWJsdWU6IFwiIzg3Q0VGQVwiLFxuICBibHVldmlvbGV0OiBcIiM4QTJCRTJcIixcbiAgZGFya3JlZDogXCIjOEIwMDAwXCIsXG4gIGRhcmttYWdlbnRhOiBcIiM4QjAwOEJcIixcbiAgc2FkZGxlYnJvd246IFwiIzhCNDUxM1wiLFxuICBkYXJrc2VhZ3JlZW46IFwiIzhGQkM4RlwiLFxuICBsaWdodGdyZWVuOiBcIiM5MEVFOTBcIixcbiAgbWVkaXVtcHVycGxlOiBcIiM5MzcwRDhcIixcbiAgZGFya3Zpb2xldDogXCIjOTQwMEQzXCIsXG4gIHBhbGVncmVlbjogXCIjOThGQjk4XCIsXG4gIGRhcmtvcmNoaWQ6IFwiIzk5MzJDQ1wiLFxuICB5ZWxsb3dncmVlbjogXCIjOUFDRDMyXCIsXG4gIHNpZW5uYTogXCIjQTA1MjJEXCIsXG4gIGJyb3duOiBcIiNBNTJBMkFcIixcbiAgZGFya2dyYXk6IFwiI0E5QTlBOVwiLFxuICBsaWdodGJsdWU6IFwiI0FERDhFNlwiLFxuICBncmVlbnllbGxvdzogXCIjQURGRjJGXCIsXG4gIHBhbGV0dXJxdW9pc2U6IFwiI0FGRUVFRVwiLFxuICBsaWdodHN0ZWVsYmx1ZTogXCIjQjBDNERFXCIsXG4gIHBvd2RlcmJsdWU6IFwiI0IwRTBFNlwiLFxuICBmaXJlYnJpY2s6IFwiI0IyMjIyMlwiLFxuICBkYXJrZ29sZGVucm9kOiBcIiNCODg2MEJcIixcbiAgbWVkaXVtb3JjaGlkOiBcIiNCQTU1RDNcIixcbiAgcm9zeWJyb3duOiBcIiNCQzhGOEZcIixcbiAgZGFya2toYWtpOiBcIiNCREI3NkJcIixcbiAgc2lsdmVyOiBcIiNDMEMwQzBcIixcbiAgbWVkaXVtdmlvbGV0cmVkOiBcIiNDNzE1ODVcIixcbiAgaW5kaWFucmVkOiBcIiNDRDVDNUNcIixcbiAgcGVydTogXCIjQ0Q4NTNGXCIsXG4gIGNob2NvbGF0ZTogXCIjRDI2OTFFXCIsXG4gIHRhbjogXCIjRDJCNDhDXCIsXG4gIGxpZ2h0Z3JleTogXCIjRDNEM0QzXCIsXG4gIHBhbGV2aW9sZXRyZWQ6IFwiI0Q4NzA5M1wiLFxuICB0aGlzdGxlOiBcIiNEOEJGRDhcIixcbiAgb3JjaGlkOiBcIiNEQTcwRDZcIixcbiAgZ29sZGVucm9kOiBcIiNEQUE1MjBcIixcbiAgY3JpbXNvbjogXCIjREMxNDNDXCIsXG4gIGdhaW5zYm9ybzogXCIjRENEQ0RDXCIsXG4gIHBsdW06IFwiI0REQTBERFwiLFxuICBidXJseXdvb2Q6IFwiI0RFQjg4N1wiLFxuICBsaWdodGN5YW46IFwiI0UwRkZGRlwiLFxuICBsYXZlbmRlcjogXCIjRTZFNkZBXCIsXG4gIGRhcmtzYWxtb246IFwiI0U5OTY3QVwiLFxuICB2aW9sZXQ6IFwiI0VFODJFRVwiLFxuICBwYWxlZ29sZGVucm9kOiBcIiNFRUU4QUFcIixcbiAgbGlnaHRjb3JhbDogXCIjRjA4MDgwXCIsXG4gIGtoYWtpOiBcIiNGMEU2OENcIixcbiAgYWxpY2VibHVlOiBcIiNGMEY4RkZcIixcbiAgaG9uZXlkZXc6IFwiI0YwRkZGMFwiLFxuICBhenVyZTogXCIjRjBGRkZGXCIsXG4gIHNhbmR5YnJvd246IFwiI0Y0QTQ2MFwiLFxuICB3aGVhdDogXCIjRjVERUIzXCIsXG4gIGJlaWdlOiBcIiNGNUY1RENcIixcbiAgd2hpdGVzbW9rZTogXCIjRjVGNUY1XCIsXG4gIG1pbnRjcmVhbTogXCIjRjVGRkZBXCIsXG4gIGdob3N0d2hpdGU6IFwiI0Y4RjhGRlwiLFxuICBzYWxtb246IFwiI0ZBODA3MlwiLFxuICBhbnRpcXVld2hpdGU6IFwiI0ZBRUJEN1wiLFxuICBsaW5lbjogXCIjRkFGMEU2XCIsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBcIiNGQUZBRDJcIixcbiAgb2xkbGFjZTogXCIjRkRGNUU2XCIsXG4gIHJlZDogXCIjRkYwMDAwXCIsXG4gIGZ1Y2hzaWE6IFwiI0ZGMDBGRlwiLFxuICBtYWdlbnRhOiBcIiNGRjAwRkZcIixcbiAgZGVlcHBpbms6IFwiI0ZGMTQ5M1wiLFxuICBvcmFuZ2VyZWQ6IFwiI0ZGNDUwMFwiLFxuICB0b21hdG86IFwiI0ZGNjM0N1wiLFxuICBob3RwaW5rOiBcIiNGRjY5QjRcIixcbiAgY29yYWw6IFwiI0ZGN0Y1MFwiLFxuICBkYXJrb3JhbmdlOiBcIiNGRjhDMDBcIixcbiAgbGlnaHRzYWxtb246IFwiI0ZGQTA3QVwiLFxuICBvcmFuZ2U6IFwiI0ZGQTUwMFwiLFxuICBsaWdodHBpbms6IFwiI0ZGQjZDMVwiLFxuICBwaW5rOiBcIiNGRkMwQ0JcIixcbiAgZ29sZDogXCIjRkZENzAwXCIsXG4gIHBlYWNocHVmZjogXCIjRkZEQUI5XCIsXG4gIG5hdmFqb3doaXRlOiBcIiNGRkRFQURcIixcbiAgbW9jY2FzaW46IFwiI0ZGRTRCNVwiLFxuICBiaXNxdWU6IFwiI0ZGRTRDNFwiLFxuICBtaXN0eXJvc2U6IFwiI0ZGRTRFMVwiLFxuICBibGFuY2hlZGFsbW9uZDogXCIjRkZFQkNEXCIsXG4gIHBhcGF5YXdoaXA6IFwiI0ZGRUZENVwiLFxuICBsYXZlbmRlcmJsdXNoOiBcIiNGRkYwRjVcIixcbiAgc2Vhc2hlbGw6IFwiI0ZGRjVFRVwiLFxuICBjb3Juc2lsazogXCIjRkZGOERDXCIsXG4gIGxlbW9uY2hpZmZvbjogXCIjRkZGQUNEXCIsXG4gIGZsb3JhbHdoaXRlOiBcIiNGRkZBRjBcIixcbiAgc25vdzogXCIjRkZGQUZBXCIsXG4gIHllbGxvdzogXCIjRkZGRjAwXCIsXG4gIGxpZ2h0eWVsbG93OiBcIiNGRkZGRTBcIixcbiAgaXZvcnk6IFwiI0ZGRkZGMFwiLFxuICB3aGl0ZTogXCIjRkZGRkZGXCJcbn07XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGl4ZWxSYXRpbz0xXVxuICovXG5cbnZhciBDb2xvclBpY2tlciQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGl4ZWxSYXRpbz0xXVxuICAgKi9cbiAgZnVuY3Rpb24gQ29sb3JQaWNrZXIkMSgpIHtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvclBpY2tlciQxKTtcblxuICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgdGhpcy5nZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNlbnRlckNvb3JkaW5hdGVzID0ge1xuICAgICAgeDogMjg5IC8gMixcbiAgICAgIHk6IDI4OSAvIDJcbiAgICB9O1xuICAgIHRoaXMuciA9IDI4OSAqIDAuNDk7XG4gICAgdGhpcy5jb2xvciA9IHtcbiAgICAgIHI6IDI1NSxcbiAgICAgIGc6IDI1NSxcbiAgICAgIGI6IDI1NSxcbiAgICAgIGE6IDEuMFxuICAgIH07XG4gICAgdGhpcy5odWVDaXJjbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbml0aWFsQ29sb3IgPSB7XG4gICAgICByOiAyNTUsXG4gICAgICBnOiAyNTUsXG4gICAgICBiOiAyNTUsXG4gICAgICBhOiAxLjBcbiAgICB9O1xuICAgIHRoaXMucHJldmlvdXNDb2xvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFwcGxpZWQgPSBmYWxzZTsgLy8gYm91bmQgYnlcblxuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHRoaXMuY2xvc2VDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9OyAvLyBjcmVhdGUgYWxsIERPTSBlbGVtZW50c1xuXG5cbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgfVxuICAvKipcbiAgICogdGhpcyBpbnNlcnRzIHRoZSBjb2xvclBpY2tlciBpbnRvIGEgZGl2IGZyb20gdGhlIERPTVxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDb2xvclBpY2tlciQxLCBbe1xuICAgIGtleTogXCJpbnNlcnRUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRUbyhjb250YWluZXIpIHtcbiAgICAgIGlmICh0aGlzLmhhbW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5oYW1tZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG5cbiAgICAgIHRoaXMuX2JpbmRIYW1tZXIoKTtcblxuICAgICAgdGhpcy5fc2V0U2l6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgb24gYXBwbHkgYW5kIHNhdmUuIEJpbmQgaXQgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VXBkYXRlQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VXBkYXRlQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBhdHRlbXB0ZWQgdG8gc2V0IGFzIGNvbG9yUGlja2VyIHVwZGF0ZSBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbi5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCBvbiBhcHBseSBhbmQgc2F2ZS4gQmluZCBpdCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRDbG9zZUNhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENsb3NlQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLmNsb3NlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGF0dGVtcHRlZCB0byBzZXQgYXMgY29sb3JQaWNrZXIgY2xvc2luZyBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbi5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzQ29sb3JTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzQ29sb3JTdHJpbmcoY29sb3IpIHtcbiAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGh0bWxDb2xvcnNbY29sb3JdO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNvbG9yIG9mIHRoZSBjb2xvclBpY2tlclxuICAgICAqIFN1cHBvcnRlZCBmb3JtYXRzOlxuICAgICAqICdyZWQnICAgICAgICAgICAgICAgICAgIC0tPiBIVE1MIGNvbG9yIHN0cmluZ1xuICAgICAqICcjZmZmZmZmJyAgICAgICAgICAgICAgIC0tPiBoZXggc3RyaW5nXG4gICAgICogJ3JnYigyNTUsMjU1LDI1NSknICAgICAgLS0+IHJnYiBzdHJpbmdcbiAgICAgKiAncmdiYSgyNTUsMjU1LDI1NSwxLjApJyAtLT4gcmdiYSBzdHJpbmdcbiAgICAgKiB7cjoyNTUsZzoyNTUsYjoyNTV9ICAgICAtLT4gcmdiIG9iamVjdFxuICAgICAqIHtyOjI1NSxnOjI1NSxiOjI1NSxhOjEuMH0gLS0+IHJnYmEgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG9iamVjdH0gY29sb3JcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXRJbml0aWFsPXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb2xvcihjb2xvcikge1xuICAgICAgdmFyIHNldEluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIGlmIChjb2xvciA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmdiYTsgLy8gaWYgYSBodG1sIGNvbG9yIHNob3J0aGFuZCBpcyB1c2VkLCBjb252ZXJ0IHRvIGhleFxuXG4gICAgICB2YXIgaHRtbENvbG9yID0gdGhpcy5faXNDb2xvclN0cmluZyhjb2xvcik7XG5cbiAgICAgIGlmIChodG1sQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb2xvciA9IGh0bWxDb2xvcjtcbiAgICAgIH0gLy8gY2hlY2sgZm9ybWF0XG5cblxuICAgICAgaWYgKGlzU3RyaW5nKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNWYWxpZFJHQihjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgcmdiYUFycmF5ID0gY29sb3Iuc3Vic3RyKDQpLnN1YnN0cigwLCBjb2xvci5sZW5ndGggLSA1KS5zcGxpdChcIixcIik7XG4gICAgICAgICAgcmdiYSA9IHtcbiAgICAgICAgICAgIHI6IHJnYmFBcnJheVswXSxcbiAgICAgICAgICAgIGc6IHJnYmFBcnJheVsxXSxcbiAgICAgICAgICAgIGI6IHJnYmFBcnJheVsyXSxcbiAgICAgICAgICAgIGE6IDEuMFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWYWxpZFJHQkEoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF9yZ2JhQXJyYXkgPSBjb2xvci5zdWJzdHIoNSkuc3Vic3RyKDAsIGNvbG9yLmxlbmd0aCAtIDYpLnNwbGl0KFwiLFwiKTtcblxuICAgICAgICAgIHJnYmEgPSB7XG4gICAgICAgICAgICByOiBfcmdiYUFycmF5WzBdLFxuICAgICAgICAgICAgZzogX3JnYmFBcnJheVsxXSxcbiAgICAgICAgICAgIGI6IF9yZ2JhQXJyYXlbMl0sXG4gICAgICAgICAgICBhOiBfcmdiYUFycmF5WzNdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkSGV4KGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciByZ2JPYmogPSBoZXhUb1JHQihjb2xvcik7XG4gICAgICAgICAgcmdiYSA9IHtcbiAgICAgICAgICAgIHI6IHJnYk9iai5yLFxuICAgICAgICAgICAgZzogcmdiT2JqLmcsXG4gICAgICAgICAgICBiOiByZ2JPYmouYixcbiAgICAgICAgICAgIGE6IDEuMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb2xvciBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIGlmIChjb2xvci5yICE9PSB1bmRlZmluZWQgJiYgY29sb3IuZyAhPT0gdW5kZWZpbmVkICYmIGNvbG9yLmIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gY29sb3IuYSAhPT0gdW5kZWZpbmVkID8gY29sb3IuYSA6IFwiMS4wXCI7XG4gICAgICAgICAgICByZ2JhID0ge1xuICAgICAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgICAgICBiOiBjb2xvci5iLFxuICAgICAgICAgICAgICBhOiBhbHBoYVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gc2V0IGNvbG9yXG5cblxuICAgICAgaWYgKHJnYmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbG9yIHBhc3NlZCB0byB0aGUgY29sb3JQaWNrZXIuIFN1cHBvcnRlZCBhcmUgc3RyaW5nczogcmdiLCBoZXgsIHJnYmEuIE9iamVjdDogcmdiICh7cjpyLGc6ZyxiOmIsW2E6YV19KS4gU3VwcGxpZWQ6IFwiICsgc3RyaW5naWZ5JDEoY29sb3IpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldENvbG9yKHJnYmEsIHNldEluaXRpYWwpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGlzIHNob3dzIHRoZSBjb2xvciBwaWNrZXIuXG4gICAgICogVGhlIGh1ZSBjaXJjbGUgaXMgY29uc3RydWN0ZWQgb25jZSBhbmQgc3RvcmVkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgaWYgKHRoaXMuY2xvc2VDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY2xvc2VDYWxsYmFjaygpO1xuICAgICAgICB0aGlzLmNsb3NlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gICAgICB0aGlzLl9nZW5lcmF0ZUh1ZUNpcmNsZSgpO1xuICAgIH0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFBSSVZBVEUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIHBpY2tlci4gSXMgY2FsbGVkIGJ5IHRoZSBjYW5jZWwgYnV0dG9uLlxuICAgICAqIE9wdGlvbmFsIGJvb2xlYW4gdG8gc3RvcmUgdGhlIHByZXZpb3VzIGNvbG9yIGZvciBlYXN5IGFjY2VzcyBsYXRlciBvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0b3JlUHJldmlvdXM9dHJ1ZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHN0b3JlUHJldmlvdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG5cbiAgICAgIC8vIHN0b3JlIHRoZSBwcmV2aW91cyBjb2xvciBmb3IgbmV4dCB0aW1lO1xuICAgICAgaWYgKHN0b3JlUHJldmlvdXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c0NvbG9yID0gYXNzaWduJDIoe30sIHRoaXMuY29sb3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hcHBsaWVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5pbml0aWFsQ29sb3IpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjsgLy8gY2FsbCB0aGUgY2xvc2luZyBjYWxsYmFjaywgcmVzdG9yaW5nIHRoZSBvbmNsaWNrIG1ldGhvZC5cbiAgICAgIC8vIHRoaXMgaXMgaW4gYSBzZXRUaW1lb3V0IGJlY2F1c2UgaXQgd2lsbCB0cmlnZ2VyIHRoZSBzaG93IGFnYWluIGJlZm9yZSB0aGUgY2xpY2sgaXMgZG9uZS5cblxuICAgICAgc2V0VGltZW91dCQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMi5jbG9zZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBfdGhpczIuY2xvc2VDYWxsYmFjaygpO1xuXG4gICAgICAgICAgX3RoaXMyLmNsb3NlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBib3VuZCB0byB0aGUgc2F2ZSBidXR0b24uIFNhdmVzIGFuZCBoaWRlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2F2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2F2ZSgpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5jb2xvcik7XG4gICAgICB0aGlzLmFwcGxpZWQgPSBmYWxzZTtcblxuICAgICAgdGhpcy5faGlkZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCb3VuZCB0byBhcHBseSBidXR0b24uIFNhdmVzIGJ1dCBkb2VzIG5vdCBjbG9zZS4gSXMgdW5kb25lIGJ5IHRoZSBjYW5jZWwgYnV0dG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwbHkoKSB7XG4gICAgICB0aGlzLmFwcGxpZWQgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmNvbG9yKTtcblxuICAgICAgdGhpcy5fdXBkYXRlUGlja2VyKHRoaXMuY29sb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBsb2FkIHRoZSBjb2xvciBmcm9tIHRoZSBwcmV2aW91cyBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9sb2FkTGFzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZExhc3QoKSB7XG4gICAgICBpZiAodGhpcy5wcmV2aW91c0NvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZXRDb2xvcih0aGlzLnByZXZpb3VzQ29sb3IsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsZXJ0KFwiVGhlcmUgaXMgbm8gbGFzdCBjb2xvciB0byBsb2FkLi4uXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIGNvbG9yLCBwbGFjZSB0aGUgcGlja2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmdiYVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldEluaXRpYWw9dHJ1ZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldENvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDb2xvcihyZ2JhKSB7XG4gICAgICB2YXIgc2V0SW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgLy8gc3RvcmUgdGhlIGluaXRpYWwgY29sb3JcbiAgICAgIGlmIChzZXRJbml0aWFsID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbENvbG9yID0gYXNzaWduJDIoe30sIHJnYmEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbG9yID0gcmdiYTtcbiAgICAgIHZhciBoc3YgPSBSR0JUb0hTVihyZ2JhLnIsIHJnYmEuZywgcmdiYS5iKTtcbiAgICAgIHZhciBhbmdsZUNvbnZlcnQgPSAyICogTWF0aC5QSTtcbiAgICAgIHZhciByYWRpdXMgPSB0aGlzLnIgKiBoc3YucztcbiAgICAgIHZhciB4ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHN2LmgpO1xuICAgICAgdmFyIHkgPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnkgKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUNvbnZlcnQgKiBoc3YuaCk7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUubGVmdCA9IHggLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50V2lkdGggKyBcInB4XCI7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID0geSAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRIZWlnaHQgKyBcInB4XCI7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZVBpY2tlcihyZ2JhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYm91bmQgdG8gb3BhY2l0eSBjb250cm9sXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldE9wYWNpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldE9wYWNpdHkodmFsdWUpIHtcbiAgICAgIHRoaXMuY29sb3IuYSA9IHZhbHVlIC8gMTAwO1xuXG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJvdW5kIHRvIGJyaWdodG5lc3MgY29udHJvbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRCcmlnaHRuZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRCcmlnaHRuZXNzKHZhbHVlKSB7XG4gICAgICB2YXIgaHN2ID0gUkdCVG9IU1YodGhpcy5jb2xvci5yLCB0aGlzLmNvbG9yLmcsIHRoaXMuY29sb3IuYik7XG4gICAgICBoc3YudiA9IHZhbHVlIC8gMTAwO1xuICAgICAgdmFyIHJnYmEgPSBIU1ZUb1JHQihoc3YuaCwgaHN2LnMsIGhzdi52KTtcbiAgICAgIHJnYmFbXCJhXCJdID0gdGhpcy5jb2xvci5hO1xuICAgICAgdGhpcy5jb2xvciA9IHJnYmE7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZVBpY2tlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIGNvbG9yIHBpY2tlci4gQSBibGFjayBjaXJjbGUgb3ZlcmxheXMgdGhlIGh1ZSBjaXJjbGUgdG8gbWltaWMgdGhlIGJyaWdodG5lc3MgZGVjcmVhc2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZ2JhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVQaWNrZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVBpY2tlcigpIHtcbiAgICAgIHZhciByZ2JhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLmNvbG9yO1xuICAgICAgdmFyIGhzdiA9IFJHQlRvSFNWKHJnYmEuciwgcmdiYS5nLCByZ2JhLmIpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICBpZiAodGhpcy5waXhlbFJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7IC8vIGNsZWFyIHRoZSBjYW52YXNcblxuICAgICAgdmFyIHcgPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgdmFyIGggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKHRoaXMuaHVlQ2lyY2xlLCAwLCAwKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMCwwLDAsXCIgKyAoMSAtIGhzdi52KSArIFwiKVwiO1xuICAgICAgY3R4LmNpcmNsZSh0aGlzLmNlbnRlckNvb3JkaW5hdGVzLngsIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSwgdGhpcy5yKTtcblxuICAgICAgZmlsbChjdHgpLmNhbGwoY3R4KTtcblxuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSAxMDAgKiBoc3YudjtcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLnZhbHVlID0gMTAwICogcmdiYS5hO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKFwiICsgdGhpcy5pbml0aWFsQ29sb3IuciArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuZyArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuYiArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuYSArIFwiKVwiO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoXCIgKyB0aGlzLmNvbG9yLnIgKyBcIixcIiArIHRoaXMuY29sb3IuZyArIFwiLFwiICsgdGhpcy5jb2xvci5iICsgXCIsXCIgKyB0aGlzLmNvbG9yLmEgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdXNlZCBieSBjcmVhdGUgdG8gc2V0IHRoZSBzaXplIG9mIHRoZSBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFNpemUoKSB7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy53aWR0aCA9IDI4OSAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuaGVpZ2h0ID0gMjg5ICogdGhpcy5waXhlbFJhdGlvO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYWxsIGRvbSBlbGVtZW50c1xuICAgICAqIFRPRE86IGNsZWFudXAsIGxvdHMgb2Ygc2ltaWxhciBkb20gZWxlbWVudHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICB2YXIgX2NvbnRleHQxNiwgX2NvbnRleHQxNywgX2NvbnRleHQxOCwgX2NvbnRleHQxOTtcblxuICAgICAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9IFwidmlzLWNvbG9yLXBpY2tlclwiO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsYXNzTmFtZSA9IFwidmlzLXNlbGVjdG9yXCI7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvcik7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlckNhbnZhcyk7XG5cbiAgICAgIGlmICghdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAgICAgIHZhciBub0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG4gICAgICAgIG5vQ2FudmFzLnN0eWxlLmNvbG9yID0gXCJyZWRcIjtcbiAgICAgICAgbm9DYW52YXMuc3R5bGUuZm9udFdlaWdodCA9IFwiYm9sZFwiO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5wYWRkaW5nID0gXCIxMHB4XCI7XG4gICAgICAgIG5vQ2FudmFzLmlubmVyVGV4dCA9IFwiRXJyb3I6IHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgY2FudmFzXCI7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuYXBwZW5kQ2hpbGQobm9DYW52YXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29sb3JcIjtcbiAgICAgIHRoaXMub3BhY2l0eURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm9wYWNpdHlEaXYuY2xhc3NOYW1lID0gXCJ2aXMtb3BhY2l0eVwiO1xuICAgICAgdGhpcy5icmlnaHRuZXNzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0Rpdi5jbGFzc05hbWUgPSBcInZpcy1icmlnaHRuZXNzXCI7XG4gICAgICB0aGlzLmFycm93RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuYXJyb3dEaXYuY2xhc3NOYW1lID0gXCJ2aXMtYXJyb3dcIjtcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS50eXBlID0gXCJyYW5nZVwiOyAvLyBOb3Qgc3VwcG9ydGVkIG9uIElFOVxuXG4gICAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm1pbiA9IFwiMFwiO1xuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS5tYXggPSBcIjEwMFwiO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7Ly8gVE9ETzogQWRkIHNvbWUgZXJyb3IgaGFuZGxpbmcuXG4gICAgICB9XG5cbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLnZhbHVlID0gXCIxMDBcIjtcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLmNsYXNzTmFtZSA9IFwidmlzLXJhbmdlXCI7XG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudHlwZSA9IFwicmFuZ2VcIjsgLy8gTm90IHN1cHBvcnRlZCBvbiBJRTlcblxuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5taW4gPSBcIjBcIjtcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UubWF4ID0gXCIxMDBcIjtcbiAgICAgIH0gY2F0Y2ggKGVycikgey8vIFRPRE86IEFkZCBzb21lIGVycm9yIGhhbmRsaW5nLlxuICAgICAgfVxuXG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS52YWx1ZSA9IFwiMTAwXCI7XG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5jbGFzc05hbWUgPSBcInZpcy1yYW5nZVwiO1xuICAgICAgdGhpcy5vcGFjaXR5RGl2LmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eVJhbmdlKTtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0Rpdi5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NSYW5nZSk7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3NldE9wYWNpdHkodGhpcy52YWx1ZSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fc2V0T3BhY2l0eSh0aGlzLnZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fc2V0QnJpZ2h0bmVzcyh0aGlzLnZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl9zZXRCcmlnaHRuZXNzKHRoaXMudmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5icmlnaHRuZXNzTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5icmlnaHRuZXNzTGFiZWwuY2xhc3NOYW1lID0gXCJ2aXMtbGFiZWwgdmlzLWJyaWdodG5lc3NcIjtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsLmlubmVyVGV4dCA9IFwiYnJpZ2h0bmVzczpcIjtcbiAgICAgIHRoaXMub3BhY2l0eUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMub3BhY2l0eUxhYmVsLmNsYXNzTmFtZSA9IFwidmlzLWxhYmVsIHZpcy1vcGFjaXR5XCI7XG4gICAgICB0aGlzLm9wYWNpdHlMYWJlbC5pbm5lclRleHQgPSBcIm9wYWNpdHk6XCI7XG4gICAgICB0aGlzLm5ld0NvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMubmV3Q29sb3JEaXYuY2xhc3NOYW1lID0gXCJ2aXMtbmV3LWNvbG9yXCI7XG4gICAgICB0aGlzLm5ld0NvbG9yRGl2LmlubmVyVGV4dCA9IFwibmV3XCI7XG4gICAgICB0aGlzLmluaXRpYWxDb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5jbGFzc05hbWUgPSBcInZpcy1pbml0aWFsLWNvbG9yXCI7XG4gICAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5pbm5lclRleHQgPSBcImluaXRpYWxcIjtcbiAgICAgIHRoaXMuY2FuY2VsQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtY2FuY2VsXCI7XG4gICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5pbm5lclRleHQgPSBcImNhbmNlbFwiO1xuICAgICAgdGhpcy5jYW5jZWxCdXR0b24ub25jbGljayA9IGJpbmQkNihfY29udGV4dDE2ID0gdGhpcy5faGlkZSkuY2FsbChfY29udGV4dDE2LCB0aGlzLCBmYWxzZSk7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuYXBwbHlCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1hcHBseVwiO1xuICAgICAgdGhpcy5hcHBseUJ1dHRvbi5pbm5lclRleHQgPSBcImFwcGx5XCI7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uLm9uY2xpY2sgPSBiaW5kJDYoX2NvbnRleHQxNyA9IHRoaXMuX2FwcGx5KS5jYWxsKF9jb250ZXh0MTcsIHRoaXMpO1xuICAgICAgdGhpcy5zYXZlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuc2F2ZUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLXNhdmVcIjtcbiAgICAgIHRoaXMuc2F2ZUJ1dHRvbi5pbm5lclRleHQgPSBcInNhdmVcIjtcbiAgICAgIHRoaXMuc2F2ZUJ1dHRvbi5vbmNsaWNrID0gYmluZCQ2KF9jb250ZXh0MTggPSB0aGlzLl9zYXZlKS5jYWxsKF9jb250ZXh0MTgsIHRoaXMpO1xuICAgICAgdGhpcy5sb2FkQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMubG9hZEJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLWxvYWRcIjtcbiAgICAgIHRoaXMubG9hZEJ1dHRvbi5pbm5lclRleHQgPSBcImxvYWQgbGFzdFwiO1xuICAgICAgdGhpcy5sb2FkQnV0dG9uLm9uY2xpY2sgPSBiaW5kJDYoX2NvbnRleHQxOSA9IHRoaXMuX2xvYWRMYXN0KS5jYWxsKF9jb250ZXh0MTksIHRoaXMpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcnJvd0Rpdik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc0xhYmVsKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5TGFiZWwpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlEaXYpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm5ld0NvbG9yRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5pbml0aWFsQ29sb3JEaXYpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNhbmNlbEJ1dHRvbik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYXBwbHlCdXR0b24pO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLnNhdmVCdXR0b24pO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmxvYWRCdXR0b24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBiaW5kIGhhbW1lciB0byB0aGUgY29sb3IgcGlja2VyXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JpbmRIYW1tZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRIYW1tZXIoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5kcmFnID0ge307XG4gICAgICB0aGlzLnBpbmNoID0ge307XG4gICAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIkMSh0aGlzLmNvbG9yUGlja2VyQ2FudmFzKTtcbiAgICAgIHRoaXMuaGFtbWVyLmdldChcInBpbmNoXCIpLnNldCh7XG4gICAgICAgIGVuYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcImhhbW1lci5pbnB1dFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmlzRmlyc3QpIHtcbiAgICAgICAgICBfdGhpczMuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJ0YXBcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5fbW92ZVNlbGVjdG9yKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJwYW5zdGFydFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBhbm1vdmVcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5fbW92ZVNlbGVjdG9yKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJwYW5lbmRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5fbW92ZVNlbGVjdG9yKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSB0aGUgaHVlIGNpcmNsZS4gVGhpcyBpcyByZWxhdGl2ZWx5IGhlYXZ5ICgyMDBtcykgYW5kIGlzIGRvbmUgb25seSBvbmNlIG9uIHRoZSBmaXJzdCB0aW1lIGl0IGlzIHNob3duLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZW5lcmF0ZUh1ZUNpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVIdWVDaXJjbGUoKSB7XG4gICAgICBpZiAodGhpcy5nZW5lcmF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICBpZiAodGhpcy5waXhlbFJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7IC8vIGNsZWFyIHRoZSBjYW52YXNcblxuICAgICAgICB2YXIgdyA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBoID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7IC8vIGRyYXcgaHVlIGNpcmNsZVxuXG4gICAgICAgIHZhciB4LCB5LCBodWUsIHNhdDtcbiAgICAgICAgdGhpcy5jZW50ZXJDb29yZGluYXRlcyA9IHtcbiAgICAgICAgICB4OiB3ICogMC41LFxuICAgICAgICAgIHk6IGggKiAwLjVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yID0gMC40OSAqIHc7XG4gICAgICAgIHZhciBhbmdsZUNvbnZlcnQgPSAyICogTWF0aC5QSSAvIDM2MDtcbiAgICAgICAgdmFyIGhmYWMgPSAxIC8gMzYwO1xuICAgICAgICB2YXIgc2ZhYyA9IDEgLyB0aGlzLnI7XG4gICAgICAgIHZhciByZ2I7XG5cbiAgICAgICAgZm9yIChodWUgPSAwOyBodWUgPCAzNjA7IGh1ZSsrKSB7XG4gICAgICAgICAgZm9yIChzYXQgPSAwOyBzYXQgPCB0aGlzLnI7IHNhdCsrKSB7XG4gICAgICAgICAgICB4ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgc2F0ICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHVlKTtcbiAgICAgICAgICAgIHkgPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnkgKyBzYXQgKiBNYXRoLmNvcyhhbmdsZUNvbnZlcnQgKiBodWUpO1xuICAgICAgICAgICAgcmdiID0gSFNWVG9SR0IoaHVlICogaGZhYywgc2F0ICogc2ZhYywgMSk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2IoXCIgKyByZ2IuciArIFwiLFwiICsgcmdiLmcgKyBcIixcIiArIHJnYi5iICsgXCIpXCI7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoeCAtIDAuNSwgeSAtIDAuNSwgMiwgMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDAsMCwwLDEpXCI7XG4gICAgICAgIGN0eC5jaXJjbGUodGhpcy5jZW50ZXJDb29yZGluYXRlcy54LCB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnksIHRoaXMucik7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5odWVDaXJjbGUgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHcsIGgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmdlbmVyYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1vdmUgdGhlIHNlbGVjdG9yLiBUaGlzIGlzIGNhbGxlZCBieSBoYW1tZXIgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tb3ZlU2VsZWN0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVTZWxlY3RvcihldmVudCkge1xuICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbG9yUGlja2VyRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGxlZnQgPSBldmVudC5jZW50ZXIueCAtIHJlY3QubGVmdDtcbiAgICAgIHZhciB0b3AgPSBldmVudC5jZW50ZXIueSAtIHJlY3QudG9wO1xuICAgICAgdmFyIGNlbnRlclkgPSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyRGl2LmNsaWVudEhlaWdodDtcbiAgICAgIHZhciBjZW50ZXJYID0gMC41ICogdGhpcy5jb2xvclBpY2tlckRpdi5jbGllbnRXaWR0aDtcbiAgICAgIHZhciB4ID0gbGVmdCAtIGNlbnRlclg7XG4gICAgICB2YXIgeSA9IHRvcCAtIGNlbnRlclk7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHgsIHkpO1xuICAgICAgdmFyIHJhZGl1cyA9IDAuOTggKiBNYXRoLm1pbihNYXRoLnNxcnQoeCAqIHggKyB5ICogeSksIGNlbnRlclgpO1xuICAgICAgdmFyIG5ld1RvcCA9IE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyArIGNlbnRlclk7XG4gICAgICB2YXIgbmV3TGVmdCA9IE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyArIGNlbnRlclg7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID0gbmV3VG9wIC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudEhlaWdodCArIFwicHhcIjtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS5sZWZ0ID0gbmV3TGVmdCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRXaWR0aCArIFwicHhcIjsgLy8gc2V0IGNvbG9yXG5cbiAgICAgIHZhciBoID0gYW5nbGUgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgaCA9IGggPCAwID8gaCArIDEgOiBoO1xuICAgICAgdmFyIHMgPSByYWRpdXMgLyB0aGlzLnI7XG4gICAgICB2YXIgaHN2ID0gUkdCVG9IU1YodGhpcy5jb2xvci5yLCB0aGlzLmNvbG9yLmcsIHRoaXMuY29sb3IuYik7XG4gICAgICBoc3YuaCA9IGg7XG4gICAgICBoc3YucyA9IHM7XG4gICAgICB2YXIgcmdiYSA9IEhTVlRvUkdCKGhzdi5oLCBoc3YucywgaHN2LnYpO1xuICAgICAgcmdiYVtcImFcIl0gPSB0aGlzLmNvbG9yLmE7XG4gICAgICB0aGlzLmNvbG9yID0gcmdiYTsgLy8gdXBkYXRlIHByZXZpZXdzXG5cbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwicmdiYShcIiArIHRoaXMuaW5pdGlhbENvbG9yLnIgKyBcIixcIiArIHRoaXMuaW5pdGlhbENvbG9yLmcgKyBcIixcIiArIHRoaXMuaW5pdGlhbENvbG9yLmIgKyBcIixcIiArIHRoaXMuaW5pdGlhbENvbG9yLmEgKyBcIilcIjtcbiAgICAgIHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKFwiICsgdGhpcy5jb2xvci5yICsgXCIsXCIgKyB0aGlzLmNvbG9yLmcgKyBcIixcIiArIHRoaXMuY29sb3IuYiArIFwiLFwiICsgdGhpcy5jb2xvci5hICsgXCIpXCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbG9yUGlja2VyJDE7XG59KCk7XG4vKipcbiAqIFdyYXAgZ2l2ZW4gdGV4dCAobGFzdCBhcmd1bWVudCkgaW4gSFRNTCBlbGVtZW50cyAoYWxsIHByZWNlZGluZyBhcmd1bWVudHMpLlxuICpcbiAqIEBwYXJhbSB7Li4uYW55fSByZXN0IC0gTGlzdCBvZiB0YWcgbmFtZXMgZm9sbG93ZWQgYnkgaW5uZXIgdGV4dC5cbiAqIEByZXR1cm5zIEFuIGVsZW1lbnQgb3IgYSB0ZXh0IG5vZGUuXG4gKi9cblxuXG5mdW5jdGlvbiB3cmFwSW5UYWcoKSB7XG4gIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgIHJlc3RbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuXG4gIGlmIChyZXN0Lmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMuXCIpO1xuICB9IGVsc2UgaWYgKHJlc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJlc3RbMF0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChyZXN0WzBdKTtcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKHdyYXBJblRhZy5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheShzbGljZShyZXN0KS5jYWxsKHJlc3QsIDEpKSkpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59XG4vKipcbiAqIFRoZSB3YXkgdGhpcyB3b3JrcyBpcyBmb3IgYWxsIHByb3BlcnRpZXMgb2YgdGhpcy5wb3NzaWJsZSBvcHRpb25zLCB5b3UgY2FuIHN1cHBseSB0aGUgcHJvcGVydHkgbmFtZSBpbiBhbnkgZm9ybSB0byBsaXN0IHRoZSBvcHRpb25zLlxuICogQm9vbGVhbiBvcHRpb25zIGFyZSByZWNvZ25pc2VkIGFzIEJvb2xlYW5cbiAqIE51bWJlciBvcHRpb25zIHNob3VsZCBiZSB3cml0dGVuIGFzIGFycmF5OiBbZGVmYXVsdCB2YWx1ZSwgbWluIHZhbHVlLCBtYXggdmFsdWUsIHN0ZXBzaXplXVxuICogQ29sb3JzIHNob3VsZCBiZSB3cml0dGVuIGFzIGFycmF5OiBbJ2NvbG9yJywgJyNmZmZmZmYnXVxuICogU3RyaW5ncyB3aXRoIHNob3VsZCBiZSB3cml0dGVuIGFzIGFycmF5OiBbb3B0aW9uMSwgb3B0aW9uMiwgb3B0aW9uMywgLi5dXG4gKlxuICogVGhlIG9wdGlvbnMgYXJlIG1hdGNoZWQgd2l0aCB0aGVpciBjb3VudGVycGFydHMgaW4gZWFjaCBvZiB0aGUgbW9kdWxlcyBhbmQgdGhlIHZhbHVlcyB1c2VkIGluIHRoZSBjb25maWd1cmF0aW9uIGFyZVxuICovXG5cblxudmFyIENvbmZpZ3VyYXRvciQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRNb2R1bGUgICAgICAgIHwgdGhlIGxvY2F0aW9uIHdoZXJlIHBhcmVudE1vZHVsZS5zZXRPcHRpb25zKCkgY2FuIGJlIGNhbGxlZFxuICAgKiBAcGFyYW0ge29iamVjdH0gZGVmYXVsdENvbnRhaW5lciAgICB8IHRoZSBkZWZhdWx0IGNvbnRhaW5lciBvZiB0aGUgbW9kdWxlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWd1cmVPcHRpb25zICAgIHwgdGhlIGZ1bGx5IGNvbmZpZ3VyZWQgYW5kIHByZWRlZmluZWQgb3B0aW9ucyBzZXQgZm91bmQgaW4gYWxsT3B0aW9ucy5qc1xuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyAgICAgICAgICB8IGNhbnZhcyBwaXhlbCByYXRpb1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoaWRlT3B0aW9uICAgICAgICB8IGN1c3RvbSBsb2dpYyB0byBkeW5hbWljYWxseSBoaWRlIG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIENvbmZpZ3VyYXRvciQxKHBhcmVudE1vZHVsZSwgZGVmYXVsdENvbnRhaW5lciwgY29uZmlndXJlT3B0aW9ucykge1xuICAgIHZhciBwaXhlbFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxO1xuICAgIHZhciBoaWRlT3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25maWd1cmF0b3IkMSk7XG5cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudE1vZHVsZTtcbiAgICB0aGlzLmNoYW5nZWRPcHRpb25zID0gW107XG4gICAgdGhpcy5jb250YWluZXIgPSBkZWZhdWx0Q29udGFpbmVyO1xuICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuaGlkZU9wdGlvbiA9IGhpZGVPcHRpb247XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMucG9wdXBDb3VudGVyID0gMDtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBmaWx0ZXI6IHRydWUsXG4gICAgICBjb250YWluZXI6IHVuZGVmaW5lZCxcbiAgICAgIHNob3dCdXR0b246IHRydWVcbiAgICB9O1xuXG4gICAgYXNzaWduJDIodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuY29uZmlndXJlT3B0aW9ucyA9IGNvbmZpZ3VyZU9wdGlvbnM7XG4gICAgdGhpcy5tb2R1bGVPcHRpb25zID0ge307XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IFtdO1xuICAgIHRoaXMucG9wdXBEaXYgPSB7fTtcbiAgICB0aGlzLnBvcHVwTGltaXQgPSA1O1xuICAgIHRoaXMucG9wdXBIaXN0b3J5ID0ge307XG4gICAgdGhpcy5jb2xvclBpY2tlciA9IG5ldyBDb2xvclBpY2tlciQxKHBpeGVsUmF0aW8pO1xuICAgIHRoaXMud3JhcHBlciA9IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogcmVmcmVzaCBhbGwgb3B0aW9ucy5cbiAgICogQmVjYXVzZSBhbGwgbW9kdWxlcyBwYXJzZSB0aGVpciBvcHRpb25zIGJ5IHRoZW1zZWx2ZXMsIHdlIGp1c3QgdXNlIHRoZWlyIG9wdGlvbnMuIFdlIGNvcHkgdGhlbSBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDb25maWd1cmF0b3IkMSwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gcmVzZXQgdGhlIHBvcHVwIGhpc3RvcnkgYmVjYXVzZSB0aGUgaW5kaWNlcyBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQuXG4gICAgICAgIHRoaXMucG9wdXBIaXN0b3J5ID0ge307XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlUG9wdXAoKTtcblxuICAgICAgICB2YXIgZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IG9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSQyKG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IG9wdGlvbnMuam9pbigpO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0aW9ucykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib3B0aW9ucyBjYW5ub3QgYmUgbnVsbFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5jb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmaWx0ZXIob3B0aW9ucykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IGZpbHRlcihvcHRpb25zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5zaG93QnV0dG9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zaG93QnV0dG9uID0gb3B0aW9ucy5zaG93QnV0dG9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW5hYmxlZCA9IG9wdGlvbnMuZW5hYmxlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IHRydWU7XG4gICAgICAgICAgZW5hYmxlZCA9IG9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zO1xuICAgICAgICAgIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbHRlcih0aGlzLm9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gZW5hYmxlZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbW9kdWxlT3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TW9kdWxlT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNb2R1bGVPcHRpb25zKG1vZHVsZU9wdGlvbnMpIHtcbiAgICAgIHRoaXMubW9kdWxlT3B0aW9ucyA9IG1vZHVsZU9wdGlvbnM7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFsbCBET00gZWxlbWVudHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICB0aGlzLmNoYW5nZWRPcHRpb25zID0gW107XG5cbiAgICAgIHZhciBmaWx0ZXIkMSA9IGZpbHRlcih0aGlzLm9wdGlvbnMpO1xuXG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgc2hvdyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBfb3B0aW9uIGluIHRoaXMuY29uZmlndXJlT3B0aW9ucykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29uZmlndXJlT3B0aW9ucywgX29wdGlvbikpIHtcbiAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICBzaG93ID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciQxID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHNob3cgPSBmaWx0ZXIkMShfb3B0aW9uLCBbXSk7XG4gICAgICAgICAgICBzaG93ID0gc2hvdyB8fCB0aGlzLl9oYW5kbGVPYmplY3QodGhpcy5jb25maWd1cmVPcHRpb25zW19vcHRpb25dLCBbX29wdGlvbl0sIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlsdGVyJDEgPT09IHRydWUgfHwgaW5kZXhPZihmaWx0ZXIkMSkuY2FsbChmaWx0ZXIkMSwgX29wdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IHRydWU7IC8vIGxpbmVicmVhayBiZXR3ZWVuIGNhdGVnb3JpZXNcblxuICAgICAgICAgICAgaWYgKGNvdW50ZXIgPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VJdGVtKFtdKTtcbiAgICAgICAgICAgIH0gLy8gYSBoZWFkZXIgZm9yIHRoZSBjYXRlZ29yeVxuXG5cbiAgICAgICAgICAgIHRoaXMuX21ha2VIZWFkZXIoX29wdGlvbik7IC8vIGdldCB0aGUgc3ViIG9wdGlvbnNcblxuXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVPYmplY3QodGhpcy5jb25maWd1cmVPcHRpb25zW19vcHRpb25dLCBbX29wdGlvbl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9tYWtlQnV0dG9uKCk7XG5cbiAgICAgIHRoaXMuX3B1c2goKTsgLy9+IHRoaXMuY29sb3JQaWNrZXIuaW5zZXJ0VG8odGhpcy5jb250YWluZXIpO1xuXG4gICAgfVxuICAgIC8qKlxuICAgICAqIGRyYXcgYWxsIERPTSBlbGVtZW50cyBvbiB0aGUgc2NyZWVuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3B1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3B1c2goKSB7XG4gICAgICB0aGlzLndyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy53cmFwcGVyLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24td3JhcHBlclwiO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy53cmFwcGVyKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2ldKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2hvd1BvcHVwSWZOZWVkZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZGVsZXRlIGFsbCBET00gZWxlbWVudHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2xlYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFuKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud3JhcHBlci5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2ldKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud3JhcHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlcik7XG4gICAgICAgIHRoaXMud3JhcHBlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kb21FbGVtZW50cyA9IFtdO1xuXG4gICAgICB0aGlzLl9yZW1vdmVQb3B1cCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIGFjdHVhbE9wdGlvbnMgaWYgaXQgZXhpc3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWYWx1ZShwYXRoKSB7XG4gICAgICB2YXIgYmFzZSA9IHRoaXMubW9kdWxlT3B0aW9ucztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChiYXNlW3BhdGhbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBiYXNlID0gYmFzZVtwYXRoW2ldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhbGwgb3B0aW9uIGVsZW1lbnRzIGFyZSB3cmFwcGVkIGluIGFuIGl0ZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEVsZW1lbnQ+fSBkb21FbGVtZW50c1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUl0ZW0ocGF0aCkge1xuICAgICAgaWYgKHRoaXMuYWxsb3dDcmVhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGl0ZW0uY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWl0ZW0gdmlzLWNvbmZpZy1zXCIgKyBwYXRoLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGRvbUVsZW1lbnRzID0gbmV3IEFycmF5KF9sZW42ID4gMSA/IF9sZW42IC0gMSA6IDApLCBfa2V5NiA9IDE7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgICAgICBkb21FbGVtZW50c1tfa2V5NiAtIDFdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvckVhY2gkMihkb21FbGVtZW50cykuY2FsbChkb21FbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICBpdGVtLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLnB1c2goaXRlbSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGhlYWRlciBmb3IgbWFqb3Igc3ViamVjdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlSGVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlSGVhZGVyKG5hbWUpIHtcbiAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1oZWFkZXJcIjtcbiAgICAgIGRpdi5pbm5lclRleHQgPSBuYW1lO1xuXG4gICAgICB0aGlzLl9tYWtlSXRlbShbXSwgZGl2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbWFrZSBhIGxhYmVsLCBpZiBpdCBpcyBhbiBvYmplY3QgbGFiZWwsIGl0IGdldHMgZGlmZmVyZW50IHN0eWxpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvYmplY3RMYWJlbFxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VMYWJlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUxhYmVsKG5hbWUsIHBhdGgpIHtcbiAgICAgIHZhciBvYmplY3RMYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctbGFiZWwgdmlzLWNvbmZpZy1zXCIgKyBwYXRoLmxlbmd0aDtcblxuICAgICAgaWYgKG9iamVjdExhYmVsID09PSB0cnVlKSB7XG4gICAgICAgIHdoaWxlIChkaXYuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGRpdi5yZW1vdmVDaGlsZChkaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQod3JhcEluVGFnKFwiaVwiLCBcImJcIiwgbmFtZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGl2LmlubmVyVGV4dCA9IG5hbWUgKyBcIjpcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpdjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbWFrZSBhIGRyb3Bkb3duIGxpc3QgZm9yIG11bHRpcGxlIHBvc3NpYmxlIHN0cmluZyBvcHRvaW5zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VEcm9wZG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZURyb3Bkb3duKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgICAgc2VsZWN0LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1zZWxlY3RcIjtcbiAgICAgIHZhciBzZWxlY3RlZFZhbHVlID0gMDtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGluZGV4T2YoYXJyKS5jYWxsKGFyciwgdmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHNlbGVjdGVkVmFsdWUgPSBpbmRleE9mKGFycikuY2FsbChhcnIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX29wdGlvbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuXG4gICAgICAgIF9vcHRpb24yLnZhbHVlID0gYXJyW2ldO1xuXG4gICAgICAgIGlmIChpID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgX29wdGlvbjIuc2VsZWN0ZWQgPSBcInNlbGVjdGVkXCI7XG4gICAgICAgIH1cblxuICAgICAgICBfb3B0aW9uMi5pbm5lclRleHQgPSBhcnJbaV07XG4gICAgICAgIHNlbGVjdC5hcHBlbmRDaGlsZChfb3B0aW9uMik7XG4gICAgICB9XG5cbiAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgIHNlbGVjdC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuXG4gICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgc2VsZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbWFrZSBhIHJhbmdlIG9iamVjdCBmb3IgbnVtZXJpYyBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVJhbmdlKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcnJbMF07XG4gICAgICB2YXIgbWluID0gYXJyWzFdO1xuICAgICAgdmFyIG1heCA9IGFyclsyXTtcbiAgICAgIHZhciBzdGVwID0gYXJyWzNdO1xuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgcmFuZ2UuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXJhbmdlXCI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJhbmdlLnR5cGUgPSBcInJhbmdlXCI7IC8vIG5vdCBzdXBwb3J0ZWQgb24gSUU5XG5cbiAgICAgICAgcmFuZ2UubWluID0gbWluO1xuICAgICAgICByYW5nZS5tYXggPSBtYXg7XG4gICAgICB9IGNhdGNoIChlcnIpIHsvLyBUT0RPOiBBZGQgc29tZSBlcnJvciBoYW5kbGluZy5cbiAgICAgIH1cblxuICAgICAgcmFuZ2Uuc3RlcCA9IHN0ZXA7IC8vIHNldCB1cCB0aGUgcG9wdXAgc2V0dGluZ3MgaW4gY2FzZSB0aGV5IGFyZSBuZWVkZWQuXG5cbiAgICAgIHZhciBwb3B1cFN0cmluZyA9IFwiXCI7XG4gICAgICB2YXIgcG9wdXBWYWx1ZSA9IDA7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmYWN0b3IgPSAxLjI7XG5cbiAgICAgICAgaWYgKHZhbHVlIDwgMCAmJiB2YWx1ZSAqIGZhY3RvciA8IG1pbikge1xuICAgICAgICAgIHJhbmdlLm1pbiA9IE1hdGguY2VpbCh2YWx1ZSAqIGZhY3Rvcik7XG4gICAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1pbjtcbiAgICAgICAgICBwb3B1cFN0cmluZyA9IFwicmFuZ2UgaW5jcmVhc2VkXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgLyBmYWN0b3IgPCBtaW4pIHtcbiAgICAgICAgICByYW5nZS5taW4gPSBNYXRoLmNlaWwodmFsdWUgLyBmYWN0b3IpO1xuICAgICAgICAgIHBvcHVwVmFsdWUgPSByYW5nZS5taW47XG4gICAgICAgICAgcG9wdXBTdHJpbmcgPSBcInJhbmdlIGluY3JlYXNlZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICogZmFjdG9yID4gbWF4ICYmIG1heCAhPT0gMSkge1xuICAgICAgICAgIHJhbmdlLm1heCA9IE1hdGguY2VpbCh2YWx1ZSAqIGZhY3Rvcik7XG4gICAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1heDtcbiAgICAgICAgICBwb3B1cFN0cmluZyA9IFwicmFuZ2UgaW5jcmVhc2VkXCI7XG4gICAgICAgIH1cblxuICAgICAgICByYW5nZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UudmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIGlucHV0LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1yYW5nZWlucHV0XCI7XG4gICAgICBpbnB1dC52YWx1ZSA9IHJhbmdlLnZhbHVlO1xuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgcmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy52YWx1ZTtcblxuICAgICAgICBtZS5fdXBkYXRlKE51bWJlcih0aGlzLnZhbHVlKSwgcGF0aCk7XG4gICAgICB9O1xuXG4gICAgICByYW5nZS5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnB1dC52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcblxuICAgICAgdmFyIGl0ZW1JbmRleCA9IHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCByYW5nZSwgaW5wdXQpOyAvLyBpZiBhIHBvcHVwIGlzIG5lZWRlZCBBTkQgaXQgaGFzIG5vdCBiZWVuIHNob3duIGZvciB0aGlzIHZhbHVlLCBzaG93IGl0LlxuXG5cbiAgICAgIGlmIChwb3B1cFN0cmluZyAhPT0gXCJcIiAmJiB0aGlzLnBvcHVwSGlzdG9yeVtpdGVtSW5kZXhdICE9PSBwb3B1cFZhbHVlKSB7XG4gICAgICAgIHRoaXMucG9wdXBIaXN0b3J5W2l0ZW1JbmRleF0gPSBwb3B1cFZhbHVlO1xuXG4gICAgICAgIHRoaXMuX3NldHVwUG9wdXAocG9wdXBTdHJpbmcsIGl0ZW1JbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBidXR0b24gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VCdXR0b24oKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93QnV0dG9uID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBnZW5lcmF0ZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGdlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b25cIjtcbiAgICAgICAgZ2VuZXJhdGVCdXR0b24uaW5uZXJUZXh0ID0gXCJnZW5lcmF0ZSBvcHRpb25zXCI7XG5cbiAgICAgICAgZ2VuZXJhdGVCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczQuX3ByaW50T3B0aW9ucygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGdlbmVyYXRlQnV0dG9uLm9ubW91c2VvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGdlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b24gaG92ZXJcIjtcbiAgICAgICAgfTtcblxuICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5vbm1vdXNlb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGdlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b25cIjtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLW9wdGlvbi1jb250YWluZXJcIjtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKHRoaXMub3B0aW9uc0NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaChnZW5lcmF0ZUJ1dHRvbik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHByZXBhcmUgdGhlIHBvcHVwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXR1cFBvcHVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cFBvcHVwKHN0cmluZywgaW5kZXgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCA9PT0gdHJ1ZSAmJiB0aGlzLmFsbG93Q3JlYXRpb24gPT09IHRydWUgJiYgdGhpcy5wb3B1cENvdW50ZXIgPCB0aGlzLnBvcHVwTGltaXQpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi5pZCA9IFwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIjtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIjtcbiAgICAgICAgZGl2LmlubmVyVGV4dCA9IHN0cmluZztcblxuICAgICAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczUuX3JlbW92ZVBvcHVwKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wb3B1cENvdW50ZXIgKz0gMTtcbiAgICAgICAgdGhpcy5wb3B1cERpdiA9IHtcbiAgICAgICAgICBodG1sOiBkaXYsXG4gICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgcG9wdXAgZnJvbSB0aGUgZG9tXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZVBvcHVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVQb3B1cCgpIHtcbiAgICAgIGlmICh0aGlzLnBvcHVwRGl2Lmh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wb3B1cERpdi5oaWRlVGltZW91dCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIHBvcHVwIGlmIGl0IGlzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2hvd1BvcHVwSWZOZWVkZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3dQb3B1cElmTmVlZGVkKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnBvcHVwRGl2Lmh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgY29ycmVzcG9uZGluZ0VsZW1lbnQgPSB0aGlzLmRvbUVsZW1lbnRzW3RoaXMucG9wdXBEaXYuaW5kZXhdO1xuICAgICAgICB2YXIgcmVjdCA9IGNvcnJlc3BvbmRpbmdFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwuc3R5bGUubGVmdCA9IHJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLnRvcCA9IHJlY3QudG9wIC0gMzAgKyBcInB4XCI7IC8vIDMwIGlzIHRoZSBoZWlnaHQ7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpO1xuICAgICAgICB0aGlzLnBvcHVwRGl2LmhpZGVUaW1lb3V0ID0gc2V0VGltZW91dCQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczYucG9wdXBEaXYuaHRtbC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgfSwgMTUwMCk7XG4gICAgICAgIHRoaXMucG9wdXBEaXYuZGVsZXRlVGltZW91dCA9IHNldFRpbWVvdXQkMShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM2Ll9yZW1vdmVQb3B1cCgpO1xuICAgICAgICB9LCAxODAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogbWFrZSBhIGNoZWNrYm94IGZvciBib29sZWFuIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlQ2hlY2tib3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VDaGVja2JveChkZWZhdWx0VmFsdWUsIHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBjaGVja2JveC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgICAgY2hlY2tib3guY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNoZWNrYm94XCI7XG4gICAgICBjaGVja2JveC5jaGVja2VkID0gZGVmYXVsdFZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjaGVja2JveC5jaGVja2VkID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBpZiAoX3R5cGVvZihkZWZhdWx0VmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgIGNoZWNrYm94Lm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fdXBkYXRlKHRoaXMuY2hlY2tlZCwgcGF0aCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcblxuICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGNoZWNrYm94KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbWFrZSBhIHRleHQgaW5wdXQgZmllbGQgZm9yIHN0cmluZyBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZVRleHRJbnB1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVRleHRJbnB1dChkZWZhdWx0VmFsdWUsIHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBjaGVja2JveC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICBjaGVja2JveC5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctdGV4dFwiO1xuICAgICAgY2hlY2tib3gudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgY2hlY2tib3gub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl91cGRhdGUodGhpcy52YWx1ZSwgcGF0aCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcblxuICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGNoZWNrYm94KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbWFrZSBhIGNvbG9yIGZpZWxkIHdpdGggYSBjb2xvciBwaWNrZXIgZm9yIGNvbG9yIGZpZWxkc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlQ29sb3JGaWVsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUNvbG9yRmllbGQoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciBkZWZhdWx0Q29sb3IgPSBhcnJbMV07XG4gICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY29sb3JCbG9ja1wiO1xuICAgICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNvbG9yQmxvY2sgbm9uZVwiO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyBkZWZhdWx0Q29sb3IgOiB2YWx1ZTtcblxuICAgICAgZGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNy5fc2hvd0NvbG9yUGlja2VyKHZhbHVlLCBkaXYsIHBhdGgpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG5cbiAgICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBkaXYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB1c2VkIGJ5IHRoZSBjb2xvciBidXR0b25zIHRvIGNhbGwgdGhlIGNvbG9yIHBpY2tlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpdlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2hvd0NvbG9yUGlja2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93Q29sb3JQaWNrZXIodmFsdWUsIGRpdiwgcGF0aCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIC8vIGNsZWFyIHRoZSBjYWxsYmFjayBmcm9tIHRoaXMgZGl2XG4gICAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICB0aGlzLmNvbG9yUGlja2VyLmluc2VydFRvKGRpdik7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyLnNob3coKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuc2V0Q29sb3IodmFsdWUpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlci5zZXRVcGRhdGVDYWxsYmFjayhmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgdmFyIGNvbG9yU3RyaW5nID0gXCJyZ2JhKFwiICsgY29sb3IuciArIFwiLFwiICsgY29sb3IuZyArIFwiLFwiICsgY29sb3IuYiArIFwiLFwiICsgY29sb3IuYSArIFwiKVwiO1xuICAgICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3JTdHJpbmc7XG5cbiAgICAgICAgX3RoaXM4Ll91cGRhdGUoY29sb3JTdHJpbmcsIHBhdGgpO1xuICAgICAgfSk7IC8vIG9uIGNsb3NlIG9mIHRoZSBjb2xvcnBpY2tlciwgcmVzdG9yZSB0aGUgY2FsbGJhY2suXG5cbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuc2V0Q2xvc2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzOC5fc2hvd0NvbG9yUGlja2VyKHZhbHVlLCBkaXYsIHBhdGgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHBhcnNlIGFuIG9iamVjdCBhbmQgZHJhdyB0aGUgY29ycmVjdCBpdGVtc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXRoPVtdXSAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2hlY2tPbmx5PWZhbHNlXVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVPYmplY3Qob2JqKSB7XG4gICAgICB2YXIgcGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICB2YXIgY2hlY2tPbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciBzaG93ID0gZmFsc2U7XG5cbiAgICAgIHZhciBmaWx0ZXIkMSA9IGZpbHRlcih0aGlzLm9wdGlvbnMpO1xuXG4gICAgICB2YXIgdmlzaWJsZUluU2V0ID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIHN1Yk9iaiBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHN1Yk9iaikpIHtcbiAgICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgaXRlbSA9IG9ialtzdWJPYmpdO1xuICAgICAgICAgIHZhciBuZXdQYXRoID0gY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIHN1Yk9iaik7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciQxID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHNob3cgPSBmaWx0ZXIkMShzdWJPYmosIHBhdGgpOyAvLyBpZiBuZWVkZWQgd2UgbXVzdCBnbyBkZWVwZXIgaW50byB0aGUgb2JqZWN0LlxuXG4gICAgICAgICAgICBpZiAoc2hvdyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5JDIoaXRlbSkgJiYgdHlwZW9mIGl0ZW0gIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGl0ZW0gIT09IFwiYm9vbGVhblwiICYmIGl0ZW0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzaG93ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGNoZWNrT25seSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZpc2libGVJblNldCA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldFZhbHVlKG5ld1BhdGgpO1xuXG4gICAgICAgICAgICBpZiAoaXNBcnJheSQyKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUFycmF5KGl0ZW0sIHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWFrZVRleHRJbnB1dChpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICB0aGlzLl9tYWtlQ2hlY2tib3goaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIHNraXAgdGhlIG9wdGlvbnMgdGhhdCBhcmUgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLmhpZGVPcHRpb24ocGF0aCwgc3ViT2JqLCB0aGlzLm1vZHVsZU9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGx5IGNvbGxhcHNlIG9wdGlvbnMgd2l0aCBhbiBkaXNhYmxlZCBlbmFibGVkIG9wdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5lbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlbmFibGVkUGF0aCA9IGNvcHlBbmRFeHRlbmRBcnJheShuZXdQYXRoLCBcImVuYWJsZWRcIik7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBlbmFibGVkVmFsdWUgPSB0aGlzLl9nZXRWYWx1ZShlbmFibGVkUGF0aCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkVmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0obmV3UGF0aCwgbGFiZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVJblNldCA9IHRoaXMuX2hhbmRsZU9iamVjdChpdGVtLCBuZXdQYXRoKSB8fCB2aXNpYmxlSW5TZXQ7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlQ2hlY2tib3goaXRlbSwgZW5hYmxlZFZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIF9sYWJlbCA9IHRoaXMuX21ha2VMYWJlbChzdWJPYmosIG5ld1BhdGgsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShuZXdQYXRoLCBfbGFiZWwpO1xuXG4gICAgICAgICAgICAgICAgICB2aXNpYmxlSW5TZXQgPSB0aGlzLl9oYW5kbGVPYmplY3QoaXRlbSwgbmV3UGF0aCkgfHwgdmlzaWJsZUluU2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImRvbnQga25vdyBob3cgdG8gaGFuZGxlXCIsIGl0ZW0sIHN1Yk9iaiwgbmV3UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aXNpYmxlSW5TZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGhhbmRsZSB0aGUgYXJyYXkgdHlwZSBvZiBvcHRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUFycmF5KGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJyWzBdID09PSBcInN0cmluZ1wiICYmIGFyclswXSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgIHRoaXMuX21ha2VDb2xvckZpZWxkKGFyciwgdmFsdWUsIHBhdGgpO1xuXG4gICAgICAgIGlmIChhcnJbMV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJyWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRoaXMuX21ha2VEcm9wZG93bihhcnIsIHZhbHVlLCBwYXRoKTtcblxuICAgICAgICBpZiAoYXJyWzBdICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyclswXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aGlzLl9tYWtlUmFuZ2UoYXJyLCB2YWx1ZSwgcGF0aCk7XG5cbiAgICAgICAgaWYgKGFyclswXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIodmFsdWUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogY2FsbGVkIHRvIHVwZGF0ZSB0aGUgbmV0d29yayB3aXRoIHRoZSBuZXcgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModmFsdWUsIHBhdGgpO1xuXG4gICAgICBpZiAodGhpcy5wYXJlbnQuYm9keSAmJiB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIgJiYgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQoXCJjb25maWdDaGFuZ2VcIiwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5wYXJlbnQuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IGJvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gcGF0aFxuICAgICAqIEBwYXJhbSB7e319IG9wdGlvbnNPYmpcbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jb25zdHJ1Y3RPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb25zdHJ1Y3RPcHRpb25zKHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgb3B0aW9uc09iaiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICB2YXIgcG9pbnRlciA9IG9wdGlvbnNPYmo7IC8vIHdoZW4gZHJvcGRvd24gYm94ZXMgY2FuIGJlIHN0cmluZyBvciBib29sZWFuLCB3ZSB0eXBlY2FzdCBpdCBpbnRvIGNvcnJlY3QgdHlwZXNcblxuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDogdmFsdWU7XG4gICAgICB2YWx1ZSA9IHZhbHVlID09PSBcImZhbHNlXCIgPyBmYWxzZSA6IHZhbHVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhdGhbaV0gIT09IFwiZ2xvYmFsXCIpIHtcbiAgICAgICAgICBpZiAocG9pbnRlcltwYXRoW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwb2ludGVyW3BhdGhbaV1dID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGkgIT09IHBhdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXJbcGF0aFtpXV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50ZXJbcGF0aFtpXV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbnNPYmo7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcHJpbnRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmludE9wdGlvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuXG4gICAgICB3aGlsZSAodGhpcy5vcHRpb25zQ29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMub3B0aW9uc0NvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zQ29udGFpbmVyLmFwcGVuZENoaWxkKHdyYXBJblRhZyhcInByZVwiLCBcImNvbnN0IG9wdGlvbnMgPSBcIiArIHN0cmluZ2lmeSQxKG9wdGlvbnMsIG51bGwsIDIpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge3t9fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hhbmdlZE9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fY29uc3RydWN0T3B0aW9ucyh0aGlzLmNoYW5nZWRPcHRpb25zW2ldLnZhbHVlLCB0aGlzLmNoYW5nZWRPcHRpb25zW2ldLnBhdGgsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29uZmlndXJhdG9yJDE7XG59KCk7XG4vKipcbiAqIFBvcHVwIGlzIGEgY2xhc3MgdG8gY3JlYXRlIGEgcG9wdXAgd2luZG93IHdpdGggc29tZSB0ZXh0XG4gKi9cblxuXG52YXIgUG9wdXAkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAgICAgICBUaGUgY29udGFpbmVyIG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICBvdmVyZmxvd01ldGhvZCAgSG93IHRoZSBwb3B1cCBzaG91bGQgYWN0IHRvIG92ZXJmbG93aW5nICgnZmxpcCcgb3IgJ2NhcCcpXG4gICAqL1xuICBmdW5jdGlvbiBQb3B1cCQxKGNvbnRhaW5lciwgb3ZlcmZsb3dNZXRob2QpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wdXAkMSk7XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLm92ZXJmbG93TWV0aG9kID0gb3ZlcmZsb3dNZXRob2QgfHwgXCJjYXBcIjtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5wYWRkaW5nID0gNTtcbiAgICB0aGlzLmhpZGRlbiA9IGZhbHNlOyAvLyBjcmVhdGUgdGhlIGZyYW1lXG5cbiAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9IFwidmlzLXRvb2x0aXBcIjtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggICBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBwb3B1cCB3aW5kb3dcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgICBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgcG9wdXAgd2luZG93XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFBvcHVwJDEsIFt7XG4gICAga2V5OiBcInNldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc2l0aW9uKHgsIHkpIHtcbiAgICAgIHRoaXMueCA9IF9wYXJzZUludCh4KTtcbiAgICAgIHRoaXMueSA9IF9wYXJzZUludCh5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb250ZW50IGZvciB0aGUgcG9wdXAgd2luZG93LiBUaGlzIGNhbiBiZSBIVE1MIGNvZGUgb3IgdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgRWxlbWVudH0gY29udGVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUZXh0KGNvbnRlbnQpIHtcbiAgICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFtZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLmZyYW1lLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFN0cmluZyBjb250YWluaW5nIGxpdGVyYWwgdGV4dCwgZWxlbWVudCBoYXMgdG8gYmUgdXNlZCBmb3IgSFRNTCBkdWUgdG9cbiAgICAgICAgLy8gWFNTIHJpc2tzIGFzc29jaWF0ZWQgd2l0aCBpbm5lckhUTUwgKGkuZS4gcHJldmVudCBYU1MgYnkgYWNjaWRlbnQpLlxuICAgICAgICB0aGlzLmZyYW1lLmlubmVyVGV4dCA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIHBvcHVwIHdpbmRvd1xuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9TaG93XSAgICBTaG93IG9yIGhpZGUgdGhlIHdpbmRvd1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KGRvU2hvdykge1xuICAgICAgaWYgKGRvU2hvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRvU2hvdyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb1Nob3cgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZnJhbWUuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmZyYW1lLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gdGhpcy5mcmFtZS5wYXJlbnROb2RlLmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIG1heFdpZHRoID0gdGhpcy5mcmFtZS5wYXJlbnROb2RlLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgbGVmdCA9IDAsXG4gICAgICAgICAgICB0b3AgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLm92ZXJmbG93TWV0aG9kID09IFwiZmxpcFwiKSB7XG4gICAgICAgICAgdmFyIGlzTGVmdCA9IGZhbHNlLFxuICAgICAgICAgICAgICBpc1RvcCA9IHRydWU7IC8vIFdoZXJlIGFyb3VuZCB0aGUgcG9zaXRpb24gaXQncyBsb2NhdGVkXG5cbiAgICAgICAgICBpZiAodGhpcy55IC0gaGVpZ2h0IDwgdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICBpc1RvcCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnggKyB3aWR0aCA+IG1heFdpZHRoIC0gdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICBpc0xlZnQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0xlZnQpIHtcbiAgICAgICAgICAgIGxlZnQgPSB0aGlzLnggLSB3aWR0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IHRoaXMueDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNUb3ApIHtcbiAgICAgICAgICAgIHRvcCA9IHRoaXMueSAtIGhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wID0gdGhpcy55O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3AgPSB0aGlzLnkgLSBoZWlnaHQ7XG5cbiAgICAgICAgICBpZiAodG9wICsgaGVpZ2h0ICsgdGhpcy5wYWRkaW5nID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICB0b3AgPSBtYXhIZWlnaHQgLSBoZWlnaHQgLSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRvcCA8IHRoaXMucGFkZGluZykge1xuICAgICAgICAgICAgdG9wID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxlZnQgPSB0aGlzLng7XG5cbiAgICAgICAgICBpZiAobGVmdCArIHdpZHRoICsgdGhpcy5wYWRkaW5nID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgIGxlZnQgPSBtYXhXaWR0aCAtIHdpZHRoIC0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZWZ0IDwgdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICBsZWZ0ID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBwb3B1cCB3aW5kb3dcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUubGVmdCA9IFwiMFwiO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgcG9wdXAgd2luZG93XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mcmFtZSk7IC8vIFJlbW92ZSBlbGVtZW50IGZyb20gRE9NXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvcHVwJDE7XG59KCk7XG5cbnZhciBlcnJvckZvdW5kID0gZmFsc2U7XG52YXIgYWxsT3B0aW9ucyQxO1xudmFyIFZBTElEQVRPUl9QUklOVF9TVFlMRSQxID0gXCJiYWNrZ3JvdW5kOiAjRkZlZWVlOyBjb2xvcjogI2RkMDAwMFwiO1xuLyoqXG4gKiAgVXNlZCB0byB2YWxpZGF0ZSBvcHRpb25zLlxuICovXG5cbnZhciBWYWxpZGF0b3IkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZhbGlkYXRvciQxKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWYWxpZGF0b3IkMSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVmFsaWRhdG9yJDEsIG51bGwsIFt7XG4gICAga2V5OiBcInZhbGlkYXRlXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogTWFpbiBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlZmVyZW5jZU9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3ViT2JqZWN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHN1Yk9iamVjdCkge1xuICAgICAgZXJyb3JGb3VuZCA9IGZhbHNlO1xuICAgICAgYWxsT3B0aW9ucyQxID0gcmVmZXJlbmNlT3B0aW9ucztcbiAgICAgIHZhciB1c2VkT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnM7XG5cbiAgICAgIGlmIChzdWJPYmplY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1c2VkT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnNbc3ViT2JqZWN0XTtcbiAgICAgIH1cblxuICAgICAgVmFsaWRhdG9yJDEucGFyc2Uob3B0aW9ucywgdXNlZE9wdGlvbnMsIFtdKTtcbiAgICAgIHJldHVybiBlcnJvckZvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHRyYXZlcnNlIGFuIG9iamVjdCByZWN1cnNpdmVseSBhbmQgY2hlY2sgZXZlcnkgdmFsdWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlZmVyZW5jZU9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKSB7XG4gICAgICBmb3IgKHZhciBfb3B0aW9uMyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgX29wdGlvbjMpKSB7XG4gICAgICAgICAgVmFsaWRhdG9yJDEuY2hlY2soX29wdGlvbjMsIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGV2ZXJ5IHZhbHVlLiBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LCBjYWxsIHRoZSBwYXJzZSBmdW5jdGlvbiBvbiB0aGF0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VPcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2sob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKSB7XG4gICAgICBpZiAocmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dID09PSB1bmRlZmluZWQgJiYgcmVmZXJlbmNlT3B0aW9ucy5fX2FueV9fID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgVmFsaWRhdG9yJDEuZ2V0U3VnZ2VzdGlvbihvcHRpb24sIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZWZlcmVuY2VPcHRpb24gPSBvcHRpb247XG4gICAgICB2YXIgaXNfb2JqZWN0ID0gdHJ1ZTtcblxuICAgICAgaWYgKHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXSA9PT0gdW5kZWZpbmVkICYmIHJlZmVyZW5jZU9wdGlvbnMuX19hbnlfXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgb25seSB0cmlnZ2VycyBpZiB0aGUgX19hbnlfXyBpcyBpbiB0aGUgdG9wIGxldmVsIG9mIHRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgICAgLy8gICAgICAgVEhBVCdTIEEgUkVBTExZIEJBRCBQTEFDRSBUTyBBTExPVyBJVCEhISFcbiAgICAgICAgLy8gVE9ETzogRXhhbWluZSBpZiBuZWVkZWQsIHJlbW92ZSBpZiBwb3NzaWJsZVxuICAgICAgICAvLyBfX2FueV9fIGlzIGEgd2lsZGNhcmQuIEFueSB2YWx1ZSBpcyBhY2NlcHRlZCBhbmQgd2lsbCBiZSBmdXJ0aGVyIGFuYWx5c2VkIGJ5IHJlZmVyZW5jZS5cbiAgICAgICAgcmVmZXJlbmNlT3B0aW9uID0gXCJfX2FueV9fXCI7IC8vIGlmIHRoZSBhbnktc3ViZ3JvdXAgaXMgbm90IGEgcHJlZGVmaW5lZCBvYmplY3QgaW4gdGhlIGNvbmZpZ3VyYXRvcixcbiAgICAgICAgLy8gd2UgZG8gbm90IGxvb2sgZGVlcGVyIGludG8gdGhlIG9iamVjdC5cblxuICAgICAgICBpc19vYmplY3QgPSBWYWxpZGF0b3IkMS5nZXRUeXBlKG9wdGlvbnNbb3B0aW9uXSkgPT09IFwib2JqZWN0XCI7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWZPcHRpb25PYmogPSByZWZlcmVuY2VPcHRpb25zW3JlZmVyZW5jZU9wdGlvbl07XG5cbiAgICAgIGlmIChpc19vYmplY3QgJiYgcmVmT3B0aW9uT2JqLl9fdHlwZV9fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVmT3B0aW9uT2JqID0gcmVmT3B0aW9uT2JqLl9fdHlwZV9fO1xuICAgICAgfVxuXG4gICAgICBWYWxpZGF0b3IkMS5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbiwgcmVmT3B0aW9uT2JqLCBwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIG9wdGlvbiAgICAgICAgICAgfCB0aGUgb3B0aW9uIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtvYmplY3R9ICBvcHRpb25zICAgICAgICAgIHwgVGhlIHN1cHBsaWVkIG9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9ICByZWZlcmVuY2VPcHRpb25zIHwgVGhlIHJlZmVyZW5jZSBvcHRpb25zIGNvbnRhaW5pbmcgYWxsIG9wdGlvbnMgYW5kIHRoZWlyIGFsbG93ZWQgZm9ybWF0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgcmVmZXJlbmNlT3B0aW9uICB8IFVzdWFsbHkgdGhpcyBpcyB0aGUgc2FtZSBhcyBvcHRpb24sIGV4Y2VwdCB3aGVuIGhhbmRsaW5nIGFuIF9fYW55X18gdGFnLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgcmVmT3B0aW9uT2JqICAgICB8IFRoaXMgaXMgdGhlIHR5cGUgb2JqZWN0IGZyb20gdGhlIHJlZmVyZW5jZSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheX0gICBwYXRoICAgICAgICAgICAgIHwgd2hlcmUgaW4gdGhlIG9iamVjdCBpcyB0aGUgb3B0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tGaWVsZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCByZWZlcmVuY2VPcHRpb24sIHJlZk9wdGlvbk9iaiwgcGF0aCkge1xuICAgICAgdmFyIGxvZyA9IGZ1bmN0aW9uIGxvZyhtZXNzYWdlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCIlY1wiICsgbWVzc2FnZSArIFZhbGlkYXRvciQxLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSwgVkFMSURBVE9SX1BSSU5UX1NUWUxFJDEpO1xuICAgICAgfTtcblxuICAgICAgdmFyIG9wdGlvblR5cGUgPSBWYWxpZGF0b3IkMS5nZXRUeXBlKG9wdGlvbnNbb3B0aW9uXSk7XG4gICAgICB2YXIgcmVmT3B0aW9uVHlwZSA9IHJlZk9wdGlvbk9ialtvcHRpb25UeXBlXTtcblxuICAgICAgaWYgKHJlZk9wdGlvblR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBpZiB0aGUgdHlwZSBpcyBjb3JyZWN0LCB3ZSBjaGVjayBpZiBpdCBpcyBzdXBwb3NlZCB0byBiZSBvbmUgb2YgYSBmZXcgc2VsZWN0IHZhbHVlc1xuICAgICAgICBpZiAoVmFsaWRhdG9yJDEuZ2V0VHlwZShyZWZPcHRpb25UeXBlKSA9PT0gXCJhcnJheVwiICYmIGluZGV4T2YocmVmT3B0aW9uVHlwZSkuY2FsbChyZWZPcHRpb25UeXBlLCBvcHRpb25zW29wdGlvbl0pID09PSAtMSkge1xuICAgICAgICAgIGxvZygnSW52YWxpZCBvcHRpb24gZGV0ZWN0ZWQgaW4gXCInICsgb3B0aW9uICsgJ1wiLicgKyBcIiBBbGxvd2VkIHZhbHVlcyBhcmU6XCIgKyBWYWxpZGF0b3IkMS5wcmludChyZWZPcHRpb25UeXBlKSArICcgbm90IFwiJyArIG9wdGlvbnNbb3B0aW9uXSArICdcIi4gJyk7XG4gICAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9uVHlwZSA9PT0gXCJvYmplY3RcIiAmJiByZWZlcmVuY2VPcHRpb24gIT09IFwiX19hbnlfX1wiKSB7XG4gICAgICAgICAgcGF0aCA9IGNvcHlBbmRFeHRlbmRBcnJheShwYXRoLCBvcHRpb24pO1xuICAgICAgICAgIFZhbGlkYXRvciQxLnBhcnNlKG9wdGlvbnNbb3B0aW9uXSwgcmVmZXJlbmNlT3B0aW9uc1tyZWZlcmVuY2VPcHRpb25dLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWZPcHRpb25PYmpbXCJhbnlcIl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0eXBlIG9mIHRoZSBmaWVsZCBpcyBpbmNvcnJlY3QgYW5kIHRoZSBmaWVsZCBjYW5ub3QgYmUgYW55XG4gICAgICAgIGxvZygnSW52YWxpZCB0eXBlIHJlY2VpdmVkIGZvciBcIicgKyBvcHRpb24gKyAnXCIuIEV4cGVjdGVkOiAnICsgVmFsaWRhdG9yJDEucHJpbnQoa2V5cyQ0KHJlZk9wdGlvbk9iaikpICsgXCIuIFJlY2VpdmVkIFtcIiArIG9wdGlvblR5cGUgKyAnXSBcIicgKyBvcHRpb25zW29wdGlvbl0gKyAnXCInKTtcbiAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3QgfCBib29sZWFuIHwgbnVtYmVyIHwgc3RyaW5nIHwgQXJyYXkuPG51bWJlcj4gfCBEYXRlIHwgTm9kZSB8IE1vbWVudCB8IHVuZGVmaW5lZCB8IG51bGx9IG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUeXBlKG9iamVjdCkge1xuICAgICAgdmFyIHR5cGUgPSBfdHlwZW9mKG9iamVjdCk7XG5cbiAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FycmF5JDIob2JqZWN0KSkge1xuICAgICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgIHJldHVybiBcImRhdGVcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmplY3Qubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBcImRvbVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdC5faXNBTW9tZW50T2JqZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIFwibW9tZW50XCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJvYmplY3RcIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3VnZ2VzdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdWdnZXN0aW9uKG9wdGlvbiwgb3B0aW9ucywgcGF0aCkge1xuICAgICAgdmFyIGxvY2FsU2VhcmNoID0gVmFsaWRhdG9yJDEuZmluZEluT3B0aW9ucyhvcHRpb24sIG9wdGlvbnMsIHBhdGgsIGZhbHNlKTtcbiAgICAgIHZhciBnbG9iYWxTZWFyY2ggPSBWYWxpZGF0b3IkMS5maW5kSW5PcHRpb25zKG9wdGlvbiwgYWxsT3B0aW9ucyQxLCBbXSwgdHJ1ZSk7XG4gICAgICB2YXIgbG9jYWxTZWFyY2hUaHJlc2hvbGQgPSA4O1xuICAgICAgdmFyIGdsb2JhbFNlYXJjaFRocmVzaG9sZCA9IDQ7XG4gICAgICB2YXIgbXNnO1xuXG4gICAgICBpZiAobG9jYWxTZWFyY2guaW5kZXhNYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1zZyA9IFwiIGluIFwiICsgVmFsaWRhdG9yJDEucHJpbnRMb2NhdGlvbihsb2NhbFNlYXJjaC5wYXRoLCBvcHRpb24sIFwiXCIpICsgJ1BlcmhhcHMgaXQgd2FzIGluY29tcGxldGU/IERpZCB5b3UgbWVhbjogXCInICsgbG9jYWxTZWFyY2guaW5kZXhNYXRjaCArICdcIj9cXG5cXG4nO1xuICAgICAgfSBlbHNlIGlmIChnbG9iYWxTZWFyY2guZGlzdGFuY2UgPD0gZ2xvYmFsU2VhcmNoVGhyZXNob2xkICYmIGxvY2FsU2VhcmNoLmRpc3RhbmNlID4gZ2xvYmFsU2VhcmNoLmRpc3RhbmNlKSB7XG4gICAgICAgIG1zZyA9IFwiIGluIFwiICsgVmFsaWRhdG9yJDEucHJpbnRMb2NhdGlvbihsb2NhbFNlYXJjaC5wYXRoLCBvcHRpb24sIFwiXCIpICsgXCJQZXJoYXBzIGl0IHdhcyBtaXNwbGFjZWQ/IE1hdGNoaW5nIG9wdGlvbiBmb3VuZCBhdDogXCIgKyBWYWxpZGF0b3IkMS5wcmludExvY2F0aW9uKGdsb2JhbFNlYXJjaC5wYXRoLCBnbG9iYWxTZWFyY2guY2xvc2VzdE1hdGNoLCBcIlwiKTtcbiAgICAgIH0gZWxzZSBpZiAobG9jYWxTZWFyY2guZGlzdGFuY2UgPD0gbG9jYWxTZWFyY2hUaHJlc2hvbGQpIHtcbiAgICAgICAgbXNnID0gJy4gRGlkIHlvdSBtZWFuIFwiJyArIGxvY2FsU2VhcmNoLmNsb3Nlc3RNYXRjaCArICdcIj8nICsgVmFsaWRhdG9yJDEucHJpbnRMb2NhdGlvbihsb2NhbFNlYXJjaC5wYXRoLCBvcHRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXNnID0gXCIuIERpZCB5b3UgbWVhbiBvbmUgb2YgdGhlc2U6IFwiICsgVmFsaWRhdG9yJDEucHJpbnQoa2V5cyQ0KG9wdGlvbnMpKSArIFZhbGlkYXRvciQxLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5lcnJvcignJWNVbmtub3duIG9wdGlvbiBkZXRlY3RlZDogXCInICsgb3B0aW9uICsgJ1wiJyArIG1zZywgVkFMSURBVE9SX1BSSU5UX1NUWUxFJDEpO1xuICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRyYXZlcnNlIHRoZSBvcHRpb25zIGluIHNlYXJjaCBmb3IgYSBtYXRjaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlY3Vyc2l2ZT1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7e2Nsb3Nlc3RNYXRjaDogc3RyaW5nLCBwYXRoOiBBcnJheSwgZGlzdGFuY2U6IG51bWJlcn19XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZEluT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9ucywgcGF0aCkge1xuICAgICAgdmFyIHJlY3Vyc2l2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgICB2YXIgbWluID0gMWU5O1xuICAgICAgdmFyIGNsb3Nlc3RNYXRjaCA9IFwiXCI7XG4gICAgICB2YXIgY2xvc2VzdE1hdGNoUGF0aCA9IFtdO1xuICAgICAgdmFyIGxvd2VyQ2FzZU9wdGlvbiA9IG9wdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGluZGV4TWF0Y2ggPSB1bmRlZmluZWQ7XG5cbiAgICAgIGZvciAodmFyIG9wIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChvcHRpb25zW29wXS5fX3R5cGVfXyAhPT0gdW5kZWZpbmVkICYmIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBWYWxpZGF0b3IkMS5maW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9uc1tvcF0sIGNvcHlBbmRFeHRlbmRBcnJheShwYXRoLCBvcCkpO1xuXG4gICAgICAgICAgaWYgKG1pbiA+IHJlc3VsdC5kaXN0YW5jZSkge1xuICAgICAgICAgICAgY2xvc2VzdE1hdGNoID0gcmVzdWx0LmNsb3Nlc3RNYXRjaDtcbiAgICAgICAgICAgIGNsb3Nlc3RNYXRjaFBhdGggPSByZXN1bHQucGF0aDtcbiAgICAgICAgICAgIG1pbiA9IHJlc3VsdC5kaXN0YW5jZTtcbiAgICAgICAgICAgIGluZGV4TWF0Y2ggPSByZXN1bHQuaW5kZXhNYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0MjA7XG5cbiAgICAgICAgICBpZiAoaW5kZXhPZihfY29udGV4dDIwID0gb3AudG9Mb3dlckNhc2UoKSkuY2FsbChfY29udGV4dDIwLCBsb3dlckNhc2VPcHRpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgaW5kZXhNYXRjaCA9IG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpc3RhbmNlID0gVmFsaWRhdG9yJDEubGV2ZW5zaHRlaW5EaXN0YW5jZShvcHRpb24sIG9wKTtcblxuICAgICAgICAgIGlmIChtaW4gPiBkaXN0YW5jZSkge1xuICAgICAgICAgICAgY2xvc2VzdE1hdGNoID0gb3A7XG4gICAgICAgICAgICBjbG9zZXN0TWF0Y2hQYXRoID0gY29weUFycmF5KHBhdGgpO1xuICAgICAgICAgICAgbWluID0gZGlzdGFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsb3Nlc3RNYXRjaDogY2xvc2VzdE1hdGNoLFxuICAgICAgICBwYXRoOiBjbG9zZXN0TWF0Y2hQYXRoLFxuICAgICAgICBkaXN0YW5jZTogbWluLFxuICAgICAgICBpbmRleE1hdGNoOiBpbmRleE1hdGNoXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByaW50TG9jYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pIHtcbiAgICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiUHJvYmxlbSB2YWx1ZSBmb3VuZCBhdDogXFxuXCI7XG4gICAgICB2YXIgc3RyID0gXCJcXG5cXG5cIiArIHByZWZpeCArIFwib3B0aW9ucyA9IHtcXG5cIjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaSArIDE7IGorKykge1xuICAgICAgICAgIHN0ciArPSBcIiAgXCI7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gcGF0aFtpXSArIFwiOiB7XFxuXCI7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBwYXRoLmxlbmd0aCArIDE7IF9qKyspIHtcbiAgICAgICAgc3RyICs9IFwiICBcIjtcbiAgICAgIH1cblxuICAgICAgc3RyICs9IG9wdGlvbiArIFwiXFxuXCI7XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHBhdGgubGVuZ3RoICsgMTsgX2kzKyspIHtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgcGF0aC5sZW5ndGggLSBfaTM7IF9qMisrKSB7XG4gICAgICAgICAgc3RyICs9IFwiICBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSBcIn1cXG5cIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ciArIFwiXFxuXFxuXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcmludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5JDEob3B0aW9ucykucmVwbGFjZSgvKFwiKXwoXFxbKXwoXFxdKXwoLFwiX190eXBlX19cIikvZywgXCJcIikucmVwbGFjZSgvKCwpL2csIFwiLCBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBlZGl0IGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzXG4gICAgICogaHR0cDovL2VuLndpa2lib29rcy5vcmcvd2lraS9BbGdvcml0aG1fSW1wbGVtZW50YXRpb24vU3RyaW5ncy9MZXZlbnNodGVpbl9kaXN0YW5jZSNKYXZhU2NyaXB0XG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTEgQW5kcmVpIE1hY2tlbnppZVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48bnVtYmVyPj59fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxldmVuc2h0ZWluRGlzdGFuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGV2ZW5zaHRlaW5EaXN0YW5jZShhLCBiKSB7XG4gICAgICBpZiAoYS5sZW5ndGggPT09IDApIHJldHVybiBiLmxlbmd0aDtcbiAgICAgIGlmIChiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGEubGVuZ3RoO1xuICAgICAgdmFyIG1hdHJpeCA9IFtdOyAvLyBpbmNyZW1lbnQgYWxvbmcgdGhlIGZpcnN0IGNvbHVtbiBvZiBlYWNoIHJvd1xuXG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8PSBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hdHJpeFtpXSA9IFtpXTtcbiAgICAgIH0gLy8gaW5jcmVtZW50IGVhY2ggY29sdW1uIGluIHRoZSBmaXJzdCByb3dcblxuXG4gICAgICB2YXIgajtcblxuICAgICAgZm9yIChqID0gMDsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG1hdHJpeFswXVtqXSA9IGo7XG4gICAgICB9IC8vIEZpbGwgaW4gdGhlIHJlc3Qgb2YgdGhlIG1hdHJpeFxuXG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAxOyBqIDw9IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoYi5jaGFyQXQoaSAtIDEpID09IGEuY2hhckF0KGogLSAxKSkge1xuICAgICAgICAgICAgbWF0cml4W2ldW2pdID0gbWF0cml4W2kgLSAxXVtqIC0gMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IE1hdGgubWluKG1hdHJpeFtpIC0gMV1baiAtIDFdICsgMSwgLy8gc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICBNYXRoLm1pbihtYXRyaXhbaV1baiAtIDFdICsgMSwgLy8gaW5zZXJ0aW9uXG4gICAgICAgICAgICBtYXRyaXhbaSAtIDFdW2pdICsgMSkpOyAvLyBkZWxldGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0cml4W2IubGVuZ3RoXVthLmxlbmd0aF07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZhbGlkYXRvciQxO1xufSgpO1xuXG52YXIgQWN0aXZhdG9yID0gQWN0aXZhdG9yJDE7XG52YXIgQ29uZmlndXJhdG9yID0gQ29uZmlndXJhdG9yJDE7XG52YXIgSGFtbWVyID0gSGFtbWVyJDE7XG52YXIgUG9wdXAgPSBQb3B1cCQxO1xudmFyIFZBTElEQVRPUl9QUklOVF9TVFlMRSA9IFZBTElEQVRPUl9QUklOVF9TVFlMRSQxO1xudmFyIFZhbGlkYXRvciA9IFZhbGlkYXRvciQxO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdmFyICovXG5cbi8qKlxuICogUGFyc2UgYSB0ZXh0IHNvdXJjZSBjb250YWluaW5nIGRhdGEgaW4gRE9UIGxhbmd1YWdlIGludG8gYSBKU09OIG9iamVjdC5cbiAqIFRoZSBvYmplY3QgY29udGFpbnMgdHdvIGxpc3RzOiBvbmUgd2l0aCBub2RlcyBhbmQgb25lIHdpdGggZWRnZXMuXG4gKlxuICogRE9UIGxhbmd1YWdlIHJlZmVyZW5jZTogaHR0cDovL3d3dy5ncmFwaHZpei5vcmcvZG9jL2luZm8vbGFuZy5odG1sXG4gKlxuICogRE9UIGxhbmd1YWdlIGF0dHJpYnV0ZXM6IGh0dHA6Ly9ncmFwaHZpei5vcmcvY29udGVudC9hdHRyc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhICAgICBUZXh0IGNvbnRhaW5pbmcgYSBncmFwaCBpbiBET1Qtbm90YXRpb25cbiAqIEByZXR1cm5zIHtvYmplY3R9IGdyYXBoICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdFtdfSBub2Rlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3RbXX0gZWRnZXNcbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUT0RPXG4gKiA9PT09XG4gKlxuICogRm9yIGxhYmVsIGhhbmRsaW5nLCB0aGlzIGlzIGFuIGluY29tcGxldGUgaW1wbGVtZW50YXRpb24uIEZyb20gZG9jcyAocXVvdGUgIzMwMTUpOlxuICpcbiAqID4gdGhlIGVzY2FwZSBzZXF1ZW5jZXMgXCJcXG5cIiwgXCJcXGxcIiBhbmQgXCJcXHJcIiBkaXZpZGUgdGhlIGxhYmVsIGludG8gbGluZXMsIGNlbnRlcmVkLFxuICogPiBsZWZ0LWp1c3RpZmllZCwgYW5kIHJpZ2h0LWp1c3RpZmllZCwgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIFNvdXJjZTogaHR0cDovL3d3dy5ncmFwaHZpei5vcmcvY29udGVudC9hdHRycyNrZXNjU3RyaW5nXG4gKlxuICogPiBBcyBhbm90aGVyIGFpZCBmb3IgcmVhZGFiaWxpdHksIGRvdCBhbGxvd3MgZG91YmxlLXF1b3RlZCBzdHJpbmdzIHRvIHNwYW4gbXVsdGlwbGUgcGh5c2ljYWxcbiAqID4gbGluZXMgdXNpbmcgdGhlIHN0YW5kYXJkIEMgY29udmVudGlvbiBvZiBhIGJhY2tzbGFzaCBpbW1lZGlhdGVseSBwcmVjZWRpbmcgYSBuZXdsaW5lXG4gKiA+IGNoYXJhY3RlclxuICogPiBJbiBhZGRpdGlvbiwgZG91YmxlLXF1b3RlZCBzdHJpbmdzIGNhbiBiZSBjb25jYXRlbmF0ZWQgdXNpbmcgYSAnKycgb3BlcmF0b3IuXG4gKiA+IEFzIEhUTUwgc3RyaW5ncyBjYW4gY29udGFpbiBuZXdsaW5lIGNoYXJhY3RlcnMsIHdoaWNoIGFyZSB1c2VkIHNvbGVseSBmb3IgZm9ybWF0dGluZyxcbiAqID4gdGhlIGxhbmd1YWdlIGRvZXMgbm90IGFsbG93IGVzY2FwZWQgbmV3bGluZXMgb3IgY29uY2F0ZW5hdGlvbiBvcGVyYXRvcnMgdG8gYmUgdXNlZFxuICogPiB3aXRoaW4gdGhlbS5cbiAqXG4gKiAtIEN1cnJlbnRseSwgb25seSAnXFxcXG4nIGlzIGhhbmRsZWRcbiAqIC0gTm90ZSB0aGF0IHRleHQgZXhwbGljaXRseSBzYXlzICdsYWJlbHMnOyB0aGUgZG90IHBhcnNlciBjdXJyZW50bHkgaGFuZGxlcyBlc2NhcGVcbiAqICAgc2VxdWVuY2VzIGluICoqYWxsKiogc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VET1QoZGF0YSkge1xuICBkb3QgPSBkYXRhO1xuICByZXR1cm4gcGFyc2VHcmFwaCgpO1xufSAvLyBtYXBwaW5nIG9mIGF0dHJpYnV0ZXMgZnJvbSBET1QgKHRoZSBrZXlzKSB0byB2aXMuanMgKHRoZSB2YWx1ZXMpXG5cbnZhciBOT0RFX0FUVFJfTUFQUElORyA9IHtcbiAgZm9udHNpemU6IFwiZm9udC5zaXplXCIsXG4gIGZvbnRjb2xvcjogXCJmb250LmNvbG9yXCIsXG4gIGxhYmVsZm9udGNvbG9yOiBcImZvbnQuY29sb3JcIixcbiAgZm9udG5hbWU6IFwiZm9udC5mYWNlXCIsXG4gIGNvbG9yOiBbXCJjb2xvci5ib3JkZXJcIiwgXCJjb2xvci5iYWNrZ3JvdW5kXCJdLFxuICBmaWxsY29sb3I6IFwiY29sb3IuYmFja2dyb3VuZFwiLFxuICB0b29sdGlwOiBcInRpdGxlXCIsXG4gIGxhYmVsdG9vbHRpcDogXCJ0aXRsZVwiXG59O1xuXG52YXIgRURHRV9BVFRSX01BUFBJTkcgPSBjcmVhdGUkNShOT0RFX0FUVFJfTUFQUElORyk7XG5cbkVER0VfQVRUUl9NQVBQSU5HLmNvbG9yID0gXCJjb2xvci5jb2xvclwiO1xuRURHRV9BVFRSX01BUFBJTkcuc3R5bGUgPSBcImRhc2hlc1wiOyAvLyB0b2tlbiB0eXBlcyBlbnVtZXJhdGlvblxuXG52YXIgVE9LRU5UWVBFID0ge1xuICBOVUxMOiAwLFxuICBERUxJTUlURVI6IDEsXG4gIElERU5USUZJRVI6IDIsXG4gIFVOS05PV046IDNcbn07IC8vIG1hcCB3aXRoIGFsbCBkZWxpbWl0ZXJzXG5cbnZhciBERUxJTUlURVJTID0ge1xuICBcIntcIjogdHJ1ZSxcbiAgXCJ9XCI6IHRydWUsXG4gIFwiW1wiOiB0cnVlLFxuICBcIl1cIjogdHJ1ZSxcbiAgXCI7XCI6IHRydWUsXG4gIFwiPVwiOiB0cnVlLFxuICBcIixcIjogdHJ1ZSxcbiAgXCItPlwiOiB0cnVlLFxuICBcIi0tXCI6IHRydWVcbn07XG52YXIgZG90ID0gXCJcIjsgLy8gY3VycmVudCBkb3QgZmlsZVxuXG52YXIgaW5kZXgkMSA9IDA7IC8vIGN1cnJlbnQgaW5kZXggaW4gZG90IGZpbGVcblxudmFyIGMgPSBcIlwiOyAvLyBjdXJyZW50IHRva2VuIGNoYXJhY3RlciBpbiBleHByXG5cbnZhciB0b2tlbiA9IFwiXCI7IC8vIGN1cnJlbnQgdG9rZW5cblxudmFyIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5OVUxMOyAvLyB0eXBlIG9mIHRoZSB0b2tlblxuXG4vKipcbiAqIEdldCB0aGUgZmlyc3QgY2hhcmFjdGVyIGZyb20gdGhlIGRvdCBmaWxlLlxuICogVGhlIGNoYXJhY3RlciBpcyBzdG9yZWQgaW50byB0aGUgY2hhciBjLiBJZiB0aGUgZW5kIG9mIHRoZSBkb3QgZmlsZSBpc1xuICogcmVhY2hlZCwgdGhlIGZ1bmN0aW9uIHB1dHMgYW4gZW1wdHkgc3RyaW5nIGluIGMuXG4gKi9cblxuZnVuY3Rpb24gZmlyc3QoKSB7XG4gIGluZGV4JDEgPSAwO1xuICBjID0gZG90LmNoYXJBdCgwKTtcbn1cbi8qKlxuICogR2V0IHRoZSBuZXh0IGNoYXJhY3RlciBmcm9tIHRoZSBkb3QgZmlsZS5cbiAqIFRoZSBjaGFyYWN0ZXIgaXMgc3RvcmVkIGludG8gdGhlIGNoYXIgYy4gSWYgdGhlIGVuZCBvZiB0aGUgZG90IGZpbGUgaXNcbiAqIHJlYWNoZWQsIHRoZSBmdW5jdGlvbiBwdXRzIGFuIGVtcHR5IHN0cmluZyBpbiBjLlxuICovXG5cblxuZnVuY3Rpb24gbmV4dCgpIHtcbiAgaW5kZXgkMSsrO1xuICBjID0gZG90LmNoYXJBdChpbmRleCQxKTtcbn1cbi8qKlxuICogUHJldmlldyB0aGUgbmV4dCBjaGFyYWN0ZXIgZnJvbSB0aGUgZG90IGZpbGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gY05leHRcbiAqL1xuXG5cbmZ1bmN0aW9uIG5leHRQcmV2aWV3KCkge1xuICByZXR1cm4gZG90LmNoYXJBdChpbmRleCQxICsgMSk7XG59XG4vKipcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBjaGFyYWN0ZXIgaXMgYWxwaGFiZXRpYyBvciBudW1lcmljICggYS16QS1aXzAtOS46IyApXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNcbiAqIEByZXR1cm5zIHtib29sZWFufSBpc0FscGhhTnVtZXJpY1xuICovXG5cblxuZnVuY3Rpb24gaXNBbHBoYU51bWVyaWMoYykge1xuICB2YXIgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG5cbiAgaWYgKGNoYXJDb2RlIDwgNDcpIHtcbiAgICAvLyAjLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMzUgfHwgY2hhckNvZGUgPT09IDQ2O1xuICB9XG5cbiAgaWYgKGNoYXJDb2RlIDwgNTkpIHtcbiAgICAvLyAwLTkgYW5kIDpcbiAgICByZXR1cm4gY2hhckNvZGUgPiA0NztcbiAgfVxuXG4gIGlmIChjaGFyQ29kZSA8IDkxKSB7XG4gICAgLy8gQS1aXG4gICAgcmV0dXJuIGNoYXJDb2RlID4gNjQ7XG4gIH1cblxuICBpZiAoY2hhckNvZGUgPCA5Nikge1xuICAgIC8vIF9cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDk1O1xuICB9XG5cbiAgaWYgKGNoYXJDb2RlIDwgMTIzKSB7XG4gICAgLy8gYS16XG4gICAgcmV0dXJuIGNoYXJDb2RlID4gOTY7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIE1lcmdlIGFsbCBvcHRpb25zIG9mIG9iamVjdCBiIGludG8gb2JqZWN0IGJcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYVxuICogQHBhcmFtIHtvYmplY3R9IGJcbiAqIEByZXR1cm5zIHtvYmplY3R9IGFcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlJDEoYSwgYikge1xuICBpZiAoIWEpIHtcbiAgICBhID0ge307XG4gIH1cblxuICBpZiAoYikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gYikge1xuICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgYVtuYW1lXSA9IGJbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGE7XG59XG4vKipcbiAqIFNldCBhIHZhbHVlIGluIGFuIG9iamVjdCwgd2hlcmUgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBuYW1lIGNhbiBiZSBhXG4gKiBwYXRoIHdpdGggbmVzdGVkIHBhcmFtZXRlcnMuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICB2YXIgb2JqID0ge2E6IDJ9O1xuICogICAgIHNldFZhbHVlKG9iaiwgJ2IuYycsIDMpOyAgICAgLy8gb2JqID0ge2E6IDIsIGI6IHtjOiAzfX1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAgQSBwYXJhbWV0ZXIgbmFtZSBvciBkb3Qtc2VwYXJhdGVkIHBhcmFtZXRlciBwYXRoLFxuICogICAgICAgICAgICAgICAgICAgICAgbGlrZSBcImNvbG9yLmhpZ2hsaWdodC5ib3JkZXJcIi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFZhbHVlKG9iaiwgcGF0aCwgdmFsdWUpIHtcbiAgdmFyIGtleXMgPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgdmFyIG8gPSBvYmo7XG5cbiAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IGtleXMuc2hpZnQoKTtcblxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgLy8gdGhpcyBpc24ndCB0aGUgZW5kIHBvaW50XG4gICAgICBpZiAoIW9ba2V5XSkge1xuICAgICAgICBvW2tleV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgbyA9IG9ba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhpcyBpcyB0aGUgZW5kIHBvaW50XG4gICAgICBvW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQWRkIGEgbm9kZSB0byBhIGdyYXBoIG9iamVjdC4gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIG5vZGUgd2l0aFxuICogdGhlIHNhbWUgaWQsIHRoZWlyIGF0dHJpYnV0ZXMgd2lsbCBiZSBtZXJnZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICovXG5cblxuZnVuY3Rpb24gYWRkTm9kZShncmFwaCwgbm9kZSkge1xuICB2YXIgaSwgbGVuO1xuICB2YXIgY3VycmVudCA9IG51bGw7IC8vIGZpbmQgcm9vdCBncmFwaCAoaW4gY2FzZSBvZiBzdWJncmFwaClcblxuICB2YXIgZ3JhcGhzID0gW2dyYXBoXTsgLy8gbGlzdCB3aXRoIGFsbCBncmFwaHMgZnJvbSBjdXJyZW50IGdyYXBoIHRvIHJvb3QgZ3JhcGhcblxuICB2YXIgcm9vdCA9IGdyYXBoO1xuXG4gIHdoaWxlIChyb290LnBhcmVudCkge1xuICAgIGdyYXBocy5wdXNoKHJvb3QucGFyZW50KTtcbiAgICByb290ID0gcm9vdC5wYXJlbnQ7XG4gIH0gLy8gZmluZCBleGlzdGluZyBub2RlIChhdCByb290IGxldmVsKSBieSBpdHMgaWRcblxuXG4gIGlmIChyb290Lm5vZGVzKSB7XG4gICAgZm9yIChpID0gMCwgbGVuID0gcm9vdC5ub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKG5vZGUuaWQgPT09IHJvb3Qubm9kZXNbaV0uaWQpIHtcbiAgICAgICAgY3VycmVudCA9IHJvb3Qubm9kZXNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghY3VycmVudCkge1xuICAgIC8vIHRoaXMgaXMgYSBuZXcgbm9kZVxuICAgIGN1cnJlbnQgPSB7XG4gICAgICBpZDogbm9kZS5pZFxuICAgIH07XG5cbiAgICBpZiAoZ3JhcGgubm9kZSkge1xuICAgICAgLy8gY2xvbmUgZGVmYXVsdCBhdHRyaWJ1dGVzXG4gICAgICBjdXJyZW50LmF0dHIgPSBtZXJnZSQxKGN1cnJlbnQuYXR0ciwgZ3JhcGgubm9kZSk7XG4gICAgfVxuICB9IC8vIGFkZCBub2RlIHRvIHRoaXMgKHN1YilncmFwaCBhbmQgYWxsIGl0cyBwYXJlbnQgZ3JhcGhzXG5cblxuICBmb3IgKGkgPSBncmFwaHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICB2YXIgZyA9IGdyYXBoc1tpXTtcblxuICAgIGlmICghZy5ub2Rlcykge1xuICAgICAgZy5ub2RlcyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChpbmRleE9mKF9jb250ZXh0ID0gZy5ub2RlcykuY2FsbChfY29udGV4dCwgY3VycmVudCkgPT09IC0xKSB7XG4gICAgICBnLm5vZGVzLnB1c2goY3VycmVudCk7XG4gICAgfVxuICB9IC8vIG1lcmdlIGF0dHJpYnV0ZXNcblxuXG4gIGlmIChub2RlLmF0dHIpIHtcbiAgICBjdXJyZW50LmF0dHIgPSBtZXJnZSQxKGN1cnJlbnQuYXR0ciwgbm9kZS5hdHRyKTtcbiAgfVxufVxuLyoqXG4gKiBBZGQgYW4gZWRnZSB0byBhIGdyYXBoIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICogQHBhcmFtIHtvYmplY3R9IGVkZ2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZEVkZ2UoZ3JhcGgsIGVkZ2UpIHtcbiAgaWYgKCFncmFwaC5lZGdlcykge1xuICAgIGdyYXBoLmVkZ2VzID0gW107XG4gIH1cblxuICBncmFwaC5lZGdlcy5wdXNoKGVkZ2UpO1xuXG4gIGlmIChncmFwaC5lZGdlKSB7XG4gICAgdmFyIGF0dHIgPSBtZXJnZSQxKHt9LCBncmFwaC5lZGdlKTsgLy8gY2xvbmUgZGVmYXVsdCBhdHRyaWJ1dGVzXG5cbiAgICBlZGdlLmF0dHIgPSBtZXJnZSQxKGF0dHIsIGVkZ2UuYXR0cik7IC8vIG1lcmdlIGF0dHJpYnV0ZXNcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYW4gZWRnZSB0byBhIGdyYXBoIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBvYmplY3R9IGZyb21cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgb2JqZWN0fSB0b1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbH0gYXR0clxuICogQHJldHVybnMge29iamVjdH0gZWRnZVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRWRnZShncmFwaCwgZnJvbSwgdG8sIHR5cGUsIGF0dHIpIHtcbiAgdmFyIGVkZ2UgPSB7XG4gICAgZnJvbTogZnJvbSxcbiAgICB0bzogdG8sXG4gICAgdHlwZTogdHlwZVxuICB9O1xuXG4gIGlmIChncmFwaC5lZGdlKSB7XG4gICAgZWRnZS5hdHRyID0gbWVyZ2UkMSh7fSwgZ3JhcGguZWRnZSk7IC8vIGNsb25lIGRlZmF1bHQgYXR0cmlidXRlc1xuICB9XG5cbiAgZWRnZS5hdHRyID0gbWVyZ2UkMShlZGdlLmF0dHIgfHwge30sIGF0dHIpOyAvLyBtZXJnZSBhdHRyaWJ1dGVzXG4gIC8vIE1vdmUgYXJyb3dzIGF0dHJpYnV0ZSBmcm9tIGF0dHIgdG8gZWRnZSB0ZW1wb3JhbGx5IGNyZWF0ZWQgaW5cbiAgLy8gcGFyc2VBdHRyaWJ1dGVMaXN0KCkuXG5cbiAgaWYgKGF0dHIgIT0gbnVsbCkge1xuICAgIGlmIChhdHRyLmhhc093blByb3BlcnR5KFwiYXJyb3dzXCIpICYmIGF0dHJbXCJhcnJvd3NcIl0gIT0gbnVsbCkge1xuICAgICAgZWRnZVtcImFycm93c1wiXSA9IHtcbiAgICAgICAgdG86IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIHR5cGU6IGF0dHIuYXJyb3dzLnR5cGVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGF0dHJbXCJhcnJvd3NcIl0gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlZGdlO1xufVxuLyoqXG4gKiBHZXQgbmV4dCB0b2tlbiBpbiB0aGUgY3VycmVudCBkb3QgZmlsZS5cbiAqIFRoZSB0b2tlbiBhbmQgdG9rZW4gdHlwZSBhcmUgYXZhaWxhYmxlIGFzIHRva2VuIGFuZCB0b2tlblR5cGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRva2VuKCkge1xuICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuTlVMTDtcbiAgdG9rZW4gPSBcIlwiOyAvLyBza2lwIG92ZXIgd2hpdGVzcGFjZXNcblxuICB3aGlsZSAoYyA9PT0gXCIgXCIgfHwgYyA9PT0gXCJcXHRcIiB8fCBjID09PSBcIlxcblwiIHx8IGMgPT09IFwiXFxyXCIpIHtcbiAgICAvLyBzcGFjZSwgdGFiLCBlbnRlclxuICAgIG5leHQoKTtcbiAgfVxuXG4gIGRvIHtcbiAgICB2YXIgaXNDb21tZW50ID0gZmFsc2U7IC8vIHNraXAgY29tbWVudFxuXG4gICAgaWYgKGMgPT09IFwiI1wiKSB7XG4gICAgICAvLyBmaW5kIHRoZSBwcmV2aW91cyBub24tc3BhY2UgY2hhcmFjdGVyXG4gICAgICB2YXIgaSA9IGluZGV4JDEgLSAxO1xuXG4gICAgICB3aGlsZSAoZG90LmNoYXJBdChpKSA9PT0gXCIgXCIgfHwgZG90LmNoYXJBdChpKSA9PT0gXCJcXHRcIikge1xuICAgICAgICBpLS07XG4gICAgICB9XG5cbiAgICAgIGlmIChkb3QuY2hhckF0KGkpID09PSBcIlxcblwiIHx8IGRvdC5jaGFyQXQoaSkgPT09IFwiXCIpIHtcbiAgICAgICAgLy8gdGhlICMgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZSwgdGhpcyBpcyBpbmRlZWQgYSBsaW5lIGNvbW1lbnRcbiAgICAgICAgd2hpbGUgKGMgIT0gXCJcIiAmJiBjICE9IFwiXFxuXCIpIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpc0NvbW1lbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjID09PSBcIi9cIiAmJiBuZXh0UHJldmlldygpID09PSBcIi9cIikge1xuICAgICAgLy8gc2tpcCBsaW5lIGNvbW1lbnRcbiAgICAgIHdoaWxlIChjICE9IFwiXCIgJiYgYyAhPSBcIlxcblwiKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cblxuICAgICAgaXNDb21tZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYyA9PT0gXCIvXCIgJiYgbmV4dFByZXZpZXcoKSA9PT0gXCIqXCIpIHtcbiAgICAgIC8vIHNraXAgYmxvY2sgY29tbWVudFxuICAgICAgd2hpbGUgKGMgIT0gXCJcIikge1xuICAgICAgICBpZiAoYyA9PT0gXCIqXCIgJiYgbmV4dFByZXZpZXcoKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAvLyBlbmQgb2YgYmxvY2sgY29tbWVudCBmb3VuZC4gc2tpcCB0aGVzZSBsYXN0IHR3byBjaGFyYWN0ZXJzXG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXNDb21tZW50ID0gdHJ1ZTtcbiAgICB9IC8vIHNraXAgb3ZlciB3aGl0ZXNwYWNlc1xuXG5cbiAgICB3aGlsZSAoYyA9PT0gXCIgXCIgfHwgYyA9PT0gXCJcXHRcIiB8fCBjID09PSBcIlxcblwiIHx8IGMgPT09IFwiXFxyXCIpIHtcbiAgICAgIC8vIHNwYWNlLCB0YWIsIGVudGVyXG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9IHdoaWxlIChpc0NvbW1lbnQpOyAvLyBjaGVjayBmb3IgZW5kIG9mIGRvdCBmaWxlXG5cblxuICBpZiAoYyA9PT0gXCJcIikge1xuICAgIC8vIHRva2VuIGlzIHN0aWxsIGVtcHR5XG4gICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICByZXR1cm47XG4gIH0gLy8gY2hlY2sgZm9yIGRlbGltaXRlcnMgY29uc2lzdGluZyBvZiAyIGNoYXJhY3RlcnNcblxuXG4gIHZhciBjMiA9IGMgKyBuZXh0UHJldmlldygpO1xuXG4gIGlmIChERUxJTUlURVJTW2MyXSkge1xuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgdG9rZW4gPSBjMjtcbiAgICBuZXh0KCk7XG4gICAgbmV4dCgpO1xuICAgIHJldHVybjtcbiAgfSAvLyBjaGVjayBmb3IgZGVsaW1pdGVycyBjb25zaXN0aW5nIG9mIDEgY2hhcmFjdGVyXG5cblxuICBpZiAoREVMSU1JVEVSU1tjXSkge1xuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgdG9rZW4gPSBjO1xuICAgIG5leHQoKTtcbiAgICByZXR1cm47XG4gIH0gLy8gY2hlY2sgZm9yIGFuIGlkZW50aWZpZXIgKG51bWJlciBvciBzdHJpbmcpXG4gIC8vIFRPRE86IG1vcmUgcHJlY2lzZSBwYXJzaW5nIG9mIG51bWJlcnMvc3RyaW5ncyAoYW5kIHRoZSBwb3J0IHNlcGFyYXRvciAnOicpXG5cblxuICBpZiAoaXNBbHBoYU51bWVyaWMoYykgfHwgYyA9PT0gXCItXCIpIHtcbiAgICB0b2tlbiArPSBjO1xuICAgIG5leHQoKTtcblxuICAgIHdoaWxlIChpc0FscGhhTnVtZXJpYyhjKSkge1xuICAgICAgdG9rZW4gKz0gYztcbiAgICAgIG5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4gPT09IFwiZmFsc2VcIikge1xuICAgICAgdG9rZW4gPSBmYWxzZTsgLy8gY29udmVydCB0byBib29sZWFuXG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgIHRva2VuID0gdHJ1ZTsgLy8gY29udmVydCB0byBib29sZWFuXG4gICAgfSBlbHNlIGlmICghaXNOYU4oTnVtYmVyKHRva2VuKSkpIHtcbiAgICAgIHRva2VuID0gTnVtYmVyKHRva2VuKTsgLy8gY29udmVydCB0byBudW1iZXJcbiAgICB9XG5cbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuSURFTlRJRklFUjtcbiAgICByZXR1cm47XG4gIH0gLy8gY2hlY2sgZm9yIGEgc3RyaW5nIGVuY2xvc2VkIGJ5IGRvdWJsZSBxdW90ZXNcblxuXG4gIGlmIChjID09PSAnXCInKSB7XG4gICAgbmV4dCgpO1xuXG4gICAgd2hpbGUgKGMgIT0gXCJcIiAmJiAoYyAhPSAnXCInIHx8IGMgPT09ICdcIicgJiYgbmV4dFByZXZpZXcoKSA9PT0gJ1wiJykpIHtcbiAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgIC8vIHNraXAgdGhlIGVzY2FwZSBjaGFyYWN0ZXJcbiAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSBlbHNlIGlmIChjID09PSBcIlxcXFxcIiAmJiBuZXh0UHJldmlldygpID09PSBcIm5cIikge1xuICAgICAgICAvLyBIb25vciBhIG5ld2xpbmUgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgIHRva2VuICs9IFwiXFxuXCI7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2VuICs9IGM7XG4gICAgICB9XG5cbiAgICAgIG5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAoYyAhPSAnXCInKSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignRW5kIG9mIHN0cmluZyBcIiBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIG5leHQoKTtcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuSURFTlRJRklFUjtcbiAgICByZXR1cm47XG4gIH0gLy8gc29tZXRoaW5nIHVua25vd24gaXMgZm91bmQsIHdyb25nIGNoYXJhY3RlcnMsIGEgc3ludGF4IGVycm9yXG5cblxuICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuVU5LTk9XTjtcblxuICB3aGlsZSAoYyAhPSBcIlwiKSB7XG4gICAgdG9rZW4gKz0gYztcbiAgICBuZXh0KCk7XG4gIH1cblxuICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1N5bnRheCBlcnJvciBpbiBwYXJ0IFwiJyArIGNob3AodG9rZW4sIDMwKSArICdcIicpO1xufVxuLyoqXG4gKiBQYXJzZSBhIGdyYXBoLlxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9IGdyYXBoXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUdyYXBoKCkge1xuICB2YXIgZ3JhcGggPSB7fTtcbiAgZmlyc3QoKTtcbiAgZ2V0VG9rZW4oKTsgLy8gb3B0aW9uYWwgc3RyaWN0IGtleXdvcmRcblxuICBpZiAodG9rZW4gPT09IFwic3RyaWN0XCIpIHtcbiAgICBncmFwaC5zdHJpY3QgPSB0cnVlO1xuICAgIGdldFRva2VuKCk7XG4gIH0gLy8gZ3JhcGggb3IgZGlncmFwaCBrZXl3b3JkXG5cblxuICBpZiAodG9rZW4gPT09IFwiZ3JhcGhcIiB8fCB0b2tlbiA9PT0gXCJkaWdyYXBoXCIpIHtcbiAgICBncmFwaC50eXBlID0gdG9rZW47XG4gICAgZ2V0VG9rZW4oKTtcbiAgfSAvLyBvcHRpb25hbCBncmFwaCBpZFxuXG5cbiAgaWYgKHRva2VuVHlwZSA9PT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICBncmFwaC5pZCA9IHRva2VuO1xuICAgIGdldFRva2VuKCk7XG4gIH0gLy8gb3BlbiBhbmdsZSBicmFja2V0XG5cblxuICBpZiAodG9rZW4gIT0gXCJ7XCIpIHtcbiAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkFuZ2xlIGJyYWNrZXQgeyBleHBlY3RlZFwiKTtcbiAgfVxuXG4gIGdldFRva2VuKCk7IC8vIHN0YXRlbWVudHNcblxuICBwYXJzZVN0YXRlbWVudHMoZ3JhcGgpOyAvLyBjbG9zZSBhbmdsZSBicmFja2V0XG5cbiAgaWYgKHRva2VuICE9IFwifVwiKSB7XG4gICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJBbmdsZSBicmFja2V0IH0gZXhwZWN0ZWRcIik7XG4gIH1cblxuICBnZXRUb2tlbigpOyAvLyBlbmQgb2YgZmlsZVxuXG4gIGlmICh0b2tlbiAhPT0gXCJcIikge1xuICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiRW5kIG9mIGZpbGUgZXhwZWN0ZWRcIik7XG4gIH1cblxuICBnZXRUb2tlbigpOyAvLyByZW1vdmUgdGVtcG9yYXJ5IGRlZmF1bHQgb3B0aW9uc1xuXG4gIGRlbGV0ZSBncmFwaC5ub2RlO1xuICBkZWxldGUgZ3JhcGguZWRnZTtcbiAgZGVsZXRlIGdyYXBoLmdyYXBoO1xuICByZXR1cm4gZ3JhcGg7XG59XG4vKipcbiAqIFBhcnNlIGEgbGlzdCB3aXRoIHN0YXRlbWVudHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVN0YXRlbWVudHMoZ3JhcGgpIHtcbiAgd2hpbGUgKHRva2VuICE9PSBcIlwiICYmIHRva2VuICE9IFwifVwiKSB7XG4gICAgcGFyc2VTdGF0ZW1lbnQoZ3JhcGgpO1xuXG4gICAgaWYgKHRva2VuID09PSBcIjtcIikge1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LiBDYW4gYmUgYSBhbiBhdHRyaWJ1dGUgc3RhdGVtZW50LCBub2RlXG4gKiBzdGF0ZW1lbnQsIGEgc2VyaWVzIG9mIG5vZGUgc3RhdGVtZW50cyBhbmQgZWRnZSBzdGF0ZW1lbnRzLCBvciBhXG4gKiBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVN0YXRlbWVudChncmFwaCkge1xuICAvLyBwYXJzZSBzdWJncmFwaFxuICB2YXIgc3ViZ3JhcGggPSBwYXJzZVN1YmdyYXBoKGdyYXBoKTtcblxuICBpZiAoc3ViZ3JhcGgpIHtcbiAgICAvLyBlZGdlIHN0YXRlbWVudHNcbiAgICBwYXJzZUVkZ2UoZ3JhcGgsIHN1YmdyYXBoKTtcbiAgICByZXR1cm47XG4gIH0gLy8gcGFyc2UgYW4gYXR0cmlidXRlIHN0YXRlbWVudFxuXG5cbiAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZVN0YXRlbWVudChncmFwaCk7XG5cbiAgaWYgKGF0dHIpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gcGFyc2Ugbm9kZVxuXG5cbiAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiSWRlbnRpZmllciBleHBlY3RlZFwiKTtcbiAgfVxuXG4gIHZhciBpZCA9IHRva2VuOyAvLyBpZCBjYW4gYmUgYSBzdHJpbmcgb3IgYSBudW1iZXJcblxuICBnZXRUb2tlbigpO1xuXG4gIGlmICh0b2tlbiA9PT0gXCI9XCIpIHtcbiAgICAvLyBpZCBzdGF0ZW1lbnRcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJJZGVudGlmaWVyIGV4cGVjdGVkXCIpO1xuICAgIH1cblxuICAgIGdyYXBoW2lkXSA9IHRva2VuO1xuICAgIGdldFRva2VuKCk7IC8vIFRPRE86IGltcGxlbWVudCBjb21tYSBzZXBhcmF0ZWQgbGlzdCB3aXRoIFwiYV9saXN0OiBJRD1JRCBbJywnXSBbYV9saXN0XSBcIlxuICB9IGVsc2Uge1xuICAgIHBhcnNlTm9kZVN0YXRlbWVudChncmFwaCwgaWQpO1xuICB9XG59XG4vKipcbiAqIFBhcnNlIGEgc3ViZ3JhcGhcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGggICAgcGFyZW50IGdyYXBoIG9iamVjdFxuICogQHJldHVybnMge29iamVjdCB8IG51bGx9IHN1YmdyYXBoXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVN1YmdyYXBoKGdyYXBoKSB7XG4gIHZhciBzdWJncmFwaCA9IG51bGw7IC8vIG9wdGlvbmFsIHN1YmdyYXBoIGtleXdvcmRcblxuICBpZiAodG9rZW4gPT09IFwic3ViZ3JhcGhcIikge1xuICAgIHN1YmdyYXBoID0ge307XG4gICAgc3ViZ3JhcGgudHlwZSA9IFwic3ViZ3JhcGhcIjtcbiAgICBnZXRUb2tlbigpOyAvLyBvcHRpb25hbCBncmFwaCBpZFxuXG4gICAgaWYgKHRva2VuVHlwZSA9PT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgIHN1YmdyYXBoLmlkID0gdG9rZW47XG4gICAgICBnZXRUb2tlbigpO1xuICAgIH1cbiAgfSAvLyBvcGVuIGFuZ2xlIGJyYWNrZXRcblxuXG4gIGlmICh0b2tlbiA9PT0gXCJ7XCIpIHtcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgaWYgKCFzdWJncmFwaCkge1xuICAgICAgc3ViZ3JhcGggPSB7fTtcbiAgICB9XG5cbiAgICBzdWJncmFwaC5wYXJlbnQgPSBncmFwaDtcbiAgICBzdWJncmFwaC5ub2RlID0gZ3JhcGgubm9kZTtcbiAgICBzdWJncmFwaC5lZGdlID0gZ3JhcGguZWRnZTtcbiAgICBzdWJncmFwaC5ncmFwaCA9IGdyYXBoLmdyYXBoOyAvLyBzdGF0ZW1lbnRzXG5cbiAgICBwYXJzZVN0YXRlbWVudHMoc3ViZ3JhcGgpOyAvLyBjbG9zZSBhbmdsZSBicmFja2V0XG5cbiAgICBpZiAodG9rZW4gIT0gXCJ9XCIpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiQW5nbGUgYnJhY2tldCB9IGV4cGVjdGVkXCIpO1xuICAgIH1cblxuICAgIGdldFRva2VuKCk7IC8vIHJlbW92ZSB0ZW1wb3JhcnkgZGVmYXVsdCBvcHRpb25zXG5cbiAgICBkZWxldGUgc3ViZ3JhcGgubm9kZTtcbiAgICBkZWxldGUgc3ViZ3JhcGguZWRnZTtcbiAgICBkZWxldGUgc3ViZ3JhcGguZ3JhcGg7XG4gICAgZGVsZXRlIHN1YmdyYXBoLnBhcmVudDsgLy8gcmVnaXN0ZXIgYXQgdGhlIHBhcmVudCBncmFwaFxuXG4gICAgaWYgKCFncmFwaC5zdWJncmFwaHMpIHtcbiAgICAgIGdyYXBoLnN1YmdyYXBocyA9IFtdO1xuICAgIH1cblxuICAgIGdyYXBoLnN1YmdyYXBocy5wdXNoKHN1YmdyYXBoKTtcbiAgfVxuXG4gIHJldHVybiBzdWJncmFwaDtcbn1cbi8qKlxuICogcGFyc2UgYW4gYXR0cmlidXRlIHN0YXRlbWVudCBsaWtlIFwibm9kZSBbc2hhcGU9Y2lyY2xlIGZvbnRTaXplPTE2XVwiLlxuICogQXZhaWxhYmxlIGtleXdvcmRzIGFyZSAnbm9kZScsICdlZGdlJywgJ2dyYXBoJy5cbiAqIFRoZSBwcmV2aW91cyBsaXN0IHdpdGggZGVmYXVsdCBhdHRyaWJ1dGVzIHdpbGwgYmUgcmVwbGFjZWRcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfSBrZXl3b3JkIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHBhcnNlZCBhdHRyaWJ1dGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLCBlZGdlLCBncmFwaCksIG9yIG51bGwgaWYgbm90aGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcGFyc2VkLlxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVTdGF0ZW1lbnQoZ3JhcGgpIHtcbiAgLy8gYXR0cmlidXRlIHN0YXRlbWVudHNcbiAgaWYgKHRva2VuID09PSBcIm5vZGVcIikge1xuICAgIGdldFRva2VuKCk7IC8vIG5vZGUgYXR0cmlidXRlc1xuXG4gICAgZ3JhcGgubm9kZSA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgIHJldHVybiBcIm5vZGVcIjtcbiAgfSBlbHNlIGlmICh0b2tlbiA9PT0gXCJlZGdlXCIpIHtcbiAgICBnZXRUb2tlbigpOyAvLyBlZGdlIGF0dHJpYnV0ZXNcblxuICAgIGdyYXBoLmVkZ2UgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTtcbiAgICByZXR1cm4gXCJlZGdlXCI7XG4gIH0gZWxzZSBpZiAodG9rZW4gPT09IFwiZ3JhcGhcIikge1xuICAgIGdldFRva2VuKCk7IC8vIGdyYXBoIGF0dHJpYnV0ZXNcblxuICAgIGdyYXBoLmdyYXBoID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG4gICAgcmV0dXJuIFwiZ3JhcGhcIjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBwYXJzZSBhIG5vZGUgc3RhdGVtZW50XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gaWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlTm9kZVN0YXRlbWVudChncmFwaCwgaWQpIHtcbiAgLy8gbm9kZSBzdGF0ZW1lbnRcbiAgdmFyIG5vZGUgPSB7XG4gICAgaWQ6IGlkXG4gIH07XG4gIHZhciBhdHRyID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG5cbiAgaWYgKGF0dHIpIHtcbiAgICBub2RlLmF0dHIgPSBhdHRyO1xuICB9XG5cbiAgYWRkTm9kZShncmFwaCwgbm9kZSk7IC8vIGVkZ2Ugc3RhdGVtZW50c1xuXG4gIHBhcnNlRWRnZShncmFwaCwgaWQpO1xufVxuLyoqXG4gKiBQYXJzZSBhbiBlZGdlIG9yIGEgc2VyaWVzIG9mIGVkZ2VzXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gZnJvbSAgICAgICAgSWQgb2YgdGhlIGZyb20gbm9kZVxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VFZGdlKGdyYXBoLCBmcm9tKSB7XG4gIHdoaWxlICh0b2tlbiA9PT0gXCItPlwiIHx8IHRva2VuID09PSBcIi0tXCIpIHtcbiAgICB2YXIgdG87XG4gICAgdmFyIHR5cGUgPSB0b2tlbjtcbiAgICBnZXRUb2tlbigpO1xuICAgIHZhciBzdWJncmFwaCA9IHBhcnNlU3ViZ3JhcGgoZ3JhcGgpO1xuXG4gICAgaWYgKHN1YmdyYXBoKSB7XG4gICAgICB0byA9IHN1YmdyYXBoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiSWRlbnRpZmllciBvciBzdWJncmFwaCBleHBlY3RlZFwiKTtcbiAgICAgIH1cblxuICAgICAgdG8gPSB0b2tlbjtcbiAgICAgIGFkZE5vZGUoZ3JhcGgsIHtcbiAgICAgICAgaWQ6IHRvXG4gICAgICB9KTtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgfSAvLyBwYXJzZSBlZGdlIGF0dHJpYnV0ZXNcblxuXG4gICAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTsgLy8gY3JlYXRlIGVkZ2VcblxuICAgIHZhciBlZGdlID0gY3JlYXRlRWRnZShncmFwaCwgZnJvbSwgdG8sIHR5cGUsIGF0dHIpO1xuICAgIGFkZEVkZ2UoZ3JhcGgsIGVkZ2UpO1xuICAgIGZyb20gPSB0bztcbiAgfVxufVxuLyoqXG4gKiBQYXJzZSBhIHNldCB3aXRoIGF0dHJpYnV0ZXMsXG4gKiBmb3IgZXhhbXBsZSBbbGFiZWw9XCIxLjAwMFwiLCBzaGFwZT1zb2xpZF1cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0IHwgbnVsbH0gYXR0clxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVMaXN0KCkge1xuICB2YXIgaTtcbiAgdmFyIGF0dHIgPSBudWxsOyAvLyBlZGdlIHN0eWxlcyBvZiBkb3QgYW5kIHZpc1xuXG4gIHZhciBlZGdlU3R5bGVzID0ge1xuICAgIGRhc2hlZDogdHJ1ZSxcbiAgICBzb2xpZDogZmFsc2UsXG4gICAgZG90dGVkOiBbMSwgNV1cbiAgfTtcbiAgLyoqXG4gICAqIERlZmluZSBhcnJvdyB0eXBlcy5cbiAgICogdmlzIGN1cnJlbnRseSBzdXBwb3J0cyB0eXBlcyBkZWZpbmVkIGluICdhcnJvd1R5cGVzJy5cbiAgICogRGV0YWlscyBvZiBhcnJvdyBzaGFwZXMgYXJlIGRlc2NyaWJlZCBpblxuICAgKiBodHRwOi8vd3d3LmdyYXBodml6Lm9yZy9jb250ZW50L2Fycm93LXNoYXBlc1xuICAgKi9cblxuICB2YXIgYXJyb3dUeXBlcyA9IHtcbiAgICBkb3Q6IFwiY2lyY2xlXCIsXG4gICAgYm94OiBcImJveFwiLFxuICAgIGNyb3c6IFwiY3Jvd1wiLFxuICAgIGN1cnZlOiBcImN1cnZlXCIsXG4gICAgaWN1cnZlOiBcImludl9jdXJ2ZVwiLFxuICAgIG5vcm1hbDogXCJ0cmlhbmdsZVwiLFxuICAgIGludjogXCJpbnZfdHJpYW5nbGVcIixcbiAgICBkaWFtb25kOiBcImRpYW1vbmRcIixcbiAgICB0ZWU6IFwiYmFyXCIsXG4gICAgdmVlOiBcInZlZVwiXG4gIH07XG4gIC8qKlxuICAgKiAnYXR0cl9saXN0JyBjb250YWlucyBhdHRyaWJ1dGVzIGZvciBjaGVja2luZyBpZiBzb21lIG9mIHRoZW0gYXJlIGFmZmVjdGVkXG4gICAqIGxhdGVyLiBGb3IgaW5zdGFuY2UsIGJvdGggb2YgJ2Fycm93aGVhZCcgYW5kICdkaXInIChlZGdlIHN0eWxlIGRlZmluZWRcbiAgICogaW4gRE9UKSBtYWtlIGNoYW5nZXMgdG8gJ2Fycm93cycgYXR0cmlidXRlIGluIHZpcy5cbiAgICovXG5cbiAgdmFyIGF0dHJfbGlzdCA9IG5ldyBBcnJheSgpO1xuICB2YXIgYXR0cl9uYW1lcyA9IG5ldyBBcnJheSgpOyAvLyB1c2VkIGZvciBjaGVja2luZyB0aGUgY2FzZS5cbiAgLy8gcGFyc2UgYXR0cmlidXRlc1xuXG4gIHdoaWxlICh0b2tlbiA9PT0gXCJbXCIpIHtcbiAgICBnZXRUb2tlbigpO1xuICAgIGF0dHIgPSB7fTtcblxuICAgIHdoaWxlICh0b2tlbiAhPT0gXCJcIiAmJiB0b2tlbiAhPSBcIl1cIikge1xuICAgICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkF0dHJpYnV0ZSBuYW1lIGV4cGVjdGVkXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHRva2VuO1xuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgaWYgKHRva2VuICE9IFwiPVwiKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiRXF1YWwgc2lnbiA9IGV4cGVjdGVkXCIpO1xuICAgICAgfVxuXG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiQXR0cmlidXRlIHZhbHVlIGV4cGVjdGVkXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSB0b2tlbjsgLy8gY29udmVydCBmcm9tIGRvdCBzdHlsZSB0byB2aXNcblxuICAgICAgaWYgKG5hbWUgPT09IFwic3R5bGVcIikge1xuICAgICAgICB2YWx1ZSA9IGVkZ2VTdHlsZXNbdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJyb3dUeXBlO1xuXG4gICAgICBpZiAobmFtZSA9PT0gXCJhcnJvd2hlYWRcIikge1xuICAgICAgICBhcnJvd1R5cGUgPSBhcnJvd1R5cGVzW3ZhbHVlXTtcbiAgICAgICAgbmFtZSA9IFwiYXJyb3dzXCI7XG4gICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogYXJyb3dUeXBlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gXCJhcnJvd3RhaWxcIikge1xuICAgICAgICBhcnJvd1R5cGUgPSBhcnJvd1R5cGVzW3ZhbHVlXTtcbiAgICAgICAgbmFtZSA9IFwiYXJyb3dzXCI7XG4gICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBhcnJvd1R5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgYXR0cjogYXR0cixcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGF0dHJfbmFtZXMucHVzaChuYW1lKTtcbiAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgIGlmICh0b2tlbiA9PSBcIixcIikge1xuICAgICAgICBnZXRUb2tlbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlbiAhPSBcIl1cIikge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJCcmFja2V0IF0gZXhwZWN0ZWRcIik7XG4gICAgfVxuXG4gICAgZ2V0VG9rZW4oKTtcbiAgfVxuICAvKipcbiAgICogQXMgZXhwbGFpbmVkIGluIFsxXSwgZ3JhcGh2aXogaGFzIGxpbWl0YXRpb25zIGZvciBjb21iaW5hdGlvbiBvZlxuICAgKiBhcnJvd1toZWFkfHRhaWxdIGFuZCBkaXIuIElmIGF0dHJpYnV0ZSBsaXN0IGluY2x1ZGVzICdkaXInLFxuICAgKiBmb2xsb3dpbmcgY2FzZXMganVzdCBiZSBzdXBwb3J0ZWQuXG4gICAqICAgMS4gYm90aCBvciBub25lICsgYXJyb3doZWFkLCBhcnJvd3RhaWxcbiAgICogICAyLiBmb3J3YXJkICsgYXJyb3doZWFkIChhcnJvd3RhaWwgaXMgbm90IGFmZmVkdGVkKVxuICAgKiAgIDMuIGJhY2sgKyBhcnJvd3RhaWwgKGFycm93aGVhZCBpcyBub3QgYWZmZWN0ZWQpXG4gICAqIFsxXSBodHRwczovL3d3dy5ncmFwaHZpei5vcmcvZG9jL2luZm8vYXR0cnMuaHRtbCNoOnVuZGlyX25vdGVcbiAgICovXG5cblxuICBpZiAoaW5jbHVkZXMoYXR0cl9uYW1lcykuY2FsbChhdHRyX25hbWVzLCBcImRpclwiKSkge1xuICAgIHZhciBpZHggPSB7fTsgLy8gZ2V0IGluZGV4IG9mICdhcnJvd3MnIGFuZCAnZGlyJ1xuXG4gICAgaWR4LmFycm93cyA9IHt9O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGF0dHJfbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGF0dHJfbGlzdFtpXS5uYW1lID09PSBcImFycm93c1wiKSB7XG4gICAgICAgIGlmIChhdHRyX2xpc3RbaV0udmFsdWUudG8gIT0gbnVsbCkge1xuICAgICAgICAgIGlkeC5hcnJvd3MudG8gPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGF0dHJfbGlzdFtpXS52YWx1ZS5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICBpZHguYXJyb3dzLmZyb20gPSBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiSW52YWxpZCB2YWx1ZSBvZiBhcnJvd3NcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXR0cl9saXN0W2ldLm5hbWUgPT09IFwiZGlyXCIpIHtcbiAgICAgICAgaWR4LmRpciA9IGk7XG4gICAgICB9XG4gICAgfSAvLyBmaXJzdCwgYWRkIGRlZmF1bHQgYXJyb3cgc2hhcGUgaWYgaXQgaXMgbm90IGFzc2lnbmVkIHRvIGF2b2lkIGVycm9yXG5cblxuICAgIHZhciBkaXJfdHlwZSA9IGF0dHJfbGlzdFtpZHguZGlyXS52YWx1ZTtcblxuICAgIGlmICghaW5jbHVkZXMoYXR0cl9uYW1lcykuY2FsbChhdHRyX25hbWVzLCBcImFycm93c1wiKSkge1xuICAgICAgaWYgKGRpcl90eXBlID09PSBcImJvdGhcIikge1xuICAgICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5kaXJdLmF0dHIsXG4gICAgICAgICAgbmFtZTogXCJhcnJvd3NcIixcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlkeC5hcnJvd3MudG8gPSBhdHRyX2xpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguZGlyXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IFwiYXJyb3dzXCIsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlkeC5hcnJvd3MuZnJvbSA9IGF0dHJfbGlzdC5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIGlmIChkaXJfdHlwZSA9PT0gXCJmb3J3YXJkXCIpIHtcbiAgICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguZGlyXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IFwiYXJyb3dzXCIsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZHguYXJyb3dzLnRvID0gYXR0cl9saXN0Lmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSBcImJhY2tcIikge1xuICAgICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5kaXJdLmF0dHIsXG4gICAgICAgICAgbmFtZTogXCJhcnJvd3NcIixcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWR4LmFycm93cy5mcm9tID0gYXR0cl9saXN0Lmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSBcIm5vbmVcIikge1xuICAgICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5kaXJdLmF0dHIsXG4gICAgICAgICAgbmFtZTogXCJhcnJvd3NcIixcbiAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWR4LmFycm93cy50byA9IGF0dHJfbGlzdC5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0ludmFsaWQgZGlyIHR5cGUgXCInICsgZGlyX3R5cGUgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJvbV90eXBlO1xuICAgIHZhciB0b190eXBlOyAvLyB1cGRhdGUgJ2Fycm93cycgYXR0cmlidXRlIGZyb20gJ2RpcicuXG5cbiAgICBpZiAoZGlyX3R5cGUgPT09IFwiYm90aFwiKSB7XG4gICAgICAvLyBib3RoIG9mIHNoYXBlcyBvZiAnZnJvbScgYW5kICd0bycgYXJlIGdpdmVuXG4gICAgICBpZiAoaWR4LmFycm93cy50byAmJiBpZHguYXJyb3dzLmZyb20pIHtcbiAgICAgICAgdG9fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS52YWx1ZS50by50eXBlO1xuICAgICAgICBmcm9tX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGU7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNwbGljZSQxKGF0dHJfbGlzdCkuY2FsbChhdHRyX2xpc3QsIGlkeC5hcnJvd3MuZnJvbSwgMSk7IC8vIHNoYXBlIG9mICd0bycgaXMgYXNzaWduZWQgYW5kIHVzZSBkZWZhdWx0IHRvICdmcm9tJ1xuXG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MudG8pIHtcbiAgICAgICAgdG9fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS52YWx1ZS50by50eXBlO1xuICAgICAgICBmcm9tX3R5cGUgPSBcImFycm93XCI7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9OyAvLyBvbmx5IHNoYXBlIG9mICdmcm9tJyBpcyBhc3NpZ25lZCBhbmQgdXNlIGRlZmF1bHQgZm9yICd0bydcbiAgICAgIH0gZWxzZSBpZiAoaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBcImFycm93XCI7XG4gICAgICAgIGZyb21fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZTtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXJfdHlwZSA9PT0gXCJiYWNrXCIpIHtcbiAgICAgIC8vIGdpdmVuIGJvdGggb2Ygc2hhcGVzLCBidXQgdXNlIG9ubHkgJ2Zyb20nXG4gICAgICBpZiAoaWR4LmFycm93cy50byAmJiBpZHguYXJyb3dzLmZyb20pIHtcbiAgICAgICAgdG9fdHlwZSA9IFwiXCI7XG4gICAgICAgIGZyb21fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZTtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07IC8vIGdpdmVuIHNoYXBlIG9mICd0bycsIGJ1dCBkb2VzIG5vdCB1c2UgaXRcbiAgICAgIH0gZWxzZSBpZiAoaWR4LmFycm93cy50bykge1xuICAgICAgICB0b190eXBlID0gXCJcIjtcbiAgICAgICAgZnJvbV90eXBlID0gXCJhcnJvd1wiO1xuICAgICAgICBpZHguYXJyb3dzLmZyb20gPSBpZHguYXJyb3dzLnRvO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTsgLy8gYXNzaWduIGdpdmVuICdmcm9tJyBzaGFwZVxuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLmZyb20pIHtcbiAgICAgICAgdG9fdHlwZSA9IFwiXCI7XG4gICAgICAgIGZyb21fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZTtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXSA9IHtcbiAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0udmFsdWUuZnJvbS50eXBlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgICB2YXIgaWR4X2Fycm93O1xuXG4gICAgICBpZiAoaWR4LmFycm93cy50bykge1xuICAgICAgICBpZHhfYXJyb3cgPSBpZHguYXJyb3dzLnRvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWR4X2Fycm93ID0gaWR4LmFycm93cy5mcm9tO1xuICAgICAgfVxuXG4gICAgICBhdHRyX2xpc3RbaWR4X2Fycm93XSA9IHtcbiAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeF9hcnJvd10uYXR0cixcbiAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeF9hcnJvd10ubmFtZSxcbiAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkaXJfdHlwZSA9PT0gXCJmb3J3YXJkXCIpIHtcbiAgICAgIC8vIGdpdmVuIGJvdGggb2Ygc2hhcGVzLCBidXQgdXNlIG9ubHkgJ3RvJ1xuICAgICAgaWYgKGlkeC5hcnJvd3MudG8gJiYgaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZTtcbiAgICAgICAgZnJvbV90eXBlID0gXCJcIjtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07IC8vIGFzc2lnbiBnaXZlbiAndG8nIHNoYXBlXG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MudG8pIHtcbiAgICAgICAgdG9fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS52YWx1ZS50by50eXBlO1xuICAgICAgICBmcm9tX3R5cGUgPSBcIlwiO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTsgLy8gZ2l2ZW4gc2hhcGUgb2YgJ2Zyb20nLCBidXQgZG9lcyBub3QgdXNlIGl0XG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gXCJhcnJvd1wiO1xuICAgICAgICBmcm9tX3R5cGUgPSBcIlwiO1xuICAgICAgICBpZHguYXJyb3dzLnRvID0gaWR4LmFycm93cy5mcm9tO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgdG86IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0ludmFsaWQgZGlyIHR5cGUgXCInICsgZGlyX3R5cGUgKyAnXCInKTtcbiAgICB9IC8vIHJlbW92ZSAnZGlyJyBhdHRyaWJ1dGUgbm8gbmVlZCBhbnltb3JlXG5cblxuICAgIHNwbGljZSQxKGF0dHJfbGlzdCkuY2FsbChhdHRyX2xpc3QsIGlkeC5kaXIsIDEpO1xuICB9IC8vIHBhcnNlICdwZW53aWR0aCdcblxuXG4gIHZhciBub2ZfYXR0cl9saXN0O1xuXG4gIGlmIChpbmNsdWRlcyhhdHRyX25hbWVzKS5jYWxsKGF0dHJfbmFtZXMsIFwicGVud2lkdGhcIikpIHtcbiAgICB2YXIgdG1wX2F0dHJfbGlzdCA9IFtdO1xuICAgIG5vZl9hdHRyX2xpc3QgPSBhdHRyX2xpc3QubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5vZl9hdHRyX2xpc3Q7IGkrKykge1xuICAgICAgLy8gZXhjbHVkZSAnd2lkdGgnIGZyb20gYXR0cl9saXN0IGlmICdwZW53aWR0aCcgZXhpc3RzXG4gICAgICBpZiAoYXR0cl9saXN0W2ldLm5hbWUgIT09IFwid2lkdGhcIikge1xuICAgICAgICBpZiAoYXR0cl9saXN0W2ldLm5hbWUgPT09IFwicGVud2lkdGhcIikge1xuICAgICAgICAgIGF0dHJfbGlzdFtpXS5uYW1lID0gXCJ3aWR0aFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdG1wX2F0dHJfbGlzdC5wdXNoKGF0dHJfbGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cl9saXN0ID0gdG1wX2F0dHJfbGlzdDtcbiAgfVxuXG4gIG5vZl9hdHRyX2xpc3QgPSBhdHRyX2xpc3QubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBub2ZfYXR0cl9saXN0OyBpKyspIHtcbiAgICBzZXRWYWx1ZShhdHRyX2xpc3RbaV0uYXR0ciwgYXR0cl9saXN0W2ldLm5hbWUsIGF0dHJfbGlzdFtpXS52YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gYXR0cjtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3ludGF4IGVycm9yIHdpdGggZXh0cmEgaW5mb3JtYXRpb24gb24gY3VycmVudCB0b2tlbiBhbmQgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtTeW50YXhFcnJvcn0gZXJyXG4gKi9cblxuXG5mdW5jdGlvbiBuZXdTeW50YXhFcnJvcihtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSArICcsIGdvdCBcIicgKyBjaG9wKHRva2VuLCAzMCkgKyAnXCIgKGNoYXIgJyArIGluZGV4JDEgKyBcIilcIik7XG59XG4vKipcbiAqIENob3Agb2ZmIHRleHQgYWZ0ZXIgYSBtYXhpbXVtIGxlbmd0aFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0gbWF4TGVuZ3RoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gY2hvcCh0ZXh0LCBtYXhMZW5ndGgpIHtcbiAgcmV0dXJuIHRleHQubGVuZ3RoIDw9IG1heExlbmd0aCA/IHRleHQgOiB0ZXh0LnN1YnN0cigwLCAyNykgKyBcIi4uLlwiO1xufVxuLyoqXG4gKiBFeGVjdXRlIGEgZnVuY3Rpb24gZm4gZm9yIGVhY2ggcGFpciBvZiBlbGVtZW50cyBpbiB0d28gYXJyYXlzXG4gKlxuICogQHBhcmFtIHtBcnJheSB8ICp9IGFycmF5MVxuICogQHBhcmFtIHtBcnJheSB8ICp9IGFycmF5MlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZvckVhY2gyKGFycmF5MSwgYXJyYXkyLCBmbikge1xuICBpZiAoaXNBcnJheSQyKGFycmF5MSkpIHtcbiAgICBmb3JFYWNoJDIoYXJyYXkxKS5jYWxsKGFycmF5MSwgZnVuY3Rpb24gKGVsZW0xKSB7XG4gICAgICBpZiAoaXNBcnJheSQyKGFycmF5MikpIHtcbiAgICAgICAgZm9yRWFjaCQyKGFycmF5MikuY2FsbChhcnJheTIsIGZ1bmN0aW9uIChlbGVtMikge1xuICAgICAgICAgIGZuKGVsZW0xLCBlbGVtMik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4oZWxlbTEsIGFycmF5Mik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzQXJyYXkkMihhcnJheTIpKSB7XG4gICAgICBmb3JFYWNoJDIoYXJyYXkyKS5jYWxsKGFycmF5MiwgZnVuY3Rpb24gKGVsZW0yKSB7XG4gICAgICAgIGZuKGFycmF5MSwgZWxlbTIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuKGFycmF5MSwgYXJyYXkyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogU2V0IGEgbmVzdGVkIHByb3BlcnR5IG9uIGFuIG9iamVjdFxuICogV2hlbiBuZXN0ZWQgb2JqZWN0cyBhcmUgbWlzc2luZywgdGhleSB3aWxsIGJlIGNyZWF0ZWQuXG4gKiBGb3IgZXhhbXBsZSBzZXRQcm9wKHt9LCAnZm9udC5jb2xvcicsICdyZWQnKSB3aWxsIHJldHVybiB7Zm9udDoge2NvbG9yOiAncmVkJ319XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggICBBIGRvdCBzZXBhcmF0ZWQgc3RyaW5nIGxpa2UgJ2ZvbnQuY29sb3InXG4gKiBAcGFyYW0geyp9IHZhbHVlICAgICAgIFZhbHVlIGZvciB0aGUgcHJvcGVydHlcbiAqIEByZXR1cm5zIHtvYmplY3R9IFJldHVybnMgdGhlIG9yaWdpbmFsIG9iamVjdCwgYWxsb3dzIGZvciBjaGFpbmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFByb3Aob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICB2YXIgbmFtZXMgPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgdmFyIHByb3AgPSBuYW1lcy5wb3AoKTsgLy8gdHJhdmVyc2Ugb3ZlciB0aGUgbmVzdGVkIG9iamVjdHNcblxuICB2YXIgb2JqID0gb2JqZWN0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuXG4gICAgaWYgKCEobmFtZSBpbiBvYmopKSB7XG4gICAgICBvYmpbbmFtZV0gPSB7fTtcbiAgICB9XG5cbiAgICBvYmogPSBvYmpbbmFtZV07XG4gIH0gLy8gc2V0IHRoZSBwcm9wZXJ0eSB2YWx1ZVxuXG5cbiAgb2JqW3Byb3BdID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59XG4vKipcbiAqIENvbnZlcnQgYW4gb2JqZWN0IHdpdGggRE9UIGF0dHJpYnV0ZXMgdG8gdGhlaXIgdmlzLmpzIGVxdWl2YWxlbnRzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyICAgICBPYmplY3Qgd2l0aCBET1QgYXR0cmlidXRlc1xuICogQHBhcmFtIHtvYmplY3R9IG1hcHBpbmdcbiAqIEByZXR1cm5zIHtvYmplY3R9ICAgICAgICAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB2aXMuanMgYXR0cmlidXRlc1xuICovXG5cblxuZnVuY3Rpb24gY29udmVydEF0dHIoYXR0ciwgbWFwcGluZykge1xuICB2YXIgY29udmVydGVkID0ge307XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBhdHRyKSB7XG4gICAgaWYgKGF0dHIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHZhciB2aXNQcm9wID0gbWFwcGluZ1twcm9wXTtcblxuICAgICAgaWYgKGlzQXJyYXkkMih2aXNQcm9wKSkge1xuICAgICAgICBmb3JFYWNoJDIodmlzUHJvcCkuY2FsbCh2aXNQcm9wLCBmdW5jdGlvbiAodmlzUHJvcEkpIHtcbiAgICAgICAgICBzZXRQcm9wKGNvbnZlcnRlZCwgdmlzUHJvcEksIGF0dHJbcHJvcF0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZpc1Byb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHZpc1Byb3AsIGF0dHJbcHJvcF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHByb3AsIGF0dHJbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59XG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgY29udGFpbmluZyBhIGdyYXBoIGluIERPVCBsYW5ndWFnZSBpbnRvIGEgbWFwIGNvbnRhaW5pbmdcbiAqIHdpdGggbm9kZXMgYW5kIGVkZ2VzIGluIHRoZSBmb3JtYXQgb2YgZ3JhcGguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgICAgICAgICBUZXh0IGNvbnRhaW5pbmcgYSBncmFwaCBpbiBET1Qtbm90YXRpb25cbiAqIEByZXR1cm5zIHtvYmplY3R9IGdyYXBoRGF0YVxuICovXG5cblxuZnVuY3Rpb24gRE9UVG9HcmFwaChkYXRhKSB7XG4gIC8vIHBhcnNlIHRoZSBET1QgZmlsZVxuICB2YXIgZG90RGF0YSA9IHBhcnNlRE9UKGRhdGEpO1xuICB2YXIgZ3JhcGhEYXRhID0ge1xuICAgIG5vZGVzOiBbXSxcbiAgICBlZGdlczogW10sXG4gICAgb3B0aW9uczoge31cbiAgfTsgLy8gY29weSB0aGUgbm9kZXNcblxuICBpZiAoZG90RGF0YS5ub2Rlcykge1xuICAgIHZhciBfY29udGV4dDI7XG5cbiAgICBmb3JFYWNoJDIoX2NvbnRleHQyID0gZG90RGF0YS5ub2RlcykuY2FsbChfY29udGV4dDIsIGZ1bmN0aW9uIChkb3ROb2RlKSB7XG4gICAgICB2YXIgZ3JhcGhOb2RlID0ge1xuICAgICAgICBpZDogZG90Tm9kZS5pZCxcbiAgICAgICAgbGFiZWw6IFN0cmluZyhkb3ROb2RlLmxhYmVsIHx8IGRvdE5vZGUuaWQpXG4gICAgICB9O1xuICAgICAgbWVyZ2UkMShncmFwaE5vZGUsIGNvbnZlcnRBdHRyKGRvdE5vZGUuYXR0ciwgTk9ERV9BVFRSX01BUFBJTkcpKTtcblxuICAgICAgaWYgKGdyYXBoTm9kZS5pbWFnZSkge1xuICAgICAgICBncmFwaE5vZGUuc2hhcGUgPSBcImltYWdlXCI7XG4gICAgICB9XG5cbiAgICAgIGdyYXBoRGF0YS5ub2Rlcy5wdXNoKGdyYXBoTm9kZSk7XG4gICAgfSk7XG4gIH0gLy8gY29weSB0aGUgZWRnZXNcblxuXG4gIGlmIChkb3REYXRhLmVkZ2VzKSB7XG4gICAgdmFyIF9jb250ZXh0MztcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYW4gZWRnZSBpbiBET1QgZm9ybWF0IHRvIGFuIGVkZ2Ugd2l0aCBWaXNHcmFwaCBmb3JtYXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkb3RFZGdlXG4gICAgICogQHJldHVybnMge29iamVjdH0gZ3JhcGhFZGdlXG4gICAgICovXG4gICAgdmFyIGNvbnZlcnRFZGdlID0gZnVuY3Rpb24gY29udmVydEVkZ2UoZG90RWRnZSkge1xuICAgICAgdmFyIGdyYXBoRWRnZSA9IHtcbiAgICAgICAgZnJvbTogZG90RWRnZS5mcm9tLFxuICAgICAgICB0bzogZG90RWRnZS50b1xuICAgICAgfTtcbiAgICAgIG1lcmdlJDEoZ3JhcGhFZGdlLCBjb252ZXJ0QXR0cihkb3RFZGdlLmF0dHIsIEVER0VfQVRUUl9NQVBQSU5HKSk7IC8vIEFkZCBhcnJvd3MgYXR0cmlidXRlIHRvIGRlZmF1bHQgc3R5bGVkIGFycm93LlxuICAgICAgLy8gVGhlIHJlYXNvbiB3aHkgZGVmYXVsdCBzdHlsZSBpcyBub3QgYWRkZWQgaW4gcGFyc2VBdHRyaWJ1dGVMaXN0KCkgaXNcbiAgICAgIC8vIGJlY2F1c2Ugb25seSBkZWZhdWx0IGlzIGNsZWFyZWQgYmVmb3JlIGhlcmUuXG5cbiAgICAgIGlmIChncmFwaEVkZ2UuYXJyb3dzID09IG51bGwgJiYgZG90RWRnZS50eXBlID09PSBcIi0+XCIpIHtcbiAgICAgICAgZ3JhcGhFZGdlLmFycm93cyA9IFwidG9cIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyYXBoRWRnZTtcbiAgICB9O1xuXG4gICAgZm9yRWFjaCQyKF9jb250ZXh0MyA9IGRvdERhdGEuZWRnZXMpLmNhbGwoX2NvbnRleHQzLCBmdW5jdGlvbiAoZG90RWRnZSkge1xuICAgICAgdmFyIGZyb20sIHRvO1xuXG4gICAgICBpZiAoZG90RWRnZS5mcm9tIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIGZyb20gPSBkb3RFZGdlLmZyb20ubm9kZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tID0ge1xuICAgICAgICAgIGlkOiBkb3RFZGdlLmZyb21cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvdEVkZ2UudG8gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgdG8gPSBkb3RFZGdlLnRvLm5vZGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG8gPSB7XG4gICAgICAgICAgaWQ6IGRvdEVkZ2UudG9cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvdEVkZ2UuZnJvbSBpbnN0YW5jZW9mIE9iamVjdCAmJiBkb3RFZGdlLmZyb20uZWRnZXMpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NDtcblxuICAgICAgICBmb3JFYWNoJDIoX2NvbnRleHQ0ID0gZG90RWRnZS5mcm9tLmVkZ2VzKS5jYWxsKF9jb250ZXh0NCwgZnVuY3Rpb24gKHN1YkVkZ2UpIHtcbiAgICAgICAgICB2YXIgZ3JhcGhFZGdlID0gY29udmVydEVkZ2Uoc3ViRWRnZSk7XG4gICAgICAgICAgZ3JhcGhEYXRhLmVkZ2VzLnB1c2goZ3JhcGhFZGdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvckVhY2gyKGZyb20sIHRvLCBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIHN1YkVkZ2UgPSBjcmVhdGVFZGdlKGdyYXBoRGF0YSwgZnJvbS5pZCwgdG8uaWQsIGRvdEVkZ2UudHlwZSwgZG90RWRnZS5hdHRyKTtcbiAgICAgICAgdmFyIGdyYXBoRWRnZSA9IGNvbnZlcnRFZGdlKHN1YkVkZ2UpO1xuICAgICAgICBncmFwaERhdGEuZWRnZXMucHVzaChncmFwaEVkZ2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChkb3RFZGdlLnRvIGluc3RhbmNlb2YgT2JqZWN0ICYmIGRvdEVkZ2UudG8uZWRnZXMpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NTtcblxuICAgICAgICBmb3JFYWNoJDIoX2NvbnRleHQ1ID0gZG90RWRnZS50by5lZGdlcykuY2FsbChfY29udGV4dDUsIGZ1bmN0aW9uIChzdWJFZGdlKSB7XG4gICAgICAgICAgdmFyIGdyYXBoRWRnZSA9IGNvbnZlcnRFZGdlKHN1YkVkZ2UpO1xuICAgICAgICAgIGdyYXBoRGF0YS5lZGdlcy5wdXNoKGdyYXBoRWRnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9IC8vIGNvcHkgdGhlIG9wdGlvbnNcblxuXG4gIGlmIChkb3REYXRhLmF0dHIpIHtcbiAgICBncmFwaERhdGEub3B0aW9ucyA9IGRvdERhdGEuYXR0cjtcbiAgfVxuXG4gIHJldHVybiBncmFwaERhdGE7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXZhciAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qIGVzbGludC1lbmFibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG5cbnZhciBkb3RwYXJzZXIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0cGFyc2VET1Q6IHBhcnNlRE9ULFxuXHRET1RUb0dyYXBoOiBET1RUb0dyYXBoXG59KTtcblxuLyoqXHJcbiAqIENvbnZlcnQgR2VwaGkgdG8gVmlzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZ2VwaGlKU09OIC0gVGhlIHBhcnNlZCBKU09OIGRhdGEgaW4gR2VwaGkgZm9ybWF0LlxyXG4gKiBAcGFyYW0gb3B0aW9uc09iaiAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cclxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBkYXRhIHJlYWR5IHRvIGJlIHVzZWQgaW4gVmlzLlxyXG4gKi9cbmZ1bmN0aW9uIHBhcnNlR2VwaGkoZ2VwaGlKU09OLCBvcHRpb25zT2JqKSB7XG4gIHZhciBfY29udGV4dDtcblxuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBlZGdlczoge1xuICAgICAgaW5oZXJpdENvbG9yOiBmYWxzZVxuICAgIH0sXG4gICAgbm9kZXM6IHtcbiAgICAgIGZpeGVkOiBmYWxzZSxcbiAgICAgIHBhcnNlQ29sb3I6IGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIGlmIChvcHRpb25zT2JqICE9IG51bGwpIHtcbiAgICBpZiAob3B0aW9uc09iai5maXhlZCAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLm5vZGVzLmZpeGVkID0gb3B0aW9uc09iai5maXhlZDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uc09iai5wYXJzZUNvbG9yICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMubm9kZXMucGFyc2VDb2xvciA9IG9wdGlvbnNPYmoucGFyc2VDb2xvcjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uc09iai5pbmhlcml0Q29sb3IgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5lZGdlcy5pbmhlcml0Q29sb3IgPSBvcHRpb25zT2JqLmluaGVyaXRDb2xvcjtcbiAgICB9XG4gIH1cblxuICB2YXIgZ0VkZ2VzID0gZ2VwaGlKU09OLmVkZ2VzO1xuXG4gIHZhciB2RWRnZXMgPSBtYXAkMyhnRWRnZXMpLmNhbGwoZ0VkZ2VzLCBmdW5jdGlvbiAoZ0VkZ2UpIHtcbiAgICB2YXIgdkVkZ2UgPSB7XG4gICAgICBmcm9tOiBnRWRnZS5zb3VyY2UsXG4gICAgICBpZDogZ0VkZ2UuaWQsXG4gICAgICB0bzogZ0VkZ2UudGFyZ2V0XG4gICAgfTtcblxuICAgIGlmIChnRWRnZS5hdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgIHZFZGdlLmF0dHJpYnV0ZXMgPSBnRWRnZS5hdHRyaWJ1dGVzO1xuICAgIH1cblxuICAgIGlmIChnRWRnZS5sYWJlbCAhPSBudWxsKSB7XG4gICAgICB2RWRnZS5sYWJlbCA9IGdFZGdlLmxhYmVsO1xuICAgIH1cblxuICAgIGlmIChnRWRnZS5hdHRyaWJ1dGVzICE9IG51bGwgJiYgZ0VkZ2UuYXR0cmlidXRlcy50aXRsZSAhPSBudWxsKSB7XG4gICAgICB2RWRnZS50aXRsZSA9IGdFZGdlLmF0dHJpYnV0ZXMudGl0bGU7XG4gICAgfVxuXG4gICAgaWYgKGdFZGdlLnR5cGUgPT09IFwiRGlyZWN0ZWRcIikge1xuICAgICAgdkVkZ2UuYXJyb3dzID0gXCJ0b1wiO1xuICAgIH0gLy8gZWRnZVsndmFsdWUnXSA9IGdFZGdlLmF0dHJpYnV0ZXMgIT0gbnVsbCA/IGdFZGdlLmF0dHJpYnV0ZXMuV2VpZ2h0IDogdW5kZWZpbmVkO1xuICAgIC8vIGVkZ2VbJ3dpZHRoJ10gPSBlZGdlWyd2YWx1ZSddICE9IG51bGwgPyB1bmRlZmluZWQgOiBlZGdlZ0VkZ2Uuc2l6ZTtcblxuXG4gICAgaWYgKGdFZGdlLmNvbG9yICYmIG9wdGlvbnMuZWRnZXMuaW5oZXJpdENvbG9yID09PSBmYWxzZSkge1xuICAgICAgdkVkZ2UuY29sb3IgPSBnRWRnZS5jb2xvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdkVkZ2U7XG4gIH0pO1xuXG4gIHZhciB2Tm9kZXMgPSBtYXAkMyhfY29udGV4dCA9IGdlcGhpSlNPTi5ub2RlcykuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKGdOb2RlKSB7XG4gICAgdmFyIHZOb2RlID0ge1xuICAgICAgaWQ6IGdOb2RlLmlkLFxuICAgICAgZml4ZWQ6IG9wdGlvbnMubm9kZXMuZml4ZWQgJiYgZ05vZGUueCAhPSBudWxsICYmIGdOb2RlLnkgIT0gbnVsbFxuICAgIH07XG5cbiAgICBpZiAoZ05vZGUuYXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS5hdHRyaWJ1dGVzID0gZ05vZGUuYXR0cmlidXRlcztcbiAgICB9XG5cbiAgICBpZiAoZ05vZGUubGFiZWwgIT0gbnVsbCkge1xuICAgICAgdk5vZGUubGFiZWwgPSBnTm9kZS5sYWJlbDtcbiAgICB9XG5cbiAgICBpZiAoZ05vZGUuc2l6ZSAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS5zaXplID0gZ05vZGUuc2l6ZTtcbiAgICB9XG5cbiAgICBpZiAoZ05vZGUuYXR0cmlidXRlcyAhPSBudWxsICYmIGdOb2RlLmF0dHJpYnV0ZXMudGl0bGUgIT0gbnVsbCkge1xuICAgICAgdk5vZGUudGl0bGUgPSBnTm9kZS5hdHRyaWJ1dGVzLnRpdGxlO1xuICAgIH1cblxuICAgIGlmIChnTm9kZS50aXRsZSAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS50aXRsZSA9IGdOb2RlLnRpdGxlO1xuICAgIH1cblxuICAgIGlmIChnTm9kZS54ICE9IG51bGwpIHtcbiAgICAgIHZOb2RlLnggPSBnTm9kZS54O1xuICAgIH1cblxuICAgIGlmIChnTm9kZS55ICE9IG51bGwpIHtcbiAgICAgIHZOb2RlLnkgPSBnTm9kZS55O1xuICAgIH1cblxuICAgIGlmIChnTm9kZS5jb2xvciAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5ub2Rlcy5wYXJzZUNvbG9yID09PSB0cnVlKSB7XG4gICAgICAgIHZOb2RlLmNvbG9yID0gZ05vZGUuY29sb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2Tm9kZS5jb2xvciA9IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBnTm9kZS5jb2xvcixcbiAgICAgICAgICBib3JkZXI6IGdOb2RlLmNvbG9yLFxuICAgICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogZ05vZGUuY29sb3IsXG4gICAgICAgICAgICBib3JkZXI6IGdOb2RlLmNvbG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogZ05vZGUuY29sb3IsXG4gICAgICAgICAgICBib3JkZXI6IGdOb2RlLmNvbG9yXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2Tm9kZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBub2Rlczogdk5vZGVzLFxuICAgIGVkZ2VzOiB2RWRnZXNcbiAgfTtcbn1cblxudmFyIGdlcGhpUGFyc2VyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdHBhcnNlR2VwaGk6IHBhcnNlR2VwaGlcbn0pO1xuXG4vLyBFbmdsaXNoXG52YXIgZW4gPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIkNsaWNrIGluIGFuIGVtcHR5IHNwYWNlIHRvIHBsYWNlIGEgbmV3IG5vZGUuXCIsXG4gIGFkZEVkZ2U6IFwiQWRkIEVkZ2VcIixcbiAgYWRkTm9kZTogXCJBZGQgTm9kZVwiLFxuICBiYWNrOiBcIkJhY2tcIixcbiAgY2xvc2U6IFwiQ2xvc2VcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcIkNhbm5vdCBsaW5rIGVkZ2VzIHRvIGEgY2x1c3Rlci5cIixcbiAgZGVsOiBcIkRlbGV0ZSBzZWxlY3RlZFwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlcnMgY2Fubm90IGJlIGRlbGV0ZWQuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJDbGljayBvbiBhIG5vZGUgYW5kIGRyYWcgdGhlIGVkZ2UgdG8gYW5vdGhlciBub2RlIHRvIGNvbm5lY3QgdGhlbS5cIixcbiAgZWRpdDogXCJFZGl0XCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlcnMgY2Fubm90IGJlIGVkaXRlZC5cIixcbiAgZWRpdEVkZ2U6IFwiRWRpdCBFZGdlXCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwiQ2xpY2sgb24gdGhlIGNvbnRyb2wgcG9pbnRzIGFuZCBkcmFnIHRoZW0gdG8gYSBub2RlIHRvIGNvbm5lY3QgdG8gaXQuXCIsXG4gIGVkaXROb2RlOiBcIkVkaXQgTm9kZVwiXG59OyAvLyBHZXJtYW5cblxudmFyIGRlID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJLbGlja2UgYXVmIGVpbmUgZnJlaWUgU3RlbGxlLCB1bSBlaW5lbiBuZXVlbiBLbm90ZW4genUgcGxhemllcmVuLlwiLFxuICBhZGRFZGdlOiBcIkthbnRlIGhpbnp1ZlxceEZDZ2VuXCIsXG4gIGFkZE5vZGU6IFwiS25vdGVuIGhpbnp1ZlxceEZDZ2VuXCIsXG4gIGJhY2s6IFwiWnVyXFx4RkNja1wiLFxuICBjbG9zZTogXCJTY2hsaWXDn2VuXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJFcyBpc3QgbmljaHQgbVxceEY2Z2xpY2gsIEthbnRlbiBtaXQgQ2x1c3Rlcm4genUgdmVyYmluZGVuLlwiLFxuICBkZWw6IFwiTFxceEY2c2NoZSBBdXN3YWhsXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJDbHVzdGVyIGtcXHhGNm5uZW4gbmljaHQgZ2VsXFx4RjZzY2h0IHdlcmRlbi5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIktsaWNrZSBhdWYgZWluZW4gS25vdGVuIHVuZCB6aWVoZSBkaWUgS2FudGUgenUgZWluZW0gYW5kZXJlbiBLbm90ZW4sIHVtIGRpZXNlIHp1IHZlcmJpbmRlbi5cIixcbiAgZWRpdDogXCJFZGl0aWVyZW5cIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJDbHVzdGVyIGtcXHhGNm5uZW4gbmljaHQgZWRpdGllcnQgd2VyZGVuLlwiLFxuICBlZGl0RWRnZTogXCJLYW50ZSBlZGl0aWVyZW5cIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJLbGlja2UgYXVmIGRpZSBWZXJiaW5kdW5nc3B1bmt0ZSB1bmQgemllaGUgZGllc2UgYXVmIGVpbmVuIEtub3RlbiwgdW0gc2llIHp1IHZlcmJpbmRlbi5cIixcbiAgZWRpdE5vZGU6IFwiS25vdGVuIGVkaXRpZXJlblwiXG59OyAvLyBTcGFuaXNoXG5cbnZhciBlcyA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiSGFnYSBjbGljIGVuIHVuIGx1Z2FyIHZhY1xceEVEbyBwYXJhIGNvbG9jYXIgdW4gbnVldm8gbm9kby5cIixcbiAgYWRkRWRnZTogXCJBXFx4RjFhZGlyIGFyaXN0YVwiLFxuICBhZGROb2RlOiBcIkFcXHhGMWFkaXIgbm9kb1wiLFxuICBiYWNrOiBcIkF0clxceEUxc1wiLFxuICBjbG9zZTogXCJDZXJyYXJcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcIk5vIHNlIHB1ZWRlIGNvbmVjdGFyIHVuYSBhcmlzdGEgYSB1biBncnVwby5cIixcbiAgZGVsOiBcIkVsaW1pbmFyIHNlbGVjY2lcXHhGM25cIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIk5vIGVzIHBvc2libGUgZWxpbWluYXIgZ3J1cG9zLlwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiSGFnYSBjbGljIGVuIHVuIG5vZG8geSBhcnJhc3RyZSBsYSBhcmlzdGEgaGFjaWEgb3RybyBub2RvIHBhcmEgY29uZWN0YXJsb3MuXCIsXG4gIGVkaXQ6IFwiRWRpdGFyXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiTm8gZXMgcG9zaWJsZSBlZGl0YXIgZ3J1cG9zLlwiLFxuICBlZGl0RWRnZTogXCJFZGl0YXIgYXJpc3RhXCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwiSGFnYSBjbGljIGVuIHVuIHB1bnRvIGRlIGNvbnRyb2wgeSBhcnJhc3RyZWxvIGEgdW4gbm9kbyBwYXJhIGNvbmVjdGFybG8uXCIsXG4gIGVkaXROb2RlOiBcIkVkaXRhciBub2RvXCJcbn07IC8vSXRhbGlhbm9cblxudmFyIGl0ID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJDbGljY2EgcGVyIGFnZ2l1bmdlcmUgdW4gbnVvdm8gbm9kb1wiLFxuICBhZGRFZGdlOiBcIkFnZ2l1bmdpIHVuIHZlcnRpY2VcIixcbiAgYWRkTm9kZTogXCJBZ2dpdW5naSB1biBub2RvXCIsXG4gIGJhY2s6IFwiSW5kaWV0cm9cIixcbiAgY2xvc2U6IFwiQ2hpdWRlcmVcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcIk5vbiBzaSBwb3Nzb25vIGNvbGxlZ2FyZSB2ZXJ0aWNpIGFkIHVuIGNsdXN0ZXJcIixcbiAgZGVsOiBcIkNhbmNlbGxhIGxhIHNlbGV6aW9uZVwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiSSBjbHVzdGVyIG5vbiBwb3Nzb25vIGVzc2VyZSBjYW5jZWxsYXRpXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJDbGljY2Egc3UgdW4gbm9kbyBlIHRyYXNjaW5hbG8gYWQgdW4gYWx0cm8gbm9kbyBwZXIgY29ubmV0dGVybGkuXCIsXG4gIGVkaXQ6IFwiTW9kaWZpY2FcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJJIGNsdXN0ZXJzIG5vbiBwb3Nzb25vIGVzc2VyZSBtb2RpZmljYXRpLlwiLFxuICBlZGl0RWRnZTogXCJNb2RpZmljYSBpbCB2ZXJ0aWNlXCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwiQ2xpY2NhIHN1aSBQdW50aSBkaSBjb250cm9sbG8gZSB0cmFzY2luYWxpIGFkIHVuIG5vZG8gcGVyIGNvbm5ldHRlcmxpLlwiLFxuICBlZGl0Tm9kZTogXCJNb2RpZmljYSBpbCBub2RvXCJcbn07IC8vIER1dGNoXG5cbnZhciBubCA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiS2xpayBvcCBlZW4gbGVlZyBnZWJpZWQgb20gZWVuIG5pZXV3ZSBub2RlIHRlIG1ha2VuLlwiLFxuICBhZGRFZGdlOiBcIkxpbmsgdG9ldm9lZ2VuXCIsXG4gIGFkZE5vZGU6IFwiTm9kZSB0b2V2b2VnZW5cIixcbiAgYmFjazogXCJUZXJ1Z1wiLFxuICBjbG9zZTogXCJTbHVpdGVuXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJLYW4gZ2VlbiBsaW5rIG1ha2VuIG5hYXIgZWVuIGNsdXN0ZXIuXCIsXG4gIGRlbDogXCJTZWxlY3RpZSB2ZXJ3aWpkZXJlblwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlcnMga3VubmVuIG5pZXQgd29yZGVuIHZlcndpamRlcmQuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJLbGlrIG9wIGVlbiBub2RlIGVuIHNsZWVwIGRlIGxpbmsgbmFhciBlZW4gYW5kZXJlIG5vZGUgb20gemUgdGUgdmVyYmluZGVuLlwiLFxuICBlZGl0OiBcIldpanppZ2VuXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlcnMga3VubmVuIG5pZXQgd29yZGVuIGFhbmdlcGFzdC5cIixcbiAgZWRpdEVkZ2U6IFwiTGluayB3aWp6aWdlblwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIktsaWsgb3AgZGUgdmVyYmluZGluZ3NwdW50ZW4gZW4gc2xlZXAgemUgbmFhciBlZW4gbm9kZSBvbSBkYWFybWVlIHRlIHZlcmJpbmRlbi5cIixcbiAgZWRpdE5vZGU6IFwiTm9kZSB3aWp6aWdlblwiXG59OyAvLyBQb3J0dWd1ZXNlIEJyYXppbFxuXG52YXIgcHQgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIkNsaXF1ZSBlbSB1bSBlc3Bhw6dvIGVtIGJyYW5jbyBwYXJhIGFkaWNpb25hciB1bSBub3ZvIG7Ds1wiLFxuICBhZGRFZGdlOiBcIkFkaWNpb25hciBhcmVzdGFcIixcbiAgYWRkTm9kZTogXCJBZGljaW9uYXIgbsOzXCIsXG4gIGJhY2s6IFwiVm9sdGFyXCIsXG4gIGNsb3NlOiBcIkZlY2hhclwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiTsOjbyBmb2kgcG9zc8OtdmVsIGxpbmthciBhcmVzdGFzIGEgdW0gY2x1c3Rlci5cIixcbiAgZGVsOiBcIlJlbW92ZXIgc2VsZWNpb25hZG9cIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIkNsdXN0ZXJzIG7Do28gcHVkZXJhbSBzZXIgcmVtb3ZpZG9zLlwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiQ2xpcXVlIGVtIHVtIG7DsyBlIGFycmFzdGUgYSBhcmVzdGEgYXTDqSBvdXRybyBuw7MgcGFyYSBjb25lY3TDoS1sb3NcIixcbiAgZWRpdDogXCJFZGl0YXJcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJDbHVzdGVycyBuw6NvIHB1ZGVyYW0gc2VyIGVkaXRhZG9zLlwiLFxuICBlZGl0RWRnZTogXCJFZGl0YXIgYXJlc3RhXCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwiQ2xpcXVlIG5vcyBwb250b3MgZGUgY29udHJvbGUgZSBvcyBhcnJhc3RlIHBhcmEgdW0gbsOzIHBhcmEgY29uZWN0w6EtbG9zXCIsXG4gIGVkaXROb2RlOiBcIkVkaXRhciBuw7NcIlxufTsgLy8gUnVzc2lhblxuXG52YXIgcnUgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcItCa0LvQuNC60L3QuNGC0LUg0LIg0YHQstC+0LHQvtC00L3QvtC1INC80LXRgdGC0L4sINGH0YLQvtCx0Ysg0LTQvtCx0LDQstC40YLRjCDQvdC+0LLRi9C5INGD0LfQtdC7LlwiLFxuICBhZGRFZGdlOiBcItCU0L7QsdCw0LLQuNGC0Ywg0YDQtdCx0YDQvlwiLFxuICBhZGROb2RlOiBcItCU0L7QsdCw0LLQuNGC0Ywg0YPQt9C10LtcIixcbiAgYmFjazogXCLQndCw0LfQsNC0XCIsXG4gIGNsb3NlOiBcItCX0LDQutGA0YvQstCw0YLRjFwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwi0J3QtdCy0L7Qt9C80L7QttC90L4g0YHQvtC10LTQuNC90LjRgtGMINGA0LXQsdGA0LAg0LIg0LrQu9Cw0YHRgtC10YAuXCIsXG4gIGRlbDogXCLQo9C00LDQu9C40YLRjCDQstGL0LHRgNCw0L3QvdC+0LVcIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcItCa0LvQsNGB0YLQtdGA0Ysg0L3QtSDQvNC+0LPRg9GCINCx0YvRgtGMINGD0LTQsNC70LXQvdGLXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCLQmtC70LjQutC90LjRgtC1INC90LAg0YPQt9C10Lsg0Lgg0L/RgNC+0YLRj9C90LjRgtC1INGA0LXQsdGA0L4g0Log0LTRgNGD0LPQvtC80YMg0YPQt9C70YMsINGH0YLQvtCx0Ysg0YHQvtC10LTQuNC90LjRgtGMINC40YUuXCIsXG4gIGVkaXQ6IFwi0KDQtdC00LDQutGC0LjRgNC+0LLQsNGC0YxcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCLQmtC70LDRgdGC0LXRgNGLINC90LXQtNC+0YHRgtGD0L/QvdGLINC00LvRjyDRgNC10LTQsNC60YLQuNGA0L7QstCw0L3QuNGPLlwiLFxuICBlZGl0RWRnZTogXCLQoNC10LTQsNC60YLQuNGA0L7QstCw0YLRjCDRgNC10LHRgNC+XCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwi0JrQu9C40LrQvdC40YLQtSDQvdCwINC60L7QvdGC0YDQvtC70YzQvdGL0LUg0YLQvtGH0LrQuCDQuCDQv9C10YDQtdGC0LDRidC40YLQtSDQuNGFINCyINGD0LfQtdC7LCDRh9GC0L7QsdGLINC/0L7QtNC60LvRjtGH0LjRgtGM0YHRjyDQuiDQvdC10LzRgy5cIixcbiAgZWRpdE5vZGU6IFwi0KDQtdC00LDQutGC0LjRgNC+0LLQsNGC0Ywg0YPQt9C10LtcIlxufTsgLy8gQ2hpbmVzZVxuXG52YXIgY24gPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIuWNleWHu+epuueZveWkhOaUvue9ruaWsOiKgueCueOAglwiLFxuICBhZGRFZGdlOiBcIua3u+WKoOi/nuaOpee6v1wiLFxuICBhZGROb2RlOiBcIua3u+WKoOiKgueCuVwiLFxuICBiYWNrOiBcIui/lOWbnlwiLFxuICBjbG9zZTogXCLpl5zplolcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcIuaXoOazleWwhui/nuaOpee6v+i/nuaOpeWIsOe+pOmbhuOAglwiLFxuICBkZWw6IFwi5Yig6Zmk6YCJ5a6aXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCLml6Dms5XliKDpmaTnvqTpm4bjgIJcIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIuWNleWHu+afkOS4quiKgueCueW5tuWwhuivpei/nuaOpee6v+aLluWKqOWIsOWPpuS4gOS4quiKgueCueS7pei/nuaOpeWug+S7rOOAglwiLFxuICBlZGl0OiBcIue8lui+kVwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIuaXoOazlee8lui+kee+pOmbhuOAglwiLFxuICBlZGl0RWRnZTogXCLnvJbovpHov57mjqXnur9cIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCLljZXlh7vmjqfliLboioLngrnlubblsIblroPku6zmi5bliLDoioLngrnkuIrov57mjqXjgIJcIixcbiAgZWRpdE5vZGU6IFwi57yW6L6R6IqC54K5XCJcbn07IC8vIFVrcmFpbmlhblxuXG52YXIgdWsgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIkvQu9GW0LrQvdGW0YLRjCDQvdCwINCy0ZbQu9GM0L3QtSDQvNGW0YHRhtC1LCDRidC+0LEg0LTQvtC00LDRgtC4INC90L7QstC40Lkg0LLRg9C30L7Quy5cIixcbiAgYWRkRWRnZTogXCLQlNC+0LTQsNGC0Lgg0LrRgNCw0LlcIixcbiAgYWRkTm9kZTogXCLQlNC+0LTQsNGC0Lgg0LLRg9C30L7Qu1wiLFxuICBiYWNrOiBcItCd0LDQt9Cw0LRcIixcbiAgY2xvc2U6IFwi0JfQsNC60YDQuNGC0LhcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcItCd0LUg0LzQvtC20LvQuNCy0L4g0L7QsSfRlNC00L3QsNGC0Lgg0LrRgNCw0Zcg0LIg0LPRgNGD0L/Rgy5cIixcbiAgZGVsOiBcItCS0LjQtNCw0LvQuNGC0Lgg0L7QsdGA0LDQvdC1XCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCLQk9GA0YPQv9C4INC90LUg0LzQvtC20YPRgtGMINCx0YPRgtC4INCy0LjQtNCw0LvQtdC90ZYuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCLQmtC70ZbQutC90ZbRgtGMINC90LAg0LLRg9C30L7QuyDRliDQv9C10YDQtdGC0Y/Qs9C90ZbRgtGMINC60YDQsNC5INC00L4g0ZbQvdGI0L7Qs9C+INCy0YPQt9C70LAsINGJ0L7QsSDRl9GFINC3J9GU0LTQvdCw0YLQuC5cIixcbiAgZWRpdDogXCLQoNC10LTQsNCz0YPQstCw0YLQuFwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcItCT0YDRg9C/0Lgg0L3QtdC00L7RgdGC0YPQv9C90ZYg0LTQu9GPINGA0LXQtNCw0LPRg9Cy0LDQvdC90Y8uXCIsXG4gIGVkaXRFZGdlOiBcItCg0LXQtNCw0LPRg9Cy0LDRgtC4INC60YDQsNC5XCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwi0JrQu9GW0LrQvdGW0YLRjCDQvdCwINC60L7QvdGC0YDQvtC70YzQvdGWINGC0L7Rh9C60Lgg0ZYg0L/QtdGA0LXRgtGP0LPQvdGW0YLRjCDRl9GFINGDINCy0YPQt9C+0LssINGJ0L7QsSDQv9GW0LTQutC70Y7Rh9C40YLQuNGB0Y8g0LTQviDQvdGM0L7Qs9C+LlwiLFxuICBlZGl0Tm9kZTogXCLQoNC10LTQsNCz0YPQstCw0YLQuCDQstGD0LfQvtC7XCJcbn07IC8vIEZyZW5jaFxuXG52YXIgZnIgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIkNsaXF1ZXogZGFucyB1biBlbmRyb2l0IHZpZGUgcG91ciBwbGFjZXIgdW4gbsWTdWQuXCIsXG4gIGFkZEVkZ2U6IFwiQWpvdXRlciB1biBsaWVuXCIsXG4gIGFkZE5vZGU6IFwiQWpvdXRlciB1biBuxZN1ZFwiLFxuICBiYWNrOiBcIlJldG91clwiLFxuICBjbG9zZTogXCJGZXJtZXJcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcIkltcG9zc2libGUgZGUgY3LDqWVyIHVuIGxpZW4gdmVycyB1biBjbHVzdGVyLlwiLFxuICBkZWw6IFwiRWZmYWNlciBsYSBzw6lsZWN0aW9uXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJMZXMgY2x1c3RlcnMgbmUgcGV1dmVudCBwYXMgw6p0cmUgZWZmYWPDqXMuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJDbGlxdWV6IHN1ciB1biBuxZN1ZCBldCBnbGlzc2V6IGxlIGxpZW4gdmVycyB1biBhdXRyZSBuxZN1ZCBwb3VyIGxlcyBjb25uZWN0ZXIuXCIsXG4gIGVkaXQ6IFwiw4lkaXRlclwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIkxlcyBjbHVzdGVycyBuZSBwZXV2ZW50IHBhcyDDqnRyZSDDqWRpdMOpcy5cIixcbiAgZWRpdEVkZ2U6IFwiw4lkaXRlciBsZSBsaWVuXCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwiQ2xpcXVleiBzdXIgbGVzIHBvaW50cyBkZSBjb250csO0bGUgZXQgZ2xpc3Nlei1sZXMgcG91ciBjb25uZWN0ZXIgdW4gbsWTdWQuXCIsXG4gIGVkaXROb2RlOiBcIsOJZGl0ZXIgbGUgbsWTdWRcIlxufTsgLy8gQ3plY2hcblxudmFyIGNzID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJLbHVrbnV0w61tIGRvIHByw6F6ZG7DqWhvIHByb3N0b3J1IG3Fr8W+ZXRlIHDFmWlkYXQgbm92w70gdnJjaG9sLlwiLFxuICBhZGRFZGdlOiBcIlDFmWlkYXQgaHJhbnVcIixcbiAgYWRkTm9kZTogXCJQxZlpZGF0IHZyY2hvbFwiLFxuICBiYWNrOiBcIlpwxJt0XCIsXG4gIGNsb3NlOiBcIlphdsWZw610XCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJOZWx6ZSBwxZlpcG9qaXQgaHJhbnUga2Ugc2hsdWt1LlwiLFxuICBkZWw6IFwiU21hemF0IHbDvWLEm3JcIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIk5lbHplIG1hemF0IHNobHVreS5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIlDFmWV0YcW+ZW7DrW0geiBqZWRub2hvIHZyY2hvbHUgZG8gZHJ1aMOpaG8gbcWvxb5ldGUgc3Bvaml0IHR5dG8gdnJjaG9seSBub3ZvdSBocmFub3UuXCIsXG4gIGVkaXQ6IFwiVXByYXZpdFwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIk5lbHplIHVwcmF2b3ZhdCBzaGx1a3kuXCIsXG4gIGVkaXRFZGdlOiBcIlVwcmF2aXQgaHJhbnVcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJQxZlldGHFvmVuw61tIGtvbnRyb2xuw61obyB2cmNob2x1IGhyYW55IGppIG3Fr8W+ZXRlIHDFmWlwb2ppdCBrIGppbsOpbXUgdnJjaG9sdS5cIixcbiAgZWRpdE5vZGU6IFwiVXByYXZpdCB2cmNob2xcIlxufTtcblxudmFyIGxvY2FsZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0ZW46IGVuLFxuXHRkZTogZGUsXG5cdGVzOiBlcyxcblx0aXQ6IGl0LFxuXHRubDogbmwsXG5cdHB0OiBwdCxcblx0cnU6IHJ1LFxuXHRjbjogY24sXG5cdHVrOiB1ayxcblx0ZnI6IGZyLFxuXHRjczogY3Ncbn0pO1xuXG4vKipcclxuICogTm9ybWFsaXplcyBsYW5ndWFnZSBjb2RlIGludG8gdGhlIGZvcm1hdCB1c2VkIGludGVybmFsbHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBsb2NhbGVzIC0gQWxsIHRoZSBhdmFpbGFibGUgbG9jYWxlcy5cclxuICogQHBhcmFtIHJhd0NvZGUgLSBUaGUgb3JpZ2luYWwgY29kZSBhcyBzdXBwbGllZCBieSB0aGUgdXNlci5cclxuICogQHJldHVybnMgTGFuZ3VhZ2UgY29kZSBpbiB0aGUgZm9ybWF0IGxhbmd1YWdlLUNPVU5UUlkgb3IgbGFuZ3VhZ2UsIGV2ZW50dWFsbHlcclxuICogZmFsbGJhY2tzIHRvIGVuLlxyXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxhbmd1YWdlQ29kZShsb2NhbGVzLCByYXdDb2RlKSB7XG4gIHRyeSB7XG4gICAgdmFyIF9yYXdDb2RlJHNwbGl0ID0gcmF3Q29kZS5zcGxpdCgvWy1fIC9dLywgMiksXG4gICAgICAgIF9yYXdDb2RlJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9yYXdDb2RlJHNwbGl0LCAyKSxcbiAgICAgICAgcmF3TGFuZ3VhZ2UgPSBfcmF3Q29kZSRzcGxpdDJbMF0sXG4gICAgICAgIHJhd0NvdW50cnkgPSBfcmF3Q29kZSRzcGxpdDJbMV07XG5cbiAgICB2YXIgbGFuZ3VhZ2UgPSByYXdMYW5ndWFnZSAhPSBudWxsID8gcmF3TGFuZ3VhZ2UudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgdmFyIGNvdW50cnkgPSByYXdDb3VudHJ5ICE9IG51bGwgPyByYXdDb3VudHJ5LnRvVXBwZXJDYXNlKCkgOiBudWxsO1xuXG4gICAgaWYgKGxhbmd1YWdlICYmIGNvdW50cnkpIHtcbiAgICAgIHZhciBjb2RlID0gbGFuZ3VhZ2UgKyBcIi1cIiArIGNvdW50cnk7XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobG9jYWxlcywgY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICAgICAgY29uc29sZS53YXJuKGNvbmNhdChfY29udGV4dCA9IFwiVW5rbm93biB2YXJpYW50IFwiLmNvbmNhdChjb3VudHJ5LCBcIiBvZiBsYW5ndWFnZSBcIikpLmNhbGwoX2NvbnRleHQsIGxhbmd1YWdlLCBcIi5cIikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgdmFyIF9jb2RlID0gbGFuZ3VhZ2U7XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobG9jYWxlcywgX2NvZGUpKSB7XG4gICAgICAgIHJldHVybiBfY29kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gbGFuZ3VhZ2UgXCIuY29uY2F0KGxhbmd1YWdlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc29sZS53YXJuKFwiVW5rbm93biBsb2NhbGUgXCIuY29uY2F0KHJhd0NvZGUsIFwiLCBmYWxsaW5nIGJhY2sgdG8gRW5nbGlzaC5cIikpO1xuICAgIHJldHVybiBcImVuXCI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgY29uc29sZS53YXJuKFwiVW5leHBlY3RlZCBlcnJvciB3aGlsZSBub3JtYWxpemluZyBsb2NhbGUgXCIuY29uY2F0KHJhd0NvZGUsIFwiLCBmYWxsaW5nIGJhY2sgdG8gRW5nbGlzaC5cIikpO1xuICAgIHJldHVybiBcImVuXCI7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NvY2lhdGVzIGEgY2FudmFzIHRvIGEgZ2l2ZW4gaW1hZ2UsIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcmVuZGVyaW5nc1xuICogb2YgdGhlIGltYWdlIGF0IHZhcmlvdXMgc2l6ZXMuXG4gKlxuICogVGhpcyB0ZWNobmlxdWUgaXMga25vd24gYXMgJ21pcG1hcHBpbmcnLlxuICpcbiAqIE5PVEU6IEltYWdlcyBjYW4gYWxzbyBiZSBvZiB0eXBlICdkYXRhOnN2Zyt4bWxgLiBUaGlzIGNvZGUgYWxzbyB3b3Jrc1xuICogICAgICAgZm9yIHN2ZywgYnV0IHRoZSBtaXBtYXBwaW5nIG1heSBub3QgYmUgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gKi9cbnZhciBDYWNoZWRJbWFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBDYWNoZWRJbWFnZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FjaGVkSW1hZ2UpO1xuXG4gICAgdGhpcy5OVU1fSVRFUkFUSU9OUyA9IDQ7IC8vIE51bWJlciBvZiBpdGVtcyBpbiB0aGUgY29vcmRpbmF0ZXMgYXJyYXlcblxuICAgIHRoaXMuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBpbWFnZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDYWNoZWRJbWFnZSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQoKSkgcmV0dXJuO1xuICAgICAgdGhpcy5zcmMgPSB0aGlzLmltYWdlLnNyYzsgLy8gRm9yIHNhbWUgaW50ZXJmYWNlIHdpdGggSW1hZ2VcblxuICAgICAgdmFyIHcgPSB0aGlzLmltYWdlLndpZHRoO1xuICAgICAgdmFyIGggPSB0aGlzLmltYWdlLmhlaWdodDsgLy8gRWFzZSBleHRlcm5hbCBhY2Nlc3NcblxuICAgICAgdGhpcy53aWR0aCA9IHc7XG4gICAgICB0aGlzLmhlaWdodCA9IGg7XG4gICAgICB2YXIgaDIgPSBNYXRoLmZsb29yKGggLyAyKTtcbiAgICAgIHZhciBoNCA9IE1hdGguZmxvb3IoaCAvIDQpO1xuICAgICAgdmFyIGg4ID0gTWF0aC5mbG9vcihoIC8gOCk7XG4gICAgICB2YXIgaDE2ID0gTWF0aC5mbG9vcihoIC8gMTYpO1xuICAgICAgdmFyIHcyID0gTWF0aC5mbG9vcih3IC8gMik7XG4gICAgICB2YXIgdzQgPSBNYXRoLmZsb29yKHcgLyA0KTtcbiAgICAgIHZhciB3OCA9IE1hdGguZmxvb3IodyAvIDgpO1xuICAgICAgdmFyIHcxNiA9IE1hdGguZmxvb3IodyAvIDE2KTsgLy8gTWFrZSBjYW52YXMgYXMgc21hbGwgYXMgcG9zc2libGVcblxuICAgICAgdGhpcy5jYW52YXMud2lkdGggPSAzICogdzQ7XG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoMjsgLy8gQ29vcmRpbmF0ZXMgYW5kIHNpemVzIG9mIGltYWdlcyBjb250YWluZWQgaW4gdGhlIGNhbnZhc1xuICAgICAgLy8gVmFsdWVzIHBlciByb3c6ICBbdG9wIHgsIGxlZnQgeSwgd2lkdGgsIGhlaWdodF1cblxuICAgICAgdGhpcy5jb29yZGluYXRlcyA9IFtbMCwgMCwgdzIsIGgyXSwgW3cyLCAwLCB3NCwgaDRdLCBbdzIsIGg0LCB3OCwgaDhdLCBbNSAqIHc4LCBoNCwgdzE2LCBoMTZdXTtcblxuICAgICAgdGhpcy5fZmlsbE1pcE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBpbml0KCkgaGFzIGJlZW4gY2FsbGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsaXplZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVzICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBtYWluIGltYWdlIGluIHZhcmlvdXMgc2l6ZXMgdG8gdGhlIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBUaGUgcmF0aW9uYWxlIGJlaGluZCB0aGlzIGlzIHRvIHJlZHVjZSBhcnRlZmFjdHMgZHVlIHRvIGludGVycG9sYXRpb25cbiAgICAgKiBhdCBkaWZmZXJpbmcgem9vbSBsZXZlbHMuXG4gICAgICpcbiAgICAgKiBTb3VyY2U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4NzYxNDA0LzEyMjM1MzFcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kcyB0YWtlcyB0aGUgcmVzaXppbmcgb3V0IG9mIHRoZSBkcmF3aW5nIGxvb3AsIGluIG9yZGVyIHRvXG4gICAgICogcmVkdWNlIHBlcmZvcm1hbmNlIG92ZXJoZWFkLlxuICAgICAqXG4gICAgICogVE9ETzogVGhlIGNvZGUgYXNzdW1lcyB0aGF0IGEgMkQgY29udGV4dCBjYW4gYWx3YXlzIGJlIGdvdHRlbi4gVGhpcyBpc1xuICAgICAqICAgICAgIG5vdCBuZWNlc3NhcmlseSB0cnVlISBPVE9ILCBpZiBub3QgdHJ1ZSB0aGVuIHVzYWdlIG9mIHRoaXMgY2xhc3NcbiAgICAgKiAgICAgICBpcyBzZW5zZWxlc3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbGxNaXBNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbGxNaXBNYXAoKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpOyAvLyBGaXJzdCB6b29tLWxldmVsIGNvbWVzIGZyb20gdGhlIGltYWdlXG5cbiAgICAgIHZhciB0byA9IHRoaXMuY29vcmRpbmF0ZXNbMF07XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuaW1hZ2UsIHRvWzBdLCB0b1sxXSwgdG9bMl0sIHRvWzNdKTsgLy8gVGhlIHJlc3QgYXJlIGNvcHkgYWN0aW9ucyBpbnRlcm5hbCB0byB0aGUgY2FudmFzL2NvbnRleHRcblxuICAgICAgZm9yICh2YXIgaXRlcmF0aW9ucyA9IDE7IGl0ZXJhdGlvbnMgPCB0aGlzLk5VTV9JVEVSQVRJT05TOyBpdGVyYXRpb25zKyspIHtcbiAgICAgICAgdmFyIGZyb20gPSB0aGlzLmNvb3JkaW5hdGVzW2l0ZXJhdGlvbnMgLSAxXTtcbiAgICAgICAgdmFyIF90byA9IHRoaXMuY29vcmRpbmF0ZXNbaXRlcmF0aW9uc107XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXMsIGZyb21bMF0sIGZyb21bMV0sIGZyb21bMl0sIGZyb21bM10sIF90b1swXSwgX3RvWzFdLCBfdG9bMl0sIF90b1szXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIGltYWdlLCB1c2luZyB0aGUgbWlwbWFwIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIE1pcE1hcCBpcyBvbmx5IHVzZWQgaWYgcGFyYW0gZmFjdG9yID4gMjsgb3RoZXJ3aXNlLCBvcmlnaW5hbCBiaXRtYXBcbiAgICAgKiBpcyByZXNpemVkLiBUaGlzIGlzIGFsc28gdXNlZCB0byBza2lwIG1pcG1hcCB1c2FnZSwgZS5nLiBieSBzZXR0aW5nIGZhY3RvciA9IDFcbiAgICAgKlxuICAgICAqIENyZWRpdHMgdG8gJ0FsZXggZGUgTXVsZGVyJyBmb3Igb3JpZ2luYWwgaW1wbGVtZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4ICBjb250ZXh0IG9uIHdoaWNoIHRvIGRyYXcgem9vbWVkIGltYWdlXG4gICAgICogQHBhcmFtIHtGbG9hdH0gZmFjdG9yIHNjYWxlIGZhY3RvciBhdCB3aGljaCB0byBkcmF3XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlZnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0ltYWdlQXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgZmFjdG9yLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCgpKSByZXR1cm47IC8vY2FuJ3QgZHJhdyBpbWFnZSB5ZXQgbm90IGludGlhbGl6ZWRcblxuICAgICAgaWYgKGZhY3RvciA+IDIpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHpvb21lZCBpbWFnZSB0byB1c2VcbiAgICAgICAgZmFjdG9yICo9IDAuNTtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChmYWN0b3IgPiAyICYmIGl0ZXJhdGlvbnMgPCB0aGlzLk5VTV9JVEVSQVRJT05TKSB7XG4gICAgICAgICAgZmFjdG9yICo9IDAuNTtcbiAgICAgICAgICBpdGVyYXRpb25zICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlcmF0aW9ucyA+PSB0aGlzLk5VTV9JVEVSQVRJT05TKSB7XG4gICAgICAgICAgaXRlcmF0aW9ucyA9IHRoaXMuTlVNX0lURVJBVElPTlMgLSAxO1xuICAgICAgICB9IC8vY29uc29sZS5sb2coXCJpdGVyYXRpb25zOiBcIiArIGl0ZXJhdGlvbnMpO1xuXG5cbiAgICAgICAgdmFyIGZyb20gPSB0aGlzLmNvb3JkaW5hdGVzW2l0ZXJhdGlvbnNdO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzLCBmcm9tWzBdLCBmcm9tWzFdLCBmcm9tWzJdLCBmcm9tWzNdLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRHJhdyBpbWFnZSBkaXJlY3RseVxuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuaW1hZ2UsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhY2hlZEltYWdlO1xufSgpO1xuXG4vKipcbiAqIFRoaXMgY2FsbGJhY2sgaXMgYSBjYWxsYmFjayB0aGF0IGFjY2VwdHMgYW4gSW1hZ2UuXG4gKlxuICogQGNhbGxiYWNrIEltYWdlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gKi9cblxuLyoqXG4gKiBUaGlzIGNsYXNzIGxvYWRzIGltYWdlcyBhbmQga2VlcHMgdGhlbSBzdG9yZWQuXG4gKlxuICogQHBhcmFtIHtJbWFnZUNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5cbnZhciBJbWFnZXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtJbWFnZUNhbGxiYWNrfSBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gSW1hZ2VzKGNhbGxiYWNrKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlcyk7XG5cbiAgICB0aGlzLmltYWdlcyA9IHt9O1xuICAgIHRoaXMuaW1hZ2VCcm9rZW4gPSB7fTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgICAgICAgICAgICAgICAgICAgVGhlIG9yaWdpbmFsIFVybCB0aGF0IGZhaWxlZCB0byBsb2FkLCBpZiB0aGUgYnJva2VuIGltYWdlIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWQgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgY2FjaGUgdXNpbmcgdGhpcyBVcmwgYXMgdGhlIGtleSBzbyB0aGF0IHN1YnNlcXVlbnQgcmVxdWVzdHMgZm9yIHRoaXMgVXJsIHdpbGwgcmV0dXJuIHRoZSBicm9rZW4gaW1hZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJyb2tlblVybCAgICAgICAgICAgICAgICBVcmwgdGhlIGJyb2tlbiBpbWFnZSB0byB0cnkgYW5kIGxvYWRcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbiAgIFRoZSBpbWFnZSBvYmplY3RcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSW1hZ2VzLCBbe1xuICAgIGtleTogXCJfdHJ5bG9hZEJyb2tlblVybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJ5bG9hZEJyb2tlblVybCh1cmwsIGJyb2tlblVybCwgaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbikge1xuICAgICAgLy9JZiB0aGVzZSBwYXJhbWV0ZXJzIGFyZW4ndCBzcGVjaWZpZWQgdGhlbiBleGl0IHRoZSBmdW5jdGlvbiBiZWNhdXNlIG5vdGhpbmcgY29uc3RydWN0aXZlIGNhbiBiZSBkb25lXG4gICAgICBpZiAodXJsID09PSB1bmRlZmluZWQgfHwgaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbiA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgIGlmIChicm9rZW5VcmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJObyBicm9rZW4gdXJsIGltYWdlIGRlZmluZWRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy9DbGVhciB0aGUgb2xkIHN1YnNjcmlwdGlvbiB0byB0aGUgZXJyb3IgZXZlbnQgYW5kIHB1dCBhIG5ldyBpbiBwbGFjZSB0aGF0IG9ubHkgaGFuZGxlIGVycm9ycyBpbiBsb2FkaW5nIHRoZSBicm9rZW5JbWFnZVVybFxuXG5cbiAgICAgIGltYWdlVG9Mb2FkQnJva2VuVXJsT24uaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBsb2FkIGJyb2tlbkltYWdlOlwiLCBicm9rZW5VcmwpOyAvLyBjYWNoZSBpdGVtIHdpbGwgY29udGFpbiBlbXB0eSBpbWFnZSwgdGhpcyBzaG91bGQgYmUgT0sgZm9yIGRlZmF1bHRcbiAgICAgIH07IC8vU2V0IHRoZSBzb3VyY2Ugb2YgdGhlIGltYWdlIHRvIHRoZSBicm9rZW5VcmwsIHRoaXMgaXMgYWN0dWFsbHkgd2hhdCBraWNrcyBvZmYgdGhlIGxvYWRpbmcgb2YgdGhlIGJyb2tlbiBpbWFnZVxuXG5cbiAgICAgIGltYWdlVG9Mb2FkQnJva2VuVXJsT24uaW1hZ2Uuc3JjID0gYnJva2VuVXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkltYWdlfSBpbWFnZVRvUmVkcmF3V2l0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVkcmF3V2l0aEltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWRyYXdXaXRoSW1hZ2UoaW1hZ2VUb1JlZHJhd1dpdGgpIHtcbiAgICAgIGlmICh0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soaW1hZ2VUb1JlZHJhd1dpdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsICAgICAgICAgIFVybCBvZiB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnJva2VuVXJsICAgIFVybCBvZiBhbiBpbWFnZSB0byB1c2UgaWYgdGhlIHVybCBpbWFnZSBpcyBub3QgZm91bmRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2V9IGltZyAgICAgICAgICBUaGUgaW1hZ2Ugb2JqZWN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQodXJsLCBicm9rZW5VcmwpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vVHJ5IGFuZCBnZXQgdGhlIGltYWdlIGZyb20gdGhlIGNhY2hlLCBpZiBzdWNjZXNzZnVsIHRoZW4gcmV0dXJuIHRoZSBjYWNoZWQgaW1hZ2VcbiAgICAgIHZhciBjYWNoZWRJbWFnZSA9IHRoaXMuaW1hZ2VzW3VybF07XG4gICAgICBpZiAoY2FjaGVkSW1hZ2UpIHJldHVybiBjYWNoZWRJbWFnZTsgLy9DcmVhdGUgYSBuZXcgaW1hZ2VcblxuICAgICAgdmFyIGltZyA9IG5ldyBDYWNoZWRJbWFnZSgpOyAvLyBOZWVkIHRvIGFkZCB0byBjYWNoZSBoZXJlLCBvdGhlcndpc2UgZmluYWwgcmV0dXJuIHdpbGwgc3Bhd24gZGlmZmVyZW50IGNvcGllcyBvZiB0aGUgc2FtZSBpbWFnZSxcbiAgICAgIC8vIEFsc28sIHRoZXJlIHdpbGwgYmUgbXVsdGlwbGUgbG9hZHMgb2YgdGhlIHNhbWUgaW1hZ2UuXG5cbiAgICAgIHRoaXMuaW1hZ2VzW3VybF0gPSBpbWc7IC8vU3Vic2NyaWJlIHRvIHRoZSBldmVudCB0aGF0IGlzIHJhaXNlZCBpZiB0aGUgaW1hZ2UgbG9hZHMgc3VjY2Vzc2Z1bGx5XG5cbiAgICAgIGltZy5pbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFByb3Blcmx5IGluaXQgdGhlIGNhY2hlZCBpdGVtIGFuZCB0aGVuIHJlcXVlc3QgYSByZWRyYXdcbiAgICAgICAgX3RoaXMuX2ZpeEltYWdlQ29vcmRpbmF0ZXMoaW1nLmltYWdlKTtcblxuICAgICAgICBpbWcuaW5pdCgpO1xuXG4gICAgICAgIF90aGlzLl9yZWRyYXdXaXRoSW1hZ2UoaW1nKTtcbiAgICAgIH07IC8vU3Vic2NyaWJlIHRvIHRoZSBldmVudCB0aGF0IGlzIHJhaXNlZCBpZiB0aGUgaW1hZ2UgZmFpbHMgdG8gbG9hZFxuXG5cbiAgICAgIGltZy5pbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGxvYWQgaW1hZ2U6XCIsIHVybCk7IC8vVHJ5IGFuZCBsb2FkIHRoZSBpbWFnZSBzcGVjaWZpZWQgYnkgdGhlIGJyb2tlblVybCB1c2luZ1xuXG4gICAgICAgIF90aGlzLl90cnlsb2FkQnJva2VuVXJsKHVybCwgYnJva2VuVXJsLCBpbWcpO1xuICAgICAgfTsgLy9TZXQgdGhlIHNvdXJjZSBvZiB0aGUgaW1hZ2UgdG8gdGhlIHVybCwgdGhpcyBpcyB3aGF0IGFjdHVhbGx5IGtpY2tzIG9mZiB0aGUgbG9hZGluZyBvZiB0aGUgaW1hZ2VcblxuXG4gICAgICBpbWcuaW1hZ2Uuc3JjID0gdXJsOyAvL1JldHVybiB0aGUgbmV3IGltYWdlXG5cbiAgICAgIHJldHVybiBpbWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElFMTEgZml4IC0tIHRoYW5rcyBkcG9uY2ghXG4gICAgICpcbiAgICAgKiBMb2NhbCBoZWxwZXIgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkltYWdlfSBpbWFnZVRvQ2FjaGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpeEltYWdlQ29vcmRpbmF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeEltYWdlQ29vcmRpbmF0ZXMoaW1hZ2VUb0NhY2hlKSB7XG4gICAgICBpZiAoaW1hZ2VUb0NhY2hlLndpZHRoID09PSAwKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW1hZ2VUb0NhY2hlKTtcbiAgICAgICAgaW1hZ2VUb0NhY2hlLndpZHRoID0gaW1hZ2VUb0NhY2hlLm9mZnNldFdpZHRoO1xuICAgICAgICBpbWFnZVRvQ2FjaGUuaGVpZ2h0ID0gaW1hZ2VUb0NhY2hlLm9mZnNldEhlaWdodDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpbWFnZVRvQ2FjaGUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbWFnZXM7XG59KCk7XG5cbnZhciBpbnRlcm5hbE1ldGFkYXRhID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGZhaWxzJDcgPSBmYWlscyR0O1xudmFyIGFycmF5QnVmZmVyTm9uRXh0ZW5zaWJsZSA9IGZhaWxzJDcoZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSwgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcblxuICAgIGlmIChPYmplY3QuaXNFeHRlbnNpYmxlKGJ1ZmZlcikpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShidWZmZXIsICdhJywge1xuICAgICAgdmFsdWU6IDhcbiAgICB9KTtcbiAgfVxufSk7XG5cbnZhciBmYWlscyQ2ID0gZmFpbHMkdDtcbnZhciBpc09iamVjdCQ2ID0gaXNPYmplY3QkajtcbnZhciBjbGFzc29mJDQgPSBjbGFzc29mUmF3JDE7XG52YXIgQVJSQVlfQlVGRkVSX05PTl9FWFRFTlNJQkxFID0gYXJyYXlCdWZmZXJOb25FeHRlbnNpYmxlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSAtLSBzYWZlXG5cbnZhciAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTJDEgPSBmYWlscyQ2KGZ1bmN0aW9uICgpIHtcbiAgJGlzRXh0ZW5zaWJsZSgxKTtcbn0pOyAvLyBgT2JqZWN0LmlzRXh0ZW5zaWJsZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5pc2V4dGVuc2libGVcblxudmFyIG9iamVjdElzRXh0ZW5zaWJsZSA9IEZBSUxTX09OX1BSSU1JVElWRVMkMSB8fCBBUlJBWV9CVUZGRVJfTk9OX0VYVEVOU0lCTEUgPyBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpIHtcbiAgaWYgKCFpc09iamVjdCQ2KGl0KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoQVJSQVlfQlVGRkVSX05PTl9FWFRFTlNJQkxFICYmIGNsYXNzb2YkNChpdCkgPT0gJ0FycmF5QnVmZmVyJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZTtcbn0gOiAkaXNFeHRlbnNpYmxlO1xuXG52YXIgZmFpbHMkNSA9IGZhaWxzJHQ7XG52YXIgZnJlZXppbmcgPSAhZmFpbHMkNShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaXNleHRlbnNpYmxlLCBlcy9uby1vYmplY3QtcHJldmVudGV4dGVuc2lvbnMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcblxudmFyICQkZSA9IF9leHBvcnQ7XG52YXIgdW5jdXJyeVRoaXMkNCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGlkZGVuS2V5cyA9IGhpZGRlbktleXMkNjtcbnZhciBpc09iamVjdCQ1ID0gaXNPYmplY3QkajtcbnZhciBoYXNPd24kNSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgZGVmaW5lUHJvcGVydHkkMiA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsO1xudmFyIGlzRXh0ZW5zaWJsZSQxID0gb2JqZWN0SXNFeHRlbnNpYmxlO1xudmFyIHVpZCA9IHVpZCQ0O1xudmFyIEZSRUVaSU5HID0gZnJlZXppbmc7XG52YXIgUkVRVUlSRUQgPSBmYWxzZTtcbnZhciBNRVRBREFUQSA9IHVpZCgnbWV0YScpO1xudmFyIGlkJDEgPSAwO1xuXG52YXIgc2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgZGVmaW5lUHJvcGVydHkkMihpdCwgTUVUQURBVEEsIHtcbiAgICB2YWx1ZToge1xuICAgICAgb2JqZWN0SUQ6ICdPJyArIGlkJDErKyxcbiAgICAgIC8vIG9iamVjdCBJRFxuICAgICAgd2Vha0RhdGE6IHt9IC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG5cbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGZhc3RLZXkkMSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBhIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0JDUoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuXG4gIGlmICghaGFzT3duJDUoaXQsIE1FVEFEQVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUkMShpdCkpIHJldHVybiAnRic7IC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG5cbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJzsgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcblxuICAgIHNldE1ldGFkYXRhKGl0KTsgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9XG5cbiAgcmV0dXJuIGl0W01FVEFEQVRBXS5vYmplY3RJRDtcbn07XG5cbnZhciBnZXRXZWFrRGF0YSQxID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXNPd24kNShpdCwgTUVUQURBVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZSQxKGl0KSkgcmV0dXJuIHRydWU7IC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG5cbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlOyAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuXG4gICAgc2V0TWV0YWRhdGEoaXQpOyAvLyByZXR1cm4gdGhlIHN0b3JlIG9mIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH1cblxuICByZXR1cm4gaXRbTUVUQURBVEFdLndlYWtEYXRhO1xufTsgLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG5cblxudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWklORyAmJiBSRVFVSVJFRCAmJiBpc0V4dGVuc2libGUkMShpdCkgJiYgIWhhc093biQ1KGl0LCBNRVRBREFUQSkpIHNldE1ldGFkYXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxudmFyIGVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgbWV0YS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfTtcblxuICBSRVFVSVJFRCA9IHRydWU7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mO1xuICB2YXIgc3BsaWNlID0gdW5jdXJyeVRoaXMkNChbXS5zcGxpY2UpO1xuICB2YXIgdGVzdCA9IHt9O1xuICB0ZXN0W01FVEFEQVRBXSA9IDE7IC8vIHByZXZlbnQgZXhwb3Npbmcgb2YgbWV0YWRhdGEga2V5XG5cbiAgaWYgKGdldE93blByb3BlcnR5TmFtZXModGVzdCkubGVuZ3RoKSB7XG4gICAgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlc3VsdFtpXSA9PT0gTUVUQURBVEEpIHtcbiAgICAgICAgICBzcGxpY2UocmVzdWx0LCBpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAkJGUoe1xuICAgICAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgICAgIHN0YXQ6IHRydWUsXG4gICAgICBmb3JjZWQ6IHRydWVcbiAgICB9LCB7XG4gICAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWxNb2R1bGUuZlxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgbWV0YSA9IGludGVybmFsTWV0YWRhdGEuZXhwb3J0cyA9IHtcbiAgZW5hYmxlOiBlbmFibGUsXG4gIGZhc3RLZXk6IGZhc3RLZXkkMSxcbiAgZ2V0V2Vha0RhdGE6IGdldFdlYWtEYXRhJDEsXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbmhpZGRlbktleXNbTUVUQURBVEFdID0gdHJ1ZTtcblxudmFyIGdsb2JhbCRhID0gZ2xvYmFsJFA7XG52YXIgYmluZCQzID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjYWxsJDEgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkMyA9IGFuT2JqZWN0JGQ7XG52YXIgdHJ5VG9TdHJpbmckMSA9IHRyeVRvU3RyaW5nJDQ7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDI7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNCA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG52YXIgaXNQcm90b3R5cGVPZiQ5ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBnZXRJdGVyYXRvciQ1ID0gZ2V0SXRlcmF0b3IkNztcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kJDg7XG52YXIgaXRlcmF0b3JDbG9zZSA9IGl0ZXJhdG9yQ2xvc2UkMjtcbnZhciBUeXBlRXJyb3IkNSA9IGdsb2JhbCRhLlR5cGVFcnJvcjtcblxudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcbiAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuXG52YXIgUmVzdWx0UHJvdG90eXBlID0gUmVzdWx0LnByb3RvdHlwZTtcblxudmFyIGl0ZXJhdGUkMyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgdW5ib3VuZEZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRoYXQ7XG4gIHZhciBBU19FTlRSSUVTID0gISEob3B0aW9ucyAmJiBvcHRpb25zLkFTX0VOVFJJRVMpO1xuICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuICB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xuICB2YXIgZm4gPSBiaW5kJDModW5ib3VuZEZ1bmN0aW9uLCB0aGF0KTtcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcblxuICB2YXIgc3RvcCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICBpZiAoaXRlcmF0b3IpIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICdub3JtYWwnLCBjb25kaXRpb24pO1xuICAgIHJldHVybiBuZXcgUmVzdWx0KHRydWUsIGNvbmRpdGlvbik7XG4gIH07XG5cbiAgdmFyIGNhbGxGbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChBU19FTlRSSUVTKSB7XG4gICAgICBhbk9iamVjdCQzKHZhbHVlKTtcbiAgICAgIHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSwgc3RvcCkgOiBmbih2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgIH1cblxuICAgIHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgfTtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgICBpZiAoIWl0ZXJGbikgdGhyb3cgVHlwZUVycm9yJDUodHJ5VG9TdHJpbmckMShpdGVyYWJsZSkgKyAnIGlzIG5vdCBpdGVyYWJsZScpOyAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNChpdGVyYWJsZSk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0ICYmIGlzUHJvdG90eXBlT2YkOShSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbiAgICB9XG5cbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yJDUoaXRlcmFibGUsIGl0ZXJGbik7XG4gIH1cblxuICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcblxuICB3aGlsZSAoIShzdGVwID0gY2FsbCQxKG5leHQsIGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBjYWxsRm4oc3RlcC52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQ5KFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG5cbnZhciBnbG9iYWwkOSA9IGdsb2JhbCRQO1xudmFyIGlzUHJvdG90eXBlT2YkOCA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgVHlwZUVycm9yJDQgPSBnbG9iYWwkOS5UeXBlRXJyb3I7XG5cbnZhciBhbkluc3RhbmNlJDMgPSBmdW5jdGlvbiAoaXQsIFByb3RvdHlwZSkge1xuICBpZiAoaXNQcm90b3R5cGVPZiQ4KFByb3RvdHlwZSwgaXQpKSByZXR1cm4gaXQ7XG4gIHRocm93IFR5cGVFcnJvciQ0KCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xufTtcblxudmFyICQkZCA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJDggPSBnbG9iYWwkUDtcbnZhciBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlJDEgPSBpbnRlcm5hbE1ldGFkYXRhLmV4cG9ydHM7XG52YXIgZmFpbHMkNCA9IGZhaWxzJHQ7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG52YXIgaXRlcmF0ZSQyID0gaXRlcmF0ZSQzO1xudmFyIGFuSW5zdGFuY2UkMiA9IGFuSW5zdGFuY2UkMztcbnZhciBpc0NhbGxhYmxlID0gaXNDYWxsYWJsZSRoO1xudmFyIGlzT2JqZWN0JDQgPSBpc09iamVjdCRqO1xudmFyIHNldFRvU3RyaW5nVGFnID0gc2V0VG9TdHJpbmdUYWckNTtcbnZhciBkZWZpbmVQcm9wZXJ0eSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBmb3JFYWNoID0gYXJyYXlJdGVyYXRpb24uZm9yRWFjaDtcbnZhciBERVNDUklQVE9SUyQyID0gZGVzY3JpcHRvcnM7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQyID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDIuc2V0O1xudmFyIGludGVybmFsU3RhdGVHZXR0ZXJGb3IkMiA9IEludGVybmFsU3RhdGVNb2R1bGUkMi5nZXR0ZXJGb3I7XG5cbnZhciBjb2xsZWN0aW9uJDMgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSwgd3JhcHBlciwgY29tbW9uKSB7XG4gIHZhciBJU19NQVAgPSBDT05TVFJVQ1RPUl9OQU1FLmluZGV4T2YoJ01hcCcpICE9PSAtMTtcbiAgdmFyIElTX1dFQUsgPSBDT05TVFJVQ1RPUl9OQU1FLmluZGV4T2YoJ1dlYWsnKSAhPT0gLTE7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBOYXRpdmVDb25zdHJ1Y3RvciA9IGdsb2JhbCQ4W0NPTlNUUlVDVE9SX05BTUVdO1xuICB2YXIgTmF0aXZlUHJvdG90eXBlID0gTmF0aXZlQ29uc3RydWN0b3IgJiYgTmF0aXZlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICB2YXIgZXhwb3J0ZWQgPSB7fTtcbiAgdmFyIENvbnN0cnVjdG9yO1xuXG4gIGlmICghREVTQ1JJUFRPUlMkMiB8fCAhaXNDYWxsYWJsZShOYXRpdmVDb25zdHJ1Y3RvcikgfHwgIShJU19XRUFLIHx8IE5hdGl2ZVByb3RvdHlwZS5mb3JFYWNoICYmICFmYWlscyQ0KGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgTmF0aXZlQ29uc3RydWN0b3IoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIENvbnN0cnVjdG9yID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpO1xuICAgIEludGVybmFsTWV0YWRhdGFNb2R1bGUkMS5lbmFibGUoKTtcbiAgfSBlbHNlIHtcbiAgICBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKHRhcmdldCwgaXRlcmFibGUpIHtcbiAgICAgIHNldEludGVybmFsU3RhdGUkMihhbkluc3RhbmNlJDIodGFyZ2V0LCBQcm90b3R5cGUpLCB7XG4gICAgICAgIHR5cGU6IENPTlNUUlVDVE9SX05BTUUsXG4gICAgICAgIGNvbGxlY3Rpb246IG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpXG4gICAgICB9KTtcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGUkMihpdGVyYWJsZSwgdGFyZ2V0W0FEREVSXSwge1xuICAgICAgICB0aGF0OiB0YXJnZXQsXG4gICAgICAgIEFTX0VOVFJJRVM6IElTX01BUFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIFByb3RvdHlwZSA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IkMihDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICBmb3JFYWNoKFsnYWRkJywgJ2NsZWFyJywgJ2RlbGV0ZScsICdmb3JFYWNoJywgJ2dldCcsICdoYXMnLCAnc2V0JywgJ2tleXMnLCAndmFsdWVzJywgJ2VudHJpZXMnXSwgZnVuY3Rpb24gKEtFWSkge1xuICAgICAgdmFyIElTX0FEREVSID0gS0VZID09ICdhZGQnIHx8IEtFWSA9PSAnc2V0JztcblxuICAgICAgaWYgKEtFWSBpbiBOYXRpdmVQcm90b3R5cGUgJiYgIShJU19XRUFLICYmIEtFWSA9PSAnY2xlYXInKSkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoUHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmNvbGxlY3Rpb247XG4gICAgICAgICAgaWYgKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdCQ0KGEpKSByZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbGxlY3Rpb25bS0VZXShhID09PSAwID8gMCA6IGEsIGIpO1xuICAgICAgICAgIHJldHVybiBJU19BRERFUiA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIElTX1dFQUsgfHwgZGVmaW5lUHJvcGVydHkkMShQcm90b3R5cGUsICdzaXplJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmNvbGxlY3Rpb24uc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBmYWxzZSwgdHJ1ZSk7XG4gIGV4cG9ydGVkW0NPTlNUUlVDVE9SX05BTUVdID0gQ29uc3RydWN0b3I7XG4gICQkZCh7XG4gICAgZ2xvYmFsOiB0cnVlLFxuICAgIGZvcmNlZDogdHJ1ZVxuICB9LCBleHBvcnRlZCk7XG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufTtcblxudmFyIHJlZGVmaW5lID0gcmVkZWZpbmUkNDtcblxudmFyIHJlZGVmaW5lQWxsJDMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudW5zYWZlICYmIHRhcmdldFtrZXldKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO2Vsc2UgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQxID0gZ2V0QnVpbHRJbiQ5O1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgREVTQ1JJUFRPUlMkMSA9IGRlc2NyaXB0b3JzO1xudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxudmFyIHNldFNwZWNpZXMkMSA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4kMShDT05TVFJVQ1RPUl9OQU1FKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcblxuICBpZiAoREVTQ1JJUFRPUlMkMSAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFU10pIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgU1BFQ0lFUywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGNyZWF0ZSQ0ID0gb2JqZWN0Q3JlYXRlO1xudmFyIHJlZGVmaW5lQWxsJDIgPSByZWRlZmluZUFsbCQzO1xudmFyIGJpbmQkMiA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgYW5JbnN0YW5jZSQxID0gYW5JbnN0YW5jZSQzO1xudmFyIGl0ZXJhdGUkMSA9IGl0ZXJhdGUkMztcbnZhciBkZWZpbmVJdGVyYXRvciA9IGRlZmluZUl0ZXJhdG9yJDM7XG52YXIgc2V0U3BlY2llcyA9IHNldFNwZWNpZXMkMTtcbnZhciBERVNDUklQVE9SUyA9IGRlc2NyaXB0b3JzO1xudmFyIGZhc3RLZXkgPSBpbnRlcm5hbE1ldGFkYXRhLmV4cG9ydHMuZmFzdEtleTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDEgPSBpbnRlcm5hbFN0YXRlO1xudmFyIHNldEludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLmdldHRlckZvcjtcbnZhciBjb2xsZWN0aW9uU3Ryb25nJDIgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlJDEodGhhdCwgUHJvdG90eXBlKTtcbiAgICAgIHNldEludGVybmFsU3RhdGUkMSh0aGF0LCB7XG4gICAgICAgIHR5cGU6IENPTlNUUlVDVE9SX05BTUUsXG4gICAgICAgIGluZGV4OiBjcmVhdGUkNChudWxsKSxcbiAgICAgICAgZmlyc3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgbGFzdDogdW5kZWZpbmVkLFxuICAgICAgICBzaXplOiAwXG4gICAgICB9KTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMpIHRoYXQuc2l6ZSA9IDA7XG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlJDEoaXRlcmFibGUsIHRoYXRbQURERVJdLCB7XG4gICAgICAgIHRoYXQ6IHRoYXQsXG4gICAgICAgIEFTX0VOVFJJRVM6IElTX01BUFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIFByb3RvdHlwZSA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IkMShDT05TVFJVQ1RPUl9OQU1FKTtcblxuICAgIHZhciBkZWZpbmUgPSBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICB2YXIgcHJldmlvdXMsIGluZGV4OyAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcblxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIGVudHJ5LnZhbHVlID0gdmFsdWU7IC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmxhc3QgPSBlbnRyeSA9IHtcbiAgICAgICAgICBpbmRleDogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksXG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHByZXZpb3VzOiBwcmV2aW91cyA9IHN0YXRlLmxhc3QsXG4gICAgICAgICAgbmV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgIHJlbW92ZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmICghc3RhdGUuZmlyc3QpIHN0YXRlLmZpcnN0ID0gZW50cnk7XG4gICAgICAgIGlmIChwcmV2aW91cykgcHJldmlvdXMubmV4dCA9IGVudHJ5O1xuICAgICAgICBpZiAoREVTQ1JJUFRPUlMpIHN0YXRlLnNpemUrKztlbHNlIHRoYXQuc2l6ZSsrOyAvLyBhZGQgdG8gaW5kZXhcblxuICAgICAgICBpZiAoaW5kZXggIT09ICdGJykgc3RhdGUuaW5kZXhbaW5kZXhdID0gZW50cnk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpOyAvLyBmYXN0IGNhc2VcblxuICAgICAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICAgICAgdmFyIGVudHJ5O1xuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiBzdGF0ZS5pbmRleFtpbmRleF07IC8vIGZyb3plbiBvYmplY3QgY2FzZVxuXG4gICAgICBmb3IgKGVudHJ5ID0gc3RhdGUuZmlyc3Q7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm5leHQpIHtcbiAgICAgICAgaWYgKGVudHJ5LmtleSA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVkZWZpbmVBbGwkMihQcm90b3R5cGUsIHtcbiAgICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLmNsZWFyKClgIG1ldGhvZHNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5jbGVhclxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmNsZWFyXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgICAgdmFyIGRhdGEgPSBzdGF0ZS5pbmRleDtcbiAgICAgICAgdmFyIGVudHJ5ID0gc3RhdGUuZmlyc3Q7XG5cbiAgICAgICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICAgICAgZW50cnkucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnByZXZpb3VzKSBlbnRyeS5wcmV2aW91cyA9IGVudHJ5LnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaW5kZXhdO1xuICAgICAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmZpcnN0ID0gc3RhdGUubGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplID0gMDtlbHNlIHRoYXQuc2l6ZSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUuZGVsZXRlKGtleSlgIG1ldGhvZHNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5kZWxldGVcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5kZWxldGVcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcblxuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5leHQ7XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgICAgICBkZWxldGUgc3RhdGUuaW5kZXhbZW50cnkuaW5kZXhdO1xuICAgICAgICAgIGVudHJ5LnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnByZXZpb3VzID0gcHJldjtcbiAgICAgICAgICBpZiAoc3RhdGUuZmlyc3QgPT0gZW50cnkpIHN0YXRlLmZpcnN0ID0gbmV4dDtcbiAgICAgICAgICBpZiAoc3RhdGUubGFzdCA9PSBlbnRyeSkgc3RhdGUubGFzdCA9IHByZXY7XG4gICAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplLS07ZWxzZSB0aGF0LnNpemUtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClgIG1ldGhvZHNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5mb3JlYWNoXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZm9yZWFjaFxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuXG4gICAgICAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi9cbiAgICAgICkge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQkMihjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHZhciBlbnRyeTtcblxuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5maXJzdCkge1xuICAgICAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7IC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuXG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBgeyBNYXAsIFNldH0ucHJvdG90eXBlLmhhcyhrZXkpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuaGFzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuaGFzXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZWRlZmluZUFsbCQyKFByb3RvdHlwZSwgSVNfTUFQID8ge1xuICAgICAgLy8gYE1hcC5wcm90b3R5cGUuZ2V0KGtleSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmdldFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52YWx1ZTtcbiAgICAgIH0sXG4gICAgICAvLyBgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLnNldFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgLy8gYFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuYWRkXG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KFByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH0sXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApIHtcbiAgICB2YXIgSVRFUkFUT1JfTkFNRSA9IENPTlNUUlVDVE9SX05BTUUgKyAnIEl0ZXJhdG9yJztcbiAgICB2YXIgZ2V0SW50ZXJuYWxDb2xsZWN0aW9uU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yJDEoQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgdmFyIGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IkMShJVEVSQVRPUl9OQU1FKTsgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUueyBrZXlzLCB2YWx1ZXMsIGVudHJpZXMsIEBAaXRlcmF0b3IgfSgpYCBtZXRob2RzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmVudHJpZXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUua2V5c1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS52YWx1ZXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUtQEBpdGVyYXRvclxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5lbnRyaWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmtleXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUudmFsdWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLUBAaXRlcmF0b3JcblxuICAgIGRlZmluZUl0ZXJhdG9yKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHNldEludGVybmFsU3RhdGUkMSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IElURVJBVE9SX05BTUUsXG4gICAgICAgIHRhcmdldDogaXRlcmF0ZWQsXG4gICAgICAgIHN0YXRlOiBnZXRJbnRlcm5hbENvbGxlY3Rpb25TdGF0ZShpdGVyYXRlZCksXG4gICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgIGxhc3Q6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlKHRoaXMpO1xuICAgICAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICAgICAgdmFyIGVudHJ5ID0gc3RhdGUubGFzdDsgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG5cbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yZW1vdmVkKSBlbnRyeSA9IGVudHJ5LnByZXZpb3VzOyAvLyBnZXQgbmV4dCBlbnRyeVxuXG5cbiAgICAgIGlmICghc3RhdGUudGFyZ2V0IHx8ICEoc3RhdGUubGFzdCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uZXh0IDogc3RhdGUuc3RhdGUuZmlyc3QpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuXG5cbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGVudHJ5LmtleSxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBbZW50cnkua2V5LCBlbnRyeS52YWx1ZV0sXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTsgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGVbQEBzcGVjaWVzXWAgYWNjZXNzb3JzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtbWFwLUBAc3BlY2llc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LXNldC1AQHNwZWNpZXNcblxuICAgIHNldFNwZWNpZXMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIH1cbn07XG5cbnZhciBjb2xsZWN0aW9uJDIgPSBjb2xsZWN0aW9uJDM7XG52YXIgY29sbGVjdGlvblN0cm9uZyQxID0gY29sbGVjdGlvblN0cm9uZyQyOyAvLyBgTWFwYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAtb2JqZWN0c1xuXG5jb2xsZWN0aW9uJDIoJ01hcCcsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59LCBjb2xsZWN0aW9uU3Ryb25nJDEpO1xuXG52YXIgcGF0aCRiID0gcGF0aCR5O1xudmFyIG1hcCQyID0gcGF0aCRiLk1hcDtcblxudmFyIHBhcmVudCR2ID0gbWFwJDI7XG52YXIgbWFwJDEgPSBwYXJlbnQkdjtcblxudmFyIG1hcCA9IG1hcCQxO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgY2FuIHN0b3JlIGdyb3VwcyBhbmQgb3B0aW9ucyBzcGVjaWZpYyBmb3IgZ3JvdXBzLlxuICovXG52YXIgR3JvdXBzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIEdyb3VwcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JvdXBzKTtcblxuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLl9kZWZhdWx0SW5kZXggPSAwO1xuICAgIHRoaXMuX2dyb3VwSW5kZXggPSAwO1xuICAgIHRoaXMuX2RlZmF1bHRHcm91cHMgPSBbe1xuICAgICAgYm9yZGVyOiBcIiMyQjdDRTlcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzk3QzJGQ1wiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjMkI3Q0U5XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0QyRTVGRlwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiMyQjdDRTlcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRDJFNUZGXCJcbiAgICAgIH1cbiAgICB9LCAvLyAwOiBibHVlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNGRkE1MDBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0ZGRkYwMFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkZBNTAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGRkZBM1wiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRkE1MDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZGRkEzXCJcbiAgICAgIH1cbiAgICB9LCAvLyAxOiB5ZWxsb3dcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0ZBMEExMFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkI3RTgxXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGQTBBMTBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZBRkIxXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0ZBMEExMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkFGQjFcIlxuICAgICAgfVxuICAgIH0sIC8vIDI6IHJlZFxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjNDFBOTA2XCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiM3QkUxNDFcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiIzQxQTkwNlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNBMUVDNzZcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjNDFBOTA2XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ExRUM3NlwiXG4gICAgICB9XG4gICAgfSwgLy8gMzogZ3JlZW5cbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0UxMjlGMFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRUI3REY0XCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNFMTI5RjBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRjBCM0Y1XCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0UxMjlGMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGMEIzRjVcIlxuICAgICAgfVxuICAgIH0sIC8vIDQ6IG1hZ2VudGFcbiAgICB7XG4gICAgICBib3JkZXI6IFwiIzdDMjlGMFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjQUQ4NUU0XCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM3QzI5RjBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRDNCREYwXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiIzdDMjlGMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNEM0JERjBcIlxuICAgICAgfVxuICAgIH0sIC8vIDU6IHB1cnBsZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjQzM3RjAwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNGRkE4MDdcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0MzN0YwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkNBNjZcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjQzM3RjAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGQ0E2NlwiXG4gICAgICB9XG4gICAgfSwgLy8gNjogb3JhbmdlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM0MjIwRkJcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzZFNkVGRFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjNDIyMEZCXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzlCOUJGRFwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM0MjIwRkJcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjOUI5QkZEXCJcbiAgICAgIH1cbiAgICB9LCAvLyA3OiBkYXJrYmx1ZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRkQ1QTc3XCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNGRkMwQ0JcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0ZENUE3N1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkQxRDlcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkQ1QTc3XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGRDFEOVwiXG4gICAgICB9XG4gICAgfSwgLy8gODogcGlua1xuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjNEFENjNBXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNDMkZBQkNcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiIzRBRDYzQVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNFNkZGRTNcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjNEFENjNBXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0U2RkZFM1wiXG4gICAgICB9XG4gICAgfSwgLy8gOTogbWludFxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjOTkwMDAwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNFRTAwMDBcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0JCMDAwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRjMzMzNcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjQkIwMDAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGMzMzM1wiXG4gICAgICB9XG4gICAgfSwgLy8gMTA6YnJpZ2h0IHJlZFxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRkY2MDAwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNGRjYwMDBcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGNjAwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRjYwMDBcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkY2MDAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGNjAwMFwiXG4gICAgICB9XG4gICAgfSwgLy8gMTI6IHJlYWwgb3JhbmdlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM5N0MyRkNcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzJCN0NFOVwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRDJFNUZGXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzJCN0NFOVwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNEMkU1RkZcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMkI3Q0U5XCJcbiAgICAgIH1cbiAgICB9LCAvLyAxMzogYmx1ZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjMzk5NjA1XCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiMyNTVDMDNcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiIzM5OTYwNVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyNTVDMDNcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjMzk5NjA1XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzI1NUMwM1wiXG4gICAgICB9XG4gICAgfSwgLy8gMTQ6IGdyZWVuXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNCNzAwNTRcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0ZGMDA3RVwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjQjcwMDU0XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGMDA3RVwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNCNzAwNTRcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkYwMDdFXCJcbiAgICAgIH1cbiAgICB9LCAvLyAxNTogbWFnZW50YVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjQUQ4NUU0XCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiM3QzI5RjBcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0QzQkRGMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM3QzI5RjBcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRDNCREYwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzdDMjlGMFwiXG4gICAgICB9XG4gICAgfSwgLy8gMTY6IHB1cnBsZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjNDU1N0ZBXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiMwMDBFQTFcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiIzZFNkVGRFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMwMDBFQTFcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjNkU2RUZEXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzAwMEVBMVwiXG4gICAgICB9XG4gICAgfSwgLy8gMTc6IGRhcmtibHVlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNGRkMwQ0JcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0ZENUE3N1wiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkZEMUQ5XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZENUE3N1wiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRkQxRDlcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkQ1QTc3XCJcbiAgICAgIH1cbiAgICB9LCAvLyAxODogcGlua1xuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjQzJGQUJDXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiM3NEQ2NkFcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0U2RkZFM1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM3NEQ2NkFcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRTZGRkUzXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzc0RDY2QVwiXG4gICAgICB9XG4gICAgfSwgLy8gMTk6IG1pbnRcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0VFMDAwMFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjOTkwMDAwXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRjMzMzNcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjQkIwMDAwXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGMzMzM1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNCQjAwMDBcIlxuICAgICAgfVxuICAgIH0gLy8gMjA6YnJpZ2h0IHJlZFxuICAgIF07XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHVzZURlZmF1bHRHcm91cHM6IHRydWVcbiAgICB9O1xuXG4gICAgYXNzaWduJDIodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoR3JvdXBzLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIG9wdGlvbkZpZWxkcyA9IFtcInVzZURlZmF1bHRHcm91cHNcIl07XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgZ3JvdXBOYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGdyb3VwTmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChpbmRleE9mKG9wdGlvbkZpZWxkcykuY2FsbChvcHRpb25GaWVsZHMsIGdyb3VwTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHZhciBncm91cCA9IG9wdGlvbnNbZ3JvdXBOYW1lXTtcbiAgICAgICAgICAgICAgdGhpcy5hZGQoZ3JvdXBOYW1lLCBncm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBncm91cHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5fZ3JvdXBzID0gbmV3IG1hcCgpO1xuICAgICAgdGhpcy5fZ3JvdXBOYW1lcyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZ3JvdXAgb3B0aW9ucyBvZiBhIGdyb3VwbmFtZS5cbiAgICAgKiBJZiBncm91cG5hbWUgaXMgbm90IGZvdW5kLCBhIG5ldyBncm91cCBtYXkgYmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gICAgICAgZ3JvdXBuYW1lICAgICBDYW4gYmUgYSBudW1iZXIsIHN0cmluZywgRGF0ZSwgZXRjLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Nob3VsZENyZWF0ZT10cnVlXSBJZiB0cnVlLCBjcmVhdGUgYSBuZXcgZ3JvdXBcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgZm91bmQgb3IgY3JlYXRlZCBncm91cFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChncm91cG5hbWUpIHtcbiAgICAgIHZhciBzaG91bGRDcmVhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIHZhciBncm91cCA9IHRoaXMuX2dyb3Vwcy5nZXQoZ3JvdXBuYW1lKTtcblxuICAgICAgaWYgKGdyb3VwID09PSB1bmRlZmluZWQgJiYgc2hvdWxkQ3JlYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlRGVmYXVsdEdyb3VwcyA9PT0gZmFsc2UgJiYgdGhpcy5fZ3JvdXBOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gY3JlYXRlIG5ldyBncm91cFxuICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2dyb3VwSW5kZXggJSB0aGlzLl9ncm91cE5hbWVzLmxlbmd0aDtcbiAgICAgICAgICArK3RoaXMuX2dyb3VwSW5kZXg7XG4gICAgICAgICAgZ3JvdXAgPSB7fTtcbiAgICAgICAgICBncm91cC5jb2xvciA9IHRoaXMuX2dyb3Vwcy5nZXQodGhpcy5fZ3JvdXBOYW1lc1tpbmRleF0pO1xuXG4gICAgICAgICAgdGhpcy5fZ3JvdXBzLnNldChncm91cG5hbWUsIGdyb3VwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjcmVhdGUgbmV3IGdyb3VwXG4gICAgICAgICAgdmFyIF9pbmRleCA9IHRoaXMuX2RlZmF1bHRJbmRleCAlIHRoaXMuX2RlZmF1bHRHcm91cHMubGVuZ3RoO1xuXG4gICAgICAgICAgdGhpcy5fZGVmYXVsdEluZGV4Kys7XG4gICAgICAgICAgZ3JvdXAgPSB7fTtcbiAgICAgICAgICBncm91cC5jb2xvciA9IHRoaXMuX2RlZmF1bHRHcm91cHNbX2luZGV4XTtcblxuICAgICAgICAgIHRoaXMuX2dyb3Vwcy5zZXQoZ3JvdXBuYW1lLCBncm91cCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgY3VzdG9tIGdyb3VwIHN0eWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBncm91cCwgYSBuZXcgZ3JvdXAgd2lsbCBiZVxuICAgICAqIGNyZWF0ZWQgaWYgYSBncm91cCB3aXRoIHRoZSBzYW1lIG5hbWUgZG9lc24ndCBleGlzdCwgb3RoZXJ3aXNlIHRoZSBvbGRcbiAgICAgKiBncm91cHMgc3R5bGUgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGUgLSBBbiBvYmplY3QgY29udGFpbmluZyBib3JkZXJDb2xvciwgYmFja2dyb3VuZENvbG9yLFxuICAgICAqIGV0Yy5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgY3JlYXRlZCBncm91cCBvYmplY3QuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGdyb3VwTmFtZSwgc3R5bGUpIHtcbiAgICAgIC8vIE9ubHkgcHVzaCBncm91cCBuYW1lIG9uY2UgdG8gcHJldmVudCBkdXBsaWNhdGVzIHdoaWNoIHdvdWxkIGNvbnN1bWUgbW9yZVxuICAgICAgLy8gUkFNIGFuZCBhbHNvIHNrZXcgdGhlIGRpc3RyaWJ1dGlvbiB0b3dhcmRzIG1vcmUgb2Z0ZW4gdXBkYXRlZCBncm91cHMsXG4gICAgICAvLyBuZWl0aGVyIG9mIHdoaWNoIGlzIGRlc2lyYWJsZS5cbiAgICAgIGlmICghdGhpcy5fZ3JvdXBzLmhhcyhncm91cE5hbWUpKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwTmFtZXMucHVzaChncm91cE5hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ncm91cHMuc2V0KGdyb3VwTmFtZSwgc3R5bGUpO1xuXG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdyb3Vwcztcbn0oKTtcblxudmFyICQkYyA9IF9leHBvcnQ7IC8vIGBOdW1iZXIuaXNOYU5gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1udW1iZXIuaXNuYW5cblxuJCRjKHtcbiAgdGFyZ2V0OiAnTnVtYmVyJyxcbiAgc3RhdDogdHJ1ZVxufSwge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICByZXR1cm4gbnVtYmVyICE9IG51bWJlcjtcbiAgfVxufSk7XG5cbnZhciBwYXRoJGEgPSBwYXRoJHk7XG52YXIgaXNOYW4kMiA9IHBhdGgkYS5OdW1iZXIuaXNOYU47XG5cbnZhciBwYXJlbnQkdSA9IGlzTmFuJDI7XG52YXIgaXNOYW4kMSA9IHBhcmVudCR1O1xuXG52YXIgaXNOYW4gPSBpc05hbiQxO1xuXG52YXIgZ2xvYmFsJDcgPSBnbG9iYWwkUDtcbnZhciBnbG9iYWxJc0Zpbml0ZSA9IGdsb2JhbCQ3LmlzRmluaXRlOyAvLyBgTnVtYmVyLmlzRmluaXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbnVtYmVyLmlzZmluaXRlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tbnVtYmVyLWlzZmluaXRlIC0tIHNhZmVcblxudmFyIG51bWJlcklzRmluaXRlJDEgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBnbG9iYWxJc0Zpbml0ZShpdCk7XG59O1xuXG52YXIgJCRiID0gX2V4cG9ydDtcbnZhciBudW1iZXJJc0Zpbml0ZSA9IG51bWJlcklzRmluaXRlJDE7IC8vIGBOdW1iZXIuaXNGaW5pdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1udW1iZXIuaXNmaW5pdGVcblxuJCRiKHtcbiAgdGFyZ2V0OiAnTnVtYmVyJyxcbiAgc3RhdDogdHJ1ZVxufSwge1xuICBpc0Zpbml0ZTogbnVtYmVySXNGaW5pdGVcbn0pO1xuXG52YXIgcGF0aCQ5ID0gcGF0aCR5O1xudmFyIF9pc0Zpbml0ZSQyID0gcGF0aCQ5Lk51bWJlci5pc0Zpbml0ZTtcblxudmFyIHBhcmVudCR0ID0gX2lzRmluaXRlJDI7XG52YXIgX2lzRmluaXRlJDEgPSBwYXJlbnQkdDtcblxudmFyIF9pc0Zpbml0ZSA9IF9pc0Zpbml0ZSQxO1xuXG52YXIgJCRhID0gX2V4cG9ydDtcbnZhciAkc29tZSA9IGFycmF5SXRlcmF0aW9uLnNvbWU7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCQzID0gYXJyYXlNZXRob2RJc1N0cmljdCQ2O1xudmFyIFNUUklDVF9NRVRIT0QkMyA9IGFycmF5TWV0aG9kSXNTdHJpY3QkMygnc29tZScpOyAvLyBgQXJyYXkucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuXG4kJGEoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6ICFTVFJJQ1RfTUVUSE9EJDNcbn0sIHtcbiAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuXG4gIC8qICwgdGhpc0FyZyAqL1xuICApIHtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCQ3ID0gZW50cnlWaXJ0dWFsJGw7XG52YXIgc29tZSQzID0gZW50cnlWaXJ0dWFsJDcoJ0FycmF5Jykuc29tZTtcblxudmFyIGlzUHJvdG90eXBlT2YkNyA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDcgPSBzb21lJDM7XG52YXIgQXJyYXlQcm90b3R5cGUkNyA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHNvbWUkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuc29tZTtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ3IHx8IGlzUHJvdG90eXBlT2YkNyhBcnJheVByb3RvdHlwZSQ3LCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQ3LnNvbWUgPyBtZXRob2QkNyA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkcyA9IHNvbWUkMjtcbnZhciBzb21lJDEgPSBwYXJlbnQkcztcblxudmFyIHNvbWUgPSBzb21lJDE7XG5cbnZhciBnbG9iYWwkNiA9IGdsb2JhbCRQO1xudmFyIGlzQ29uc3RydWN0b3IgPSBpc0NvbnN0cnVjdG9yJDQ7XG52YXIgdHJ5VG9TdHJpbmcgPSB0cnlUb1N0cmluZyQ0O1xudmFyIFR5cGVFcnJvciQzID0gZ2xvYmFsJDYuVHlwZUVycm9yOyAvLyBgQXNzZXJ0OiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSBpcyB0cnVlYFxuXG52YXIgYUNvbnN0cnVjdG9yJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ29uc3RydWN0b3IoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93IFR5cGVFcnJvciQzKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbn07XG5cbnZhciAkJDkgPSBfZXhwb3J0O1xudmFyIGdldEJ1aWx0SW4gPSBnZXRCdWlsdEluJDk7XG52YXIgYXBwbHkgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGJpbmQkMSA9IGZ1bmN0aW9uQmluZDtcbnZhciBhQ29uc3RydWN0b3IgPSBhQ29uc3RydWN0b3IkMTtcbnZhciBhbk9iamVjdCQyID0gYW5PYmplY3QkZDtcbnZhciBpc09iamVjdCQzID0gaXNPYmplY3QkajtcbnZhciBjcmVhdGUkMyA9IG9iamVjdENyZWF0ZTtcbnZhciBmYWlscyQzID0gZmFpbHMkdDtcbnZhciBuYXRpdmVDb25zdHJ1Y3QgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgcHVzaCQxID0gW10ucHVzaDsgLy8gYFJlZmxlY3QuY29uc3RydWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVmbGVjdC5jb25zdHJ1Y3Rcbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxuXG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG5cbiAgcmV0dXJuICEobmF0aXZlQ29uc3RydWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xudmFyIEFSR1NfQlVHID0gIWZhaWxzJDMoZnVuY3Rpb24gKCkge1xuICBuYXRpdmVDb25zdHJ1Y3QoZnVuY3Rpb24gKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH0pO1xufSk7XG52YXIgRk9SQ0VEJDIgPSBORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRztcbiQkOSh7XG4gIHRhcmdldDogJ1JlZmxlY3QnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IEZPUkNFRCQyLFxuICBzaGFtOiBGT1JDRUQkMlxufSwge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3NcbiAgLyogLCBuZXdUYXJnZXQgKi9cbiAgKSB7XG4gICAgYUNvbnN0cnVjdG9yKFRhcmdldCk7XG4gICAgYW5PYmplY3QkMihhcmdzKTtcbiAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhQ29uc3RydWN0b3IoYXJndW1lbnRzWzJdKTtcbiAgICBpZiAoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKSByZXR1cm4gbmF0aXZlQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcblxuICAgIGlmIChUYXJnZXQgPT0gbmV3VGFyZ2V0KSB7XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoKTtcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSk7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICB9IC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG5cblxuICAgICAgdmFyICRhcmdzID0gW251bGxdO1xuICAgICAgYXBwbHkocHVzaCQxLCAkYXJncywgYXJncyk7XG4gICAgICByZXR1cm4gbmV3IChhcHBseShiaW5kJDEsIFRhcmdldCwgJGFyZ3MpKSgpO1xuICAgIH0gLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG5cblxuICAgIHZhciBwcm90byA9IG5ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlJDMoaXNPYmplY3QkMyhwcm90bykgPyBwcm90byA6IE9iamVjdFByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IGFwcGx5KFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdCQzKHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7XG5cbnZhciBwYXRoJDggPSBwYXRoJHk7XG52YXIgY29uc3RydWN0JDIgPSBwYXRoJDguUmVmbGVjdC5jb25zdHJ1Y3Q7XG5cbnZhciBwYXJlbnQkciA9IGNvbnN0cnVjdCQyO1xudmFyIGNvbnN0cnVjdCQxID0gcGFyZW50JHI7XG5cbnZhciBjb25zdHJ1Y3QgPSBjb25zdHJ1Y3QkMTtcblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxudmFyIHBhcmVudCRxID0gY3JlYXRlJDY7XG52YXIgY3JlYXRlJDIgPSBwYXJlbnQkcTtcblxudmFyIHBhcmVudCRwID0gY3JlYXRlJDI7XG52YXIgY3JlYXRlJDEgPSBwYXJlbnQkcDtcblxudmFyIGNyZWF0ZSA9IGNyZWF0ZSQxO1xuXG52YXIgJCQ4ID0gX2V4cG9ydDtcbnZhciBzZXRQcm90b3R5cGVPZiQ1ID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7IC8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2ZcblxuJCQ4KHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZVxufSwge1xuICBzZXRQcm90b3R5cGVPZjogc2V0UHJvdG90eXBlT2YkNVxufSk7XG5cbnZhciBwYXRoJDcgPSBwYXRoJHk7XG52YXIgc2V0UHJvdG90eXBlT2YkNCA9IHBhdGgkNy5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cbnZhciBwYXJlbnQkbyA9IHNldFByb3RvdHlwZU9mJDQ7XG52YXIgc2V0UHJvdG90eXBlT2YkMyA9IHBhcmVudCRvO1xuXG52YXIgcGFyZW50JG4gPSBzZXRQcm90b3R5cGVPZiQzO1xudmFyIHNldFByb3RvdHlwZU9mJDIgPSBwYXJlbnQkbjtcblxudmFyIHBhcmVudCRtID0gc2V0UHJvdG90eXBlT2YkMjtcbnZhciBzZXRQcm90b3R5cGVPZiQxID0gcGFyZW50JG07XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHNldFByb3RvdHlwZU9mJDE7XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IHNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuXG4gIGRlZmluZVByb3BlcnR5JDMoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG5cbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxudmFyIHBhcmVudCRsID0gZ2V0UHJvdG90eXBlT2YkNTtcbnZhciBnZXRQcm90b3R5cGVPZiQzID0gcGFyZW50JGw7XG5cbnZhciBwYXJlbnQkayA9IGdldFByb3RvdHlwZU9mJDM7XG52YXIgZ2V0UHJvdG90eXBlT2YkMiA9IHBhcmVudCRrO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YkMSA9IGdldFByb3RvdHlwZU9mJDI7XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IHNldFByb3RvdHlwZU9mID8gZ2V0UHJvdG90eXBlT2YkMSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IGdldFByb3RvdHlwZU9mJDEobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbnZhciBydW50aW1lID0ge2V4cG9ydHM6IHt9fTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuICB2YXIgcnVudGltZSA9IGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICAgIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgdW5kZWZpbmVkJDE7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuXG4gICAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICAgIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gICAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICAgIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGRlZmluZSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cblxuICAgICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgICB9XG5cbiAgICBleHBvcnRzLndyYXAgPSB3cmFwOyAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gICAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAgIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAgIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAgIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG5cbiAgICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgICBhcmc6IGZuLmNhbGwob2JqLCBhcmcpXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInRocm93XCIsXG4gICAgICAgICAgYXJnOiBlcnJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICAgIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7IC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG5cbiAgICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9OyAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAgIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG5cbiAgICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuXG4gICAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuXG4gICAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gICAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cblxuXG4gICAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gICAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICAgIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcblxuICAgIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gICAgfVxuXG4gICAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgIGRlZmluZShHcCwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKTtcbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7IC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gICAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cblxuICAgIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuIGN0b3IgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgICAgfVxuXG4gICAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgICByZXR1cm4gZ2VuRnVuO1xuICAgIH07IC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gICAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAgIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG5cblxuICAgIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfX2F3YWl0OiBhcmdcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG5cbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPSAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICAgIH0gLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuXG5cbiAgICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gICAgfVxuXG4gICAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICAgIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7IC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cblxuICAgIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuICAgICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpO1xuICAgICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9IC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuXG5cbiAgICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcblxuICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lID8gR2VuU3RhdGVDb21wbGV0ZWQgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7IC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG5cbiAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAgIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cblxuXG4gICAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcblxuICAgICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkJDEpIHtcbiAgICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICAgIGlmICghaW5mbykge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTsgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuXG4gICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7IC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgfSAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cblxuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0gLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG5cblxuICAgIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG4gICAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7IC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gICAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAgIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgdHJ5TG9jOiBsb2NzWzBdXG4gICAgICB9O1xuXG4gICAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgICB0aGlzLnRyeUVudHJpZXMgPSBbe1xuICAgICAgICB0cnlMb2M6IFwicm9vdFwiXG4gICAgICB9XTtcbiAgICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5cy5yZXZlcnNlKCk7IC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG5cbiAgICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cblxuXG4gICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuXG4gICAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG5cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZG9uZVJlc3VsdFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICAgIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkJDEsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcbiAgICAgIHJlc2V0OiBmdW5jdGlvbiAoc2tpcFRlbXBSZXNldCkge1xuICAgICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgICB0aGlzLm5leHQgPSAwOyAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuXG4gICAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgICB9LFxuICAgICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhYnJ1cHQ6IGZ1bmN0aW9uICh0eXBlLCBhcmcpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJiAodHlwZSA9PT0gXCJicmVha1wiIHx8IHR5cGUgPT09IFwiY29udGludWVcIikgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9LFxuICAgICAgY29tcGxldGU6IGZ1bmN0aW9uIChyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8IHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH0sXG4gICAgICBmaW5pc2g6IGZ1bmN0aW9uIChmaW5hbGx5TG9jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gKHRyeUxvYykge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuXG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgICAgfSxcbiAgICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG4gICAgfTsgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAgIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAgIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAgIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG5cbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfSggLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICBtb2R1bGUuZXhwb3J0cyApO1xuXG4gIHRyeSB7XG4gICAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbiAgfSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAgIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAgIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgICAvLyB3ZSBjYW4gZXhwbGljaXRseSBhY2Nlc3MgZ2xvYmFsVGhpcy4gSW4gb2xkZXIgZW5naW5lcyB3ZSBjYW4gZXNjYXBlXG4gICAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gICAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gICAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAgIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAgIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xuICAgIH1cbiAgfVxufSkocnVudGltZSk7XG5cbnZhciByZWdlbmVyYXRvciA9IHJ1bnRpbWUuZXhwb3J0cztcblxudmFyIGdsb2JhbCQ1ID0gZ2xvYmFsJFA7XG52YXIgYUNhbGxhYmxlJDIgPSBhQ2FsbGFibGUkNztcbnZhciB0b09iamVjdCQyID0gdG9PYmplY3QkZTtcbnZhciBJbmRleGVkT2JqZWN0ID0gaW5kZXhlZE9iamVjdDtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQzID0gbGVuZ3RoT2ZBcnJheUxpa2UkZDtcbnZhciBUeXBlRXJyb3IkMiA9IGdsb2JhbCQ1LlR5cGVFcnJvcjsgLy8gYEFycmF5LnByb3RvdHlwZS57IHJlZHVjZSwgcmVkdWNlUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX1JJR0hUKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgY2FsbGJhY2tmbiwgYXJndW1lbnRzTGVuZ3RoLCBtZW1vKSB7XG4gICAgYUNhbGxhYmxlJDIoY2FsbGJhY2tmbik7XG4gICAgdmFyIE8gPSB0b09iamVjdCQyKHRoYXQpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMyhPKTtcbiAgICB2YXIgaW5kZXggPSBJU19SSUdIVCA/IGxlbmd0aCAtIDEgOiAwO1xuICAgIHZhciBpID0gSVNfUklHSFQgPyAtMSA6IDE7XG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA8IDIpIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpbmRleCArPSBpO1xuXG4gICAgICBpZiAoSVNfUklHSFQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yJDIoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDsgSVNfUklHSFQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufTtcblxudmFyIGFycmF5UmVkdWNlID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuICBsZWZ0OiBjcmVhdGVNZXRob2QoZmFsc2UpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlcmlnaHRcbiAgcmlnaHQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcblxudmFyIGNsYXNzb2YkMyA9IGNsYXNzb2ZSYXckMTtcbnZhciBnbG9iYWwkNCA9IGdsb2JhbCRQO1xudmFyIGVuZ2luZUlzTm9kZSA9IGNsYXNzb2YkMyhnbG9iYWwkNC5wcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbnZhciAkJDcgPSBfZXhwb3J0O1xudmFyICRyZWR1Y2UgPSBhcnJheVJlZHVjZS5sZWZ0O1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkMiA9IGFycmF5TWV0aG9kSXNTdHJpY3QkNjtcbnZhciBDSFJPTUVfVkVSU0lPTiA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBJU19OT0RFID0gZW5naW5lSXNOb2RlO1xudmFyIFNUUklDVF9NRVRIT0QkMiA9IGFycmF5TWV0aG9kSXNTdHJpY3QkMigncmVkdWNlJyk7IC8vIENocm9tZSA4MC04MiBoYXMgYSBjcml0aWNhbCBidWdcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwNDk5ODJcblxudmFyIENIUk9NRV9CVUcgPSAhSVNfTk9ERSAmJiBDSFJPTUVfVkVSU0lPTiA+IDc5ICYmIENIUk9NRV9WRVJTSU9OIDwgODM7IC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuXG4kJDcoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6ICFTVFJJQ1RfTUVUSE9EJDIgfHwgQ0hST01FX0JVR1xufSwge1xuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuXG4gIC8qICwgaW5pdGlhbFZhbHVlICovXG4gICkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGxlbmd0aCwgbGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJDYgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciByZWR1Y2UkMyA9IGVudHJ5VmlydHVhbCQ2KCdBcnJheScpLnJlZHVjZTtcblxudmFyIGlzUHJvdG90eXBlT2YkNiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDYgPSByZWR1Y2UkMztcbnZhciBBcnJheVByb3RvdHlwZSQ2ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgcmVkdWNlJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnJlZHVjZTtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ2IHx8IGlzUHJvdG90eXBlT2YkNihBcnJheVByb3RvdHlwZSQ2LCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQ2LnJlZHVjZSA/IG1ldGhvZCQ2IDogb3duO1xufTtcblxudmFyIHBhcmVudCRqID0gcmVkdWNlJDI7XG52YXIgcmVkdWNlJDEgPSBwYXJlbnQkajtcblxudmFyIHJlZHVjZSA9IHJlZHVjZSQxO1xuXG52YXIgZ2xvYmFsJDMgPSBnbG9iYWwkUDtcbnZhciBpc0FycmF5ID0gaXNBcnJheSRkO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDIgPSBsZW5ndGhPZkFycmF5TGlrZSRkO1xudmFyIGJpbmQgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIFR5cGVFcnJvciQxID0gZ2xvYmFsJDMuVHlwZUVycm9yOyAvLyBgRmxhdHRlbkludG9BcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1GbGF0dGVuSW50b0FycmF5XG5cbnZhciBmbGF0dGVuSW50b0FycmF5JDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBvcmlnaW5hbCwgc291cmNlLCBzb3VyY2VMZW4sIHN0YXJ0LCBkZXB0aCwgbWFwcGVyLCB0aGlzQXJnKSB7XG4gIHZhciB0YXJnZXRJbmRleCA9IHN0YXJ0O1xuICB2YXIgc291cmNlSW5kZXggPSAwO1xuICB2YXIgbWFwRm4gPSBtYXBwZXIgPyBiaW5kKG1hcHBlciwgdGhpc0FyZykgOiBmYWxzZTtcbiAgdmFyIGVsZW1lbnQsIGVsZW1lbnRMZW47XG5cbiAgd2hpbGUgKHNvdXJjZUluZGV4IDwgc291cmNlTGVuKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IGluIHNvdXJjZSkge1xuICAgICAgZWxlbWVudCA9IG1hcEZuID8gbWFwRm4oc291cmNlW3NvdXJjZUluZGV4XSwgc291cmNlSW5kZXgsIG9yaWdpbmFsKSA6IHNvdXJjZVtzb3VyY2VJbmRleF07XG5cbiAgICAgIGlmIChkZXB0aCA+IDAgJiYgaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICBlbGVtZW50TGVuID0gbGVuZ3RoT2ZBcnJheUxpa2UkMihlbGVtZW50KTtcbiAgICAgICAgdGFyZ2V0SW5kZXggPSBmbGF0dGVuSW50b0FycmF5JDEodGFyZ2V0LCBvcmlnaW5hbCwgZWxlbWVudCwgZWxlbWVudExlbiwgdGFyZ2V0SW5kZXgsIGRlcHRoIC0gMSkgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldEluZGV4ID49IDB4MUZGRkZGRkZGRkZGRkYpIHRocm93IFR5cGVFcnJvciQxKCdFeGNlZWQgdGhlIGFjY2VwdGFibGUgYXJyYXkgbGVuZ3RoJyk7XG4gICAgICAgIHRhcmdldFt0YXJnZXRJbmRleF0gPSBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRJbmRleCsrO1xuICAgIH1cblxuICAgIHNvdXJjZUluZGV4Kys7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0SW5kZXg7XG59O1xuXG52YXIgZmxhdHRlbkludG9BcnJheV8xID0gZmxhdHRlbkludG9BcnJheSQxO1xuXG52YXIgJCQ2ID0gX2V4cG9ydDtcbnZhciBmbGF0dGVuSW50b0FycmF5ID0gZmxhdHRlbkludG9BcnJheV8xO1xudmFyIGFDYWxsYWJsZSQxID0gYUNhbGxhYmxlJDc7XG52YXIgdG9PYmplY3QkMSA9IHRvT2JqZWN0JGU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMSA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDQ7IC8vIGBBcnJheS5wcm90b3R5cGUuZmxhdE1hcGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mbGF0bWFwXG5cbiQkNih7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWVcbn0sIHtcbiAgZmxhdE1hcDogZnVuY3Rpb24gZmxhdE1hcChjYWxsYmFja2ZuXG4gIC8qICwgdGhpc0FyZyAqL1xuICApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0JDEodGhpcyk7XG4gICAgdmFyIHNvdXJjZUxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlJDEoTyk7XG4gICAgdmFyIEE7XG4gICAgYUNhbGxhYmxlJDEoY2FsbGJhY2tmbik7XG4gICAgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICBBLmxlbmd0aCA9IGZsYXR0ZW5JbnRvQXJyYXkoQSwgTywgTywgc291cmNlTGVuLCAwLCAxLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJDUgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBmbGF0TWFwJDMgPSBlbnRyeVZpcnR1YWwkNSgnQXJyYXknKS5mbGF0TWFwO1xuXG52YXIgaXNQcm90b3R5cGVPZiQ1ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkNSA9IGZsYXRNYXAkMztcbnZhciBBcnJheVByb3RvdHlwZSQ1ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgZmxhdE1hcCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5mbGF0TWFwO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDUgfHwgaXNQcm90b3R5cGVPZiQ1KEFycmF5UHJvdG90eXBlJDUsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDUuZmxhdE1hcCA/IG1ldGhvZCQ1IDogb3duO1xufTtcblxudmFyIHBhcmVudCRpID0gZmxhdE1hcCQyO1xudmFyIGZsYXRNYXAkMSA9IHBhcmVudCRpO1xuXG52YXIgZmxhdE1hcCA9IGZsYXRNYXAkMTtcblxudmFyIGNvbGxlY3Rpb24kMSA9IGNvbGxlY3Rpb24kMztcbnZhciBjb2xsZWN0aW9uU3Ryb25nID0gY29sbGVjdGlvblN0cm9uZyQyOyAvLyBgU2V0YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQtb2JqZWN0c1xuXG5jb2xsZWN0aW9uJDEoJ1NldCcsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59LCBjb2xsZWN0aW9uU3Ryb25nKTtcblxudmFyIHBhdGgkNiA9IHBhdGgkeTtcbnZhciBzZXQkMiA9IHBhdGgkNi5TZXQ7XG5cbnZhciBwYXJlbnQkaCA9IHNldCQyO1xudmFyIHNldCQxID0gcGFyZW50JGg7XG5cbnZhciBzZXQgPSBzZXQkMTtcblxudmFyIGl0ZXJhdG9yID0gaXRlcmF0b3IkNDtcblxudmFyIGdldEl0ZXJhdG9yJDQgPSBnZXRJdGVyYXRvciQ3O1xudmFyIGdldEl0ZXJhdG9yXzEgPSBnZXRJdGVyYXRvciQ0O1xuXG52YXIgcGFyZW50JGcgPSBnZXRJdGVyYXRvcl8xO1xudmFyIGdldEl0ZXJhdG9yJDMgPSBwYXJlbnQkZztcblxudmFyIHBhcmVudCRmID0gZ2V0SXRlcmF0b3IkMztcbnZhciBnZXRJdGVyYXRvciQyID0gcGFyZW50JGY7XG5cbnZhciBwYXJlbnQkZSA9IGdldEl0ZXJhdG9yJDI7XG52YXIgZ2V0SXRlcmF0b3IkMSA9IHBhcmVudCRlO1xuXG52YXIgZ2V0SXRlcmF0b3IgPSBnZXRJdGVyYXRvciQxO1xuXG52YXIgYXJyYXlTbGljZSA9IGFycmF5U2xpY2VTaW1wbGU7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG52YXIgbWVyZ2VTb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIG1pZGRsZSA9IGZsb29yKGxlbmd0aCAvIDIpO1xuICByZXR1cm4gbGVuZ3RoIDwgOCA/IGluc2VydGlvblNvcnQoYXJyYXksIGNvbXBhcmVmbikgOiBtZXJnZShhcnJheSwgbWVyZ2VTb3J0KGFycmF5U2xpY2UoYXJyYXksIDAsIG1pZGRsZSksIGNvbXBhcmVmbiksIG1lcmdlU29ydChhcnJheVNsaWNlKGFycmF5LCBtaWRkbGUpLCBjb21wYXJlZm4pLCBjb21wYXJlZm4pO1xufTtcblxudmFyIGluc2VydGlvblNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgaSA9IDE7XG4gIHZhciBlbGVtZW50LCBqO1xuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaiA9IGk7XG4gICAgZWxlbWVudCA9IGFycmF5W2ldO1xuXG4gICAgd2hpbGUgKGogJiYgY29tcGFyZWZuKGFycmF5W2ogLSAxXSwgZWxlbWVudCkgPiAwKSB7XG4gICAgICBhcnJheVtqXSA9IGFycmF5Wy0tal07XG4gICAgfVxuXG4gICAgaWYgKGogIT09IGkrKykgYXJyYXlbal0gPSBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gKGFycmF5LCBsZWZ0LCByaWdodCwgY29tcGFyZWZuKSB7XG4gIHZhciBsbGVuZ3RoID0gbGVmdC5sZW5ndGg7XG4gIHZhciBybGVuZ3RoID0gcmlnaHQubGVuZ3RoO1xuICB2YXIgbGluZGV4ID0gMDtcbiAgdmFyIHJpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGxpbmRleCA8IGxsZW5ndGggfHwgcmluZGV4IDwgcmxlbmd0aCkge1xuICAgIGFycmF5W2xpbmRleCArIHJpbmRleF0gPSBsaW5kZXggPCBsbGVuZ3RoICYmIHJpbmRleCA8IHJsZW5ndGggPyBjb21wYXJlZm4obGVmdFtsaW5kZXhdLCByaWdodFtyaW5kZXhdKSA8PSAwID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK10gOiBsaW5kZXggPCBsbGVuZ3RoID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK107XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgYXJyYXlTb3J0ID0gbWVyZ2VTb3J0O1xuXG52YXIgdXNlckFnZW50JDEgPSBlbmdpbmVVc2VyQWdlbnQ7XG52YXIgZmlyZWZveCA9IHVzZXJBZ2VudCQxLm1hdGNoKC9maXJlZm94XFwvKFxcZCspL2kpO1xudmFyIGVuZ2luZUZmVmVyc2lvbiA9ICEhZmlyZWZveCAmJiArZmlyZWZveFsxXTtcblxudmFyIFVBID0gZW5naW5lVXNlckFnZW50O1xudmFyIGVuZ2luZUlzSWVPckVkZ2UgPSAvTVNJRXxUcmlkZW50Ly50ZXN0KFVBKTtcblxudmFyIHVzZXJBZ2VudCA9IGVuZ2luZVVzZXJBZ2VudDtcbnZhciB3ZWJraXQgPSB1c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLyk7XG52YXIgZW5naW5lV2Via2l0VmVyc2lvbiA9ICEhd2Via2l0ICYmICt3ZWJraXRbMV07XG5cbnZhciAkJDUgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJDMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFDYWxsYWJsZSA9IGFDYWxsYWJsZSQ3O1xudmFyIHRvT2JqZWN0ID0gdG9PYmplY3QkZTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IGxlbmd0aE9mQXJyYXlMaWtlJGQ7XG52YXIgdG9TdHJpbmckMSA9IHRvU3RyaW5nJDg7XG52YXIgZmFpbHMkMiA9IGZhaWxzJHQ7XG52YXIgaW50ZXJuYWxTb3J0ID0gYXJyYXlTb3J0O1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkMSA9IGFycmF5TWV0aG9kSXNTdHJpY3QkNjtcbnZhciBGRiA9IGVuZ2luZUZmVmVyc2lvbjtcbnZhciBJRV9PUl9FREdFID0gZW5naW5lSXNJZU9yRWRnZTtcbnZhciBWOCA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBXRUJLSVQgPSBlbmdpbmVXZWJraXRWZXJzaW9uO1xudmFyIHRlc3QgPSBbXTtcbnZhciB1biRTb3J0ID0gdW5jdXJyeVRoaXMkMyh0ZXN0LnNvcnQpO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyQzKHRlc3QucHVzaCk7IC8vIElFOC1cblxudmFyIEZBSUxTX09OX1VOREVGSU5FRCA9IGZhaWxzJDIoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pOyAvLyBWOCBidWdcblxudmFyIEZBSUxTX09OX05VTEwgPSBmYWlscyQyKGZ1bmN0aW9uICgpIHtcbiAgdGVzdC5zb3J0KG51bGwpO1xufSk7IC8vIE9sZCBXZWJLaXRcblxudmFyIFNUUklDVF9NRVRIT0QkMSA9IGFycmF5TWV0aG9kSXNTdHJpY3QkMSgnc29ydCcpO1xudmFyIFNUQUJMRV9TT1JUID0gIWZhaWxzJDIoZnVuY3Rpb24gKCkge1xuICAvLyBmZWF0dXJlIGRldGVjdGlvbiBjYW4gYmUgdG9vIHNsb3csIHNvIGNoZWNrIGVuZ2luZXMgdmVyc2lvbnNcbiAgaWYgKFY4KSByZXR1cm4gVjggPCA3MDtcbiAgaWYgKEZGICYmIEZGID4gMykgcmV0dXJuO1xuICBpZiAoSUVfT1JfRURHRSkgcmV0dXJuIHRydWU7XG4gIGlmIChXRUJLSVQpIHJldHVybiBXRUJLSVQgPCA2MDM7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGNvZGUsIGNociwgdmFsdWUsIGluZGV4OyAvLyBnZW5lcmF0ZSBhbiBhcnJheSB3aXRoIG1vcmUgNTEyIGVsZW1lbnRzIChDaGFrcmEgYW5kIG9sZCBWOCBmYWlscyBvbmx5IGluIHRoaXMgY2FzZSlcblxuICBmb3IgKGNvZGUgPSA2NTsgY29kZSA8IDc2OyBjb2RlKyspIHtcbiAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuXG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlIDY2OlxuICAgICAgY2FzZSA2OTpcbiAgICAgIGNhc2UgNzA6XG4gICAgICBjYXNlIDcyOlxuICAgICAgICB2YWx1ZSA9IDM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDY4OlxuICAgICAgY2FzZSA3MTpcbiAgICAgICAgdmFsdWUgPSA0O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFsdWUgPSAyO1xuICAgIH1cblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IDQ3OyBpbmRleCsrKSB7XG4gICAgICB0ZXN0LnB1c2goe1xuICAgICAgICBrOiBjaHIgKyBpbmRleCxcbiAgICAgICAgdjogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHRlc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnYgLSBhLnY7XG4gIH0pO1xuXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRlc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY2hyID0gdGVzdFtpbmRleF0uay5jaGFyQXQoMCk7XG4gICAgaWYgKHJlc3VsdC5jaGFyQXQocmVzdWx0Lmxlbmd0aCAtIDEpICE9PSBjaHIpIHJlc3VsdCArPSBjaHI7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICE9PSAnREdCRUZIQUNJSksnO1xufSk7XG52YXIgRk9SQ0VEJDEgPSBGQUlMU19PTl9VTkRFRklORUQgfHwgIUZBSUxTX09OX05VTEwgfHwgIVNUUklDVF9NRVRIT0QkMSB8fCAhU1RBQkxFX1NPUlQ7XG5cbnZhciBnZXRTb3J0Q29tcGFyZSA9IGZ1bmN0aW9uIChjb21wYXJlZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIC0xO1xuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHJldHVybiAxO1xuICAgIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgcmV0dXJuICtjb21wYXJlZm4oeCwgeSkgfHwgMDtcbiAgICByZXR1cm4gdG9TdHJpbmckMSh4KSA+IHRvU3RyaW5nJDEoeSkgPyAxIDogLTE7XG4gIH07XG59OyAvLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29ydFxuXG5cbiQkNSh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogRk9SQ0VEJDFcbn0sIHtcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIGFDYWxsYWJsZShjb21wYXJlZm4pO1xuICAgIHZhciBhcnJheSA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIGlmIChTVEFCTEVfU09SVCkgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkID8gdW4kU29ydChhcnJheSkgOiB1biRTb3J0KGFycmF5LCBjb21wYXJlZm4pO1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciBhcnJheUxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKGFycmF5KTtcbiAgICB2YXIgaXRlbXNMZW5ndGgsIGluZGV4O1xuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChpbmRleCBpbiBhcnJheSkgcHVzaChpdGVtcywgYXJyYXlbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbFNvcnQoaXRlbXMsIGdldFNvcnRDb21wYXJlKGNvbXBhcmVmbikpO1xuICAgIGl0ZW1zTGVuZ3RoID0gaXRlbXMubGVuZ3RoO1xuICAgIGluZGV4ID0gMDtcblxuICAgIHdoaWxlIChpbmRleCA8IGl0ZW1zTGVuZ3RoKSBhcnJheVtpbmRleF0gPSBpdGVtc1tpbmRleCsrXTtcblxuICAgIHdoaWxlIChpbmRleCA8IGFycmF5TGVuZ3RoKSBkZWxldGUgYXJyYXlbaW5kZXgrK107XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJDQgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBzb3J0JDMgPSBlbnRyeVZpcnR1YWwkNCgnQXJyYXknKS5zb3J0O1xuXG52YXIgaXNQcm90b3R5cGVPZiQ0ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkNCA9IHNvcnQkMztcbnZhciBBcnJheVByb3RvdHlwZSQ0ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgc29ydCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5zb3J0O1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDQgfHwgaXNQcm90b3R5cGVPZiQ0KEFycmF5UHJvdG90eXBlJDQsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDQuc29ydCA/IG1ldGhvZCQ0IDogb3duO1xufTtcblxudmFyIHBhcmVudCRkID0gc29ydCQyO1xudmFyIHNvcnQkMSA9IHBhcmVudCRkO1xuXG52YXIgc29ydCA9IHNvcnQkMTtcblxudmFyIGVudHJ5VmlydHVhbCQzID0gZW50cnlWaXJ0dWFsJGw7XG52YXIga2V5cyQzID0gZW50cnlWaXJ0dWFsJDMoJ0FycmF5Jykua2V5cztcblxudmFyIHBhcmVudCRjID0ga2V5cyQzO1xudmFyIGtleXMkMiA9IHBhcmVudCRjO1xuXG52YXIgY2xhc3NvZiQyID0gY2xhc3NvZiRlO1xudmFyIGhhc093biQ0ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc1Byb3RvdHlwZU9mJDMgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQzID0ga2V5cyQyO1xudmFyIEFycmF5UHJvdG90eXBlJDMgPSBBcnJheS5wcm90b3R5cGU7XG52YXIgRE9NSXRlcmFibGVzJDIgPSB7XG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgTm9kZUxpc3Q6IHRydWVcbn07XG5cbnZhciBrZXlzJDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmtleXM7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkMyB8fCBpc1Byb3RvdHlwZU9mJDMoQXJyYXlQcm90b3R5cGUkMywgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkMy5rZXlzIHx8IGhhc093biQ0KERPTUl0ZXJhYmxlcyQyLCBjbGFzc29mJDIoaXQpKSA/IG1ldGhvZCQzIDogb3duO1xufTtcblxudmFyIGtleXMgPSBrZXlzJDE7XG5cbnZhciBlbnRyeVZpcnR1YWwkMiA9IGVudHJ5VmlydHVhbCRsO1xudmFyIHZhbHVlcyQzID0gZW50cnlWaXJ0dWFsJDIoJ0FycmF5JykudmFsdWVzO1xuXG52YXIgcGFyZW50JGIgPSB2YWx1ZXMkMztcbnZhciB2YWx1ZXMkMiA9IHBhcmVudCRiO1xuXG52YXIgY2xhc3NvZiQxID0gY2xhc3NvZiRlO1xudmFyIGhhc093biQzID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc1Byb3RvdHlwZU9mJDIgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQyID0gdmFsdWVzJDI7XG52YXIgQXJyYXlQcm90b3R5cGUkMiA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBET01JdGVyYWJsZXMkMSA9IHtcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBOb2RlTGlzdDogdHJ1ZVxufTtcblxudmFyIHZhbHVlcyQxID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC52YWx1ZXM7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkMiB8fCBpc1Byb3RvdHlwZU9mJDIoQXJyYXlQcm90b3R5cGUkMiwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkMi52YWx1ZXMgfHwgaGFzT3duJDMoRE9NSXRlcmFibGVzJDEsIGNsYXNzb2YkMShpdCkpID8gbWV0aG9kJDIgOiBvd247XG59O1xuXG52YXIgdmFsdWVzID0gdmFsdWVzJDE7XG5cbnZhciBlbnRyeVZpcnR1YWwkMSA9IGVudHJ5VmlydHVhbCRsO1xudmFyIGVudHJpZXMkMyA9IGVudHJ5VmlydHVhbCQxKCdBcnJheScpLmVudHJpZXM7XG5cbnZhciBwYXJlbnQkYSA9IGVudHJpZXMkMztcbnZhciBlbnRyaWVzJDIgPSBwYXJlbnQkYTtcblxudmFyIGNsYXNzb2YgPSBjbGFzc29mJGU7XG52YXIgaGFzT3duJDIgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzUHJvdG90eXBlT2YkMSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDEgPSBlbnRyaWVzJDI7XG52YXIgQXJyYXlQcm90b3R5cGUkMSA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBET01JdGVyYWJsZXMgPSB7XG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgTm9kZUxpc3Q6IHRydWVcbn07XG5cbnZhciBlbnRyaWVzJDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmVudHJpZXM7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkMSB8fCBpc1Byb3RvdHlwZU9mJDEoQXJyYXlQcm90b3R5cGUkMSwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkMS5lbnRyaWVzIHx8IGhhc093biQyKERPTUl0ZXJhYmxlcywgY2xhc3NvZihpdCkpID8gbWV0aG9kJDEgOiBvd247XG59O1xuXG52YXIgZW50cmllcyA9IGVudHJpZXMkMTtcblxuLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG52YXIgZ2V0UmFuZG9tVmFsdWVzO1xudmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uIEFsc28sXG4gICAgLy8gZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIChtc0NyeXB0bykgb24gSUUxMS5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pIHx8IHR5cGVvZiBtc0NyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG5cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufVxuXG52YXIgUkVHRVggPSAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxudmFyIGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyKSB7XG4gIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7IC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuXG4gIHZhciB1dWlkID0gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeShybmRzKTtcbn1cblxudmFyIF9TeW1ib2wkaXRlcmF0b3I7XG5cbmZ1bmN0aW9uIG93bktleXMkNChvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0ga2V5cyQ0KG9iamVjdCk7IGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBmaWx0ZXIoc3ltYm9scykuY2FsbChzeW1ib2xzLCBmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyhvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ0KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgX2NvbnRleHQzMiwgX2NvbnRleHQzMzsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gZm9yRWFjaCQyKF9jb250ZXh0MzIgPSBvd25LZXlzJDQoT2JqZWN0KHNvdXJjZSksICEwKSkuY2FsbChfY29udGV4dDMyLCBmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IGZvckVhY2gkMihfY29udGV4dDMzID0gb3duS2V5cyQ0KE9iamVjdChzb3VyY2UpKSkuY2FsbChfY29udGV4dDMzLCBmdW5jdGlvbiAoa2V5KSB7IGRlZmluZVByb3BlcnR5JDYodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHQoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBzeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoaXNBcnJheSQyKG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ3KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDcobywgbWluTGVuKSB7IHZhciBfY29udGV4dDMxOyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNyhvLCBtaW5MZW4pOyB2YXIgbiA9IHNsaWNlKF9jb250ZXh0MzEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQzMSwgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbSQzKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDcobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ3KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuLyoqXHJcbiAqIENyZWF0ZSBuZXcgZGF0YSBwaXBlLlxyXG4gKlxyXG4gKiBAcGFyYW0gZnJvbSAtIFRoZSBzb3VyY2UgZGF0YSBzZXQgb3IgZGF0YSB2aWV3LlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBFeGFtcGxlIHVzYWdlOlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGludGVyZmFjZSBBcHBJdGVtIHtcclxuICogICB3aG9hbWk6IHN0cmluZztcclxuICogICBhcHBEYXRhOiB1bmtub3duO1xyXG4gKiAgIHZpc0RhdGE6IFZpc0l0ZW07XHJcbiAqIH1cclxuICogaW50ZXJmYWNlIFZpc0l0ZW0ge1xyXG4gKiAgIGlkOiBudW1iZXI7XHJcbiAqICAgbGFiZWw6IHN0cmluZztcclxuICogICBjb2xvcjogc3RyaW5nO1xyXG4gKiAgIHg6IG51bWJlcjtcclxuICogICB5OiBudW1iZXI7XHJcbiAqIH1cclxuICpcclxuICogY29uc3QgZHMxID0gbmV3IERhdGFTZXQ8QXBwSXRlbSwgXCJ3aG9hbWlcIj4oW10sIHsgZmllbGRJZDogXCJ3aG9hbWlcIiB9KTtcclxuICogY29uc3QgZHMyID0gbmV3IERhdGFTZXQ8VmlzSXRlbSwgXCJpZFwiPigpO1xyXG4gKlxyXG4gKiBjb25zdCBwaXBlID0gY3JlYXRlTmV3RGF0YVBpcGVGcm9tKGRzMSlcclxuICogICAuZmlsdGVyKChpdGVtKTogYm9vbGVhbiA9PiBpdGVtLmVuYWJsZWQgPT09IHRydWUpXHJcbiAqICAgLm1hcDxWaXNJdGVtLCBcImlkXCI+KChpdGVtKTogVmlzSXRlbSA9PiBpdGVtLnZpc0RhdGEpXHJcbiAqICAgLnRvKGRzMik7XHJcbiAqXHJcbiAqIHBpcGUuc3RhcnQoKTtcclxuICogYGBgXHJcbiAqIEByZXR1cm5zIEEgZmFjdG9yeSB3aG9zZSBtZXRob2RzIGNhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgcGlwZS5cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld0RhdGFQaXBlRnJvbShmcm9tKSB7XG4gIHJldHVybiBuZXcgRGF0YVBpcGVVbmRlckNvbnN0cnVjdGlvbihmcm9tKTtcbn1cbi8qKlxyXG4gKiBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcGlwZS4gVGhpcyBzaG91bGQgYmUgYWNjZXNzaWJsZSBvbmx5IHRocm91Z2hcclxuICogYGNyZWF0ZU5ld0RhdGFQaXBlRnJvbWAgZnJvbSB0aGUgb3V0c2lkZS5cclxuICpcclxuICogQHR5cGVQYXJhbSBTSSAtIFNvdXJjZSBpdGVtIHR5cGUuXHJcbiAqIEB0eXBlUGFyYW0gU1AgLSBTb3VyY2UgaXRlbSB0eXBlJ3MgaWQgcHJvcGVydHkgbmFtZS5cclxuICogQHR5cGVQYXJhbSBUSSAtIFRhcmdldCBpdGVtIHR5cGUuXHJcbiAqIEB0eXBlUGFyYW0gVFAgLSBUYXJnZXQgaXRlbSB0eXBlJ3MgaWQgcHJvcGVydHkgbmFtZS5cclxuICovXG5cblxudmFyIFNpbXBsZURhdGFQaXBlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQm91bmQgbGlzdGVuZXJzIGZvciB1c2Ugd2l0aCBgRGF0YUludGVyZmFjZVsnb24nIHwgJ29mZiddYC5cclxuICAgKi9cblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgZGF0YSBwaXBlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIF9zb3VyY2UgLSBUaGUgZGF0YSBzZXQgb3IgZGF0YSB2aWV3IHRoYXQgd2lsbCBiZSBvYnNlcnZlZC5cclxuICAgKiBAcGFyYW0gX3RyYW5zZm9ybWVycyAtIEFuIGFycmF5IG9mIHRyYW5zZm9ybWluZyBmdW5jdGlvbnMgdG8gYmUgdXNlZCB0b1xyXG4gICAqIGZpbHRlciBvciB0cmFuc2Zvcm0gdGhlIGl0ZW1zIGluIHRoZSBwaXBlLlxyXG4gICAqIEBwYXJhbSBfdGFyZ2V0IC0gVGhlIGRhdGEgc2V0IG9yIGRhdGEgdmlldyB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgaXRlbXMuXHJcbiAgICovXG4gIGZ1bmN0aW9uIFNpbXBsZURhdGFQaXBlKF9zb3VyY2UsIF90cmFuc2Zvcm1lcnMsIF90YXJnZXQpIHtcbiAgICB2YXIgX2NvbnRleHQsIF9jb250ZXh0MiwgX2NvbnRleHQzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpbXBsZURhdGFQaXBlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zb3VyY2VcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90cmFuc2Zvcm1lcnNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YXJnZXRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9saXN0ZW5lcnNcIiwge1xuICAgICAgYWRkOiBiaW5kJDYoX2NvbnRleHQgPSB0aGlzLl9hZGQpLmNhbGwoX2NvbnRleHQsIHRoaXMpLFxuICAgICAgcmVtb3ZlOiBiaW5kJDYoX2NvbnRleHQyID0gdGhpcy5fcmVtb3ZlKS5jYWxsKF9jb250ZXh0MiwgdGhpcyksXG4gICAgICB1cGRhdGU6IGJpbmQkNihfY29udGV4dDMgPSB0aGlzLl91cGRhdGUpLmNhbGwoX2NvbnRleHQzLCB0aGlzKVxuICAgIH0pO1xuXG4gICAgdGhpcy5fc291cmNlID0gX3NvdXJjZTtcbiAgICB0aGlzLl90cmFuc2Zvcm1lcnMgPSBfdHJhbnNmb3JtZXJzO1xuICAgIHRoaXMuX3RhcmdldCA9IF90YXJnZXQ7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG5cblxuICBfY3JlYXRlQ2xhc3MoU2ltcGxlRGF0YVBpcGUsIFt7XG4gICAga2V5OiBcImFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGwoKSB7XG4gICAgICB0aGlzLl90YXJnZXQudXBkYXRlKHRoaXMuX3RyYW5zZm9ybUl0ZW1zKHRoaXMuX3NvdXJjZS5nZXQoKSkpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHRoaXMuX3NvdXJjZS5vbihcImFkZFwiLCB0aGlzLl9saXN0ZW5lcnMuYWRkKTtcblxuICAgICAgdGhpcy5fc291cmNlLm9uKFwicmVtb3ZlXCIsIHRoaXMuX2xpc3RlbmVycy5yZW1vdmUpO1xuXG4gICAgICB0aGlzLl9zb3VyY2Uub24oXCJ1cGRhdGVcIiwgdGhpcy5fbGlzdGVuZXJzLnVwZGF0ZSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0b3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMuX3NvdXJjZS5vZmYoXCJhZGRcIiwgdGhpcy5fbGlzdGVuZXJzLmFkZCk7XG5cbiAgICAgIHRoaXMuX3NvdXJjZS5vZmYoXCJyZW1vdmVcIiwgdGhpcy5fbGlzdGVuZXJzLnJlbW92ZSk7XG5cbiAgICAgIHRoaXMuX3NvdXJjZS5vZmYoXCJ1cGRhdGVcIiwgdGhpcy5fbGlzdGVuZXJzLnVwZGF0ZSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEFwcGx5IHRoZSB0cmFuc2Zvcm1lcnMgdG8gdGhlIGl0ZW1zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpdGVtcyAtIFRoZSBpdGVtcyB0byBiZSB0cmFuc2Zvcm1lZC5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2Zvcm1lZCBpdGVtcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyYW5zZm9ybUl0ZW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2Zvcm1JdGVtcyhpdGVtcykge1xuICAgICAgdmFyIF9jb250ZXh0NDtcblxuICAgICAgcmV0dXJuIHJlZHVjZShfY29udGV4dDQgPSB0aGlzLl90cmFuc2Zvcm1lcnMpLmNhbGwoX2NvbnRleHQ0LCBmdW5jdGlvbiAoaXRlbXMsIHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtKGl0ZW1zKTtcbiAgICAgIH0sIGl0ZW1zKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgYW4gYWRkIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBfbmFtZSAtIElnbm9yZWQuXHJcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCAtIFRoZSBwYXlsb2FkIGNvbnRhaW5pbmcgdGhlIGlkcyBvZiB0aGUgYWRkZWQgaXRlbXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZChfbmFtZSwgcGF5bG9hZCkge1xuICAgICAgaWYgKHBheWxvYWQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RhcmdldC5hZGQodGhpcy5fdHJhbnNmb3JtSXRlbXModGhpcy5fc291cmNlLmdldChwYXlsb2FkLml0ZW1zKSkpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBhbiB1cGRhdGUgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIF9uYW1lIC0gSWdub3JlZC5cclxuICAgICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIHBheWxvYWQgY29udGFpbmluZyB0aGUgaWRzIG9mIHRoZSB1cGRhdGVkIGl0ZW1zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUoX25hbWUsIHBheWxvYWQpIHtcbiAgICAgIGlmIChwYXlsb2FkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90YXJnZXQudXBkYXRlKHRoaXMuX3RyYW5zZm9ybUl0ZW1zKHRoaXMuX3NvdXJjZS5nZXQocGF5bG9hZC5pdGVtcykpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgYSByZW1vdmUgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIF9uYW1lIC0gSWdub3JlZC5cclxuICAgICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIHBheWxvYWQgY29udGFpbmluZyB0aGUgZGF0YSBvZiB0aGUgcmVtb3ZlZCBpdGVtcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlKF9uYW1lLCBwYXlsb2FkKSB7XG4gICAgICBpZiAocGF5bG9hZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZSh0aGlzLl90cmFuc2Zvcm1JdGVtcyhwYXlsb2FkLm9sZERhdGEpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2ltcGxlRGF0YVBpcGU7XG59KCk7XG4vKipcclxuICogSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIHBpcGUgZmFjdG9yeS4gVGhpcyBzaG91bGQgYmUgYWNjZXNzaWJsZVxyXG4gKiBvbmx5IHRocm91Z2ggYGNyZWF0ZU5ld0RhdGFQaXBlRnJvbWAgZnJvbSB0aGUgb3V0c2lkZS5cclxuICpcclxuICogQHR5cGVQYXJhbSBUSSAtIFRhcmdldCBpdGVtIHR5cGUuXHJcbiAqIEB0eXBlUGFyYW0gVFAgLSBUYXJnZXQgaXRlbSB0eXBlJ3MgaWQgcHJvcGVydHkgbmFtZS5cclxuICovXG5cblxudmFyIERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBBcnJheSB0cmFuc2Zvcm1lcnMgdXNlZCB0byB0cmFuc2Zvcm0gaXRlbXMgd2l0aGluIHRoZSBwaXBlLiBUaGlzIGlzIHR5cGVkXHJcbiAgICogYXMgYW55IGZvciB0aGUgc2FrZSBvZiBzaW1wbGljaXR5LlxyXG4gICAqL1xuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBkYXRhIHBpcGUgZmFjdG9yeS4gVGhpcyBpcyBhbiBpbnRlcm5hbCBjb25zdHJ1Y3RvciB0aGF0XHJcbiAgICogc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCBmcm9tIG91dHNpZGUgb2YgdGhpcyBmaWxlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIF9zb3VyY2UgLSBUaGUgc291cmNlIGRhdGEgc2V0IG9yIGRhdGEgdmlldyBmb3IgdGhpcyBwaXBlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBEYXRhUGlwZVVuZGVyQ29uc3RydWN0aW9uKF9zb3VyY2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVBpcGVVbmRlckNvbnN0cnVjdGlvbik7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc291cmNlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdHJhbnNmb3JtZXJzXCIsIFtdKTtcblxuICAgIHRoaXMuX3NvdXJjZSA9IF9zb3VyY2U7XG4gIH1cbiAgLyoqXHJcbiAgICogRmlsdGVyIHRoZSBpdGVtcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIEEgZmlsdGVyaW5nIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIGdpdmVuIGl0ZW1cclxuICAgKiBzaG91bGQgYmUgcGlwZWQgYW5kIGZhbHNlIGlmIG5vdC5cclxuICAgKiBAcmV0dXJucyBUaGlzIGZhY3RvcnkgZm9yIGZ1cnRoZXIgY29uZmlndXJhdGlvbi5cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhEYXRhUGlwZVVuZGVyQ29uc3RydWN0aW9uLCBbe1xuICAgIGtleTogXCJmaWx0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyJDEoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybWVycy5wdXNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZmlsdGVyKGlucHV0KS5jYWxsKGlucHV0LCBjYWxsYmFjayk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogTWFwIGVhY2ggc291cmNlIGl0ZW0gdG8gYSBuZXcgdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBIG1hcHBpbmcgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHNvdXJjZSBpdGVtIGFuZCByZXR1cm5zXHJcbiAgICAgKiBjb3JyZXNwb25kaW5nIG1hcHBlZCBpdGVtLlxyXG4gICAgICogQHR5cGVQYXJhbSBUSSAtIFRhcmdldCBpdGVtIHR5cGUuXHJcbiAgICAgKiBAdHlwZVBhcmFtIFRQIC0gVGFyZ2V0IGl0ZW0gdHlwZSdzIGlkIHByb3BlcnR5IG5hbWUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGlzIGZhY3RvcnkgZm9yIGZ1cnRoZXIgY29uZmlndXJhdGlvbi5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChjYWxsYmFjaykge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtZXJzLnB1c2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBtYXAkMyhpbnB1dCkuY2FsbChpbnB1dCwgY2FsbGJhY2spO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIE1hcCBlYWNoIHNvdXJjZSBpdGVtIHRvIHplcm8gb3IgbW9yZSBpdGVtcyBvZiBhIG5ldyB0eXBlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEEgbWFwcGluZyBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc291cmNlIGl0ZW0gYW5kIHJldHVybnNcclxuICAgICAqIGFuIGFycmF5IG9mIGNvcnJlc3BvbmRpbmcgbWFwcGVkIGl0ZW1zLlxyXG4gICAgICogQHR5cGVQYXJhbSBUSSAtIFRhcmdldCBpdGVtIHR5cGUuXHJcbiAgICAgKiBAdHlwZVBhcmFtIFRQIC0gVGFyZ2V0IGl0ZW0gdHlwZSdzIGlkIHByb3BlcnR5IG5hbWUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGlzIGZhY3RvcnkgZm9yIGZ1cnRoZXIgY29uZmlndXJhdGlvbi5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmxhdE1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmbGF0TWFwJDEoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybWVycy5wdXNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZmxhdE1hcChpbnB1dCkuY2FsbChpbnB1dCwgY2FsbGJhY2spO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENvbm5lY3QgdGhpcyBwaXBlIHRvIGdpdmVuIGRhdGEgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgZGF0YSBzZXQgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGl0ZW1zIGZyb20gdGhpcyBwaXBlLlxyXG4gICAgICogQHJldHVybnMgVGhlIHBpcGUgY29ubmVjdGVkIGJldHdlZW4gZ2l2ZW4gZGF0YSBzZXRzIGFuZCBwZXJmb3JtaW5nXHJcbiAgICAgKiBjb25maWd1cmVkIHRyYW5zZm9ybWF0aW9uIG9uIHRoZSBwcm9jZXNzZWQgaXRlbXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvKHRhcmdldCkge1xuICAgICAgcmV0dXJuIG5ldyBTaW1wbGVEYXRhUGlwZSh0aGlzLl9zb3VyY2UsIHRoaXMuX3RyYW5zZm9ybWVycywgdGFyZ2V0KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0YVBpcGVVbmRlckNvbnN0cnVjdGlvbjtcbn0oKTtcbi8qKlxyXG4gKiBEZXRlcm1pbmUgd2hldGhlciBhIHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGlkLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBJbnB1dCB2YWx1ZSBvZiB1bmtub3duIHR5cGUuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIHZhbGlkIGlkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzSWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59XG4vKipcclxuICogQSBxdWV1ZS5cclxuICpcclxuICogQHR5cGVQYXJhbSBUIC0gVGhlIHR5cGUgb2YgbWV0aG9kIG5hbWVzIHRvIGJlIHJlcGxhY2VkIGJ5IHF1ZXVlZCB2ZXJzaW9ucy5cclxuICovXG5cblxudmFyIFF1ZXVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqIERlbGF5IGluIG1pbGxpc2Vjb25kcy4gSWYgZGVmaW5lZCB0aGUgcXVldWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgZmx1c2hlZC4gKi9cblxuICAvKiogTWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgcXVldWUgYmVmb3JlIGl0IHdpbGwgYmUgZmx1c2hlZC4gKi9cblxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgUXVldWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFF1ZXVlIGNvbmZpZ3VyYXRpb24uXHJcbiAgICovXG4gIGZ1bmN0aW9uIFF1ZXVlKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUXVldWUpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVsYXlcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3F1ZXVlXCIsIFtdKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90aW1lb3V0XCIsIG51bGwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2V4dGVuZGVkXCIsIG51bGwpO1xuXG4gICAgLy8gb3B0aW9uc1xuICAgIHRoaXMuZGVsYXkgPSBudWxsO1xuICAgIHRoaXMubWF4ID0gSW5maW5pdHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgcXVldWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFF1ZXVlIGNvbmZpZ3VyYXRpb24uXHJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUXVldWUsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5kZWxheSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMubWF4ID0gb3B0aW9ucy5tYXg7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2ZsdXNoSWZOZWVkZWQoKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmQgYW4gb2JqZWN0IHdpdGggcXVldWluZyBmdW5jdGlvbmFsaXR5LlxyXG4gICAgICogVGhlIG9iamVjdCB3aWxsIGJlIGV4dGVuZGVkIHdpdGggYSBmdW5jdGlvbiBmbHVzaCwgYW5kIHRoZSBtZXRob2RzIHByb3ZpZGVkIGluIG9wdGlvbnMucmVwbGFjZSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggcXVldWVkIG9uZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHF1ZXVlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95IHRoZSBxdWV1ZS4gVGhlIHF1ZXVlIHdpbGwgZmlyc3QgZmx1c2ggYWxsIHF1ZXVlZCBhY3Rpb25zLCBhbmQgaW4gY2FzZSBpdCBoYXMgZXh0ZW5kZWQgYW4gb2JqZWN0LCB3aWxsIHJlc3RvcmUgdGhlIG9yaWdpbmFsIG9iamVjdC5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmZsdXNoKCk7XG5cbiAgICAgIGlmICh0aGlzLl9leHRlbmRlZCkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5fZXh0ZW5kZWQub2JqZWN0O1xuICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMuX2V4dGVuZGVkLm1ldGhvZHM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG1ldGhvZCA9IG1ldGhvZHNbaV07XG5cbiAgICAgICAgICBpZiAobWV0aG9kLm9yaWdpbmFsKSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogYmV0dGVyIHNvbHV0aW9uP1xuICAgICAgICAgICAgb2JqZWN0W21ldGhvZC5uYW1lXSA9IG1ldGhvZC5vcmlnaW5hbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQFRPRE86IGJldHRlciBzb2x1dGlvbj9cbiAgICAgICAgICAgIGRlbGV0ZSBvYmplY3RbbWV0aG9kLm5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2V4dGVuZGVkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlIGEgbWV0aG9kIG9uIGFuIG9iamVjdCB3aXRoIGEgcXVldWVkIHZlcnNpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9iamVjdCAtIE9iamVjdCBoYXZpbmcgdGhlIG1ldGhvZC5cclxuICAgICAqIEBwYXJhbSBtZXRob2QgLSBUaGUgbWV0aG9kIG5hbWUuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlcGxhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZShvYmplY3QsIG1ldGhvZCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzIC0tIEZ1bmN0aW9uIHRoaXMgaXMgbmVjZXNzYXJ5IGluIHRoZSBmdW5jdGlvbiBiZWxsb3csIHNvIGNsYXNzIHRoaXMgaGFzIHRvIGJlIHNhdmVkIGludG8gYSB2YXJpYWJsZSBoZXJlLiAqL1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBvcmlnaW5hbCA9IG9iamVjdFttZXRob2RdO1xuXG4gICAgICBpZiAoIW9yaWdpbmFsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBcIiArIG1ldGhvZCArIFwiIHVuZGVmaW5lZFwiKTtcbiAgICAgIH1cblxuICAgICAgb2JqZWN0W21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhpcyBjYWxsIHRvIHRoZSBxdWV1ZVxuICAgICAgICBtZS5xdWV1ZSh7XG4gICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICBmbjogb3JpZ2luYWwsXG4gICAgICAgICAgY29udGV4dDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUXVldWUgYSBjYWxsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRyeSAtIFRoZSBmdW5jdGlvbiBvciBlbnRyeSB0byBiZSBxdWV1ZWQuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInF1ZXVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHF1ZXVlKGVudHJ5KSB7XG4gICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaCh7XG4gICAgICAgICAgZm46IGVudHJ5XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaChlbnRyeSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2ZsdXNoSWZOZWVkZWQoKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBxdWV1ZSBuZWVkcyB0byBiZSBmbHVzaGVkLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmx1c2hJZk5lZWRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmx1c2hJZk5lZWRlZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIGZsdXNoIHdoZW4gdGhlIG1heGltdW0gaXMgZXhjZWVkZWQuXG4gICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gdGhpcy5tYXgpIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgfSAvLyBmbHVzaCBhZnRlciBhIHBlcmlvZCBvZiBpbmFjdGl2aXR5IHdoZW4gYSBkZWxheSBpcyBjb25maWd1cmVkXG5cblxuICAgICAgaWYgKHRoaXMuX3RpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwICYmIHR5cGVvZiB0aGlzLmRlbGF5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0JDEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmZsdXNoKCk7XG4gICAgICAgIH0sIHRoaXMuZGVsYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIEZsdXNoIGFsbCBxdWV1ZWQgY2FsbHNcclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmx1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICB2YXIgX2NvbnRleHQ1LCBfY29udGV4dDY7XG5cbiAgICAgIGZvckVhY2gkMihfY29udGV4dDUgPSBzcGxpY2UkMShfY29udGV4dDYgPSB0aGlzLl9xdWV1ZSkuY2FsbChfY29udGV4dDYsIDApKS5jYWxsKF9jb250ZXh0NSwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGVudHJ5LmZuLmFwcGx5KGVudHJ5LmNvbnRleHQgfHwgZW50cnkuZm4sIGVudHJ5LmFyZ3MgfHwgW10pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZXh0ZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZChvYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBxdWV1ZSA9IG5ldyBRdWV1ZShvcHRpb25zKTtcblxuICAgICAgaWYgKG9iamVjdC5mbHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRhcmdldCBvYmplY3QgYWxyZWFkeSBoYXMgYSBwcm9wZXJ0eSBmbHVzaFwiKTtcbiAgICAgIH1cblxuICAgICAgb2JqZWN0LmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBxdWV1ZS5mbHVzaCgpO1xuICAgICAgfTtcblxuICAgICAgdmFyIG1ldGhvZHMgPSBbe1xuICAgICAgICBuYW1lOiBcImZsdXNoXCIsXG4gICAgICAgIG9yaWdpbmFsOiB1bmRlZmluZWRcbiAgICAgIH1dO1xuXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLnJlcGxhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdGlvbnMucmVwbGFjZVtpXTtcbiAgICAgICAgICBtZXRob2RzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIC8vIEBUT0RPOiBiZXR0ZXIgc29sdXRpb24/XG4gICAgICAgICAgICBvcmlnaW5hbDogb2JqZWN0W25hbWVdXG4gICAgICAgICAgfSk7IC8vIEBUT0RPOiBiZXR0ZXIgc29sdXRpb24/XG5cbiAgICAgICAgICBxdWV1ZS5yZXBsYWNlKG9iamVjdCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcXVldWUuX2V4dGVuZGVkID0ge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgbWV0aG9kczogbWV0aG9kc1xuICAgICAgfTtcbiAgICAgIHJldHVybiBxdWV1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUXVldWU7XG59KCk7XG4vKipcclxuICogW1tEYXRhU2V0XV0gY29kZSB0aGF0IGNhbiBiZSByZXVzZWQgaW4gW1tEYXRhVmlld11dIG9yIG90aGVyIHNpbWlsYXIgaW1wbGVtZW50YXRpb25zIG9mIFtbRGF0YUludGVyZmFjZV1dLlxyXG4gKlxyXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxyXG4gKiBAdHlwZVBhcmFtIElkUHJvcCAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIGlkLlxyXG4gKi9cblxuXG52YXIgRGF0YVNldFBhcnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEYXRhU2V0UGFydCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVNldFBhcnQpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N1YnNjcmliZXJzXCIsIHtcbiAgICAgIFwiKlwiOiBbXSxcbiAgICAgIGFkZDogW10sXG4gICAgICByZW1vdmU6IFtdLFxuICAgICAgdXBkYXRlOiBbXVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3Vic2NyaWJlXCIsIERhdGFTZXRQYXJ0LnByb3RvdHlwZS5vbik7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1bnN1YnNjcmliZVwiLCBEYXRhU2V0UGFydC5wcm90b3R5cGUub2ZmKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEYXRhU2V0UGFydCwgW3tcbiAgICBrZXk6IFwiX3RyaWdnZXJcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXIgYW4gZXZlbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBFdmVudCBuYW1lLlxyXG4gICAgICogQHBhcmFtIHBheWxvYWQgLSBFdmVudCBwYXlsb2FkLlxyXG4gICAgICogQHBhcmFtIHNlbmRlcklkIC0gSWQgb2YgdGhlIHNlbmRlci5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF90cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCBzZW5kZXJJZCkge1xuICAgICAgdmFyIF9jb250ZXh0NywgX2NvbnRleHQ4O1xuXG4gICAgICBpZiAoZXZlbnQgPT09IFwiKlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0cmlnZ2VyIGV2ZW50ICpcIik7XG4gICAgICB9XG5cbiAgICAgIGZvckVhY2gkMihfY29udGV4dDcgPSBjb25jYXQoX2NvbnRleHQ4ID0gW10pLmNhbGwoX2NvbnRleHQ4LCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdKSwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX3N1YnNjcmliZXJzW1wiKlwiXSkpKS5jYWxsKF9jb250ZXh0NywgZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgc3Vic2NyaWJlcihldmVudCwgcGF5bG9hZCwgc2VuZGVySWQgIT0gbnVsbCA/IHNlbmRlcklkIDogbnVsbCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgdG8gYW4gZXZlbnQsIGFkZCBhbiBldmVudCBsaXN0ZW5lci5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrcyBOb24tZnVuY3Rpb24gY2FsbGJhY2tzIGFyZSBpZ25vcmVkLlxyXG4gICAgICogQHBhcmFtIGV2ZW50IC0gRXZlbnQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIG1ldGhvZC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdLnB1c2goY2FsbGJhY2spO1xuICAgICAgfSAvLyBAVE9ETzogTWF5YmUgdGhyb3cgZm9yIGludmFsaWQgY2FsbGJhY2tzP1xuXG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmUgZnJvbSBhbiBldmVudCwgcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzIElmIHRoZSBzYW1lIGNhbGxiYWNrIHdhcyBzdWJzY3JpYmVkIG1vcmUgdGhhbiBvbmNlICoqYWxsKiogb2NjdXJlbmNlcyB3aWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBFdmVudCBuYW1lLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGJhY2sgbWV0aG9kLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvZmZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgdmFyIF9jb250ZXh0OTtcblxuICAgICAgdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdID0gZmlsdGVyKF9jb250ZXh0OSA9IHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XSkuY2FsbChfY29udGV4dDksIGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyICE9PSBjYWxsYmFjaztcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBvbiBpbnN0ZWFkIChQUzogRGF0YVZpZXcuc3Vic2NyaWJlID09PSBEYXRhVmlldy5vbikuXHJcbiAgICAgKi9cblxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGFTZXRQYXJ0O1xufSgpO1xuLyoqXHJcbiAqIERhdGEgc3RyZWFtXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFtbRGF0YVN0cmVhbV1dIG9mZmVycyBhbiBhbHdheXMgdXAgdG8gZGF0ZSBzdHJlYW0gb2YgaXRlbXMgZnJvbSBhIFtbRGF0YVNldF1dIG9yIFtbRGF0YVZpZXddXS5cclxuICogVGhhdCBtZWFucyB0aGF0IHRoZSBzdHJlYW0gaXMgZXZhbHVhdGVkIGF0IHRoZSB0aW1lIG9mIGl0ZXJhdGlvbiwgY29udmVyc2lvbiB0byBhbm90aGVyIGRhdGEgdHlwZSBvciB3aGVuIFtbY2FjaGVdXSBpcyBjYWxsZWQsIG5vdCB3aGVuIHRoZSBbW0RhdGFTdHJlYW1dXSB3YXMgY3JlYXRlZC5cclxuICogTXVsdGlwbGUgaW52b2NhdGlvbnMgb2YgZm9yIGV4YW1wbGUgW1t0b0l0ZW1BcnJheV1dIG1heSB5aWVsZCBkaWZmZXJlbnQgcmVzdWx0cyAoaWYgdGhlIGRhdGEgc291cmNlIGxpa2UgZm9yIGV4YW1wbGUgW1tEYXRhU2V0XV0gZ2V0cyBtb2RpZmllZCkuXHJcbiAqIEB0eXBlUGFyYW0gSXRlbSAtIFRoZSBpdGVtIHR5cGUgdGhpcyBzdHJlYW0gaXMgZ29pbmcgdG8gd29yayB3aXRoLlxyXG4gKi9cblxuXG5fU3ltYm9sJGl0ZXJhdG9yID0gaXRlcmF0b3I7XG5cbnZhciBEYXRhU3RyZWFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGRhdGEgc3RyZWFtLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHBhaXJzIC0gVGhlIGlkLCBpdGVtIHBhaXJzLlxyXG4gICAqL1xuICBmdW5jdGlvbiBEYXRhU3RyZWFtKHBhaXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFTdHJlYW0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhaXJzXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLl9wYWlycyA9IHBhaXJzO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybiBhbiBpdGVyYWJsZSBvZiBrZXksIHZhbHVlIHBhaXJzIGZvciBldmVyeSBlbnRyeSBpbiB0aGUgc3RyZWFtLlxyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKERhdGFTdHJlYW0sIFt7XG4gICAga2V5OiBfU3ltYm9sJGl0ZXJhdG9yLFxuICAgIHZhbHVlOlxuICAgIC8qI19fUFVSRV9fKi9cbiAgICByZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgdmFyIF9pdGVyYXRvciwgX3N0ZXAsIF9zdGVwJHZhbHVlLCBpZCwgaXRlbTtcblxuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gdmFsdWUkKF9jb250ZXh0MTApIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KHRoaXMuX3BhaXJzKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMC5wcmV2ID0gMTtcblxuICAgICAgICAgICAgICBfaXRlcmF0b3IucygpO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGlmICgoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9zdGVwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLCBpZCA9IF9zdGVwJHZhbHVlWzBdLCBpdGVtID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDc7XG4gICAgICAgICAgICAgIHJldHVybiBbaWQsIGl0ZW1dO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMC5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAudDAgPSBfY29udGV4dDEwW1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgX2l0ZXJhdG9yLmUoX2NvbnRleHQxMC50MCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAucHJldiA9IDE0O1xuXG4gICAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuZmluaXNoKDE0KTtcblxuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdmFsdWUsIHRoaXMsIFtbMSwgMTEsIDE0LCAxN11dKTtcbiAgICB9KVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIGtleSwgdmFsdWUgcGFpcnMgZm9yIGV2ZXJ5IGVudHJ5IGluIHRoZSBzdHJlYW0uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVudHJpZXNcIixcbiAgICB2YWx1ZTpcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgdmFyIF9pdGVyYXRvcjIsIF9zdGVwMiwgX3N0ZXAyJHZhbHVlLCBpZCwgaXRlbTtcblxuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gZW50cmllcyQoX2NvbnRleHQxMSkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KHRoaXMuX3BhaXJzKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMTtcblxuICAgICAgICAgICAgICBfaXRlcmF0b3IyLnMoKTtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBpZiAoKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksIGlkID0gX3N0ZXAyJHZhbHVlWzBdLCBpdGVtID0gX3N0ZXAyJHZhbHVlWzFdO1xuICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSA3O1xuICAgICAgICAgICAgICByZXR1cm4gW2lkLCBpdGVtXTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTEucHJldiA9IDExO1xuICAgICAgICAgICAgICBfY29udGV4dDExLnQwID0gX2NvbnRleHQxMVtcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgICAgIF9pdGVyYXRvcjIuZShfY29udGV4dDExLnQwKTtcblxuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMTQ7XG5cbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuZmluaXNoKDE0KTtcblxuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgZW50cmllcywgdGhpcywgW1sxLCAxMSwgMTQsIDE3XV0pO1xuICAgIH0pXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYW4gaXRlcmFibGUgb2Yga2V5cyBpbiB0aGUgc3RyZWFtLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJrZXlzXCIsXG4gICAgdmFsdWU6XG4gICAgLyojX19QVVJFX18qL1xuICAgIHJlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IzLCBfc3RlcDMsIF9zdGVwMyR2YWx1ZSwgaWQ7XG5cbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIGtleXMkKF9jb250ZXh0MTIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyh0aGlzLl9wYWlycyk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTIucHJldiA9IDE7XG5cbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5zKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgaWYgKChfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfc3RlcDMkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDMudmFsdWUsIDEpLCBpZCA9IF9zdGVwMyR2YWx1ZVswXTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMi5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTIudDAgPSBfY29udGV4dDEyW1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5lKF9jb250ZXh0MTIudDApO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBfY29udGV4dDEyLnByZXYgPSAxNDtcblxuICAgICAgICAgICAgICBfaXRlcmF0b3IzLmYoKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5maW5pc2goMTQpO1xuXG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBrZXlzLCB0aGlzLCBbWzEsIDExLCAxNCwgMTddXSk7XG4gICAgfSlcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhbiBpdGVyYWJsZSBvZiB2YWx1ZXMgaW4gdGhlIHN0cmVhbS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVzXCIsXG4gICAgdmFsdWU6XG4gICAgLyojX19QVVJFX18qL1xuICAgIHJlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgdmFyIF9pdGVyYXRvcjQsIF9zdGVwNCwgX3N0ZXA0JHZhbHVlLCBpdGVtO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiB2YWx1ZXMkKF9jb250ZXh0MTMpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTMucHJldiA9IF9jb250ZXh0MTMubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyh0aGlzLl9wYWlycyk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTMucHJldiA9IDE7XG5cbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5zKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgaWYgKChfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfc3RlcDQkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDQudmFsdWUsIDIpLCBpdGVtID0gX3N0ZXA0JHZhbHVlWzFdO1xuICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSA3O1xuICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTMucHJldiA9IDExO1xuICAgICAgICAgICAgICBfY29udGV4dDEzLnQwID0gX2NvbnRleHQxM1tcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgICAgIF9pdGVyYXRvcjQuZShfY29udGV4dDEzLnQwKTtcblxuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMy5wcmV2ID0gMTQ7XG5cbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuZmluaXNoKDE0KTtcblxuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdmFsdWVzLCB0aGlzLCBbWzEsIDExLCAxNCwgMTddXSk7XG4gICAgfSlcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgaWRzIGluIHRoaXMgc3RyZWFtLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBUaGUgYXJyYXkgbWF5IGNvbnRhaW4gZHVwbGljaXRpZXMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYXJyYXkgd2l0aCBhbGwgaWRzIGZyb20gdGhpcyBzdHJlYW0uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvSWRBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0lkQXJyYXkoKSB7XG4gICAgICB2YXIgX2NvbnRleHQxNDtcblxuICAgICAgcmV0dXJuIG1hcCQzKF9jb250ZXh0MTQgPSBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fcGFpcnMpKS5jYWxsKF9jb250ZXh0MTQsIGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgIHJldHVybiBwYWlyWzBdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBpdGVtcyBpbiB0aGlzIHN0cmVhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogVGhlIGFycmF5IG1heSBjb250YWluIGR1cGxpY2l0aWVzLlxyXG4gICAgICogQHJldHVybnMgVGhlIGFycmF5IHdpdGggYWxsIGl0ZW1zIGZyb20gdGhpcyBzdHJlYW0uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvSXRlbUFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSXRlbUFycmF5KCkge1xuICAgICAgdmFyIF9jb250ZXh0MTU7XG5cbiAgICAgIHJldHVybiBtYXAkMyhfY29udGV4dDE1ID0gX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX3BhaXJzKSkuY2FsbChfY29udGV4dDE1LCBmdW5jdGlvbiAocGFpcikge1xuICAgICAgICByZXR1cm4gcGFpclsxXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgZW50cmllcyBpbiB0aGlzIHN0cmVhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogVGhlIGFycmF5IG1heSBjb250YWluIGR1cGxpY2l0aWVzLlxyXG4gICAgICogQHJldHVybnMgVGhlIGFycmF5IHdpdGggYWxsIGVudHJpZXMgZnJvbSB0aGlzIHN0cmVhbS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9FbnRyeUFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvRW50cnlBcnJheSgpIHtcbiAgICAgIHJldHVybiBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fcGFpcnMpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybiBhbiBvYmplY3QgbWFwIGNvbnRhaW5pbmcgYWxsIHRoZSBpdGVtcyBpbiB0aGlzIHN0cmVhbSBhY2Nlc3NpYmxlIGJ5IGlkcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogSW4gY2FzZSBvZiBkdXBsaWNhdGUgaWRzIChjb2VyY2VkIHRvIHN0cmluZyBzbyBgNyA9PSAnNydgKSB0aGUgbGFzdCBlbmNvdXRlcmVkIGFwcGVhcnMgaW4gdGhlIHJldHVybmVkIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBvYmplY3QgbWFwIG9mIGFsbCBpZCDihpIgaXRlbSBwYWlycyBmcm9tIHRoaXMgc3RyZWFtLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b09iamVjdE1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b09iamVjdE1hcCgpIHtcbiAgICAgIHZhciBtYXAgPSBjcmVhdGUkNShudWxsKTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KHRoaXMuX3BhaXJzKSxcbiAgICAgICAgICBfc3RlcDU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwNSR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNS52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIGlkID0gX3N0ZXA1JHZhbHVlWzBdLFxuICAgICAgICAgICAgICBpdGVtID0gX3N0ZXA1JHZhbHVlWzFdO1xuXG4gICAgICAgICAgbWFwW2lkXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIG1hcCBjb250YWluaW5nIGFsbCB0aGUgaXRlbXMgaW4gdGhpcyBzdHJlYW0gYWNjZXNzaWJsZSBieSBpZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1hcCBvZiBhbGwgaWQg4oaSIGl0ZW0gcGFpcnMgZnJvbSB0aGlzIHN0cmVhbS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9NYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9NYXAoKSB7XG4gICAgICByZXR1cm4gbmV3IG1hcCh0aGlzLl9wYWlycyk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgc2V0IGNvbnRhaW5pbmcgYWxsIHRoZSAodW5pcXVlKSBpZHMgaW4gdGhpcyBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIHNldCBvZiBhbGwgaWRzIGZyb20gdGhpcyBzdHJlYW0uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvSWRTZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9JZFNldCgpIHtcbiAgICAgIHJldHVybiBuZXcgc2V0KHRoaXMudG9JZEFycmF5KCkpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHNldCBjb250YWluaW5nIGFsbCB0aGUgKHVuaXF1ZSkgaXRlbXMgaW4gdGhpcyBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIHNldCBvZiBhbGwgaXRlbXMgZnJvbSB0aGlzIHN0cmVhbS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9JdGVtU2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSXRlbVNldCgpIHtcbiAgICAgIHJldHVybiBuZXcgc2V0KHRoaXMudG9JdGVtQXJyYXkoKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ2FjaGUgdGhlIGl0ZW1zIGZyb20gdGhpcyBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyBmb3IgaXRlbXMgdG8gYmUgZmV0Y2hlZCBpbW1lZGlhdGVsbHkgYW5kIHVzZWQgKHBvc3NpYmx5IG11bHRpcGxlIHRpbWVzKSBsYXRlci5cclxuICAgICAqIEl0IGNhbiBhbHNvIGJlIHVzZWQgdG8gb3B0aW1pemUgcGVyZm9ybWFuY2UgYXMgW1tEYXRhU3RyZWFtXV0gd291bGQgb3RoZXJ3aXNlIHJlZXZhbHVhdGUgZXZlcnl0aGluZyB1cG9uIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqICMjIEV4YW1wbGVcclxuICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAqIGNvbnN0IGRzID0gbmV3IERhdGFTZXQoW+KApl0pXHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgY2FjaGVkU3RyZWFtID0gZHMuc3RyZWFtKClcclxuICAgICAqICAgLmZpbHRlcijigKYpXHJcbiAgICAgKiAgIC5zb3J0KOKApilcclxuICAgICAqICAgLm1hcCjigKYpXHJcbiAgICAgKiAgIC5jYWNoZWQo4oCmKSAvLyBEYXRhIGFyZSBmZXRjaGVkLCBwcm9jZXNzZWQgYW5kIGNhY2hlZCBoZXJlLlxyXG4gICAgICpcclxuICAgICAqIGRzLmNsZWFyKClcclxuICAgICAqIGNoYWNoZWRTdHJlYW0gLy8gU3RpbGwgaGFzIGFsbCB0aGUgaXRlbXMuXHJcbiAgICAgKiBgYGBcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IFtbRGF0YVN0cmVhbV1dIHdpdGggY2FjaGVkIGl0ZW1zIChkZXRhY2hlZCBmcm9tIHRoZSBvcmlnaW5hbCBbW0RhdGFTZXRdXSkuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhY2hlKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRhU3RyZWFtKF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9wYWlycykpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZGlzdGluY3QgdmFsdWVzIG9mIGdpdmVuIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IHBpY2tzIGFuZCBwb3NzaWJseSBjb252ZXJ0cyB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBAdHlwZVBhcmFtIFQgLSBUaGUgdHlwZSBvZiB0aGUgZGlzdGluY3QgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyBBIHNldCBvZiBhbGwgZGlzdGluY3QgcHJvcGVydGllcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGluY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGluY3QoY2FsbGJhY2spIHtcbiAgICAgIHZhciBzZXQkMSA9IG5ldyBzZXQoKTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KHRoaXMuX3BhaXJzKSxcbiAgICAgICAgICBfc3RlcDY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwNiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNi52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIGlkID0gX3N0ZXA2JHZhbHVlWzBdLFxuICAgICAgICAgICAgICBpdGVtID0gX3N0ZXA2JHZhbHVlWzFdO1xuXG4gICAgICAgICAgc2V0JDEuYWRkKGNhbGxiYWNrKGl0ZW0sIGlkKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0JDE7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRmlsdGVyIHRoZSBpdGVtcyBvZiB0aGUgc3RyZWFtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IGRlY2lkZXMgd2hldGhlciBhbiBpdGVtIHdpbGwgYmUgaW5jbHVkZWQuXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBkYXRhIHN0cmVhbSB3aXRoIHRoZSBmaWx0ZXJlZCBpdGVtcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFjaykge1xuICAgICAgdmFyIHBhaXJzID0gdGhpcy5fcGFpcnM7XG4gICAgICByZXR1cm4gbmV3IERhdGFTdHJlYW0oX2RlZmluZVByb3BlcnR5KHt9LCBpdGVyYXRvciwgLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjcsIF9zdGVwNywgX3N0ZXA3JHZhbHVlLCBpZCwgaXRlbTtcblxuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dDE2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNi5wcmV2ID0gX2NvbnRleHQxNi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhwYWlycyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNi5wcmV2ID0gMTtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjcucygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoKF9zdGVwNyA9IF9pdGVyYXRvcjcubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9zdGVwNyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNy52YWx1ZSwgMiksIGlkID0gX3N0ZXA3JHZhbHVlWzBdLCBpdGVtID0gX3N0ZXA3JHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFjayhpdGVtLCBpZCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIHJldHVybiBbaWQsIGl0ZW1dO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNi5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDE2LnByZXYgPSAxMjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE2LnQwID0gX2NvbnRleHQxNltcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yNy5lKF9jb250ZXh0MTYudDApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNi5wcmV2ID0gMTU7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3I3LmYoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LmZpbmlzaCgxNSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMSwgMTIsIDE1LCAxOF1dKTtcbiAgICAgIH0pKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBlYWNoIGl0ZW0gb2YgdGhlIHN0cmVhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgZm9yIGVhY2ggaXRlbS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcodGhpcy5fcGFpcnMpLFxuICAgICAgICAgIF9zdGVwODtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXA4JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA4LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgaWQgPSBfc3RlcDgkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIGl0ZW0gPSBfc3RlcDgkdmFsdWVbMV07XG5cbiAgICAgICAgICBjYWxsYmFjayhpdGVtLCBpZCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I4LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjguZigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIE1hcCB0aGUgaXRlbXMgaW50byBhIGRpZmZlcmVudCB0eXBlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IGRvZXMgdGhlIGNvbnZlcnNpb24uXHJcbiAgICAgKiBAdHlwZVBhcmFtIE1hcHBlZCAtIFRoZSB0eXBlIG9mIHRoZSBpdGVtIGFmdGVyIG1hcHBpbmcuXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBkYXRhIHN0cmVhbSB3aXRoIHRoZSBtYXBwZWQgaXRlbXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBwYWlycyA9IHRoaXMuX3BhaXJzO1xuICAgICAgcmV0dXJuIG5ldyBEYXRhU3RyZWFtKF9kZWZpbmVQcm9wZXJ0eSh7fSwgaXRlcmF0b3IsIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yOSwgX3N0ZXA5LCBfc3RlcDkkdmFsdWUsIGlkLCBpdGVtO1xuXG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDE3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNy5wcmV2ID0gX2NvbnRleHQxNy5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3I5ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhwYWlycyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNy5wcmV2ID0gMTtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjkucygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoKF9zdGVwOSA9IF9pdGVyYXRvcjkubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3N0ZXA5JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA5LnZhbHVlLCAyKSwgaWQgPSBfc3RlcDkkdmFsdWVbMF0sIGl0ZW0gPSBfc3RlcDkkdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICByZXR1cm4gW2lkLCBjYWxsYmFjayhpdGVtLCBpZCldO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTcucHJldiA9IDExO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTcudDAgPSBfY29udGV4dDE3W1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3I5LmUoX2NvbnRleHQxNy50MCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDE3LnByZXYgPSAxNDtcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjkuZigpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTcuZmluaXNoKDE0KTtcblxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTcuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbMSwgMTEsIDE0LCAxN11dKTtcbiAgICAgIH0pKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBpdGVtIHdpdGggdGhlIG1heGltdW0gdmFsdWUgb2YgZ2l2ZW4gcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRoYXQgcGlja3MgYW5kIHBvc3NpYmx5IGNvbnZlcnRzIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBpdGVtIHdpdGggdGhlIG1heGltdW0gaWYgZm91bmQgb3RoZXJ3aXNlIG51bGwuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1heFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXgoY2FsbGJhY2spIHtcbiAgICAgIHZhciBpdGVyID0gZ2V0SXRlcmF0b3IodGhpcy5fcGFpcnMpO1xuXG4gICAgICB2YXIgY3VyciA9IGl0ZXIubmV4dCgpO1xuXG4gICAgICBpZiAoY3Vyci5kb25lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF4SXRlbSA9IGN1cnIudmFsdWVbMV07XG4gICAgICB2YXIgbWF4VmFsdWUgPSBjYWxsYmFjayhjdXJyLnZhbHVlWzFdLCBjdXJyLnZhbHVlWzBdKTtcblxuICAgICAgd2hpbGUgKCEoY3VyciA9IGl0ZXIubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIHZhciBfY3VyciR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KGN1cnIudmFsdWUsIDIpLFxuICAgICAgICAgICAgaWQgPSBfY3VyciR2YWx1ZVswXSxcbiAgICAgICAgICAgIGl0ZW0gPSBfY3VyciR2YWx1ZVsxXTtcblxuICAgICAgICB2YXIgX3ZhbHVlID0gY2FsbGJhY2soaXRlbSwgaWQpO1xuXG4gICAgICAgIGlmIChfdmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgICAgICAgIG1heFZhbHVlID0gX3ZhbHVlO1xuICAgICAgICAgIG1heEl0ZW0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXhJdGVtO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaXRlbSB3aXRoIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGdpdmVuIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IHBpY2tzIGFuZCBwb3NzaWJseSBjb252ZXJ0cyB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSB3aXRoIHRoZSBtaW5pbXVtIGlmIGZvdW5kIG90aGVyd2lzZSBudWxsLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaXRlciA9IGdldEl0ZXJhdG9yKHRoaXMuX3BhaXJzKTtcblxuICAgICAgdmFyIGN1cnIgPSBpdGVyLm5leHQoKTtcblxuICAgICAgaWYgKGN1cnIuZG9uZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG1pbkl0ZW0gPSBjdXJyLnZhbHVlWzFdO1xuICAgICAgdmFyIG1pblZhbHVlID0gY2FsbGJhY2soY3Vyci52YWx1ZVsxXSwgY3Vyci52YWx1ZVswXSk7XG5cbiAgICAgIHdoaWxlICghKGN1cnIgPSBpdGVyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICB2YXIgX2N1cnIkdmFsdWUyID0gX3NsaWNlZFRvQXJyYXkoY3Vyci52YWx1ZSwgMiksXG4gICAgICAgICAgICBpZCA9IF9jdXJyJHZhbHVlMlswXSxcbiAgICAgICAgICAgIGl0ZW0gPSBfY3VyciR2YWx1ZTJbMV07XG5cbiAgICAgICAgdmFyIF92YWx1ZTIgPSBjYWxsYmFjayhpdGVtLCBpZCk7XG5cbiAgICAgICAgaWYgKF92YWx1ZTIgPCBtaW5WYWx1ZSkge1xuICAgICAgICAgIG1pblZhbHVlID0gX3ZhbHVlMjtcbiAgICAgICAgICBtaW5JdGVtID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWluSXRlbTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZWR1Y2UgdGhlIGl0ZW1zIGludG8gYSBzaW5nbGUgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRoYXQgZG9lcyB0aGUgcmVkdWN0aW9uLlxyXG4gICAgICogQHBhcmFtIGFjY3VtdWxhdG9yIC0gVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxyXG4gICAgICogQHR5cGVQYXJhbSBUIC0gVGhlIHR5cGUgb2YgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMgVGhlIHJlZHVjZWQgdmFsdWUuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlZHVjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2ssIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yMTAgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KHRoaXMuX3BhaXJzKSxcbiAgICAgICAgICBfc3RlcDEwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjEwLnMoKTsgIShfc3RlcDEwID0gX2l0ZXJhdG9yMTAubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDEwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAxMC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIGlkID0gX3N0ZXAxMCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgaXRlbSA9IF9zdGVwMTAkdmFsdWVbMV07XG5cbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBpdGVtLCBpZCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxMC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxMC5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTb3J0IHRoZSBpdGVtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBJdGVtIGNvbXBhcmF0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBzdHJlYW0gd2l0aCBzb3J0ZWQgaXRlbXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29ydCQxKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBEYXRhU3RyZWFtKF9kZWZpbmVQcm9wZXJ0eSh7fSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MTg7XG5cbiAgICAgICAgcmV0dXJuIGdldEl0ZXJhdG9yKHNvcnQoX2NvbnRleHQxOCA9IF90b0NvbnN1bWFibGVBcnJheShfdGhpczIuX3BhaXJzKSkuY2FsbChfY29udGV4dDE4LCBmdW5jdGlvbiAoX3JlZiwgX3JlZjIpIHtcbiAgICAgICAgICB2YXIgX3JlZjMgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgICAgaWRBID0gX3JlZjNbMF0sXG4gICAgICAgICAgICAgIGl0ZW1BID0gX3JlZjNbMV07XG5cbiAgICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMiwgMiksXG4gICAgICAgICAgICAgIGlkQiA9IF9yZWY0WzBdLFxuICAgICAgICAgICAgICBpdGVtQiA9IF9yZWY0WzFdO1xuXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGl0ZW1BLCBpdGVtQiwgaWRBLCBpZEIpO1xuICAgICAgICB9KSk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGFTdHJlYW07XG59KCk7XG4vKipcclxuICogQWRkIGFuIGlkIHRvIGdpdmVuIGl0ZW0gaWYgaXQgZG9lc24ndCBoYXZlIG9uZSBhbHJlYWR5LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGUgaXRlbSB3aWxsIGJlIG1vZGlmaWVkLlxyXG4gKiBAcGFyYW0gaXRlbSAtIFRoZSBpdGVtIHRoYXQgd2lsbCBoYXZlIGFuIGlkIGFmdGVyIGEgY2FsbCB0byB0aGlzIGZ1bmN0aW9uLlxyXG4gKiBAcGFyYW0gaWRQcm9wIC0gVGhlIGtleSBvZiB0aGUgaWQgcHJvcGVydHkuXHJcbiAqIEB0eXBlUGFyYW0gSXRlbSAtIEl0ZW0gdHlwZSB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgYW4gaWQuXHJcbiAqIEB0eXBlUGFyYW0gSWRQcm9wIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgaWQuXHJcbiAqIEByZXR1cm5zIHRydWVcclxuICovXG5cblxuZnVuY3Rpb24gZW5zdXJlRnVsbEl0ZW0oaXRlbSwgaWRQcm9wKSB7XG4gIGlmIChpdGVtW2lkUHJvcF0gPT0gbnVsbCkge1xuICAgIC8vIGdlbmVyYXRlIGFuIGlkXG4gICAgaXRlbVtpZFByb3BdID0gdjQoKTtcbiAgfVxuXG4gIHJldHVybiBpdGVtO1xufVxuLyoqXHJcbiAqICMgRGF0YVNldFxyXG4gKlxyXG4gKiBWaXMuanMgY29tZXMgd2l0aCBhIGZsZXhpYmxlIERhdGFTZXQsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGhvbGQgYW5kXHJcbiAqIG1hbmlwdWxhdGUgdW5zdHJ1Y3R1cmVkIGRhdGEgYW5kIGxpc3RlbiBmb3IgY2hhbmdlcyBpbiB0aGUgZGF0YS4gVGhlIERhdGFTZXRcclxuICogaXMga2V5L3ZhbHVlIGJhc2VkLiBEYXRhIGl0ZW1zIGNhbiBiZSBhZGRlZCwgdXBkYXRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZVxyXG4gKiBEYXRhU2V0LCBhbmQgb25lIGNhbiBzdWJzY3JpYmUgdG8gY2hhbmdlcyBpbiB0aGUgRGF0YVNldC4gVGhlIGRhdGEgaW4gdGhlXHJcbiAqIERhdGFTZXQgY2FuIGJlIGZpbHRlcmVkIGFuZCBvcmRlcmVkLiBEYXRhIGNhbiBiZSBub3JtYWxpemVkIHdoZW4gYXBwZW5kaW5nIGl0XHJcbiAqIHRvIHRoZSBEYXRhU2V0IGFzIHdlbGwuXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVcclxuICpcclxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byB1c2UgYSBEYXRhU2V0LlxyXG4gKlxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIGNyZWF0ZSBhIERhdGFTZXRcclxuICogdmFyIG9wdGlvbnMgPSB7fTtcclxuICogdmFyIGRhdGEgPSBuZXcgdmlzLkRhdGFTZXQob3B0aW9ucyk7XHJcbiAqXHJcbiAqIC8vIGFkZCBpdGVtc1xyXG4gKiAvLyBub3RlIHRoYXQgdGhlIGRhdGEgaXRlbXMgY2FuIGNvbnRhaW4gZGlmZmVyZW50IHByb3BlcnRpZXMgYW5kIGRhdGEgZm9ybWF0c1xyXG4gKiBkYXRhLmFkZChbXHJcbiAqICAge2lkOiAxLCB0ZXh0OiAnaXRlbSAxJywgZGF0ZTogbmV3IERhdGUoMjAxMywgNiwgMjApLCBncm91cDogMSwgZmlyc3Q6IHRydWV9LFxyXG4gKiAgIHtpZDogMiwgdGV4dDogJ2l0ZW0gMicsIGRhdGU6ICcyMDEzLTA2LTIzJywgZ3JvdXA6IDJ9LFxyXG4gKiAgIHtpZDogMywgdGV4dDogJ2l0ZW0gMycsIGRhdGU6ICcyMDEzLTA2LTI1JywgZ3JvdXA6IDJ9LFxyXG4gKiAgIHtpZDogNCwgdGV4dDogJ2l0ZW0gNCd9XHJcbiAqIF0pO1xyXG4gKlxyXG4gKiAvLyBzdWJzY3JpYmUgdG8gYW55IGNoYW5nZSBpbiB0aGUgRGF0YVNldFxyXG4gKiBkYXRhLm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50LCBwcm9wZXJ0aWVzLCBzZW5kZXJJZCkge1xyXG4gKiAgIGNvbnNvbGUubG9nKCdldmVudCcsIGV2ZW50LCBwcm9wZXJ0aWVzKTtcclxuICogfSk7XHJcbiAqXHJcbiAqIC8vIHVwZGF0ZSBhbiBleGlzdGluZyBpdGVtXHJcbiAqIGRhdGEudXBkYXRlKHtpZDogMiwgZ3JvdXA6IDF9KTtcclxuICpcclxuICogLy8gcmVtb3ZlIGFuIGl0ZW1cclxuICogZGF0YS5yZW1vdmUoNCk7XHJcbiAqXHJcbiAqIC8vIGdldCBhbGwgaWRzXHJcbiAqIHZhciBpZHMgPSBkYXRhLmdldElkcygpO1xyXG4gKiBjb25zb2xlLmxvZygnaWRzJywgaWRzKTtcclxuICpcclxuICogLy8gZ2V0IGEgc3BlY2lmaWMgaXRlbVxyXG4gKiB2YXIgaXRlbTEgPSBkYXRhLmdldCgxKTtcclxuICogY29uc29sZS5sb2coJ2l0ZW0xJywgaXRlbTEpO1xyXG4gKlxyXG4gKiAvLyByZXRyaWV2ZSBhIGZpbHRlcmVkIHN1YnNldCBvZiB0aGUgZGF0YVxyXG4gKiB2YXIgaXRlbXMgPSBkYXRhLmdldCh7XHJcbiAqICAgZmlsdGVyOiBmdW5jdGlvbiAoaXRlbSkge1xyXG4gKiAgICAgcmV0dXJuIGl0ZW0uZ3JvdXAgPT0gMTtcclxuICogICB9XHJcbiAqIH0pO1xyXG4gKiBjb25zb2xlLmxvZygnZmlsdGVyZWQgaXRlbXMnLCBpdGVtcyk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxyXG4gKiBAdHlwZVBhcmFtIElkUHJvcCAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIGlkLlxyXG4gKi9cblxuXG52YXIgRGF0YVNldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0RhdGFTZXRQYXJ0KSB7XG4gIF9pbmhlcml0cyhEYXRhU2V0LCBfRGF0YVNldFBhcnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkdChEYXRhU2V0KTtcblxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgRGF0YVNldC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBkYXRhIC0gSW5pdGlhbCBkYXRhIG9yIG9wdGlvbnMuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zICh0eXBlIGVycm9yIGlmIGRhdGEgaXMgYWxzbyBvcHRpb25zKS5cclxuICAgKi9cbiAgZnVuY3Rpb24gRGF0YVNldChkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhU2V0KTtcblxuICAgIF90aGlzMyA9IF9zdXBlci5jYWxsKHRoaXMpOyAvLyBjb3JyZWN0bHkgcmVhZCBvcHRpb25hbCBhcmd1bWVudHNcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIFwiZmx1c2hcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIFwibGVuZ3RoXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBcIl9vcHRpb25zXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBcIl9kYXRhXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBcIl9pZFByb3BcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIFwiX3F1ZXVlXCIsIG51bGwpO1xuXG4gICAgaWYgKGRhdGEgJiYgIWlzQXJyYXkkMihkYXRhKSkge1xuICAgICAgb3B0aW9ucyA9IGRhdGE7XG4gICAgICBkYXRhID0gW107XG4gICAgfVxuXG4gICAgX3RoaXMzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfdGhpczMuX2RhdGEgPSBuZXcgbWFwKCk7IC8vIG1hcCB3aXRoIGRhdGEgaW5kZXhlZCBieSBpZFxuXG4gICAgX3RoaXMzLmxlbmd0aCA9IDA7IC8vIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgRGF0YVNldFxuXG4gICAgX3RoaXMzLl9pZFByb3AgPSBfdGhpczMuX29wdGlvbnMuZmllbGRJZCB8fCBcImlkXCI7IC8vIG5hbWUgb2YgdGhlIGZpZWxkIGNvbnRhaW5pbmcgaWRcbiAgICAvLyBhZGQgaW5pdGlhbCBkYXRhIHdoZW4gcHJvdmlkZWRcblxuICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgICBfdGhpczMuYWRkKGRhdGEpO1xuICAgIH1cblxuICAgIF90aGlzMy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuICAvKipcclxuICAgKiBTZXQgbmV3IG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBuZXcgb3B0aW9ucy5cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhEYXRhU2V0LCBbe1xuICAgIGtleTogXCJpZFByb3BcIixcbiAgICBnZXQ6XG4gICAgLyoqIEZsdXNoIGFsbCBxdWV1ZWQgY2FsbHMuICovXG5cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pZFByb3A7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnF1ZXVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucXVldWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gZGVsZXRlIHF1ZXVlIGlmIGxvYWRlZFxuICAgICAgICAgIGlmICh0aGlzLl9xdWV1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWUuZGVzdHJveSgpO1xuXG4gICAgICAgICAgICB0aGlzLl9xdWV1ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNyZWF0ZSBxdWV1ZSBhbmQgdXBkYXRlIGl0cyBvcHRpb25zXG4gICAgICAgICAgaWYgKCF0aGlzLl9xdWV1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWUgPSBRdWV1ZS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgICByZXBsYWNlOiBbXCJhZGRcIiwgXCJ1cGRhdGVcIiwgXCJyZW1vdmVcIl1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLnF1ZXVlICYmIF90eXBlb2Yob3B0aW9ucy5xdWV1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnNldE9wdGlvbnMob3B0aW9ucy5xdWV1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgZGF0YSBpdGVtIG9yIGFuIGFycmF5IHdpdGggaXRlbXMuXHJcbiAgICAgKlxyXG4gICAgICogQWZ0ZXIgdGhlIGl0ZW1zIGFyZSBhZGRlZCB0byB0aGUgRGF0YVNldCwgdGhlIERhdGFTZXQgd2lsbCB0cmlnZ2VyIGFuIGV2ZW50IGBhZGRgLiBXaGVuIGEgYHNlbmRlcklkYCBpcyBwcm92aWRlZCwgdGhpcyBpZCB3aWxsIGJlIHBhc3NlZCB3aXRoIHRoZSB0cmlnZ2VyZWQgZXZlbnQgdG8gYWxsIHN1YnNjcmliZXJzLlxyXG4gICAgICpcclxuICAgICAqICMjIEV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgKiAvLyBjcmVhdGUgYSBEYXRhU2V0XHJcbiAgICAgKiBjb25zdCBkYXRhID0gbmV3IHZpcy5EYXRhU2V0KClcclxuICAgICAqXHJcbiAgICAgKiAvLyBhZGQgaXRlbXNcclxuICAgICAqIGNvbnN0IGlkcyA9IGRhdGEuYWRkKFtcclxuICAgICAqICAgeyBpZDogMSwgdGV4dDogJ2l0ZW0gMScgfSxcclxuICAgICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMicgfSxcclxuICAgICAqICAgeyB0ZXh0OiAnaXRlbSB3aXRob3V0IGFuIGlkJyB9XHJcbiAgICAgKiBdKVxyXG4gICAgICpcclxuICAgICAqIGNvbnNvbGUubG9nKGlkcykgLy8gWzEsIDIsICc8VVVJRHY0PiddXHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIEl0ZW1zIHRvIGJlIGFkZGVkIChpZHMgd2lsbCBiZSBnZW5lcmF0ZWQgaWYgbWlzc2luZykuXHJcbiAgICAgKiBAcGFyYW0gc2VuZGVySWQgLSBTZW5kZXIgaWQuXHJcbiAgICAgKiBAcmV0dXJucyBhZGRlZElkcyAtIEFycmF5IHdpdGggdGhlIGlkcyAoZ2VuZXJhdGVkIGlmIG5vdCBwcmVzZW50KSBvZiB0aGUgYWRkZWQgaXRlbXMuXHJcbiAgICAgKiBAdGhyb3dzIFdoZW4gYW4gaXRlbSB3aXRoIHRoZSBzYW1lIGlkIGFzIGFueSBvZiB0aGUgYWRkZWQgaXRlbXMgYWxyZWFkeSBleGlzdHMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZGF0YSwgc2VuZGVySWQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgYWRkZWRJZHMgPSBbXTtcbiAgICAgIHZhciBpZDtcblxuICAgICAgaWYgKGlzQXJyYXkkMihkYXRhKSkge1xuICAgICAgICAvLyBBcnJheVxuICAgICAgICB2YXIgaWRzVG9BZGQgPSBtYXAkMyhkYXRhKS5jYWxsKGRhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGRbX3RoaXM0Ll9pZFByb3BdO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc29tZShpZHNUb0FkZCkuY2FsbChpZHNUb0FkZCwgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5fZGF0YS5oYXMoaWQpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgZHVwbGljYXRlIGlkIHdhcyBmb3VuZCBpbiB0aGUgcGFyYW1ldGVyIGFycmF5LlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWQgPSB0aGlzLl9hZGRJdGVtKGRhdGFbaV0pO1xuICAgICAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgJiYgX3R5cGVvZihkYXRhKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBTaW5nbGUgaXRlbVxuICAgICAgICBpZCA9IHRoaXMuX2FkZEl0ZW0oZGF0YSk7XG4gICAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhVHlwZVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyKFwiYWRkXCIsIHtcbiAgICAgICAgICBpdGVtczogYWRkZWRJZHNcbiAgICAgICAgfSwgc2VuZGVySWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWRkZWRJZHM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGV4aXN0aW5nIGl0ZW1zLiBXaGVuIGFuIGl0ZW0gZG9lcyBub3QgZXhpc3QsIGl0IHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogVGhlIHByb3ZpZGVkIHByb3BlcnRpZXMgd2lsbCBiZSBtZXJnZWQgaW4gdGhlIGV4aXN0aW5nIGl0ZW0uIFdoZW4gYW4gaXRlbSBkb2VzIG5vdCBleGlzdCwgaXQgd2lsbCBiZSBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEFmdGVyIHRoZSBpdGVtcyBhcmUgdXBkYXRlZCwgdGhlIERhdGFTZXQgd2lsbCB0cmlnZ2VyIGFuIGV2ZW50IGBhZGRgIGZvciB0aGUgYWRkZWQgaXRlbXMsIGFuZCBhbiBldmVudCBgdXBkYXRlYC4gV2hlbiBhIGBzZW5kZXJJZGAgaXMgcHJvdmlkZWQsIHRoaXMgaWQgd2lsbCBiZSBwYXNzZWQgd2l0aCB0aGUgdHJpZ2dlcmVkIGV2ZW50IHRvIGFsbCBzdWJzY3JpYmVycy5cclxuICAgICAqXHJcbiAgICAgKiAjIyBFeGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICogLy8gY3JlYXRlIGEgRGF0YVNldFxyXG4gICAgICogY29uc3QgZGF0YSA9IG5ldyB2aXMuRGF0YVNldChbXHJcbiAgICAgKiAgIHsgaWQ6IDEsIHRleHQ6ICdpdGVtIDEnIH0sXHJcbiAgICAgKiAgIHsgaWQ6IDIsIHRleHQ6ICdpdGVtIDInIH0sXHJcbiAgICAgKiAgIHsgaWQ6IDMsIHRleHQ6ICdpdGVtIDMnIH1cclxuICAgICAqIF0pXHJcbiAgICAgKlxyXG4gICAgICogLy8gdXBkYXRlIGl0ZW1zXHJcbiAgICAgKiBjb25zdCBpZHMgPSBkYXRhLnVwZGF0ZShbXHJcbiAgICAgKiAgIHsgaWQ6IDIsIHRleHQ6ICdpdGVtIDIgKHVwZGF0ZWQpJyB9LFxyXG4gICAgICogICB7IGlkOiA0LCB0ZXh0OiAnaXRlbSA0IChuZXcpJyB9XHJcbiAgICAgKiBdKVxyXG4gICAgICpcclxuICAgICAqIGNvbnNvbGUubG9nKGlkcykgLy8gWzIsIDRdXHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiAjIyBXYXJuaW5nIGZvciBUeXBlU2NyaXB0IHVzZXJzXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXkgaW50cm9kdWNlIHBhcnRpYWwgaXRlbXMgaW50byB0aGUgZGF0YSBzZXQuIFVzZSBhZGQgb3IgdXBkYXRlT25seSBpbnN0ZWFkIGZvciBiZXR0ZXIgdHlwZSBzYWZldHkuXHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIEl0ZW1zIHRvIGJlIHVwZGF0ZWQgKGlmIHRoZSBpZCBpcyBhbHJlYWR5IHByZXNlbnQpIG9yIGFkZGVkIChpZiB0aGUgaWQgaXMgbWlzc2luZykuXHJcbiAgICAgKiBAcGFyYW0gc2VuZGVySWQgLSBTZW5kZXIgaWQuXHJcbiAgICAgKiBAcmV0dXJucyB1cGRhdGVkSWRzIC0gVGhlIGlkcyBvZiB0aGUgYWRkZWQgKHRoZXNlIG1heSBiZSBuZXdseSBnZW5lcmF0ZWQgaWYgdGhlcmUgd2FzIG5vIGlkIGluIHRoZSBpdGVtIGZyb20gdGhlIGRhdGEpIG9yIHVwZGF0ZWQgaXRlbXMuXHJcbiAgICAgKiBAdGhyb3dzIFdoZW4gdGhlIHN1cHBsaWVkIGRhdGEgaXMgbmVpdGhlciBhbiBpdGVtIG5vciBhbiBhcnJheSBvZiBpdGVtcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShkYXRhLCBzZW5kZXJJZCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBhZGRlZElkcyA9IFtdO1xuICAgICAgdmFyIHVwZGF0ZWRJZHMgPSBbXTtcbiAgICAgIHZhciBvbGREYXRhID0gW107XG4gICAgICB2YXIgdXBkYXRlZERhdGEgPSBbXTtcbiAgICAgIHZhciBpZFByb3AgPSB0aGlzLl9pZFByb3A7XG5cbiAgICAgIHZhciBhZGRPclVwZGF0ZSA9IGZ1bmN0aW9uIGFkZE9yVXBkYXRlKGl0ZW0pIHtcbiAgICAgICAgdmFyIG9yaWdJZCA9IGl0ZW1baWRQcm9wXTtcblxuICAgICAgICBpZiAob3JpZ0lkICE9IG51bGwgJiYgX3RoaXM1Ll9kYXRhLmhhcyhvcmlnSWQpKSB7XG4gICAgICAgICAgdmFyIGZ1bGxJdGVtID0gaXRlbTsgLy8gaXQgaGFzIGFuIGlkLCB0aGVyZWZvcmUgaXQgaXMgYSBmdWxsaXRlbVxuXG4gICAgICAgICAgdmFyIG9sZEl0ZW0gPSBhc3NpZ24kMih7fSwgX3RoaXM1Ll9kYXRhLmdldChvcmlnSWQpKTsgLy8gdXBkYXRlIGl0ZW1cblxuXG4gICAgICAgICAgdmFyIGlkID0gX3RoaXM1Ll91cGRhdGVJdGVtKGZ1bGxJdGVtKTtcblxuICAgICAgICAgIHVwZGF0ZWRJZHMucHVzaChpZCk7XG4gICAgICAgICAgdXBkYXRlZERhdGEucHVzaChmdWxsSXRlbSk7XG4gICAgICAgICAgb2xkRGF0YS5wdXNoKG9sZEl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFkZCBuZXcgaXRlbVxuICAgICAgICAgIHZhciBfaWQgPSBfdGhpczUuX2FkZEl0ZW0oaXRlbSk7XG5cbiAgICAgICAgICBhZGRlZElkcy5wdXNoKF9pZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChpc0FycmF5JDIoZGF0YSkpIHtcbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoZGF0YVtpXSAmJiBfdHlwZW9mKGRhdGFbaV0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBhZGRPclVwZGF0ZShkYXRhW2ldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiSWdub3JpbmcgaW5wdXQgaXRlbSwgd2hpY2ggaXMgbm90IGFuIG9iamVjdCBhdCBpbmRleCBcIiArIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhICYmIF90eXBlb2YoZGF0YSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gU2luZ2xlIGl0ZW1cbiAgICAgICAgYWRkT3JVcGRhdGUoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFUeXBlXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJhZGRcIiwge1xuICAgICAgICAgIGl0ZW1zOiBhZGRlZElkc1xuICAgICAgICB9LCBzZW5kZXJJZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1cGRhdGVkSWRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgaXRlbXM6IHVwZGF0ZWRJZHMsXG4gICAgICAgICAgb2xkRGF0YTogb2xkRGF0YSxcbiAgICAgICAgICBkYXRhOiB1cGRhdGVkRGF0YVxuICAgICAgICB9OyAvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCBwcm9wZXJ0eSAnZGF0YScgc29tZSBkYXlcbiAgICAgICAgLy9PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdkYXRhJywge1xuICAgICAgICAvLyAgJ2dldCc6IChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gICAgY29uc29sZS53YXJuKCdQcm9wZXJ0eSBkYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBEYXRhU2V0LmdldChpZHMpIHRvIHJldHJpZXZlIHRoZSBuZXcgZGF0YSwgdXNlIHRoZSBvbGREYXRhIHByb3BlcnR5IG9uIHRoaXMgb2JqZWN0IHRvIGdldCB0aGUgb2xkIGRhdGEnKTtcbiAgICAgICAgLy8gICAgcmV0dXJuIHVwZGF0ZWREYXRhO1xuICAgICAgICAvLyAgfSkuYmluZCh0aGlzKVxuICAgICAgICAvL30pO1xuXG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJ1cGRhdGVcIiwgcHJvcHMsIHNlbmRlcklkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbmNhdChhZGRlZElkcykuY2FsbChhZGRlZElkcywgdXBkYXRlZElkcyk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGV4aXN0aW5nIGl0ZW1zLiBXaGVuIGFuIGl0ZW0gZG9lcyBub3QgZXhpc3QsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBUaGUgcHJvdmlkZWQgcHJvcGVydGllcyB3aWxsIGJlIGRlZXBseSBtZXJnZWQgaW50byB0aGUgZXhpc3RpbmcgaXRlbS5cclxuICAgICAqIFdoZW4gYW4gaXRlbSBkb2VzIG5vdCBleGlzdCAoaWQgbm90IHByZXNlbnQgaW4gdGhlIGRhdGEgc2V0IG9yIGFic2VudCksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duIGFuZCBub3RoaW5nIHdpbGwgYmUgY2hhbmdlZC5cclxuICAgICAqXHJcbiAgICAgKiBBZnRlciB0aGUgaXRlbXMgYXJlIHVwZGF0ZWQsIHRoZSBEYXRhU2V0IHdpbGwgdHJpZ2dlciBhbiBldmVudCBgdXBkYXRlYC5cclxuICAgICAqIFdoZW4gYSBgc2VuZGVySWRgIGlzIHByb3ZpZGVkLCB0aGlzIGlkIHdpbGwgYmUgcGFzc2VkIHdpdGggdGhlIHRyaWdnZXJlZCBldmVudCB0byBhbGwgc3Vic2NyaWJlcnMuXHJcbiAgICAgKlxyXG4gICAgICogIyMgRXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAqIC8vIGNyZWF0ZSBhIERhdGFTZXRcclxuICAgICAqIGNvbnN0IGRhdGEgPSBuZXcgdmlzLkRhdGFTZXQoW1xyXG4gICAgICogICB7IGlkOiAxLCB0ZXh0OiAnaXRlbSAxJyB9LFxyXG4gICAgICogICB7IGlkOiAyLCB0ZXh0OiAnaXRlbSAyJyB9LFxyXG4gICAgICogICB7IGlkOiAzLCB0ZXh0OiAnaXRlbSAzJyB9LFxyXG4gICAgICogXSlcclxuICAgICAqXHJcbiAgICAgKiAvLyB1cGRhdGUgaXRlbXNcclxuICAgICAqIGNvbnN0IGlkcyA9IGRhdGEudXBkYXRlKFtcclxuICAgICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMiAodXBkYXRlZCknIH0sIC8vIHdvcmtzXHJcbiAgICAgKiAgIC8vIHsgaWQ6IDQsIHRleHQ6ICdpdGVtIDQgKG5ldyknIH0sIC8vIHdvdWxkIHRocm93XHJcbiAgICAgKiAgIC8vIHsgdGV4dDogJ2l0ZW0gNCAobmV3KScgfSwgLy8gd291bGQgYWxzbyB0aHJvd1xyXG4gICAgICogXSlcclxuICAgICAqXHJcbiAgICAgKiBjb25zb2xlLmxvZyhpZHMpIC8vIFsyXVxyXG4gICAgICogYGBgXHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFVwZGF0ZXMgKHRoZSBpZCBhbmQgb3B0aW9uYWxseSBvdGhlciBwcm9wcykgdG8gdGhlIGl0ZW1zIGluIHRoaXMgZGF0YSBzZXQuXHJcbiAgICAgKiBAcGFyYW0gc2VuZGVySWQgLSBTZW5kZXIgaWQuXHJcbiAgICAgKiBAcmV0dXJucyB1cGRhdGVkSWRzIC0gVGhlIGlkcyBvZiB0aGUgdXBkYXRlZCBpdGVtcy5cclxuICAgICAqIEB0aHJvd3MgV2hlbiB0aGUgc3VwcGxpZWQgZGF0YSBpcyBuZWl0aGVyIGFuIGl0ZW0gbm9yIGFuIGFycmF5IG9mIGl0ZW1zLCB3aGVuIHRoZSBpZHMgYXJlIG1pc3NpbmcuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU9ubHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlT25seShkYXRhLCBzZW5kZXJJZCkge1xuICAgICAgdmFyIF9jb250ZXh0MTksXG4gICAgICAgICAgX3RoaXM2ID0gdGhpcztcblxuICAgICAgaWYgKCFpc0FycmF5JDIoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZUV2ZW50RGF0YSA9IG1hcCQzKF9jb250ZXh0MTkgPSBtYXAkMyhkYXRhKS5jYWxsKGRhdGEsIGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgdmFyIG9sZERhdGEgPSBfdGhpczYuX2RhdGEuZ2V0KHVwZGF0ZVtfdGhpczYuX2lkUHJvcF0pO1xuXG4gICAgICAgIGlmIChvbGREYXRhID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVcGRhdGluZyBub24tZXhpc3RlbnQgaXRlbXMgaXMgbm90IGFsbG93ZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvbGREYXRhOiBvbGREYXRhLFxuICAgICAgICAgIHVwZGF0ZTogdXBkYXRlXG4gICAgICAgIH07XG4gICAgICB9KSkuY2FsbChfY29udGV4dDE5LCBmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgICAgdmFyIG9sZERhdGEgPSBfcmVmNS5vbGREYXRhLFxuICAgICAgICAgICAgdXBkYXRlID0gX3JlZjUudXBkYXRlO1xuICAgICAgICB2YXIgaWQgPSBvbGREYXRhW190aGlzNi5faWRQcm9wXTtcbiAgICAgICAgdmFyIHVwZGF0ZWREYXRhID0gcHVyZURlZXBPYmplY3RBc3NpZ24ob2xkRGF0YSwgdXBkYXRlKTtcblxuICAgICAgICBfdGhpczYuX2RhdGEuc2V0KGlkLCB1cGRhdGVkRGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgb2xkRGF0YTogb2xkRGF0YSxcbiAgICAgICAgICB1cGRhdGVkRGF0YTogdXBkYXRlZERhdGFcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodXBkYXRlRXZlbnREYXRhLmxlbmd0aCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgaXRlbXM6IG1hcCQzKHVwZGF0ZUV2ZW50RGF0YSkuY2FsbCh1cGRhdGVFdmVudERhdGEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmlkO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIG9sZERhdGE6IG1hcCQzKHVwZGF0ZUV2ZW50RGF0YSkuY2FsbCh1cGRhdGVFdmVudERhdGEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9sZERhdGE7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZGF0YTogbWFwJDModXBkYXRlRXZlbnREYXRhKS5jYWxsKHVwZGF0ZUV2ZW50RGF0YSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudXBkYXRlZERhdGE7XG4gICAgICAgICAgfSlcbiAgICAgICAgfTsgLy8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0ZWQgcHJvcGVydHkgJ2RhdGEnIHNvbWUgZGF5XG4gICAgICAgIC8vT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAnZGF0YScsIHtcbiAgICAgICAgLy8gICdnZXQnOiAoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgIGNvbnNvbGUud2FybignUHJvcGVydHkgZGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgRGF0YVNldC5nZXQoaWRzKSB0byByZXRyaWV2ZSB0aGUgbmV3IGRhdGEsIHVzZSB0aGUgb2xkRGF0YSBwcm9wZXJ0eSBvbiB0aGlzIG9iamVjdCB0byBnZXQgdGhlIG9sZCBkYXRhJyk7XG4gICAgICAgIC8vICAgIHJldHVybiB1cGRhdGVkRGF0YTtcbiAgICAgICAgLy8gIH0pLmJpbmQodGhpcylcbiAgICAgICAgLy99KTtcblxuICAgICAgICB0aGlzLl90cmlnZ2VyKFwidXBkYXRlXCIsIHByb3BzLCBzZW5kZXJJZCk7XG5cbiAgICAgICAgcmV0dXJuIHByb3BzLml0ZW1zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoZmlyc3QsIHNlY29uZCkge1xuICAgICAgLy8gQFRPRE86IFdvdWRuJ3QgaXQgYmUgYmV0dGVyIHRvIHNwbGl0IHRoaXMgaW50byBtdWx0aXBsZSBtZXRob2RzP1xuICAgICAgLy8gcGFyc2UgdGhlIGFyZ3VtZW50c1xuICAgICAgdmFyIGlkID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGlkcyA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBvcHRpb25zID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaXNJZChmaXJzdCkpIHtcbiAgICAgICAgLy8gZ2V0KGlkIFssIG9wdGlvbnNdKVxuICAgICAgICBpZCA9IGZpcnN0O1xuICAgICAgICBvcHRpb25zID0gc2Vjb25kO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5JDIoZmlyc3QpKSB7XG4gICAgICAgIC8vIGdldChpZHMgWywgb3B0aW9uc10pXG4gICAgICAgIGlkcyA9IGZpcnN0O1xuICAgICAgICBvcHRpb25zID0gc2Vjb25kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2V0KFssIG9wdGlvbnNdKVxuICAgICAgICBvcHRpb25zID0gZmlyc3Q7XG4gICAgICB9IC8vIGRldGVybWluZSB0aGUgcmV0dXJuIHR5cGVcblxuXG4gICAgICB2YXIgcmV0dXJuVHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yZXR1cm5UeXBlID09PSBcIk9iamVjdFwiID8gXCJPYmplY3RcIiA6IFwiQXJyYXlcIjsgLy8gQFRPRE86IFdURiBpcyB0aGlzPyBPciBhbSBJIG1pc3Npbmcgc29tZXRoaW5nP1xuICAgICAgLy8gdmFyIHJldHVyblR5cGVcbiAgICAgIC8vIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmV0dXJuVHlwZSkge1xuICAgICAgLy8gICB2YXIgYWxsb3dlZFZhbHVlcyA9IFsnQXJyYXknLCAnT2JqZWN0J11cbiAgICAgIC8vICAgcmV0dXJuVHlwZSA9XG4gICAgICAvLyAgICAgYWxsb3dlZFZhbHVlcy5pbmRleE9mKG9wdGlvbnMucmV0dXJuVHlwZSkgPT0gLTFcbiAgICAgIC8vICAgICAgID8gJ0FycmF5J1xuICAgICAgLy8gICAgICAgOiBvcHRpb25zLnJldHVyblR5cGVcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIHJldHVyblR5cGUgPSAnQXJyYXknXG4gICAgICAvLyB9XG4gICAgICAvLyBidWlsZCBvcHRpb25zXG5cbiAgICAgIHZhciBmaWx0ZXIkMSA9IG9wdGlvbnMgJiYgZmlsdGVyKG9wdGlvbnMpO1xuXG4gICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgIHZhciBpdGVtID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGl0ZW1JZHMgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgaXRlbUlkID0gdW5kZWZpbmVkOyAvLyBjb252ZXJ0IGl0ZW1zXG5cbiAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgIC8vIHJldHVybiBhIHNpbmdsZSBpdGVtXG4gICAgICAgIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpZCk7XG5cbiAgICAgICAgaWYgKGl0ZW0gJiYgZmlsdGVyJDEgJiYgIWZpbHRlciQxKGl0ZW0pKSB7XG4gICAgICAgICAgaXRlbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZHMgIT0gbnVsbCkge1xuICAgICAgICAvLyByZXR1cm4gYSBzdWJzZXQgb2YgaXRlbXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpZHNbaV0pO1xuXG4gICAgICAgICAgaWYgKGl0ZW0gIT0gbnVsbCAmJiAoIWZpbHRlciQxIHx8IGZpbHRlciQxKGl0ZW0pKSkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfY29udGV4dDIwO1xuXG4gICAgICAgIC8vIHJldHVybiBhbGwgaXRlbXNcbiAgICAgICAgaXRlbUlkcyA9IF90b0NvbnN1bWFibGVBcnJheShrZXlzKF9jb250ZXh0MjAgPSB0aGlzLl9kYXRhKS5jYWxsKF9jb250ZXh0MjApKTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9sZW4yID0gaXRlbUlkcy5sZW5ndGg7IF9pIDwgX2xlbjI7IF9pKyspIHtcbiAgICAgICAgICBpdGVtSWQgPSBpdGVtSWRzW19pXTtcbiAgICAgICAgICBpdGVtID0gdGhpcy5fZGF0YS5nZXQoaXRlbUlkKTtcblxuICAgICAgICAgIGlmIChpdGVtICE9IG51bGwgJiYgKCFmaWx0ZXIkMSB8fCBmaWx0ZXIkMShpdGVtKSkpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIG9yZGVyIHRoZSByZXN1bHRzXG5cblxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlciAmJiBpZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc29ydChpdGVtcywgb3B0aW9ucy5vcmRlcik7XG4gICAgICB9IC8vIGZpbHRlciBmaWVsZHMgb2YgdGhlIGl0ZW1zXG5cblxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWVsZHMpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuXG4gICAgICAgIGlmIChpZCAhPSB1bmRlZmluZWQgJiYgaXRlbSAhPSBudWxsKSB7XG4gICAgICAgICAgaXRlbSA9IHRoaXMuX2ZpbHRlckZpZWxkcyhpdGVtLCBmaWVsZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9sZW4zID0gaXRlbXMubGVuZ3RoOyBfaTIgPCBfbGVuMzsgX2kyKyspIHtcbiAgICAgICAgICAgIGl0ZW1zW19pMl0gPSB0aGlzLl9maWx0ZXJGaWVsZHMoaXRlbXNbX2kyXSwgZmllbGRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcmV0dXJuIHRoZSByZXN1bHRzXG5cblxuICAgICAgaWYgKHJldHVyblR5cGUgPT0gXCJPYmplY3RcIikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgX2kzID0gMCwgX2xlbjQgPSBpdGVtcy5sZW5ndGg7IF9pMyA8IF9sZW40OyBfaTMrKykge1xuICAgICAgICAgIHZhciByZXN1bHRhbnQgPSBpdGVtc1tfaTNdOyAvLyBAVE9ETzogU2hvdWRuJ3QgdGhpcyBiZSB0aGlzLl9maWVsZElkP1xuICAgICAgICAgIC8vIHJlc3VsdFtyZXN1bHRhbnQuaWRdID0gcmVzdWx0YW50XG5cbiAgICAgICAgICB2YXIgX2lkMiA9IHJlc3VsdGFudFt0aGlzLl9pZFByb3BdO1xuICAgICAgICAgIHJlc3VsdFtfaWQyXSA9IHJlc3VsdGFudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfaXRlbTtcblxuICAgICAgICAgIC8vIGEgc2luZ2xlIGl0ZW1cbiAgICAgICAgICByZXR1cm4gKF9pdGVtID0gaXRlbSkgIT09IG51bGwgJiYgX2l0ZW0gIT09IHZvaWQgMCA/IF9pdGVtIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBqdXN0IHJldHVybiBvdXIgYXJyYXlcbiAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRJZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SWRzKG9wdGlvbnMpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgdmFyIGZpbHRlciQxID0gb3B0aW9ucyAmJiBmaWx0ZXIob3B0aW9ucyk7XG5cbiAgICAgIHZhciBvcmRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlcjtcblxuICAgICAgdmFyIGl0ZW1JZHMgPSBfdG9Db25zdW1hYmxlQXJyYXkoa2V5cyhkYXRhKS5jYWxsKGRhdGEpKTtcblxuICAgICAgdmFyIGlkcyA9IFtdO1xuXG4gICAgICBpZiAoZmlsdGVyJDEpIHtcbiAgICAgICAgLy8gZ2V0IGZpbHRlcmVkIGl0ZW1zXG4gICAgICAgIGlmIChvcmRlcikge1xuICAgICAgICAgIC8vIGNyZWF0ZSBvcmRlcmVkIGxpc3RcbiAgICAgICAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBpdGVtSWRzW2ldO1xuXG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkKTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0gIT0gbnVsbCAmJiBmaWx0ZXIkMShpdGVtKSkge1xuICAgICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9yZGVyKTtcblxuICAgICAgICAgIGZvciAodmFyIF9pNCA9IDAsIF9sZW41ID0gaXRlbXMubGVuZ3RoOyBfaTQgPCBfbGVuNTsgX2k0KyspIHtcbiAgICAgICAgICAgIGlkcy5wdXNoKGl0ZW1zW19pNF1bdGhpcy5faWRQcm9wXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNyZWF0ZSB1bm9yZGVyZWQgbGlzdFxuICAgICAgICAgIGZvciAodmFyIF9pNSA9IDAsIF9sZW42ID0gaXRlbUlkcy5sZW5ndGg7IF9pNSA8IF9sZW42OyBfaTUrKykge1xuICAgICAgICAgICAgdmFyIF9pZDMgPSBpdGVtSWRzW19pNV07XG5cbiAgICAgICAgICAgIHZhciBfaXRlbTIgPSB0aGlzLl9kYXRhLmdldChfaWQzKTtcblxuICAgICAgICAgICAgaWYgKF9pdGVtMiAhPSBudWxsICYmIGZpbHRlciQxKF9pdGVtMikpIHtcbiAgICAgICAgICAgICAgaWRzLnB1c2goX2l0ZW0yW3RoaXMuX2lkUHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2V0IGFsbCBpdGVtc1xuICAgICAgICBpZiAob3JkZXIpIHtcbiAgICAgICAgICAvLyBjcmVhdGUgYW4gb3JkZXJlZCBsaXN0XG4gICAgICAgICAgdmFyIF9pdGVtcyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2k2ID0gMCwgX2xlbjcgPSBpdGVtSWRzLmxlbmd0aDsgX2k2IDwgX2xlbjc7IF9pNisrKSB7XG4gICAgICAgICAgICB2YXIgX2lkNCA9IGl0ZW1JZHNbX2k2XTtcblxuICAgICAgICAgICAgX2l0ZW1zLnB1c2goZGF0YS5nZXQoX2lkNCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3NvcnQoX2l0ZW1zLCBvcmRlcik7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTcgPSAwLCBfbGVuOCA9IF9pdGVtcy5sZW5ndGg7IF9pNyA8IF9sZW44OyBfaTcrKykge1xuICAgICAgICAgICAgaWRzLnB1c2goX2l0ZW1zW19pN11bdGhpcy5faWRQcm9wXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNyZWF0ZSB1bm9yZGVyZWQgbGlzdFxuICAgICAgICAgIGZvciAodmFyIF9pOCA9IDAsIF9sZW45ID0gaXRlbUlkcy5sZW5ndGg7IF9pOCA8IF9sZW45OyBfaTgrKykge1xuICAgICAgICAgICAgdmFyIF9pZDUgPSBpdGVtSWRzW19pOF07XG5cbiAgICAgICAgICAgIHZhciBfaXRlbTMgPSBkYXRhLmdldChfaWQ1KTtcblxuICAgICAgICAgICAgaWYgKF9pdGVtMyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlkcy5wdXNoKF9pdGVtM1t0aGlzLl9pZFByb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlkcztcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXREYXRhU2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGFTZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmb3JFYWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHZhciBmaWx0ZXIkMSA9IG9wdGlvbnMgJiYgZmlsdGVyKG9wdGlvbnMpO1xuXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgIHZhciBpdGVtSWRzID0gX3RvQ29uc3VtYWJsZUFycmF5KGtleXMoZGF0YSkuY2FsbChkYXRhKSk7XG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIpIHtcbiAgICAgICAgLy8gZXhlY3V0ZSBmb3JFYWNoIG9uIG9yZGVyZWQgbGlzdFxuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmdldChvcHRpb25zKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgIHZhciBpZCA9IGl0ZW1bdGhpcy5faWRQcm9wXTtcbiAgICAgICAgICBjYWxsYmFjayhpdGVtLCBpZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVub3JkZXJlZFxuICAgICAgICBmb3IgKHZhciBfaTkgPSAwLCBfbGVuMTAgPSBpdGVtSWRzLmxlbmd0aDsgX2k5IDwgX2xlbjEwOyBfaTkrKykge1xuICAgICAgICAgIHZhciBfaWQ2ID0gaXRlbUlkc1tfaTldO1xuXG4gICAgICAgICAgdmFyIF9pdGVtNCA9IHRoaXMuX2RhdGEuZ2V0KF9pZDYpO1xuXG4gICAgICAgICAgaWYgKF9pdGVtNCAhPSBudWxsICYmICghZmlsdGVyJDEgfHwgZmlsdGVyJDEoX2l0ZW00KSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9pdGVtNCwgX2lkNik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgdmFyIGZpbHRlciQxID0gb3B0aW9ucyAmJiBmaWx0ZXIob3B0aW9ucyk7XG5cbiAgICAgIHZhciBtYXBwZWRJdGVtcyA9IFtdO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICB2YXIgaXRlbUlkcyA9IF90b0NvbnN1bWFibGVBcnJheShrZXlzKGRhdGEpLmNhbGwoZGF0YSkpOyAvLyBjb252ZXJ0IGFuZCBmaWx0ZXIgaXRlbXNcblxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpdGVtSWRzW2ldO1xuXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5fZGF0YS5nZXQoaWQpO1xuXG4gICAgICAgIGlmIChpdGVtICE9IG51bGwgJiYgKCFmaWx0ZXIkMSB8fCBmaWx0ZXIkMShpdGVtKSkpIHtcbiAgICAgICAgICBtYXBwZWRJdGVtcy5wdXNoKGNhbGxiYWNrKGl0ZW0sIGlkKSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gb3JkZXIgaXRlbXNcblxuXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyKSB7XG4gICAgICAgIHRoaXMuX3NvcnQobWFwcGVkSXRlbXMsIG9wdGlvbnMub3JkZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwcGVkSXRlbXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRmlsdGVyIHRoZSBmaWVsZHMgb2YgYW4gaXRlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXRlbSAtIFRoZSBpdGVtIHdob3NlIGZpZWxkcyBzaG91bGQgYmUgZmlsdGVyZWQuXHJcbiAgICAgKiBAcGFyYW0gZmllbGRzIC0gVGhlIG5hbWVzIG9mIHRoZSBmaWVsZHMgdGhhdCB3aWxsIGJlIGtlcHQuXHJcbiAgICAgKiBAdHlwZVBhcmFtIEsgLSBGaWVsZCBuYW1lIHR5cGUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSB3aXRob3V0IGFueSBhZGRpdGlvbmFsIGZpZWxkcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbHRlckZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmlsdGVyRmllbGRzKGl0ZW0sIGZpZWxkcykge1xuICAgICAgdmFyIF9jb250ZXh0MjE7XG5cbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAvLyBpdGVtIGlzIG51bGxcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWR1Y2UoX2NvbnRleHQyMSA9IGlzQXJyYXkkMihmaWVsZHMpID8gLy8gVXNlIHRoZSBzdXBwbGllZCBhcnJheVxuICAgICAgZmllbGRzIDogLy8gVXNlIHRoZSBrZXlzIG9mIHRoZSBzdXBwbGllZCBvYmplY3RcbiAgICAgIGtleXMkNChmaWVsZHMpKS5jYWxsKF9jb250ZXh0MjEsIGZ1bmN0aW9uIChmaWx0ZXJlZEl0ZW0sIGZpZWxkKSB7XG4gICAgICAgIGZpbHRlcmVkSXRlbVtmaWVsZF0gPSBpdGVtW2ZpZWxkXTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkSXRlbTtcbiAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTb3J0IHRoZSBwcm92aWRlZCBhcnJheSB3aXRoIGl0ZW1zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpdGVtcyAtIEl0ZW1zIHRvIGJlIHNvcnRlZCBpbiBwbGFjZS5cclxuICAgICAqIEBwYXJhbSBvcmRlciAtIEEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cclxuICAgICAqIEB0eXBlUGFyYW0gVCAtIFRoZSB0eXBlIG9mIHRoZSBpdGVtcyBpbiB0aGUgaXRlbXMgYXJyYXkuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zb3J0KGl0ZW1zLCBvcmRlcikge1xuICAgICAgaWYgKHR5cGVvZiBvcmRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBvcmRlciBieSBwcm92aWRlZCBmaWVsZCBuYW1lXG4gICAgICAgIHZhciBuYW1lID0gb3JkZXI7IC8vIGZpZWxkIG5hbWVcblxuICAgICAgICBzb3J0KGl0ZW1zKS5jYWxsKGl0ZW1zLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIC8vIEBUT0RPOiBIb3cgdG8gdHJlYXQgbWlzc2luZyBwcm9wZXJ0aWVzP1xuICAgICAgICAgIHZhciBhdiA9IGFbbmFtZV07XG4gICAgICAgICAgdmFyIGJ2ID0gYltuYW1lXTtcbiAgICAgICAgICByZXR1cm4gYXYgPiBidiA/IDEgOiBhdiA8IGJ2ID8gLTEgOiAwO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9yZGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gb3JkZXIgYnkgc29ydCBmdW5jdGlvblxuICAgICAgICBzb3J0KGl0ZW1zKS5jYWxsKGl0ZW1zLCBvcmRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBleHRlbmQgb3JkZXIgYnkgYW4gT2JqZWN0IHtmaWVsZDpzdHJpbmcsIGRpcmVjdGlvbjpzdHJpbmd9XG4gICAgICAgIC8vICAgICAgIHdoZXJlIGRpcmVjdGlvbiBjYW4gYmUgJ2FzYycgb3IgJ2Rlc2MnXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPcmRlciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFuIGl0ZW0gb3IgbXVsdGlwbGUgaXRlbXMgYnkg4oCccmVmZXJlbmNl4oCdIChvbmx5IHRoZSBpZCBpcyB1c2VkKSBvciBieSBpZC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbWV0aG9kIGlnbm9yZXMgcmVtb3ZhbCBvZiBub24tZXhpc3RpbmcgaXRlbXMsIGFuZCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGlkcyBvZiB0aGUgaXRlbXMgd2hpY2ggYXJlIGFjdHVhbGx5IHJlbW92ZWQgZnJvbSB0aGUgRGF0YVNldC5cclxuICAgICAqXHJcbiAgICAgKiBBZnRlciB0aGUgaXRlbXMgYXJlIHJlbW92ZWQsIHRoZSBEYXRhU2V0IHdpbGwgdHJpZ2dlciBhbiBldmVudCBgcmVtb3ZlYCBmb3IgdGhlIHJlbW92ZWQgaXRlbXMuIFdoZW4gYSBgc2VuZGVySWRgIGlzIHByb3ZpZGVkLCB0aGlzIGlkIHdpbGwgYmUgcGFzc2VkIHdpdGggdGhlIHRyaWdnZXJlZCBldmVudCB0byBhbGwgc3Vic2NyaWJlcnMuXHJcbiAgICAgKlxyXG4gICAgICogIyMgRXhhbXBsZVxyXG4gICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICogLy8gY3JlYXRlIGEgRGF0YVNldFxyXG4gICAgICogY29uc3QgZGF0YSA9IG5ldyB2aXMuRGF0YVNldChbXHJcbiAgICAgKiAgIHsgaWQ6IDEsIHRleHQ6ICdpdGVtIDEnIH0sXHJcbiAgICAgKiAgIHsgaWQ6IDIsIHRleHQ6ICdpdGVtIDInIH0sXHJcbiAgICAgKiAgIHsgaWQ6IDMsIHRleHQ6ICdpdGVtIDMnIH1cclxuICAgICAqIF0pXHJcbiAgICAgKlxyXG4gICAgICogLy8gcmVtb3ZlIGl0ZW1zXHJcbiAgICAgKiBjb25zdCBpZHMgPSBkYXRhLnJlbW92ZShbMiwgeyBpZDogMyB9LCA0XSlcclxuICAgICAqXHJcbiAgICAgKiBjb25zb2xlLmxvZyhpZHMpIC8vIFsyLCAzXVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkIC0gT25lIG9yIG1vcmUgaXRlbXMgb3IgaWRzIG9mIGl0ZW1zIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgKiBAcGFyYW0gc2VuZGVySWQgLSBTZW5kZXIgaWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaWRzIG9mIHRoZSByZW1vdmVkIGl0ZW1zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGlkLCBzZW5kZXJJZCkge1xuICAgICAgdmFyIHJlbW92ZWRJZHMgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkSXRlbXMgPSBbXTsgLy8gZm9yY2UgZXZlcnl0aGluZyB0byBiZSBhbiBhcnJheSBmb3Igc2ltcGxpY2l0eVxuXG4gICAgICB2YXIgaWRzID0gaXNBcnJheSQyKGlkKSA/IGlkIDogW2lkXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX3JlbW92ZShpZHNbaV0pO1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgdmFyIGl0ZW1JZCA9IGl0ZW1bdGhpcy5faWRQcm9wXTtcblxuICAgICAgICAgIGlmIChpdGVtSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVtb3ZlZElkcy5wdXNoKGl0ZW1JZCk7XG4gICAgICAgICAgICByZW1vdmVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlbW92ZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIiwge1xuICAgICAgICAgIGl0ZW1zOiByZW1vdmVkSWRzLFxuICAgICAgICAgIG9sZERhdGE6IHJlbW92ZWRJdGVtc1xuICAgICAgICB9LCBzZW5kZXJJZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZW1vdmVkSWRzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbiBpdGVtIGJ5IGl0cyBpZCBvciByZWZlcmVuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkIC0gSWQgb2YgYW4gaXRlbSBvciB0aGUgaXRlbSBpdHNlbGYuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVtb3ZlZCBpdGVtIGlmIHJlbW92ZWQsIG51bGwgb3RoZXJ3aXNlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmUoaWQpIHtcbiAgICAgIC8vIEBUT0RPOiBJdCBvcmlnaWFubGx5IHJldHVybmVkIHRoZSBpdGVtIGFsdGhvdWdoIHRoZSBkb2NzIHNheSBpZC5cbiAgICAgIC8vIFRoZSBjb2RlIGV4cGVjdHMgdGhlIGl0ZW0sIHNvIHByb2JhYmx5IGFuIGVycm9yIGluIHRoZSBkb2NzLlxuICAgICAgdmFyIGlkZW50OyAvLyBjb25maXJtIHRoZSBpZCB0byB1c2UgYmFzZWQgb24gdGhlIGFyZ3MgdHlwZVxuXG4gICAgICBpZiAoaXNJZChpZCkpIHtcbiAgICAgICAgaWRlbnQgPSBpZDtcbiAgICAgIH0gZWxzZSBpZiAoaWQgJiYgX3R5cGVvZihpZCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWRlbnQgPSBpZFt0aGlzLl9pZFByb3BdOyAvLyBsb29rIGZvciB0aGUgaWRlbnRpZmllciBmaWVsZCB1c2luZyAuX2lkUHJvcFxuICAgICAgfSAvLyBkbyB0aGUgcmVtb3ZpbmcgaWYgdGhlIGl0ZW0gaXMgZm91bmRcblxuXG4gICAgICBpZiAoaWRlbnQgIT0gbnVsbCAmJiB0aGlzLl9kYXRhLmhhcyhpZGVudCkpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpZGVudCkgfHwgbnVsbDtcblxuICAgICAgICB0aGlzLl9kYXRhLmRlbGV0ZShpZGVudCk7XG5cbiAgICAgICAgLS10aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENsZWFyIHRoZSBlbnRpcmUgZGF0YSBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQWZ0ZXIgdGhlIGl0ZW1zIGFyZSByZW1vdmVkLCB0aGUgW1tEYXRhU2V0XV0gd2lsbCB0cmlnZ2VyIGFuIGV2ZW50IGByZW1vdmVgIGZvciBhbGwgcmVtb3ZlZCBpdGVtcy4gV2hlbiBhIGBzZW5kZXJJZGAgaXMgcHJvdmlkZWQsIHRoaXMgaWQgd2lsbCBiZSBwYXNzZWQgd2l0aCB0aGUgdHJpZ2dlcmVkIGV2ZW50IHRvIGFsbCBzdWJzY3JpYmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2VuZGVySWQgLSBTZW5kZXIgaWQuXHJcbiAgICAgKiBAcmV0dXJucyByZW1vdmVkSWRzIC0gVGhlIGlkcyBvZiBhbGwgcmVtb3ZlZCBpdGVtcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoc2VuZGVySWQpIHtcbiAgICAgIHZhciBfY29udGV4dDIyO1xuXG4gICAgICB2YXIgaWRzID0gX3RvQ29uc3VtYWJsZUFycmF5KGtleXMoX2NvbnRleHQyMiA9IHRoaXMuX2RhdGEpLmNhbGwoX2NvbnRleHQyMikpO1xuXG4gICAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpdGVtcy5wdXNoKHRoaXMuX2RhdGEuZ2V0KGlkc1tpXSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kYXRhLmNsZWFyKCk7XG5cbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgICAgdGhpcy5fdHJpZ2dlcihcInJlbW92ZVwiLCB7XG4gICAgICAgIGl0ZW1zOiBpZHMsXG4gICAgICAgIG9sZERhdGE6IGl0ZW1zXG4gICAgICB9LCBzZW5kZXJJZCk7XG5cbiAgICAgIHJldHVybiBpZHM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgaXRlbSB3aXRoIG1heGltdW0gdmFsdWUgb2YgYSBzcGVjaWZpZWQgZmllbGQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpZWxkIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgc2VhcmNoZWQgZm9yIG1heCB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIEl0ZW0gY29udGFpbmluZyBtYXggdmFsdWUsIG9yIG51bGwgaWYgbm8gaXRlbXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1heFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXgoZmllbGQpIHtcbiAgICAgIHZhciBfY29udGV4dDIzO1xuXG4gICAgICB2YXIgbWF4ID0gbnVsbDtcbiAgICAgIHZhciBtYXhGaWVsZCA9IG51bGw7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IxMSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcodmFsdWVzKF9jb250ZXh0MjMgPSB0aGlzLl9kYXRhKS5jYWxsKF9jb250ZXh0MjMpKSxcbiAgICAgICAgICBfc3RlcDExO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjExLnMoKTsgIShfc3RlcDExID0gX2l0ZXJhdG9yMTEubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAxMS52YWx1ZTtcbiAgICAgICAgICB2YXIgaXRlbUZpZWxkID0gaXRlbVtmaWVsZF07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGl0ZW1GaWVsZCA9PT0gXCJudW1iZXJcIiAmJiAobWF4RmllbGQgPT0gbnVsbCB8fCBpdGVtRmllbGQgPiBtYXhGaWVsZCkpIHtcbiAgICAgICAgICAgIG1heCA9IGl0ZW07XG4gICAgICAgICAgICBtYXhGaWVsZCA9IGl0ZW1GaWVsZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxMS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxMS5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXggfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBpdGVtIHdpdGggbWluaW11bSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBmaWVsZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmllbGQgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSBzZWFyY2hlZCBmb3IgbWluIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMgSXRlbSBjb250YWluaW5nIG1pbiB2YWx1ZSwgb3IgbnVsbCBpZiBubyBpdGVtcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWluXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1pbihmaWVsZCkge1xuICAgICAgdmFyIF9jb250ZXh0MjQ7XG5cbiAgICAgIHZhciBtaW4gPSBudWxsO1xuICAgICAgdmFyIG1pbkZpZWxkID0gbnVsbDtcblxuICAgICAgdmFyIF9pdGVyYXRvcjEyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyh2YWx1ZXMoX2NvbnRleHQyNCA9IHRoaXMuX2RhdGEpLmNhbGwoX2NvbnRleHQyNCkpLFxuICAgICAgICAgIF9zdGVwMTI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTIucygpOyAhKF9zdGVwMTIgPSBfaXRlcmF0b3IxMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcDEyLnZhbHVlO1xuICAgICAgICAgIHZhciBpdGVtRmllbGQgPSBpdGVtW2ZpZWxkXTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgaXRlbUZpZWxkID09PSBcIm51bWJlclwiICYmIChtaW5GaWVsZCA9PSBudWxsIHx8IGl0ZW1GaWVsZCA8IG1pbkZpZWxkKSkge1xuICAgICAgICAgICAgbWluID0gaXRlbTtcbiAgICAgICAgICAgIG1pbkZpZWxkID0gaXRlbUZpZWxkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjEyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjEyLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pbiB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEZpbmQgYWxsIGRpc3RpbmN0IHZhbHVlcyBvZiBhIHNwZWNpZmllZCBmaWVsZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcm9wIC0gVGhlIHByb3BlcnR5IG5hbWUgd2hvc2UgZGlzdGluY3QgdmFsdWVzIHNob3VsZCBiZSByZXR1cm5lZC5cclxuICAgICAqIEByZXR1cm5zIFVub3JkZXJlZCBhcnJheSBjb250YWluaW5nIGFsbCBkaXN0aW5jdCB2YWx1ZXMuIEl0ZW1zIHdpdGhvdXQgc3BlY2lmaWVkIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0aW5jdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0aW5jdChwcm9wKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgIHZhciBpdGVtSWRzID0gX3RvQ29uc3VtYWJsZUFycmF5KGtleXMoZGF0YSkuY2FsbChkYXRhKSk7XG5cbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICAgIHZhciBpdGVtID0gZGF0YS5nZXQoaWQpO1xuICAgICAgICB2YXIgX3ZhbHVlMyA9IGl0ZW1bcHJvcF07XG4gICAgICAgIHZhciBleGlzdHMgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgICBpZiAodmFsdWVzW2pdID09IF92YWx1ZTMpIHtcbiAgICAgICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV4aXN0cyAmJiBfdmFsdWUzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YWx1ZXNbY291bnRdID0gX3ZhbHVlMztcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2luZ2xlIGl0ZW0uIFdpbGwgZmFpbCB3aGVuIGFuIGl0ZW0gd2l0aCB0aGUgc2FtZSBpZCBhbHJlYWR5IGV4aXN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXRlbSAtIEEgbmV3IGl0ZW0gdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcmV0dXJucyBBZGRlZCBpdGVtJ3MgaWQuIEFuIGlkIGlzIGdlbmVyYXRlZCB3aGVuIGl0IGlzIG5vdCBwcmVzZW50IGluIHRoZSBpdGVtLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkSXRlbShpdGVtKSB7XG4gICAgICB2YXIgZnVsbEl0ZW0gPSBlbnN1cmVGdWxsSXRlbShpdGVtLCB0aGlzLl9pZFByb3ApO1xuICAgICAgdmFyIGlkID0gZnVsbEl0ZW1bdGhpcy5faWRQcm9wXTsgLy8gY2hlY2sgd2hldGhlciB0aGlzIGlkIGlzIGFscmVhZHkgdGFrZW5cblxuICAgICAgaWYgKHRoaXMuX2RhdGEuaGFzKGlkKSkge1xuICAgICAgICAvLyBpdGVtIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgaXRlbTogaXRlbSB3aXRoIGlkIFwiICsgaWQgKyBcIiBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZGF0YS5zZXQoaWQsIGZ1bGxJdGVtKTtcblxuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgYSBzaW5nbGUgaXRlbTogbWVyZ2Ugd2l0aCBleGlzdGluZyBpdGVtLlxyXG4gICAgICogV2lsbCBmYWlsIHdoZW4gdGhlIGl0ZW0gaGFzIG5vIGlkLCBvciB3aGVuIHRoZXJlIGRvZXMgbm90IGV4aXN0IGFuIGl0ZW0gd2l0aCB0aGUgc2FtZSBpZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXBkYXRlIC0gVGhlIG5ldyBpdGVtXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaWQgb2YgdGhlIHVwZGF0ZWQgaXRlbS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUl0ZW0odXBkYXRlKSB7XG4gICAgICB2YXIgaWQgPSB1cGRhdGVbdGhpcy5faWRQcm9wXTtcblxuICAgICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVwZGF0ZSBpdGVtOiBpdGVtIGhhcyBubyBpZCAoaXRlbTogXCIgKyBzdHJpbmdpZnkkMSh1cGRhdGUpICsgXCIpXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkKTtcblxuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIC8vIGl0ZW0gZG9lc24ndCBleGlzdFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIGl0ZW06IG5vIGl0ZW0gd2l0aCBpZCBcIiArIGlkICsgXCIgZm91bmRcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RhdGEuc2V0KGlkLCBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBpdGVtKSwgdXBkYXRlKSk7XG5cbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdHJlYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyZWFtKGlkcykge1xuICAgICAgaWYgKGlkcykge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbShfZGVmaW5lUHJvcGVydHkoe30sIGl0ZXJhdG9yLCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yMTMsIF9zdGVwMTMsIGlkLCBpdGVtO1xuXG4gICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0MjUpIHtcbiAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyNS5wcmV2ID0gX2NvbnRleHQyNS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMTMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KGlkcyk7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDI1LnByZXYgPSAxO1xuXG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3IxMy5zKCk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICBpZiAoKF9zdGVwMTMgPSBfaXRlcmF0b3IxMy5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNS5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZCA9IF9zdGVwMTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICBpdGVtID0gZGF0YS5nZXQoaWQpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIShpdGVtICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjUubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtpZCwgaXRlbV07XG5cbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNS5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDI1LnByZXYgPSAxMztcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjUudDAgPSBfY29udGV4dDI1W1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjEzLmUoX2NvbnRleHQyNS50MCk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNS5wcmV2ID0gMTY7XG5cbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjEzLmYoKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjUuZmluaXNoKDE2KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjUuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgX2NhbGxlZTMsIG51bGwsIFtbMSwgMTMsIDE2LCAxOV1dKTtcbiAgICAgICAgfSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfY29udGV4dDI2O1xuXG4gICAgICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbShfZGVmaW5lUHJvcGVydHkoe30sIGl0ZXJhdG9yLCBiaW5kJDYoX2NvbnRleHQyNiA9IGVudHJpZXModGhpcy5fZGF0YSkpLmNhbGwoX2NvbnRleHQyNiwgdGhpcy5fZGF0YSkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0YVNldDtcbn0oRGF0YVNldFBhcnQpO1xuLyoqXHJcbiAqIERhdGFWaWV3XHJcbiAqXHJcbiAqIEEgRGF0YVZpZXcgb2ZmZXJzIGEgZmlsdGVyZWQgYW5kL29yIGZvcm1hdHRlZCB2aWV3IG9uIGEgRGF0YVNldC4gT25lIGNhbiBzdWJzY3JpYmUgdG8gY2hhbmdlcyBpbiBhIERhdGFWaWV3LCBhbmQgZWFzaWx5IGdldCBmaWx0ZXJlZCBvciBmb3JtYXR0ZWQgZGF0YSB3aXRob3V0IGhhdmluZyB0byBzcGVjaWZ5IGZpbHRlcnMgYW5kIGZpZWxkIHR5cGVzIGFsbCB0aGUgdGltZS5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIGNyZWF0ZSBhIERhdGFTZXRcclxuICogdmFyIGRhdGEgPSBuZXcgdmlzLkRhdGFTZXQoKTtcclxuICogZGF0YS5hZGQoW1xyXG4gKiAgIHtpZDogMSwgdGV4dDogJ2l0ZW0gMScsIGRhdGU6IG5ldyBEYXRlKDIwMTMsIDYsIDIwKSwgZ3JvdXA6IDEsIGZpcnN0OiB0cnVlfSxcclxuICogICB7aWQ6IDIsIHRleHQ6ICdpdGVtIDInLCBkYXRlOiAnMjAxMy0wNi0yMycsIGdyb3VwOiAyfSxcclxuICogICB7aWQ6IDMsIHRleHQ6ICdpdGVtIDMnLCBkYXRlOiAnMjAxMy0wNi0yNScsIGdyb3VwOiAyfSxcclxuICogICB7aWQ6IDQsIHRleHQ6ICdpdGVtIDQnfVxyXG4gKiBdKTtcclxuICpcclxuICogLy8gY3JlYXRlIGEgRGF0YVZpZXdcclxuICogLy8gdGhlIHZpZXcgd2lsbCBvbmx5IGNvbnRhaW4gaXRlbXMgaGF2aW5nIGEgcHJvcGVydHkgZ3JvdXAgd2l0aCB2YWx1ZSAxLFxyXG4gKiAvLyBhbmQgd2lsbCBvbmx5IG91dHB1dCBmaWVsZHMgaWQsIHRleHQsIGFuZCBkYXRlLlxyXG4gKiB2YXIgdmlldyA9IG5ldyB2aXMuRGF0YVZpZXcoZGF0YSwge1xyXG4gKiAgIGZpbHRlcjogZnVuY3Rpb24gKGl0ZW0pIHtcclxuICogICAgIHJldHVybiAoaXRlbS5ncm91cCA9PSAxKTtcclxuICogICB9LFxyXG4gKiAgIGZpZWxkczogWydpZCcsICd0ZXh0JywgJ2RhdGUnXVxyXG4gKiB9KTtcclxuICpcclxuICogLy8gc3Vic2NyaWJlIHRvIGFueSBjaGFuZ2UgaW4gdGhlIERhdGFWaWV3XHJcbiAqIHZpZXcub24oJyonLCBmdW5jdGlvbiAoZXZlbnQsIHByb3BlcnRpZXMsIHNlbmRlcklkKSB7XHJcbiAqICAgY29uc29sZS5sb2coJ2V2ZW50JywgZXZlbnQsIHByb3BlcnRpZXMpO1xyXG4gKiB9KTtcclxuICpcclxuICogLy8gdXBkYXRlIGFuIGl0ZW0gaW4gdGhlIGRhdGEgc2V0XHJcbiAqIGRhdGEudXBkYXRlKHtpZDogMiwgZ3JvdXA6IDF9KTtcclxuICpcclxuICogLy8gZ2V0IGFsbCBpZHMgaW4gdGhlIHZpZXdcclxuICogdmFyIGlkcyA9IHZpZXcuZ2V0SWRzKCk7XHJcbiAqIGNvbnNvbGUubG9nKCdpZHMnLCBpZHMpOyAvLyB3aWxsIG91dHB1dCBbMSwgMl1cclxuICpcclxuICogLy8gZ2V0IGFsbCBpdGVtcyBpbiB0aGUgdmlld1xyXG4gKiB2YXIgaXRlbXMgPSB2aWV3LmdldCgpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHR5cGVQYXJhbSBJdGVtIC0gSXRlbSB0eXBlIHRoYXQgbWF5IG9yIG1heSBub3QgaGF2ZSBhbiBpZC5cclxuICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cclxuICovXG5cblxudmFyIERhdGFWaWV3ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRGF0YVNldFBhcnQyKSB7XG4gIF9pbmhlcml0cyhEYXRhVmlldywgX0RhdGFTZXRQYXJ0Mik7XG5cbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIkdChEYXRhVmlldyk7XG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgRGF0YVZpZXcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBpbnN0YW5jZSBjb250YWluaW5nIGRhdGEgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHkpLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBjb25maWd1cmUgdGhpcyBkYXRhIHZpZXcuXHJcbiAgICovXG4gIGZ1bmN0aW9uIERhdGFWaWV3KGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2NvbnRleHQyNztcblxuICAgIHZhciBfdGhpczc7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVZpZXcpO1xuXG4gICAgX3RoaXM3ID0gX3N1cGVyMi5jYWxsKHRoaXMpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM3KSwgXCJsZW5ndGhcIiwgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczcpLCBcIl9saXN0ZW5lclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM3KSwgXCJfZGF0YVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM3KSwgXCJfaWRzXCIsIG5ldyBzZXQoKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczcpLCBcIl9vcHRpb25zXCIsIHZvaWQgMCk7XG5cbiAgICBfdGhpczcuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIF90aGlzNy5fbGlzdGVuZXIgPSBiaW5kJDYoX2NvbnRleHQyNyA9IF90aGlzNy5fb25FdmVudCkuY2FsbChfY29udGV4dDI3LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNykpO1xuXG4gICAgX3RoaXM3LnNldERhdGEoZGF0YSk7XG5cbiAgICByZXR1cm4gX3RoaXM3O1xuICB9IC8vIFRPRE86IGltcGxlbWVudCBhIGZ1bmN0aW9uIC5jb25maWcoKSB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhpbmdzIGxpa2UgY29uZmlndXJlZCBmaWx0ZXJcbiAgLy8gYW5kIHRyaWdnZXIgY2hhbmdlcyBhY2NvcmRpbmdseVxuXG4gIC8qKlxyXG4gICAqIFNldCBhIGRhdGEgc291cmNlIGZvciB0aGUgdmlldy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBkYXRhIC0gVGhlIGluc3RhbmNlIGNvbnRhaW5pbmcgZGF0YSAoZGlyZWN0bHkgb3IgaW5kaXJlY3RseSkuXHJcbiAgICogQHJlbWFya3NcclxuICAgKiBOb3RlIHRoYXQgd2hlbiB0aGUgZGF0YSB2aWV3IGlzIGJvdW5kIHRvIGEgZGF0YSBzZXQgaXQgd29uJ3QgYmUgZ2FyYmFnZVxyXG4gICAqIGNvbGxlY3RlZCB1bmxlc3MgdGhlIGRhdGEgc2V0IGlzIHRvby4gVXNlIGBkYXRhVmlldy5zZXREYXRhKG51bGwpYCBvclxyXG4gICAqIGBkYXRhVmlldy5kaXNwb3NlKClgIHRvIGVuYWJsZSBnYXJiYWdlIGNvbGxlY3Rpb24gYmVmb3JlIHlvdSBsb3NlIHRoZSBsYXN0XHJcbiAgICogcmVmZXJlbmNlLlxyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKERhdGFWaWV3LCBbe1xuICAgIGtleTogXCJpZFByb3BcIixcbiAgICBnZXQ6XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXREYXRhU2V0KCkuaWRQcm9wO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGEoZGF0YSkge1xuICAgICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBjdXJyZW50IGRhdGFzZXRcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEub2ZmKSB7XG4gICAgICAgICAgdGhpcy5fZGF0YS5vZmYoXCIqXCIsIHRoaXMuX2xpc3RlbmVyKTtcbiAgICAgICAgfSAvLyB0cmlnZ2VyIGEgcmVtb3ZlIG9mIGFsbCBpdGVtcyBpbiBtZW1vcnlcblxuXG4gICAgICAgIHZhciBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7XG4gICAgICAgICAgZmlsdGVyOiBmaWx0ZXIodGhpcy5fb3B0aW9ucylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5fZGF0YS5nZXQoaWRzKTtcblxuICAgICAgICB0aGlzLl9pZHMuY2xlYXIoKTtcblxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcInJlbW92ZVwiLCB7XG4gICAgICAgICAgaXRlbXM6IGlkcyxcbiAgICAgICAgICBvbGREYXRhOiBpdGVtc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTsgLy8gdHJpZ2dlciBhbiBhZGQgb2YgYWxsIGFkZGVkIGl0ZW1zXG5cbiAgICAgICAgdmFyIF9pZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7XG4gICAgICAgICAgZmlsdGVyOiBmaWx0ZXIodGhpcy5fb3B0aW9ucylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IF9pZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgaWQgPSBfaWRzW2ldO1xuXG4gICAgICAgICAgdGhpcy5faWRzLmFkZChpZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxlbmd0aCA9IF9pZHMubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJhZGRcIiwge1xuICAgICAgICAgIGl0ZW1zOiBfaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBEYXRhU2V0KCk7XG4gICAgICB9IC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuXG5cbiAgICAgIGlmICh0aGlzLl9kYXRhLm9uKSB7XG4gICAgICAgIHRoaXMuX2RhdGEub24oXCIqXCIsIHRoaXMuX2xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoIHRoZSBEYXRhVmlldy5cclxuICAgICAqIFVzZWZ1bCB3aGVuIHRoZSBEYXRhVmlldyBoYXMgYSBmaWx0ZXIgZnVuY3Rpb24gY29udGFpbmluZyBhIHZhcmlhYmxlIHBhcmFtZXRlci5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgdmFyIGlkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHtcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIodGhpcy5fb3B0aW9ucylcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgb2xkSWRzID0gX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX2lkcyk7XG5cbiAgICAgIHZhciBuZXdJZHMgPSB7fTtcbiAgICAgIHZhciBhZGRlZElkcyA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWRJZHMgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkSXRlbXMgPSBbXTsgLy8gY2hlY2sgZm9yIGFkZGl0aW9uc1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgbmV3SWRzW2lkXSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pZHMuaGFzKGlkKSkge1xuICAgICAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuXG4gICAgICAgICAgdGhpcy5faWRzLmFkZChpZCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY2hlY2sgZm9yIHJlbW92YWxzXG5cblxuICAgICAgZm9yICh2YXIgX2kxMCA9IDAsIF9sZW4xMSA9IG9sZElkcy5sZW5ndGg7IF9pMTAgPCBfbGVuMTE7IF9pMTArKykge1xuICAgICAgICB2YXIgX2lkNyA9IG9sZElkc1tfaTEwXTtcblxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KF9pZDcpO1xuXG4gICAgICAgIGlmIChpdGVtID09IG51bGwpIHtcbiAgICAgICAgICAvLyBAVE9ETzogSW52ZXN0aWdhdGUuXG4gICAgICAgICAgLy8gRG9lc24ndCBoYXBwZW4gZHVyaW5nIHRlc3RzIG9yIGV4YW1wbGVzLlxuICAgICAgICAgIC8vIElzIGl0IHJlYWxseSBpbXBvc3NpYmxlIG9yIGNvdWxkIGl0IGV2ZW50dWFsbHkgaGFwcGVuP1xuICAgICAgICAgIC8vIEhvdyB0byBoYW5kbGUgaXQgaWYgaXQgZG9lcz8gVGhlIHR5cGVzIGd1YXJhbnRlZSBub24tbnVsbGFibGUgaXRlbXMuXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIklmIHlvdSBzZWUgdGhpcywgcmVwb3J0IGl0IHBsZWFzZS5cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoIW5ld0lkc1tfaWQ3XSkge1xuICAgICAgICAgIHJlbW92ZWRJZHMucHVzaChfaWQ3KTtcbiAgICAgICAgICByZW1vdmVkSXRlbXMucHVzaChpdGVtKTtcblxuICAgICAgICAgIHRoaXMuX2lkcy5kZWxldGUoX2lkNyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggKz0gYWRkZWRJZHMubGVuZ3RoIC0gcmVtb3ZlZElkcy5sZW5ndGg7IC8vIHRyaWdnZXIgZXZlbnRzXG5cbiAgICAgIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcImFkZFwiLCB7XG4gICAgICAgICAgaXRlbXM6IGFkZGVkSWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtb3ZlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcInJlbW92ZVwiLCB7XG4gICAgICAgICAgaXRlbXM6IHJlbW92ZWRJZHMsXG4gICAgICAgICAgb2xkRGF0YTogcmVtb3ZlZEl0ZW1zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoZmlyc3QsIHNlY29uZCkge1xuICAgICAgaWYgKHRoaXMuX2RhdGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gLy8gcGFyc2UgdGhlIGFyZ3VtZW50c1xuXG5cbiAgICAgIHZhciBpZHMgPSBudWxsO1xuICAgICAgdmFyIG9wdGlvbnM7XG5cbiAgICAgIGlmIChpc0lkKGZpcnN0KSB8fCBpc0FycmF5JDIoZmlyc3QpKSB7XG4gICAgICAgIGlkcyA9IGZpcnN0O1xuICAgICAgICBvcHRpb25zID0gc2Vjb25kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IGZpcnN0O1xuICAgICAgfSAvLyBleHRlbmQgdGhlIG9wdGlvbnMgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zIGFuZCBwcm92aWRlZCBvcHRpb25zXG5cblxuICAgICAgdmFyIHZpZXdPcHRpb25zID0gYXNzaWduJDIoe30sIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpOyAvLyBjcmVhdGUgYSBjb21iaW5lZCBmaWx0ZXIgbWV0aG9kIHdoZW4gbmVlZGVkXG5cblxuICAgICAgdmFyIHRoaXNGaWx0ZXIgPSBmaWx0ZXIodGhpcy5fb3B0aW9ucyk7XG5cbiAgICAgIHZhciBvcHRpb25zRmlsdGVyID0gb3B0aW9ucyAmJiBmaWx0ZXIob3B0aW9ucyk7XG5cbiAgICAgIGlmICh0aGlzRmlsdGVyICYmIG9wdGlvbnNGaWx0ZXIpIHtcbiAgICAgICAgdmlld09wdGlvbnMuZmlsdGVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpc0ZpbHRlcihpdGVtKSAmJiBvcHRpb25zRmlsdGVyKGl0ZW0pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaWRzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0KHZpZXdPcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldChpZHMsIHZpZXdPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRJZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SWRzKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLl9kYXRhLmxlbmd0aCkge1xuICAgICAgICB2YXIgZGVmYXVsdEZpbHRlciA9IGZpbHRlcih0aGlzLl9vcHRpb25zKTtcblxuICAgICAgICB2YXIgb3B0aW9uc0ZpbHRlciA9IG9wdGlvbnMgIT0gbnVsbCA/IGZpbHRlcihvcHRpb25zKSA6IG51bGw7XG4gICAgICAgIHZhciBmaWx0ZXIkMTtcblxuICAgICAgICBpZiAob3B0aW9uc0ZpbHRlcikge1xuICAgICAgICAgIGlmIChkZWZhdWx0RmlsdGVyKSB7XG4gICAgICAgICAgICBmaWx0ZXIkMSA9IGZ1bmN0aW9uIGZpbHRlcihpdGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RmlsdGVyKGl0ZW0pICYmIG9wdGlvbnNGaWx0ZXIoaXRlbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXIkMSA9IG9wdGlvbnNGaWx0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbHRlciQxID0gZGVmYXVsdEZpbHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldElkcyh7XG4gICAgICAgICAgZmlsdGVyOiBmaWx0ZXIkMSxcbiAgICAgICAgICBvcmRlcjogb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZvckVhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0Mjg7XG5cbiAgICAgICAgdmFyIGRlZmF1bHRGaWx0ZXIgPSBmaWx0ZXIodGhpcy5fb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIG9wdGlvbnNGaWx0ZXIgPSBvcHRpb25zICYmIGZpbHRlcihvcHRpb25zKTtcblxuICAgICAgICB2YXIgZmlsdGVyJDE7XG5cbiAgICAgICAgaWYgKG9wdGlvbnNGaWx0ZXIpIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdEZpbHRlcikge1xuICAgICAgICAgICAgZmlsdGVyJDEgPSBmdW5jdGlvbiBmaWx0ZXIoaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdEZpbHRlcihpdGVtKSAmJiBvcHRpb25zRmlsdGVyKGl0ZW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlsdGVyJDEgPSBvcHRpb25zRmlsdGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWx0ZXIkMSA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JFYWNoJDIoX2NvbnRleHQyOCA9IHRoaXMuX2RhdGEpLmNhbGwoX2NvbnRleHQyOCwgY2FsbGJhY2ssIHtcbiAgICAgICAgICBmaWx0ZXI6IGZpbHRlciQxLFxuICAgICAgICAgIG9yZGVyOiBvcHRpb25zICYmIG9wdGlvbnMub3JkZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0Mjk7XG5cbiAgICAgICAgdmFyIGRlZmF1bHRGaWx0ZXIgPSBmaWx0ZXIodGhpcy5fb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIG9wdGlvbnNGaWx0ZXIgPSBvcHRpb25zICYmIGZpbHRlcihvcHRpb25zKTtcblxuICAgICAgICB2YXIgZmlsdGVyJDE7XG5cbiAgICAgICAgaWYgKG9wdGlvbnNGaWx0ZXIpIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdEZpbHRlcikge1xuICAgICAgICAgICAgZmlsdGVyJDEgPSBmdW5jdGlvbiBmaWx0ZXIoaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdEZpbHRlcihpdGVtKSAmJiBvcHRpb25zRmlsdGVyKGl0ZW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlsdGVyJDEgPSBvcHRpb25zRmlsdGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWx0ZXIkMSA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFwJDMoX2NvbnRleHQyOSA9IHRoaXMuX2RhdGEpLmNhbGwoX2NvbnRleHQyOSwgY2FsbGJhY2ssIHtcbiAgICAgICAgICBmaWx0ZXI6IGZpbHRlciQxLFxuICAgICAgICAgIG9yZGVyOiBvcHRpb25zICYmIG9wdGlvbnMub3JkZXJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGF0YVNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhU2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0RGF0YVNldCgpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0cmVhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJlYW0oaWRzKSB7XG4gICAgICB2YXIgX2NvbnRleHQzMDtcblxuICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuc3RyZWFtKGlkcyB8fCBfZGVmaW5lUHJvcGVydHkoe30sIGl0ZXJhdG9yLCBiaW5kJDYoX2NvbnRleHQzMCA9IGtleXModGhpcy5faWRzKSkuY2FsbChfY29udGV4dDMwLCB0aGlzLl9pZHMpKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmVuZGVyIHRoZSBpbnN0YW5jZSB1bnVzYWJsZSBwcmlvciB0byBnYXJiYWdlIGNvbGxlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIFRoZSBpbnRlbnRpb24gb2YgdGhpcyBtZXRob2QgaXMgdG8gaGVscCBkaXNjb3ZlciBzY2VuYXJpb3Mgd2hlcmUgdGhlIGRhdGFcclxuICAgICAqIHZpZXcgaXMgYmVpbmcgdXNlZCB3aGVuIHRoZSBwcm9ncmFtbWVyIHRoaW5rcyBpdCBoYXMgYmVlbiBnYXJiYWdlIGNvbGxlY3RlZFxyXG4gICAgICogYWxyZWFkeS4gSXQncyBzdHJpY3RlciB2ZXJzaW9uIG9mIGBkYXRhVmlldy5zZXREYXRhKG51bGwpYC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgdmFyIF90aGlzJF9kYXRhO1xuXG4gICAgICBpZiAoKF90aGlzJF9kYXRhID0gdGhpcy5fZGF0YSkgIT09IG51bGwgJiYgX3RoaXMkX2RhdGEgIT09IHZvaWQgMCAmJiBfdGhpcyRfZGF0YS5vZmYpIHtcbiAgICAgICAgdGhpcy5fZGF0YS5vZmYoXCIqXCIsIHRoaXMuX2xpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1lc3NhZ2UgPSBcIlRoaXMgZGF0YSB2aWV3IGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQgb2YuXCI7XG4gICAgICB2YXIgcmVwbGFjZW1lbnQgPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMTQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KG93bktleXMkNShEYXRhVmlldy5wcm90b3R5cGUpKSxcbiAgICAgICAgICBfc3RlcDE0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjE0LnMoKTsgIShfc3RlcDE0ID0gX2l0ZXJhdG9yMTQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDE0LnZhbHVlO1xuXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkkNih0aGlzLCBrZXksIHJlcGxhY2VtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjE0LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjE0LmYoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCBsaXN0ZW5lci4gV2lsbCBwcm9wYWdhdGUgYWxsIGV2ZW50cyBmcm9tIHRoZSBjb25uZWN0ZWQgZGF0YSBzZXQgdG8gdGhlIHN1YnNjcmliZXJzIG9mIHRoZSBEYXRhVmlldywgYnV0IHdpbGwgZmlsdGVyIHRoZSBpdGVtcyBhbmQgb25seSB0cmlnZ2VyIHdoZW4gdGhlcmUgYXJlIGNoYW5nZXMgaW4gdGhlIGZpbHRlcmVkIGRhdGEgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBzZW5kZXJJZCAtIElkIHN1cHBsaWVkIGJ5IHRoZSBzZW5kZXIuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9vbkV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkV2ZW50KGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICBpZiAoIXBhcmFtcyB8fCAhcGFyYW1zLml0ZW1zIHx8ICF0aGlzLl9kYXRhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkcyA9IHBhcmFtcy5pdGVtcztcbiAgICAgIHZhciBhZGRlZElkcyA9IFtdO1xuICAgICAgdmFyIHVwZGF0ZWRJZHMgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkSWRzID0gW107XG4gICAgICB2YXIgb2xkSXRlbXMgPSBbXTtcbiAgICAgIHZhciB1cGRhdGVkSXRlbXMgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkSXRlbXMgPSBbXTtcblxuICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICBjYXNlIFwiYWRkXCI6XG4gICAgICAgICAgLy8gZmlsdGVyIHRoZSBpZHMgb2YgdGhlIGFkZGVkIGl0ZW1zXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdldChpZCk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2lkcy5hZGQoaWQpO1xuXG4gICAgICAgICAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGV2ZW50IGZyb20gdGhlIHZpZXdzIHZpZXdwb2ludDogYW4gdXBkYXRlZFxuICAgICAgICAgIC8vIGl0ZW0gY2FuIGJlIGFkZGVkLCB1cGRhdGVkLCBvciByZW1vdmVkIGZyb20gdGhpcyB2aWV3LlxuICAgICAgICAgIGZvciAodmFyIF9pMTEgPSAwLCBfbGVuMTIgPSBpZHMubGVuZ3RoOyBfaTExIDwgX2xlbjEyOyBfaTExKyspIHtcbiAgICAgICAgICAgIHZhciBfaWQ4ID0gaWRzW19pMTFdO1xuXG4gICAgICAgICAgICB2YXIgX2l0ZW01ID0gdGhpcy5nZXQoX2lkOCk7XG5cbiAgICAgICAgICAgIGlmIChfaXRlbTUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2lkcy5oYXMoX2lkOCkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkSWRzLnB1c2goX2lkOCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlZEl0ZW1zLnB1c2gocGFyYW1zLmRhdGFbX2kxMV0pO1xuICAgICAgICAgICAgICAgIG9sZEl0ZW1zLnB1c2gocGFyYW1zLm9sZERhdGFbX2kxMV0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lkcy5hZGQoX2lkOCk7XG5cbiAgICAgICAgICAgICAgICBhZGRlZElkcy5wdXNoKF9pZDgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodGhpcy5faWRzLmhhcyhfaWQ4KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lkcy5kZWxldGUoX2lkOCk7XG5cbiAgICAgICAgICAgICAgICByZW1vdmVkSWRzLnB1c2goX2lkOCk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2gocGFyYW1zLm9sZERhdGFbX2kxMV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcInJlbW92ZVwiOlxuICAgICAgICAgIC8vIGZpbHRlciB0aGUgaWRzIG9mIHRoZSByZW1vdmVkIGl0ZW1zXG4gICAgICAgICAgZm9yICh2YXIgX2kxMiA9IDAsIF9sZW4xMyA9IGlkcy5sZW5ndGg7IF9pMTIgPCBfbGVuMTM7IF9pMTIrKykge1xuICAgICAgICAgICAgdmFyIF9pZDkgPSBpZHNbX2kxMl07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pZHMuaGFzKF9pZDkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2lkcy5kZWxldGUoX2lkOSk7XG5cbiAgICAgICAgICAgICAgcmVtb3ZlZElkcy5wdXNoKF9pZDkpO1xuICAgICAgICAgICAgICByZW1vdmVkSXRlbXMucHVzaChwYXJhbXMub2xkRGF0YVtfaTEyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IGFkZGVkSWRzLmxlbmd0aCAtIHJlbW92ZWRJZHMubGVuZ3RoO1xuXG4gICAgICBpZiAoYWRkZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJhZGRcIiwge1xuICAgICAgICAgIGl0ZW1zOiBhZGRlZElkc1xuICAgICAgICB9LCBzZW5kZXJJZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1cGRhdGVkSWRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyKFwidXBkYXRlXCIsIHtcbiAgICAgICAgICBpdGVtczogdXBkYXRlZElkcyxcbiAgICAgICAgICBvbGREYXRhOiBvbGRJdGVtcyxcbiAgICAgICAgICBkYXRhOiB1cGRhdGVkSXRlbXNcbiAgICAgICAgfSwgc2VuZGVySWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtb3ZlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcInJlbW92ZVwiLCB7XG4gICAgICAgICAgaXRlbXM6IHJlbW92ZWRJZHMsXG4gICAgICAgICAgb2xkRGF0YTogcmVtb3ZlZEl0ZW1zXG4gICAgICAgIH0sIHNlbmRlcklkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0YVZpZXc7XG59KERhdGFTZXRQYXJ0KTtcbi8qKlxyXG4gKiBDaGVjayB0aGF0IGdpdmVuIHZhbHVlIGlzIGNvbXBhdGlibGUgd2l0aCBWaXMgRGF0YSBTZXQgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gaWRQcm9wIC0gVGhlIGV4cGVjdGVkIHByb3BlcnR5IHRvIGNvbnRhaW4gaXRlbSBpZC5cclxuICogQHBhcmFtIHYgLSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIGFsbCBleHBlY3RlZCB2YWx1ZXMgYW5kIG1ldGhvZHMgbWF0Y2gsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gaXNEYXRhU2V0TGlrZShpZFByb3AsIHYpIHtcbiAgcmV0dXJuIF90eXBlb2YodikgPT09IFwib2JqZWN0XCIgJiYgdiAhPT0gbnVsbCAmJiBpZFByb3AgPT09IHYuaWRQcm9wICYmIHR5cGVvZiB2LmFkZCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmNsZWFyID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuZGlzdGluY3QgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZm9yRWFjaCQyKHYpID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuZ2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuZ2V0RGF0YVNldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LmdldElkcyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgbWFwJDModikgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5tYXggPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5taW4gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5vZmYgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5vbiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2LnNldE9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5zdHJlYW0gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi51cGRhdGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi51cGRhdGVPbmx5ID09PSBcImZ1bmN0aW9uXCI7XG59XG4vKipcclxuICogQ2hlY2sgdGhhdCBnaXZlbiB2YWx1ZSBpcyBjb21wYXRpYmxlIHdpdGggVmlzIERhdGEgVmlldyBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBpZFByb3AgLSBUaGUgZXhwZWN0ZWQgcHJvcGVydHkgdG8gY29udGFpbiBpdGVtIGlkLlxyXG4gKiBAcGFyYW0gdiAtIFRoZSB2YWx1ZSB0byBiZSB0ZXN0ZWQuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgYWxsIGV4cGVjdGVkIHZhbHVlcyBhbmQgbWV0aG9kcyBtYXRjaCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBpc0RhdGFWaWV3TGlrZShpZFByb3AsIHYpIHtcbiAgcmV0dXJuIF90eXBlb2YodikgPT09IFwib2JqZWN0XCIgJiYgdiAhPT0gbnVsbCAmJiBpZFByb3AgPT09IHYuaWRQcm9wICYmIHR5cGVvZiBmb3JFYWNoJDIodikgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5nZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygdi5nZXREYXRhU2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuZ2V0SWRzID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYubGVuZ3RoID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBtYXAkMyh2KSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2Lm9mZiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2Lm9uID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHYuc3RyZWFtID09PSBcImZ1bmN0aW9uXCIgJiYgaXNEYXRhU2V0TGlrZShpZFByb3AsIHYuZ2V0RGF0YVNldCgpKTtcbn1cblxudmFyIGluZGV4ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdERFTEVURTogREVMRVRFLFxuXHREYXRhU2V0OiBEYXRhU2V0LFxuXHREYXRhU3RyZWFtOiBEYXRhU3RyZWFtLFxuXHREYXRhVmlldzogRGF0YVZpZXcsXG5cdFF1ZXVlOiBRdWV1ZSxcblx0Y3JlYXRlTmV3RGF0YVBpcGVGcm9tOiBjcmVhdGVOZXdEYXRhUGlwZUZyb20sXG5cdGlzRGF0YVNldExpa2U6IGlzRGF0YVNldExpa2UsXG5cdGlzRGF0YVZpZXdMaWtlOiBpc0RhdGFWaWV3TGlrZVxufSk7XG5cbnZhciBnbG9iYWwkMiA9IGdsb2JhbCRQO1xudmFyIGZhaWxzJDEgPSBmYWlscyR0O1xudmFyIHVuY3VycnlUaGlzJDIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvU3RyaW5nID0gdG9TdHJpbmckODtcbnZhciB0cmltID0gc3RyaW5nVHJpbS50cmltO1xudmFyIHdoaXRlc3BhY2VzID0gd2hpdGVzcGFjZXMkNDtcbnZhciBjaGFyQXQgPSB1bmN1cnJ5VGhpcyQyKCcnLmNoYXJBdCk7XG52YXIgbiRQYXJzZUZsb2F0ID0gZ2xvYmFsJDIucGFyc2VGbG9hdDtcbnZhciBTeW1ib2wkMSA9IGdsb2JhbCQyLlN5bWJvbDtcbnZhciBJVEVSQVRPUiA9IFN5bWJvbCQxICYmIFN5bWJvbCQxLml0ZXJhdG9yO1xudmFyIEZPUkNFRCA9IDEgLyBuJFBhcnNlRmxvYXQod2hpdGVzcGFjZXMgKyAnLTAnKSAhPT0gLUluZmluaXR5IC8vIE1TIEVkZ2UgMTgtIGJyb2tlbiB3aXRoIGJveGVkIHN5bWJvbHNcbnx8IElURVJBVE9SICYmICFmYWlscyQxKGZ1bmN0aW9uICgpIHtcbiAgbiRQYXJzZUZsb2F0KE9iamVjdChJVEVSQVRPUikpO1xufSk7IC8vIGBwYXJzZUZsb2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcGFyc2VmbG9hdC1zdHJpbmdcblxudmFyIG51bWJlclBhcnNlRmxvYXQgPSBGT1JDRUQgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cmluZykge1xuICB2YXIgdHJpbW1lZFN0cmluZyA9IHRyaW0odG9TdHJpbmcoc3RyaW5nKSk7XG4gIHZhciByZXN1bHQgPSBuJFBhcnNlRmxvYXQodHJpbW1lZFN0cmluZyk7XG4gIHJldHVybiByZXN1bHQgPT09IDAgJiYgY2hhckF0KHRyaW1tZWRTdHJpbmcsIDApID09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6IG4kUGFyc2VGbG9hdDtcblxudmFyICQkNCA9IF9leHBvcnQ7XG52YXIgJHBhcnNlRmxvYXQgPSBudW1iZXJQYXJzZUZsb2F0OyAvLyBgcGFyc2VGbG9hdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXBhcnNlZmxvYXQtc3RyaW5nXG5cbiQkNCh7XG4gIGdsb2JhbDogdHJ1ZSxcbiAgZm9yY2VkOiBwYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0XG59LCB7XG4gIHBhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0XG59KTtcblxudmFyIHBhdGgkNSA9IHBhdGgkeTtcbnZhciBfcGFyc2VGbG9hdCQyID0gcGF0aCQ1LnBhcnNlRmxvYXQ7XG5cbnZhciBwYXJlbnQkOSA9IF9wYXJzZUZsb2F0JDI7XG52YXIgX3BhcnNlRmxvYXQkMSA9IHBhcmVudCQ5O1xuXG52YXIgX3BhcnNlRmxvYXQgPSBfcGFyc2VGbG9hdCQxO1xuXG52YXIgJCQzID0gX2V4cG9ydDtcbnZhciBmYWlscyA9IGZhaWxzJHQ7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyQzID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmY7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygxKTtcbn0pOyAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuXG4kJDMoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVNcbn0sIHtcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogZ2V0T3duUHJvcGVydHlOYW1lcyQzXG59KTtcblxudmFyIHBhdGgkNCA9IHBhdGgkeTtcbnZhciBPYmplY3QkMSA9IHBhdGgkNC5PYmplY3Q7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzJDIgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiBPYmplY3QkMS5nZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcbn07XG5cbnZhciBwYXJlbnQkOCA9IGdldE93blByb3BlcnR5TmFtZXMkMjtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzJDEgPSBwYXJlbnQkODtcblxudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzJDE7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lIHZhbHVlcyB0byB1c2UgZm9yIChzdWIpb3B0aW9ucyBvZiAnY2hvc2VuJy5cbiAqXG4gKiBUaGlzIG9wdGlvbiBpcyBlaXRoZXIgYSBib29sZWFuIG9yIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgc2hvdWxkIGJlIGV4YW1pbmVkIGZ1cnRoZXIuXG4gKiBUaGUgcmVsZXZhbnQgc3RydWN0dXJlcyBhcmU6XG4gKlxuICogLSBjaG9zZW46IDxib29sZWFuIHZhbHVlPlxuICogLSBjaG9zZW46IHsgc3ViT3B0aW9uOiA8Ym9vbGVhbiBvciBmdW5jdGlvbj4gfVxuICpcbiAqIFdoZXJlIHN1Yk9wdGlvbiBpcyAnbm9kZScsICdlZGdlJyBvciAnbGFiZWwnLlxuICpcbiAqIFRoZSBpbnRlbnRpb24gb2YgdGhpcyBtZXRob2QgYXBwZWFycyB0byBiZSB0byBzZXQgYSBzcGVjaWZpYyBwcmlvcml0eSB0byB0aGUgb3B0aW9ucztcbiAqIFNpbmNlIG1vc3QgcHJvcGVydGllcyBhcmUgZWl0aGVyIGJyaWRnZWQgb3IgbWVyZ2VkIGludG8gdGhlIGxvY2FsIG9wdGlvbnMgb2JqZWN0cywgdGhlcmVcbiAqIGlzIG5vdCBtdWNoIHBvaW50IGluIGhhbmRsaW5nIHRoZW0gc2VwYXJhdGVseS5cbiAqIFRPRE86IGV4YW1pbmUgaWYgJ21vc3QnIGluIHByZXZpb3VzIHNlbnRlbmNlIGNhbiBiZSByZXBsYWNlZCB3aXRoICdhbGwnLiBJbiB0aGF0IGNhc2UsIHdlXG4gKiAgICAgICBzaG91bGQgYmUgYWJsZSB0byBnZXQgcmlkIG9mIHRoaXMgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgc3ViT3B0aW9uICBvcHRpb24gd2l0aGluIG9iamVjdCAnY2hvc2VuJyB0byBjb25zaWRlcjsgZWl0aGVyICdub2RlJywgJ2VkZ2UnIG9yICdsYWJlbCdcbiAqIEBwYXJhbSB7b2JqZWN0fSAgcGlsZSAgICAgICBhcnJheSBvZiBvcHRpb25zIG9iamVjdHMgdG8gY29uc2lkZXJcbiAqIEByZXR1cm5zIHtib29sZWFuIHwgRnVuY3Rpb259ICB2YWx1ZSBmb3IgcGFzc2VkIHN1Yk9wdGlvbiBvZiAnY2hvc2VuJyB0byB1c2VcbiAqL1xuXG5mdW5jdGlvbiBjaG9vc2lmeShzdWJPcHRpb24sIHBpbGUpIHtcbiAgLy8gYWxsb3dlZCB2YWx1ZXMgZm9yIHN1Yk9wdGlvblxuICB2YXIgYWxsb3dlZCA9IFtcIm5vZGVcIiwgXCJlZGdlXCIsIFwibGFiZWxcIl07XG4gIHZhciB2YWx1ZSA9IHRydWU7XG4gIHZhciBjaG9zZW4gPSB0b3BNb3N0KHBpbGUsIFwiY2hvc2VuXCIpO1xuXG4gIGlmICh0eXBlb2YgY2hvc2VuID09PSBcImJvb2xlYW5cIikge1xuICAgIHZhbHVlID0gY2hvc2VuO1xuICB9IGVsc2UgaWYgKF90eXBlb2YoY2hvc2VuKSA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChpbmRleE9mKGFsbG93ZWQpLmNhbGwoYWxsb3dlZCwgc3ViT3B0aW9uKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNob29zaWZ5OiBzdWJPcHRpb24gJ1wiICsgc3ViT3B0aW9uICsgXCInIHNob3VsZCBiZSBvbmUgb2YgXCIgKyBcIidcIiArIGFsbG93ZWQuam9pbihcIicsICdcIikgKyBcIidcIik7XG4gICAgfVxuXG4gICAgdmFyIGNob3NlbkVkZ2UgPSB0b3BNb3N0KHBpbGUsIFtcImNob3NlblwiLCBzdWJPcHRpb25dKTtcblxuICAgIGlmICh0eXBlb2YgY2hvc2VuRWRnZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIGNob3NlbkVkZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdmFsdWUgPSBjaG9zZW5FZGdlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBvaW50IGZhbGxzIHdpdGhpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICpcbiAqIEBwYXJhbSB7cmVjdH0gcmVjdFxuICogQHBhcmFtIHtwb2ludH0gcG9pbnRcbiAqIEBwYXJhbSB7cm90YXRpb25Qb2ludH0gW3JvdGF0aW9uUG9pbnRdIGlmIHNwZWNpZmllZCwgdGhlIHJvdGF0aW9uIHRoYXQgYXBwbGllcyB0byB0aGUgcmVjdGFuZ2xlLlxuICogQHJldHVybnMge2Jvb2xlYW59ICB0cnVlIGlmIHBvaW50IHdpdGhpbiByZWN0YW5nbGUsIGZhbHNlIG90aGVyd2lzZVxuICovXG5cbmZ1bmN0aW9uIHBvaW50SW5SZWN0KHJlY3QsIHBvaW50LCByb3RhdGlvblBvaW50KSB7XG4gIGlmIChyZWN0LndpZHRoIDw9IDAgfHwgcmVjdC5oZWlnaHQgPD0gMCkge1xuICAgIHJldHVybiBmYWxzZTsgLy8gZWFybHkgb3V0XG4gIH1cblxuICBpZiAocm90YXRpb25Qb2ludCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gUm90YXRlIHRoZSBwb2ludCB0aGUgc2FtZSBhbW91bnQgYXMgdGhlIHJlY3RhbmdsZVxuICAgIHZhciB0bXAgPSB7XG4gICAgICB4OiBwb2ludC54IC0gcm90YXRpb25Qb2ludC54LFxuICAgICAgeTogcG9pbnQueSAtIHJvdGF0aW9uUG9pbnQueVxuICAgIH07XG5cbiAgICBpZiAocm90YXRpb25Qb2ludC5hbmdsZSAhPT0gMCkge1xuICAgICAgLy8gSW4gb3JkZXIgdG8gZ2V0IHRoZSBjb29yZGluYXRlcyB0aGUgc2FtZSwgeW91IG5lZWQgdG9cbiAgICAgIC8vIHJvdGF0ZSBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb25cbiAgICAgIHZhciBhbmdsZSA9IC1yb3RhdGlvblBvaW50LmFuZ2xlO1xuICAgICAgdmFyIHRtcDIgPSB7XG4gICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIHRtcC54IC0gTWF0aC5zaW4oYW5nbGUpICogdG1wLnksXG4gICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIHRtcC54ICsgTWF0aC5jb3MoYW5nbGUpICogdG1wLnlcbiAgICAgIH07XG4gICAgICBwb2ludCA9IHRtcDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ID0gdG1wO1xuICAgIH0gLy8gTm90ZSB0aGF0IGlmIGEgcm90YXRpb24gaXMgc3BlY2lmaWVkLCB0aGUgcmVjdGFuZ2xlIGNvb3JkaW5hdGVzXG4gICAgLy8gYXJlICoqbm90KiB0aGUgZnVsbCBjYW52YXMgY29vcmRpbmF0ZXMuIFRoZXkgYXJlIHJlbGF0aXZlIHRvIHRoZVxuICAgIC8vIHJvdGF0aW9uUG9pbnQuIEhlbmNlLCB0aGUgcG9pbnQgY29vcmRpbmF0ZXMgbmVlZCBub3QgYmUgdHJhbnNsYXRlZFxuICAgIC8vIGJhY2sgaW4gdGhpcyBjYXNlLlxuXG4gIH1cblxuICB2YXIgcmlnaHQgPSByZWN0LnggKyByZWN0LndpZHRoO1xuICB2YXIgYm90dG9tID0gcmVjdC55ICsgcmVjdC53aWR0aDtcbiAgcmV0dXJuIHJlY3QubGVmdCA8IHBvaW50LnggJiYgcmlnaHQgPiBwb2ludC54ICYmIHJlY3QudG9wIDwgcG9pbnQueSAmJiBib3R0b20gPiBwb2ludC55O1xufVxuLyoqXG4gKiBDaGVjayBpZiBnaXZlbiB2YWx1ZSBpcyBhY2NlcHRhYmxlIGFzIGEgbGFiZWwgdGV4dC5cbiAqXG4gKiBAcGFyYW0geyp9IHRleHQgdmFsdWUgdG8gY2hlY2s7IGNhbiBiZSBhbnl0aGluZyBhdCB0aGlzIHBvaW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCBsYWJlbCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZExhYmVsKHRleHQpIHtcbiAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgcXVpdGUgc3RyaWN0OiB0eXBlcyB0aGF0ICptaWdodCogYmUgY29udmVydGVkIHRvIHN0cmluZyBhcmUgZGlzYWxsb3dlZFxuICByZXR1cm4gdHlwZW9mIHRleHQgPT09IFwic3RyaW5nXCIgJiYgdGV4dCAhPT0gXCJcIjtcbn1cbi8qKlxuICogUmV0dXJucyB4LCB5IG9mIHNlbGYgcmVmZXJlbmNlIGNpcmNsZSBiYXNlZCBvbiBwcm92aWRlZCBhbmdsZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjdHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xuICogQHBhcmFtIHtWaXNOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB4IGFuZCB5IGNvb3JkaW5hdGVzXG4gKi9cblxuZnVuY3Rpb24gZ2V0U2VsZlJlZkNvb3JkaW5hdGVzKGN0eCwgYW5nbGUsIHJhZGl1cywgbm9kZSkge1xuICB2YXIgeCA9IG5vZGUueDtcbiAgdmFyIHkgPSBub2RlLnk7XG5cbiAgaWYgKHR5cGVvZiBub2RlLmRpc3RhbmNlVG9Cb3JkZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vY2FsY3VsYXRpbmcgb3Bwb3NpdGUgYW5kIGFkamFjZW50XG4gICAgLy9kaXN0YW5lVG9Cb3JkZXIgYmVjb21lcyBIeXBvdGVudXNlLlxuICAgIC8vRm9ybXVsYXMgc2luKGEpID0gT3Bwb3NpdGUgLyBIeXBvdGVudXNlIGFuZCBjb3MoYSkgPSBBZGphY2VudCAvIEh5cG90ZW51c2VcbiAgICB2YXIgdG9Cb3JkZXJEaXN0ID0gbm9kZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIHZhciB5RnJvbU5vZGVDZW50ZXIgPSBNYXRoLnNpbihhbmdsZSkgKiB0b0JvcmRlckRpc3Q7XG4gICAgdmFyIHhGcm9tTm9kZUNlbnRlciA9IE1hdGguY29zKGFuZ2xlKSAqIHRvQm9yZGVyRGlzdDsgLy94RnJvbU5vZGVDZW50ZXIgaXMgYmFzaWNhbGx5IHggYW5kIGlmIHhGcm9tTm9kZUNlbnRlciBlcXVhbHMgdG8gdGhlIGRpc3RhbmNlIHRvIGJvcmRlciB0aGVuIGl0IG1lYW5zXG4gICAgLy90aGF0IHkgZG9lcyBub3QgbmVlZCBjYWxjdWxhdGlvbiBiZWNhdXNlIGl0IGlzIGVxdWFsIG5vZGUuaGVpZ2h0IC8gMiBvciBub2RlLnlcbiAgICAvL3NhbWUgdGhpbmcgd2l0aCB5RnJvbU5vZGVDZW50ZXIgYW5kIGlmIHlGcm9tTm9kZUNlbnRlciBlcXVhbHMgdG8gdGhlIGRpc3RhbmNlIHRvIGJvcmRlciB0aGVuIGl0IG1lYW5zXG4gICAgLy90aGF0IHggaXMgZXF1YWwgbm9kZS53aWR0aCAvIDIgb3Igbm9kZS54XG5cbiAgICBpZiAoeEZyb21Ob2RlQ2VudGVyID09PSB0b0JvcmRlckRpc3QpIHtcbiAgICAgIHggKz0gdG9Cb3JkZXJEaXN0O1xuICAgICAgeSA9IG5vZGUueTtcbiAgICB9IGVsc2UgaWYgKHlGcm9tTm9kZUNlbnRlciA9PT0gdG9Cb3JkZXJEaXN0KSB7XG4gICAgICB4ID0gbm9kZS54O1xuICAgICAgeSAtPSB0b0JvcmRlckRpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggKz0geEZyb21Ob2RlQ2VudGVyO1xuICAgICAgeSAtPSB5RnJvbU5vZGVDZW50ZXI7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUuc2hhcGUud2lkdGggPiBub2RlLnNoYXBlLmhlaWdodCkge1xuICAgIHggPSBub2RlLnggKyBub2RlLnNoYXBlLndpZHRoICogMC41O1xuICAgIHkgPSBub2RlLnkgLSByYWRpdXM7XG4gIH0gZWxzZSB7XG4gICAgeCA9IG5vZGUueCArIHJhZGl1cztcbiAgICB5ID0gbm9kZS55IC0gbm9kZS5zaGFwZS5oZWlnaHQgKiAwLjU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufVxuXG4vKipcbiAqIENhbGxiYWNrIHRvIGRldGVybWluZSB0ZXh0IGRpbWVuc2lvbnMsIHVzaW5nIHRoZSBwYXJlbnQgbGFiZWwgc2V0dGluZ3MuXG4gKlxuICogQGNhbGxiYWNrIE1lYXN1cmVUZXh0XG4gKiBAcGFyYW0ge3RleHR9IHRleHRcbiAqIEBwYXJhbSB7dGV4dH0gbW9kXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB7IHdpZHRoLCB2YWx1ZXN9IHdpZHRoIGluIHBpeGVscyBhbmQgZm9udCBhdHRyaWJ1dGVzXG4gKi9cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgZm9yIExhYmVsIHdoaWNoIGNvbGxlY3RzIHJlc3VsdHMgb2Ygc3BsaXR0aW5nIGxhYmVscyBpbnRvIGxpbmVzIGFuZCBibG9ja3MuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIExhYmVsQWNjdW11bGF0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtNZWFzdXJlVGV4dH0gbWVhc3VyZVRleHRcbiAgICovXG4gIGZ1bmN0aW9uIExhYmVsQWNjdW11bGF0b3IobWVhc3VyZVRleHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGFiZWxBY2N1bXVsYXRvcik7XG5cbiAgICB0aGlzLm1lYXN1cmVUZXh0ID0gbWVhc3VyZVRleHQ7XG4gICAgdGhpcy5jdXJyZW50ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmQgZ2l2ZW4gdGV4dCB0byB0aGUgZ2l2ZW4gbGluZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBsICAgIGluZGV4IG9mIGxpbmUgdG8gYWRkIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgdGV4dCBzdHJpbmcgdG8gYXBwZW5kIHRvIGxpbmVcbiAgICogQHBhcmFtIHsnYm9sZCd8J2l0YWwnfCdib2xkaXRhbCd8J21vbm8nfCdub3JtYWwnfSBbbW9kPSdub3JtYWwnXVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhMYWJlbEFjY3VtdWxhdG9yLCBbe1xuICAgIGtleTogXCJfYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGQobCwgdGV4dCkge1xuICAgICAgdmFyIG1vZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJub3JtYWxcIjtcblxuICAgICAgaWYgKHRoaXMubGluZXNbbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxpbmVzW2xdID0ge1xuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICBibG9ja3M6IFtdXG4gICAgICAgIH07XG4gICAgICB9IC8vIFdlIHN0aWxsIG5lZWQgdG8gc2V0IGEgYmxvY2sgZm9yIHVuZGVmaW5lZCBhbmQgZW1wdHkgdGV4dHMsIGhlbmNlIHJldHVybiBhdCB0aGlzIHBvaW50XG4gICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIGRvbid0IGtub3cgYXQgdGhpcyBwb2ludCBpZiB3ZSdyZSBhdCB0aGVcbiAgICAgIC8vIHN0YXJ0IG9mIGFuIGVtcHR5IGxpbmUgb3Igbm90LlxuICAgICAgLy8gVG8gY29tcGVuc2F0ZSwgZW1wdHkgYmxvY2tzIGFyZSByZW1vdmVkIGluIGBmaW5hbGl6ZSgpYC5cbiAgICAgIC8vXG4gICAgICAvLyBFbXB0eSBzdHJpbmdzIHNob3VsZCBzdGlsbCBoYXZlIGEgaGVpZ2h0XG5cblxuICAgICAgdmFyIHRtcFRleHQgPSB0ZXh0O1xuICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCB8fCB0ZXh0ID09PSBcIlwiKSB0bXBUZXh0ID0gXCIgXCI7IC8vIERldGVybWluZSB3aWR0aCBhbmQgZ2V0IHRoZSBmb250IHByb3BlcnRpZXNcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubWVhc3VyZVRleHQodG1wVGV4dCwgbW9kKTtcblxuICAgICAgdmFyIGJsb2NrID0gYXNzaWduJDIoe30sIHZhbHVlcyhyZXN1bHQpKTtcblxuICAgICAgYmxvY2sudGV4dCA9IHRleHQ7XG4gICAgICBibG9jay53aWR0aCA9IHJlc3VsdC53aWR0aDtcbiAgICAgIGJsb2NrLm1vZCA9IG1vZDtcblxuICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCB8fCB0ZXh0ID09PSBcIlwiKSB7XG4gICAgICAgIGJsb2NrLndpZHRoID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5saW5lc1tsXS5ibG9ja3MucHVzaChibG9jayk7IC8vIFVwZGF0ZSB0aGUgbGluZSB3aWR0aC4gV2UgbmVlZCB0aGlzIGZvciBkZXRlcm1pbmluZyBpZiBhIHN0cmluZyBnb2VzIG92ZXIgbWF4IHdpZHRoXG5cbiAgICAgIHRoaXMubGluZXNbbF0ud2lkdGggKz0gYmxvY2sud2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIGluIHBpeGVscyBvZiB0aGUgY3VycmVudCBsaW5lLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImN1cldpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cldpZHRoKCkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW3RoaXMuY3VycmVudF07XG4gICAgICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgICAgIHJldHVybiBsaW5lLndpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGV4dCBpbiBibG9jayB0byBjdXJyZW50IGxpbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHsnYm9sZCd8J2l0YWwnfCdib2xkaXRhbCd8J21vbm8nfCdub3JtYWwnfSBbbW9kPSdub3JtYWwnXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZCh0ZXh0KSB7XG4gICAgICB2YXIgbW9kID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIm5vcm1hbFwiO1xuXG4gICAgICB0aGlzLl9hZGQodGhpcy5jdXJyZW50LCB0ZXh0LCBtb2QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGV4dCBpbiBibG9jayB0byBjdXJyZW50IGxpbmUgYW5kIHN0YXJ0IGEgbmV3IGxpbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHsnYm9sZCd8J2l0YWwnfCdib2xkaXRhbCd8J21vbm8nfCdub3JtYWwnfSBbbW9kPSdub3JtYWwnXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV3TGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdMaW5lKHRleHQpIHtcbiAgICAgIHZhciBtb2QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwibm9ybWFsXCI7XG5cbiAgICAgIHRoaXMuX2FkZCh0aGlzLmN1cnJlbnQsIHRleHQsIG1vZCk7XG5cbiAgICAgIHRoaXMuY3VycmVudCsrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgYW5kIHNldCB0aGUgaGVpZ2h0cyBvZiBhbGwgdGhlIGxpbmVzIGN1cnJlbnRseSBjb250YWluZWQgaW4gdGhpcyBpbnN0YW5jZVxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHdpZHRoIGhhcyBhbHJlYWR5IGJlZW4gc2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRldGVybWluZUxpbmVIZWlnaHRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluZUxpbmVIZWlnaHRzKCkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxpbmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1trXTsgLy8gTG9va2luZyBmb3IgbWF4IGhlaWdodCBvZiBibG9ja3MgaW4gbGluZVxuXG4gICAgICAgIHZhciBoZWlnaHQgPSAwO1xuXG4gICAgICAgIGlmIChsaW5lLmJsb2NrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gQ2FuIGhhcHBlbiBpZiB0ZXh0IGNvbnRhaW5zIGUuZy4gJ1xcbiAnXG4gICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lLmJsb2Nrcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgdmFyIGJsb2NrID0gbGluZS5ibG9ja3NbbF07XG5cbiAgICAgICAgICAgIGlmIChoZWlnaHQgPCBibG9jay5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gYmxvY2suaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGZ1bGwgc2l6ZSBvZiB0aGUgbGFiZWwgdGV4dCwgYXMgZGV0ZXJtaW5lZCBieSBjdXJyZW50IGxpbmVzIGFuZCBibG9ja3NcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmVMYWJlbFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lTGFiZWxTaXplKCkge1xuICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgIHZhciBoZWlnaHQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2tdO1xuXG4gICAgICAgIGlmIChsaW5lLndpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgICB3aWR0aCA9IGxpbmUud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBoZWlnaHQgKz0gbGluZS5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGVtcHR5IGJsb2NrcyBhbmQgZW1wdHkgbGluZXMgd2UgZG9uJ3QgbmVlZFxuICAgICAqXG4gICAgICogVGhpcyBtdXN0IGJlIGRvbmUgYWZ0ZXIgdGhlIHdpZHRoL2hlaWdodCBkZXRlcm1pbmF0aW9uLFxuICAgICAqIHNvIHRoYXQgdGhlc2UgYXJlIHNldCBwcm9wZXJseSBmb3IgcHJvY2Vzc2luZyBoZXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5PExpbmU+fSBMaW5lcyB3aXRoIGVtcHR5IGJsb2NrcyAoYW5kIHNvbWUgZW1wdHkgbGluZXMpIHJlbW92ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRW1wdHlCbG9ja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRW1wdHlCbG9ja3MoKSB7XG4gICAgICB2YXIgdG1wTGluZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxpbmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1trXTsgLy8gTm90ZTogYW4gZW1wdHkgbGluZSBpbiBiZXR3ZWVuIHRleHQgaGFzIHdpZHRoIHplcm8gYnV0IGlzIHN0aWxsIHJlbGV2YW50IHRvIGxheW91dC5cbiAgICAgICAgLy8gU28gd2UgY2FuJ3QgdXNlIHdpZHRoIGZvciB0ZXN0aW5nIGVtcHR5IGxpbmUgaGVyZVxuXG4gICAgICAgIGlmIChsaW5lLmJsb2Nrcy5sZW5ndGggPT09IDApIGNvbnRpbnVlOyAvLyBEaXNjYXJkIGZpbmFsIGVtcHR5IGxpbmUgYWx3YXlzXG5cbiAgICAgICAgaWYgKGsgPT09IHRoaXMubGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGlmIChsaW5lLndpZHRoID09PSAwKSBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0bXBMaW5lID0ge307XG5cbiAgICAgICAgYXNzaWduJDIodG1wTGluZSwgbGluZSk7XG5cbiAgICAgICAgdG1wTGluZS5ibG9ja3MgPSBbXTtcbiAgICAgICAgdmFyIGZpcnN0RW1wdHlCbG9jayA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHRtcEJsb2NrcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGluZS5ibG9ja3MubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICB2YXIgYmxvY2sgPSBsaW5lLmJsb2Nrc1tsXTtcblxuICAgICAgICAgIGlmIChibG9jay53aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgdG1wQmxvY2tzLnB1c2goYmxvY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RFbXB0eUJsb2NrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZmlyc3RFbXB0eUJsb2NrID0gYmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzICpzb21lKiB0ZXh0IHByZXNlbnRcblxuXG4gICAgICAgIGlmICh0bXBCbG9ja3MubGVuZ3RoID09PSAwICYmIGZpcnN0RW1wdHlCbG9jayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdG1wQmxvY2tzLnB1c2goZmlyc3RFbXB0eUJsb2NrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRtcExpbmUuYmxvY2tzID0gdG1wQmxvY2tzO1xuICAgICAgICB0bXBMaW5lcy5wdXNoKHRtcExpbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG1wTGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2l6ZXMgZm9yIGFsbCBsaW5lcyBhbmQgdGhlIHdob2xlIHRoaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3t3aWR0aDogKG51bWJlcnwqKSwgaGVpZ2h0OiAobnVtYmVyfCopLCBsaW5lczogQXJyYXl9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluYWxpemUoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHRoaXMubGluZXMsIG51bGwsIDIpKTtcbiAgICAgIHRoaXMuZGV0ZXJtaW5lTGluZUhlaWdodHMoKTtcbiAgICAgIHRoaXMuZGV0ZXJtaW5lTGFiZWxTaXplKCk7XG4gICAgICB2YXIgdG1wTGluZXMgPSB0aGlzLnJlbW92ZUVtcHR5QmxvY2tzKCk7IC8vIFJldHVybiBhIHNpbXBsZSBoYXNoIG9iamVjdCBmb3IgZnVydGhlciBwcm9jZXNzaW5nLlxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgbGluZXM6IHRtcExpbmVzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYWJlbEFjY3VtdWxhdG9yO1xufSgpO1xuXG52YXIgdGFnUGF0dGVybiA9IHtcbiAgLy8gSFRNTFxuICBcIjxiPlwiOiAvPGI+LyxcbiAgXCI8aT5cIjogLzxpPi8sXG4gIFwiPGNvZGU+XCI6IC88Y29kZT4vLFxuICBcIjwvYj5cIjogLzxcXC9iPi8sXG4gIFwiPC9pPlwiOiAvPFxcL2k+LyxcbiAgXCI8L2NvZGU+XCI6IC88XFwvY29kZT4vLFxuICAvLyBNYXJrZG93blxuICBcIipcIjogL1xcKi8sXG4gIC8vIGJvbGRcbiAgXzogL18vLFxuICAvLyBpdGFsXG4gIFwiYFwiOiAvYC8sXG4gIC8vIG1vbm9cbiAgYWZ0ZXJCb2xkOiAvW14qXS8sXG4gIGFmdGVySXRhbDogL1teX10vLFxuICBhZnRlck1vbm86IC9bXmBdL1xufTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGNsYXNzIGZvciBwYXJzaW5nIHRoZSBtYXJrdXAgdGFncyBmb3IgSFRNTCBhbmQgTWFya2Rvd24uXG4gKlxuICogTk9URTogU2VxdWVuY2VzIG9mIHRhYnMgYW5kIHNwYWNlcyBhcmUgcmVkdWNlZCB0byBzaW5nbGUgc3BhY2UuXG4gKiAgICAgICBTY2FuIHVzYWdlIG9mIGB0aGlzLnNwYWNpbmdgIHdpdGhpbiBtZXRob2RcbiAqL1xuXG52YXIgTWFya3VwQWNjdW11bGF0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICB0ZXh0IHRvIHBhcnNlIGZvciBtYXJrdXBcbiAgICovXG4gIGZ1bmN0aW9uIE1hcmt1cEFjY3VtdWxhdG9yKHRleHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFya3VwQWNjdW11bGF0b3IpO1xuXG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLmJvbGQgPSBmYWxzZTtcbiAgICB0aGlzLml0YWwgPSBmYWxzZTtcbiAgICB0aGlzLm1vbm8gPSBmYWxzZTtcbiAgICB0aGlzLnNwYWNpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgdGhpcy5tb2RTdGFjayA9IFtdO1xuICAgIHRoaXMuYmxvY2tzID0gW107XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbW9kIGxhYmVsIGN1cnJlbnRseSBvbiB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgbGFiZWwgb2YgdG9wbW9zdCBtb2RcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTWFya3VwQWNjdW11bGF0b3IsIFt7XG4gICAga2V5OiBcIm1vZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb2QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2RTdGFjay5sZW5ndGggPT09IDAgPyBcIm5vcm1hbFwiIDogdGhpcy5tb2RTdGFja1swXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBtb2QgbGFiZWwgY3VycmVudGx5IGFjdGl2ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gIGxhYmVsIG9mIGFjdGl2ZSBtb2RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW9kTmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb2ROYW1lKCkge1xuICAgICAgaWYgKHRoaXMubW9kU3RhY2subGVuZ3RoID09PSAwKSByZXR1cm4gXCJub3JtYWxcIjtlbHNlIGlmICh0aGlzLm1vZFN0YWNrWzBdID09PSBcIm1vbm9cIikgcmV0dXJuIFwibW9ub1wiO2Vsc2Uge1xuICAgICAgICBpZiAodGhpcy5ib2xkICYmIHRoaXMuaXRhbCkge1xuICAgICAgICAgIHJldHVybiBcImJvbGRpdGFsXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5ib2xkKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYm9sZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXRhbCkge1xuICAgICAgICAgIHJldHVybiBcIml0YWxcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdEJsb2NrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRCbG9jaygpIHtcbiAgICAgIGlmICh0aGlzLnNwYWNpbmcpIHtcbiAgICAgICAgdGhpcy5hZGQoXCIgXCIpO1xuICAgICAgICB0aGlzLnNwYWNpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5ibG9ja3MucHVzaCh7XG4gICAgICAgICAgdGV4dDogdGhpcy5idWZmZXIsXG4gICAgICAgICAgbW9kOiB0aGlzLm1vZE5hbWUoKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdXRwdXQgdGV4dCB0byBidWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICB0ZXh0IHRvIGFkZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHRleHQpIHtcbiAgICAgIGlmICh0ZXh0ID09PSBcIiBcIikge1xuICAgICAgICB0aGlzLnNwYWNpbmcgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zcGFjaW5nKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyICs9IFwiIFwiO1xuICAgICAgICB0aGlzLnNwYWNpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHQgIT0gXCIgXCIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHBhcnNpbmcgb2Ygd2hpdGVzcGFjZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoICB0aGUgY2hhcmFjdGVyIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNoYXJhY3RlciB3YXMgcHJvY2Vzc2VkIGFzIHdoaXRlc3BhY2UsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VXU1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVdTKGNoKSB7XG4gICAgICBpZiAoL1sgXFx0XS8udGVzdChjaCkpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vbm8pIHtcbiAgICAgICAgICB0aGlzLnNwYWNpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYWRkKGNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lICBsYWJlbCBmb3IgYmxvY2sgdHlwZSB0byBzZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRhZyh0YWdOYW1lKSB7XG4gICAgICB0aGlzLmVtaXRCbG9jaygpO1xuICAgICAgdGhpc1t0YWdOYW1lXSA9IHRydWU7XG4gICAgICB0aGlzLm1vZFN0YWNrLnVuc2hpZnQodGFnTmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lICBsYWJlbCBmb3IgYmxvY2sgdHlwZSB0byB1bnNldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bnNldFRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNldFRhZyh0YWdOYW1lKSB7XG4gICAgICB0aGlzLmVtaXRCbG9jaygpO1xuICAgICAgdGhpc1t0YWdOYW1lXSA9IGZhbHNlO1xuICAgICAgdGhpcy5tb2RTdGFjay5zaGlmdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBsYWJlbCBmb3IgYmxvY2sgdHlwZSB3ZSBhcmUgY3VycmVudGx5IHByb2Nlc3NpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZyBzdHJpbmcgdG8gbWF0Y2ggaW4gdGV4dFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0YWcgd2FzIHByb2Nlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVN0YXJ0VGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcodGFnTmFtZSwgdGFnKSB7XG4gICAgICAvLyBOb3RlOiBpZiAnbW9ubycgcGFzc2VkIGFzIHRhZ05hbWUsIHRoZXJlIGlzIGEgZG91YmxlIGNoZWNrIGhlcmUuIFRoaXMgaXMgT0tcbiAgICAgIGlmICghdGhpcy5tb25vICYmICF0aGlzW3RhZ05hbWVdICYmIHRoaXMubWF0Y2godGFnKSkge1xuICAgICAgICB0aGlzLnNldFRhZyh0YWdOYW1lKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSB0YWdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FkdmFuY2U9dHJ1ZV0gaWYgc2V0LCBhZHZhbmNlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGV4dFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIG1hdGNoIGF0IGdpdmVuIHBvc2l0aW9uLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2godGFnKSB7XG4gICAgICB2YXIgYWR2YW5jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgdmFyIF90aGlzJHByZXBhcmVSZWdFeHAgPSB0aGlzLnByZXBhcmVSZWdFeHAodGFnKSxcbiAgICAgICAgICBfdGhpcyRwcmVwYXJlUmVnRXhwMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJHByZXBhcmVSZWdFeHAsIDIpLFxuICAgICAgICAgIHJlZ0V4cCA9IF90aGlzJHByZXBhcmVSZWdFeHAyWzBdLFxuICAgICAgICAgIGxlbmd0aCA9IF90aGlzJHByZXBhcmVSZWdFeHAyWzFdO1xuXG4gICAgICB2YXIgbWF0Y2hlZCA9IHJlZ0V4cC50ZXN0KHRoaXMudGV4dC5zdWJzdHIodGhpcy5wb3NpdGlvbiwgbGVuZ3RoKSk7XG5cbiAgICAgIGlmIChtYXRjaGVkICYmIGFkdmFuY2UpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGggLSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0Y2hlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgbGFiZWwgZm9yIGJsb2NrIHR5cGUgd2UgYXJlIGN1cnJlbnRseSBwcm9jZXNzaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSB0YWcgc3RyaW5nIHRvIG1hdGNoIGluIHRleHRcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW25leHRUYWddIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBmb3IgY2hhcmFjdGVycyAqZm9sbG93aW5nKiB0aGUgY3VycmVudCB0YWdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdGFnIHdhcyBwcm9jZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VFbmRUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VFbmRUYWcodGFnTmFtZSwgdGFnLCBuZXh0VGFnKSB7XG4gICAgICB2YXIgY2hlY2tUYWcgPSB0aGlzLm1vZCgpID09PSB0YWdOYW1lO1xuXG4gICAgICBpZiAodGFnTmFtZSA9PT0gXCJtb25vXCIpIHtcbiAgICAgICAgLy8gc3BlY2lhbCBoYW5kbGluZyBmb3IgJ21vbm8nXG4gICAgICAgIGNoZWNrVGFnID0gY2hlY2tUYWcgJiYgdGhpcy5tb25vO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tUYWcgPSBjaGVja1RhZyAmJiAhdGhpcy5tb25vO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tUYWcgJiYgdGhpcy5tYXRjaCh0YWcpKSB7XG4gICAgICAgIGlmIChuZXh0VGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBQdXJwb3NlIG9mIHRoZSBmb2xsb3dpbmcgbWF0Y2ggaXMgdG8gcHJldmVudCBhIGRpcmVjdCB1bnNldC9zZXQgb2YgYSBnaXZlbiB0YWdcbiAgICAgICAgICAvLyBFLmcuICcqYm9sZCAqKnN0aWxsIGJvbGQqJyA9PiAnKmJvbGQgc3RpbGwgYm9sZConXG4gICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09IHRoaXMudGV4dC5sZW5ndGggLSAxIHx8IHRoaXMubWF0Y2gobmV4dFRhZywgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLnVuc2V0VGFnKHRhZ05hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVuc2V0VGFnKHRhZ05hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSB0YWcgIHN0cmluZyB0byBtYXRjaCBpbiB0ZXh0XG4gICAgICogQHBhcmFtIHt2YWx1ZX0gdmFsdWUgIHN0cmluZyB0byByZXBsYWNlIHRhZyB3aXRoLCBpZiBmb3VuZCBhdCBjdXJyZW50IHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRhZyB3YXMgcHJvY2Vzc2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlcGxhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZSh0YWcsIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0YWcpKSB7XG4gICAgICAgIHRoaXMuYWRkKHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIHRoZSB0YWcgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvbmUuXG4gICAgICpcbiAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIGFycmF5IGBbUmVnRXhwLCBudW1iZXJdYCwgd2l0aCBleGFjdGx5IHR3byB2YWx1ZSwgd2hlcmU6XG4gICAgICogIC0gUmVnRXhwIGlzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gdXNlXG4gICAgICogIC0gbnVtYmVyIGlzIHRoZSBsZW50aCBvZiB0aGUgaW5wdXQgc3RyaW5nIHRvIG1hdGNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZyAgc3RyaW5nIHRvIG1hdGNoIGluIHRleHRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9ICByZWd1bGFyIGV4cHJlc3Npb24gdG8gdXNlIGFuZCBsZW5ndGggb2YgaW5wdXQgc3RyaW5nIHRvIG1hdGNoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByZXBhcmVSZWdFeHBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZVJlZ0V4cCh0YWcpIHtcbiAgICAgIHZhciBsZW5ndGg7XG4gICAgICB2YXIgcmVnRXhwO1xuXG4gICAgICBpZiAodGFnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJlZ0V4cCA9IHRhZztcbiAgICAgICAgbGVuZ3RoID0gMTsgLy8gQVNTVU1QVElPTjogcmVnZXhwIG9ubHkgdGVzdHMgb25lIGNoYXJhY3RlclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlIHByZXBhcmVkIHJlZ2V4cCBpZiBwcmVzZW50XG4gICAgICAgIHZhciBwcmVwYXJlZCA9IHRhZ1BhdHRlcm5bdGFnXTtcblxuICAgICAgICBpZiAocHJlcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlZ0V4cCA9IHByZXBhcmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZ0V4cCA9IG5ldyBSZWdFeHAodGFnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aCA9IHRhZy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbcmVnRXhwLCBsZW5ndGhdO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXJrdXBBY2N1bXVsYXRvcjtcbn0oKTtcbi8qKlxuICogSGVscGVyIGNsYXNzIGZvciBMYWJlbCB3aGljaCBleHBsb2RlcyB0aGUgbGFiZWwgdGV4dCBpbnRvIGxpbmVzIGFuZCBibG9ja3Mgd2l0aGluIGxpbmVzXG4gKlxuICogQHByaXZhdGVcbiAqL1xuXG5cbnZhciBMYWJlbFNwbGl0dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG4gICAqIEBwYXJhbSB7TGFiZWx9IHBhcmVudCByZWZlcmVuY2UgdG8gdGhlIExhYmVsIGluc3RhbmNlIHVzaW5nIGN1cnJlbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqL1xuICBmdW5jdGlvbiBMYWJlbFNwbGl0dGVyKGN0eCwgcGFyZW50LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVsU3BsaXR0ZXIpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgIHRoaXMuaG92ZXIgPSBob3ZlcjtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byBkZXRlcm1pbmUgdGV4dCB3aWR0aDsgcGFzc2VkIHRvIExhYmVsQWNjdW11bGF0b3IgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCBzdHJpbmcgdG8gZGV0ZXJtaW5lIHdpZHRoIG9mXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBtb2QgIGZvbnQgdHlwZSB0byB1c2UgZm9yIHRoaXMgdGV4dFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHsgd2lkdGgsIHZhbHVlc30gd2lkdGggaW4gcGl4ZWxzIGFuZCBmb250IGF0dHJpYnV0ZXNcbiAgICAgKi9cblxuICAgIHZhciB0ZXh0V2lkdGggPSBmdW5jdGlvbiB0ZXh0V2lkdGgodGV4dCwgbW9kKSB7XG4gICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDsgLy8gVE9ETzogVGhpcyBjYW4gYmUgZG9uZSBtb3JlIGVmZmljaWVudGx5IHdpdGggY2FjaGluZ1xuICAgICAgLy8gVGhpcyB3aWxsIHNldCB0aGUgY3R4LmZvbnQgY29ycmVjdGx5LCBkZXBlbmRpbmcgb24gc2VsZWN0ZWQvaG92ZXIgYW5kIG1vZCAtIHNvIHRoYXQgY3R4Lm1lYXN1cmVUZXh0KCkgd2lsbCBiZSBhY2N1cmF0ZS5cblxuICAgICAgdmFyIHZhbHVlcyA9IF90aGlzLnBhcmVudC5nZXRGb3JtYXR0aW5nVmFsdWVzKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCBtb2QpO1xuXG4gICAgICB2YXIgd2lkdGggPSAwO1xuXG4gICAgICBpZiAodGV4dCAhPT0gXCJcIikge1xuICAgICAgICB2YXIgbWVhc3VyZSA9IF90aGlzLmN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcblxuICAgICAgICB3aWR0aCA9IG1lYXN1cmUud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHRoaXMubGluZXMgPSBuZXcgTGFiZWxBY2N1bXVsYXRvcih0ZXh0V2lkdGgpO1xuICB9XG4gIC8qKlxuICAgKiBTcGxpdCBwYXNzZWQgdGV4dCBvZiBhIGxhYmVsIGludG8gbGluZXMgYW5kIGJsb2Nrcy5cbiAgICpcbiAgICogIyBOT1RFXG4gICAqXG4gICAqIFRoZSBoYW5kbGluZyBvZiBzcGFjaW5nIGlzIG9wdGlvbiBkZXBlbmRlbnQ6XG4gICAqXG4gICAqIC0gaWYgYGZvbnQubXVsdGkgOiBmYWxzZWAsIGFsbCBzcGFjZXMgYXJlIHJldGFpbmVkXG4gICAqIC0gaWYgYGZvbnQubXVsdGkgOiB0cnVlYCwgZXZlcnkgc2VxdWVuY2Ugb2Ygc3BhY2VzIGlzIGNvbXByZXNzZWQgdG8gYSBzaW5nbGUgc3BhY2VcbiAgICpcbiAgICogVGhpcyBtaWdodCBub3QgYmUgdGhlIGJlc3Qgd2F5IHRvIGRvIGl0LCBidXQgdGhpcyBpcyBhcyBpdCBoYXMgYmVlbiB3b3JraW5nIHRpbGwgbm93LlxuICAgKiBJbiBvcmRlciBub3QgdG8gYnJlYWsgZXhpc3RpbmcgZnVuY3Rpb25hbGl0eSwgZm9yIHRoZSB0aW1lIGJlaW5nIHRoaXMgYmVoYXZpb3VyIHdpbGxcbiAgICogYmUgcmV0YWluZWQgaW4gYW55IGNvZGUgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgIHRleHQgdG8gc3BsaXRcbiAgICogQHJldHVybnMge0FycmF5PGxpbmU+fVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhMYWJlbFNwbGl0dGVyLCBbe1xuICAgIGtleTogXCJwcm9jZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3ModGV4dCkge1xuICAgICAgaWYgKCFpc1ZhbGlkTGFiZWwodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZXMuZmluYWxpemUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZvbnQgPSB0aGlzLnBhcmVudC5mb250T3B0aW9uczsgLy8gTm9ybWFsaXplIHRoZSBlbmQtb2YtbGluZSdzIHRvIGEgc2luZ2xlIHJlcHJlc2VudGF0aW9uIC0gb3JkZXIgaW1wb3J0YW50XG5cbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcblwiKTsgLy8gRG9zIEVPTCdzXG5cbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcci9nLCBcIlxcblwiKTsgLy8gTWFjIEVPTCdzXG4gICAgICAvLyBOb3RlIHRoYXQgYXQgdGhpcyBwb2ludCwgdGhlcmUgY2FuIGJlIG5vIFxccidzIGluIHRoZSB0ZXh0LlxuICAgICAgLy8gVGhpcyBpcyB1c2VkIGxhdGVyIG9uIHNwbGl0U3RyaW5nSW50b0xpbmVzKCkgdG8gc3BsaXQgbXVsdGlmb250IHRleHRzLlxuXG4gICAgICB2YXIgbmxMaW5lcyA9IFN0cmluZyh0ZXh0KS5zcGxpdChcIlxcblwiKTtcbiAgICAgIHZhciBsaW5lQ291bnQgPSBubExpbmVzLmxlbmd0aDtcblxuICAgICAgaWYgKGZvbnQubXVsdGkpIHtcbiAgICAgICAgLy8gTXVsdGktZm9udCBjYXNlOiBzdHlsaW5nIHRhZ3MgYWN0aXZlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgICB2YXIgYmxvY2tzID0gdGhpcy5zcGxpdEJsb2NrcyhubExpbmVzW2ldLCBmb250Lm11bHRpKTsgLy8gUG9zdDogU2VxdWVuY2VzIG9mIHRhYnMgYW5kIHNwYWNlcyBhcmUgcmVkdWNlZCB0byBzaW5nbGUgc3BhY2VcblxuICAgICAgICAgIGlmIChibG9ja3MgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG5cbiAgICAgICAgICBpZiAoYmxvY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKFwiXCIpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZvbnQubWF4V2R0ID4gMCkge1xuICAgICAgICAgICAgLy8gd2lkdGhDb25zdHJhaW50Lm1heGltdW0gZGVmaW5lZFxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnUnVubmluZyB3aWR0aENvbnN0cmFpbnQgbXVsdGksIG1heDogJyArIHRoaXMuZm9udE9wdGlvbnMubWF4V2R0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmxvY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBtb2QgPSBibG9ja3Nbal0ubW9kO1xuICAgICAgICAgICAgICB2YXIgX3RleHQgPSBibG9ja3Nbal0udGV4dDtcbiAgICAgICAgICAgICAgdGhpcy5zcGxpdFN0cmluZ0ludG9MaW5lcyhfdGV4dCwgbW9kLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2lkdGhDb25zdHJhaW50Lm1heGltdW0gTk9UIGRlZmluZWRcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBibG9ja3MubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICAgIHZhciBfbW9kID0gYmxvY2tzW19qXS5tb2Q7XG4gICAgICAgICAgICAgIHZhciBfdGV4dDIgPSBibG9ja3NbX2pdLnRleHQ7XG4gICAgICAgICAgICAgIHRoaXMubGluZXMuYXBwZW5kKF90ZXh0MiwgX21vZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpbmdsZS1mb250IGNhc2VcbiAgICAgICAgaWYgKGZvbnQubWF4V2R0ID4gMCkge1xuICAgICAgICAgIC8vIHdpZHRoQ29uc3RyYWludC5tYXhpbXVtIGRlZmluZWRcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUnVubmluZyB3aWR0aENvbnN0cmFpbnQgbm9ybWFsLCBtYXg6ICcgKyB0aGlzLmZvbnRPcHRpb25zLm1heFdkdCk7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxpbmVDb3VudDsgX2krKykge1xuICAgICAgICAgICAgdGhpcy5zcGxpdFN0cmluZ0ludG9MaW5lcyhubExpbmVzW19pXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdpZHRoQ29uc3RyYWludC5tYXhpbXVtIE5PVCBkZWZpbmVkXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGluZUNvdW50OyBfaTIrKykge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKG5sTGluZXNbX2kyXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmxpbmVzLmZpbmFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG5vcm1hbGl6ZSB0aGUgbWFya3VwIHN5c3RlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufCdtZCd8J21hcmtkb3duJ3wnaHRtbCd9IG1hcmt1cFN5c3RlbVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVNYXJrdXBTeXN0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlTWFya3VwU3lzdGVtKG1hcmt1cFN5c3RlbSkge1xuICAgICAgdmFyIHN5c3RlbSA9IFwibm9uZVwiO1xuXG4gICAgICBpZiAobWFya3VwU3lzdGVtID09PSBcIm1hcmtkb3duXCIgfHwgbWFya3VwU3lzdGVtID09PSBcIm1kXCIpIHtcbiAgICAgICAgc3lzdGVtID0gXCJtYXJrZG93blwiO1xuICAgICAgfSBlbHNlIGlmIChtYXJrdXBTeXN0ZW0gPT09IHRydWUgfHwgbWFya3VwU3lzdGVtID09PSBcImh0bWxcIikge1xuICAgICAgICBzeXN0ZW0gPSBcImh0bWxcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN5c3RlbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNwbGl0SHRtbEJsb2Nrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdEh0bWxCbG9ja3ModGV4dCkge1xuICAgICAgdmFyIHMgPSBuZXcgTWFya3VwQWNjdW11bGF0b3IodGV4dCk7XG5cbiAgICAgIHZhciBwYXJzZUVudGl0aWVzID0gZnVuY3Rpb24gcGFyc2VFbnRpdGllcyhjaCkge1xuICAgICAgICBpZiAoLyYvLnRlc3QoY2gpKSB7XG4gICAgICAgICAgdmFyIHBhcnNlZCA9IHMucmVwbGFjZShzLnRleHQsIFwiJmx0O1wiLCBcIjxcIikgfHwgcy5yZXBsYWNlKHMudGV4dCwgXCImYW1wO1wiLCBcIiZcIik7XG5cbiAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgcy5hZGQoXCImXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgd2hpbGUgKHMucG9zaXRpb24gPCBzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaCA9IHMudGV4dC5jaGFyQXQocy5wb3NpdGlvbik7XG4gICAgICAgIHZhciBwYXJzZWQgPSBzLnBhcnNlV1MoY2gpIHx8IC88Ly50ZXN0KGNoKSAmJiAocy5wYXJzZVN0YXJ0VGFnKFwiYm9sZFwiLCBcIjxiPlwiKSB8fCBzLnBhcnNlU3RhcnRUYWcoXCJpdGFsXCIsIFwiPGk+XCIpIHx8IHMucGFyc2VTdGFydFRhZyhcIm1vbm9cIiwgXCI8Y29kZT5cIikgfHwgcy5wYXJzZUVuZFRhZyhcImJvbGRcIiwgXCI8L2I+XCIpIHx8IHMucGFyc2VFbmRUYWcoXCJpdGFsXCIsIFwiPC9pPlwiKSB8fCBzLnBhcnNlRW5kVGFnKFwibW9ub1wiLCBcIjwvY29kZT5cIikpIHx8IHBhcnNlRW50aXRpZXMoY2gpO1xuXG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgcy5hZGQoY2gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5wb3NpdGlvbisrO1xuICAgICAgfVxuXG4gICAgICBzLmVtaXRCbG9jaygpO1xuICAgICAgcmV0dXJuIHMuYmxvY2tzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3BsaXRNYXJrZG93bkJsb2Nrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdE1hcmtkb3duQmxvY2tzKHRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgcyA9IG5ldyBNYXJrdXBBY2N1bXVsYXRvcih0ZXh0KTtcbiAgICAgIHZhciBiZWdpbmFibGUgPSB0cnVlO1xuXG4gICAgICB2YXIgcGFyc2VPdmVycmlkZSA9IGZ1bmN0aW9uIHBhcnNlT3ZlcnJpZGUoY2gpIHtcbiAgICAgICAgaWYgKC9cXFxcLy50ZXN0KGNoKSkge1xuICAgICAgICAgIGlmIChzLnBvc2l0aW9uIDwgX3RoaXMyLnRleHQubGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgcy5wb3NpdGlvbisrO1xuICAgICAgICAgICAgY2ggPSBfdGhpczIudGV4dC5jaGFyQXQocy5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIGlmICgvIFxcdC8udGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgcy5zcGFjaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMuYWRkKGNoKTtcbiAgICAgICAgICAgICAgYmVnaW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAocy5wb3NpdGlvbiA8IHMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoID0gcy50ZXh0LmNoYXJBdChzLnBvc2l0aW9uKTtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHMucGFyc2VXUyhjaCkgfHwgcGFyc2VPdmVycmlkZShjaCkgfHwgKGJlZ2luYWJsZSB8fCBzLnNwYWNpbmcpICYmIChzLnBhcnNlU3RhcnRUYWcoXCJib2xkXCIsIFwiKlwiKSB8fCBzLnBhcnNlU3RhcnRUYWcoXCJpdGFsXCIsIFwiX1wiKSB8fCBzLnBhcnNlU3RhcnRUYWcoXCJtb25vXCIsIFwiYFwiKSkgfHwgcy5wYXJzZUVuZFRhZyhcImJvbGRcIiwgXCIqXCIsIFwiYWZ0ZXJCb2xkXCIpIHx8IHMucGFyc2VFbmRUYWcoXCJpdGFsXCIsIFwiX1wiLCBcImFmdGVySXRhbFwiKSB8fCBzLnBhcnNlRW5kVGFnKFwibW9ub1wiLCBcImBcIiwgXCJhZnRlck1vbm9cIik7XG5cbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICBzLmFkZChjaCk7XG4gICAgICAgICAgYmVnaW5hYmxlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzLnBvc2l0aW9uKys7XG4gICAgICB9XG5cbiAgICAgIHMuZW1pdEJsb2NrKCk7XG4gICAgICByZXR1cm4gcy5ibG9ja3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cGxvZGVzIGEgcGllY2Ugb2YgdGV4dCBpbnRvIHNpbmdsZS1mb250IGJsb2NrcyB1c2luZyBhIGdpdmVuIG1hcmt1cFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58J21kJ3wnbWFya2Rvd24nfCdodG1sJ30gbWFya3VwU3lzdGVtXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7dGV4dDogc3RyaW5nLCBtb2Q6IHN0cmluZ30+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzcGxpdEJsb2Nrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdEJsb2Nrcyh0ZXh0LCBtYXJrdXBTeXN0ZW0pIHtcbiAgICAgIHZhciBzeXN0ZW0gPSB0aGlzLmRlY29kZU1hcmt1cFN5c3RlbShtYXJrdXBTeXN0ZW0pO1xuXG4gICAgICBpZiAoc3lzdGVtID09PSBcIm5vbmVcIikge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIG1vZDogXCJub3JtYWxcIlxuICAgICAgICB9XTtcbiAgICAgIH0gZWxzZSBpZiAoc3lzdGVtID09PSBcIm1hcmtkb3duXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXRNYXJrZG93bkJsb2Nrcyh0ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3lzdGVtID09PSBcImh0bWxcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdEh0bWxCbG9ja3ModGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGV4dCBsZW5ndGggb3ZlciB0aGUgY3VycmVudCBtYXggd2l0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvdmVyTWF4V2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3Zlck1heFdpZHRoKHRleHQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgcmV0dXJuIHRoaXMubGluZXMuY3VyV2lkdGgoKSArIHdpZHRoID4gdGhpcy5wYXJlbnQuZm9udE9wdGlvbnMubWF4V2R0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGxvbmdlc3QgcGFydCBvZiB0aGUgc2VudGVuY2Ugd2hpY2ggc3RpbGwgZml0cyBpbiB0aGVcbiAgICAgKiBjdXJyZW50IG1heCB3aWR0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzICBBcnJheSBvZiBzdHJpbmdzIHNpZ25pZnlpbmcgYSB0ZXh0IGxpbmVzXG4gICAgICogQHJldHVybnMge251bWJlcn0gICAgICBpbmRleCBvZiBmaXJzdCBpdGVtIGluIHN0cmluZyBtYWtpbmcgc3RyaW5nIGdvIG92ZXIgbWF4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldExvbmdlc3RGaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG9uZ2VzdEZpdCh3b3Jkcykge1xuICAgICAgdmFyIHRleHQgPSBcIlwiO1xuICAgICAgdmFyIHcgPSAwO1xuXG4gICAgICB3aGlsZSAodyA8IHdvcmRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgcHJlID0gdGV4dCA9PT0gXCJcIiA/IFwiXCIgOiBcIiBcIjtcbiAgICAgICAgdmFyIG5ld1RleHQgPSB0ZXh0ICsgcHJlICsgd29yZHNbd107XG4gICAgICAgIGlmICh0aGlzLm92ZXJNYXhXaWR0aChuZXdUZXh0KSkgYnJlYWs7XG4gICAgICAgIHRleHQgPSBuZXdUZXh0O1xuICAgICAgICB3Kys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGxvbmdlc3QgcGFydCBvZiB0aGUgc3RyaW5nIHdoaWNoIHN0aWxsIGZpdHMgaW4gdGhlXG4gICAgICogY3VycmVudCBtYXggd2lkdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBBcnJheSBvZiBzdHJpbmdzIHNpZ25pZnlpbmcgYSB0ZXh0IGxpbmVzXG4gICAgICogQHJldHVybnMge251bWJlcn0gaW5kZXggb2YgZmlyc3QgaXRlbSBpbiBzdHJpbmcgbWFraW5nIHN0cmluZyBnbyBvdmVyIG1heFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9uZ2VzdEZpdFdvcmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG9uZ2VzdEZpdFdvcmQod29yZHMpIHtcbiAgICAgIHZhciB3ID0gMDtcblxuICAgICAgd2hpbGUgKHcgPCB3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMub3Zlck1heFdpZHRoKHNsaWNlKHdvcmRzKS5jYWxsKHdvcmRzLCAwLCB3KSkpIGJyZWFrO1xuICAgICAgICB3Kys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGxpdCB0aGUgcGFzc2VkIHRleHQgaW50byBsaW5lcywgYWNjb3JkaW5nIHRvIHdpZHRoIGNvbnN0cmFpbnQgKGlmIGFueSkuXG4gICAgICpcbiAgICAgKiBUaGUgbWV0aG9kIGFzc3VtZXMgdGhhdCB0aGUgaW5wdXQgc3RyaW5nIGlzIGEgc2luZ2xlIGxpbmUsIGkuZS4gd2l0aG91dCBsaW5lcyBicmVhay5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldGFpbnMgc3BhY2VzLCBpZiBzdGlsbCBwcmVzZW50IChjYXNlIGBmb250Lm11bHRpOiBmYWxzZWApLlxuICAgICAqIEEgc3BhY2Ugd2hpY2ggZmFsbHMgb24gYW4gaW50ZXJuYWwgbGluZSBicmVhaywgd2lsbCBiZSByZXBsYWNlZCBieSBhIG5ld2xpbmUuXG4gICAgICogVGhlcmUgaXMgbm8gc3BlY2lhbCBoYW5kbGluZyBvZiB0YWJzOyB0aGVzZSBnbyBhbG9uZyB3aXRoIHRoZSBmbG93LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kPSdub3JtYWwnXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FwcGVuZExhc3Q9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNwbGl0U3RyaW5nSW50b0xpbmVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0U3RyaW5nSW50b0xpbmVzKHN0cikge1xuICAgICAgdmFyIG1vZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJub3JtYWxcIjtcbiAgICAgIHZhciBhcHBlbmRMYXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIC8vIFNldCB0aGUgY2FudmFzIGNvbnRleHQgZm9udCwgYmFzZWQgdXBvbiB0aGUgY3VycmVudCBzZWxlY3RlZC9ob3ZlciBzdGF0ZVxuICAgICAgLy8gYW5kIHRoZSBwcm92aWRlZCBtb2QsIHNvIHRoZSB0ZXh0IG1lYXN1cmVtZW50IHBlcmZvcm1lZCBieSBnZXRMb25nZXN0Rml0XG4gICAgICAvLyB3aWxsIGJlIGFjY3VyYXRlIC0gYW5kIG5vdCBqdXN0IHVzZSB0aGUgZm9udCBvZiB3aG9ldmVyIGxhc3QgdXNlZCB0aGUgY2FudmFzLlxuICAgICAgdGhpcy5wYXJlbnQuZ2V0Rm9ybWF0dGluZ1ZhbHVlcyh0aGlzLmN0eCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgbW9kKTsgLy8gU3RpbGwtcHJlc2VudCBzcGFjZXMgYXJlIHJlbGV2YW50LCByZXRhaW4gdGhlbVxuXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXiggKykvZywgXCIkMVxcclwiKTtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oW15cXHJdW14gXSopKCArKS9nLCBcIiQxXFxyJDJcXHJcIik7XG4gICAgICB2YXIgd29yZHMgPSBzdHIuc3BsaXQoXCJcXHJcIik7XG5cbiAgICAgIHdoaWxlICh3b3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy5nZXRMb25nZXN0Rml0KHdvcmRzKTtcblxuICAgICAgICBpZiAodyA9PT0gMCkge1xuICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZTogdGhlIGZpcnN0IHdvcmQgaXMgYWxyZWFkeSBsYXJnZXIgdGhhbiB0aGUgbWF4IHdpZHRoLlxuICAgICAgICAgIHZhciB3b3JkID0gd29yZHNbMF07IC8vIEJyZWFrIHRoZSB3b3JkIHRvIHRoZSBsYXJnZXN0IHBhcnQgdGhhdCBmaXRzIHRoZSBsaW5lXG5cbiAgICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0TG9uZ2VzdEZpdFdvcmQod29yZCk7XG4gICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKHNsaWNlKHdvcmQpLmNhbGwod29yZCwgMCwgeCksIG1vZCk7IC8vIEFkanVzdCB0aGUgd29yZCwgc28gdGhhdCB0aGUgcmVzdCB3aWxsIGJlIGRvbmUgbmV4dCBpdGVyYXRpb25cblxuICAgICAgICAgIHdvcmRzWzBdID0gc2xpY2Uod29yZCkuY2FsbCh3b3JkLCB4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBza2lwIGFueSBzcGFjZSB0aGF0IGlzIHJlcGxhY2VkIGJ5IGEgbmV3bGluZVxuICAgICAgICAgIHZhciBuZXdXID0gdztcblxuICAgICAgICAgIGlmICh3b3Jkc1t3IC0gMV0gPT09IFwiIFwiKSB7XG4gICAgICAgICAgICB3LS07XG4gICAgICAgICAgfSBlbHNlIGlmICh3b3Jkc1tuZXdXXSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAgIG5ld1crKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGV4dCA9IHNsaWNlKHdvcmRzKS5jYWxsKHdvcmRzLCAwLCB3KS5qb2luKFwiXCIpO1xuXG4gICAgICAgICAgaWYgKHcgPT0gd29yZHMubGVuZ3RoICYmIGFwcGVuZExhc3QpIHtcbiAgICAgICAgICAgIHRoaXMubGluZXMuYXBwZW5kKHRleHQsIG1vZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGluZXMubmV3TGluZSh0ZXh0LCBtb2QpO1xuICAgICAgICAgIH0gLy8gQWRqdXN0IHRoZSB3b3JkLCBzbyB0aGF0IHRoZSByZXN0IHdpbGwgYmUgZG9uZSBuZXh0IGl0ZXJhdGlvblxuXG5cbiAgICAgICAgICB3b3JkcyA9IHNsaWNlKHdvcmRzKS5jYWxsKHdvcmRzLCBuZXdXKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYWJlbFNwbGl0dGVyO1xufSgpO1xuXG4vKipcbiAqIExpc3Qgb2Ygc3BlY2lhbCBzdHlsZXMgZm9yIG11bHRpLWZvbnRzXG4gKlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgbXVsdGlGb250U3R5bGUgPSBbXCJib2xkXCIsIFwiaXRhbFwiLCBcImJvbGRpdGFsXCIsIFwibW9ub1wiXTtcbi8qKlxuICogQSBMYWJlbCB0byBiZSB1c2VkIGZvciBOb2RlcyBvciBFZGdlcy5cbiAqL1xuXG52YXIgTGFiZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbZWRnZWxhYmVsPWZhbHNlXVxuICAgKi9cbiAgZnVuY3Rpb24gTGFiZWwoYm9keSwgb3B0aW9ucykge1xuICAgIHZhciBlZGdlbGFiZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVsKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5wb2ludFRvU2VsZiA9IGZhbHNlO1xuICAgIHRoaXMuYmFzZVNpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb250T3B0aW9ucyA9IHt9OyAvLyBpbnN0YW5jZSB2YXJpYWJsZSBjb250YWluaW5nIHRoZSAqaW5zdGFuY2UtbG9jYWwqIGZvbnQgb3B0aW9uc1xuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuc2l6ZSA9IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHlMaW5lOiAwXG4gICAgfTtcbiAgICB0aGlzLmlzRWRnZUxhYmVsID0gZWRnZWxhYmVsO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgcGFyZW50IE5vZGUtaW5zdGFuY2VcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTGFiZWwsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLmVsZW1lbnRPcHRpb25zID0gb3B0aW9uczsgLy8gUmVmZXJlbmNlIHRvIHRoZSBvcHRpb25zIG9mIHRoZSBwYXJlbnQgTm9kZS1pbnN0YW5jZVxuXG4gICAgICB0aGlzLmluaXRGb250T3B0aW9ucyhvcHRpb25zLmZvbnQpO1xuXG4gICAgICBpZiAoaXNWYWxpZExhYmVsKG9wdGlvbnMubGFiZWwpKSB7XG4gICAgICAgIHRoaXMubGFiZWxEaXJ0eSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCYWQgbGFiZWwhIENoYW5nZSB0aGUgb3B0aW9uIHZhbHVlIHRvIHByZXZlbnQgYmFkIHN0dWZmIGhhcHBlbmluZ1xuICAgICAgICBvcHRpb25zLmxhYmVsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5mb250ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5mb250ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIGZvbnQgb3B0aW9ucyBjYW4gYmUgZGVsZXRlZCBhdCB2YXJpb3VzIGxldmVsc1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZm9udCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRoaXMuYmFzZVNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemU7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihvcHRpb25zLmZvbnQpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdmFyIHNpemUgPSBvcHRpb25zLmZvbnQuc2l6ZTtcblxuICAgICAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZVNpemUgPSBzaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0IHRoZSBmb250IE9wdGlvbnMgc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogTWVtYmVyIGZvbnRPcHRpb25zIHNlcnZlcyBhcyBhbiBhY2N1bXVsYXRvciBmb3IgdGhlIGN1cnJlbnQgZm9udCBvcHRpb25zLlxuICAgICAqIEFzIHN1Y2gsIGl0IG5lZWRzIHRvIGJlIGNvbXBsZXRlbHkgc2VwYXJhdGVkIGZyb20gdGhlIG5vZGUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdGb250T3B0aW9ucyB0aGUgbmV3IGZvbnQgb3B0aW9ucyB0byBwcm9jZXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRGb250T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0Rm9udE9wdGlvbnMobmV3Rm9udE9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIG11bHRpLWZvbnQgb3B0aW9uIG9iamVjdHMuXG4gICAgICAvLyBUaGVzZSB3aWxsIGJlIGZpbGxlZCBpbiBwcm9wYWdhdGVGb250cygpLCBpZiByZXF1aXJlZFxuICAgICAgZm9yRWFjaCQxKG11bHRpRm9udFN0eWxlLCBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgX3RoaXMuZm9udE9wdGlvbnNbc3R5bGVdID0ge307XG4gICAgICB9KTsgLy8gSGFuZGxlIHNob3J0aGFuZCBvcHRpb24sIGlmIHByZXNlbnRcblxuICAgICAgaWYgKExhYmVsLnBhcnNlRm9udFN0cmluZyh0aGlzLmZvbnRPcHRpb25zLCBuZXdGb250T3B0aW9ucykpIHtcbiAgICAgICAgdGhpcy5mb250T3B0aW9ucy52YWRqdXN0ID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBDb3B5IG92ZXIgdGhlIG5vbi1tdWx0aWZvbnQgb3B0aW9ucywgaWYgc3BlY2lmaWVkXG5cblxuICAgICAgZm9yRWFjaCQxKG5ld0ZvbnRPcHRpb25zLCBmdW5jdGlvbiAocHJvcCwgbikge1xuICAgICAgICBpZiAocHJvcCAhPT0gdW5kZWZpbmVkICYmIHByb3AgIT09IG51bGwgJiYgX3R5cGVvZihwcm9wKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIF90aGlzLmZvbnRPcHRpb25zW25dID0gcHJvcDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGluLXZhcmlhYmxlIGlzIGEgc3RyaW5nLCBwYXJzZSBpdCBhcyBhIGZvbnQgc3BlY2lmaWVyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGZvbGxvd2luZyBpcyBub3QgZG9uZSBoZXJlIGFuZCBoYXZlIHRvIGJlIGRvbmUgYWZ0ZXIgdGhlIGNhbGw6XG4gICAgICogLSBOb3QgYWxsIGZvbnQgb3B0aW9ucyBhcmUgc2V0ICh2YWRqdXN0LCBtb2QpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3V0T3B0aW9ucyAgb3V0LXBhcmFtZXRlciwgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSBwYXJzZSByZXN1bHRzIChpZiBhbnkpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluT3B0aW9ucyAgZm9udCBvcHRpb25zIHRvIHBhcnNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgZm9udCBwYXJzZWQgYXMgc3RyaW5nLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25zdHJhaW5cIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgY29uc3RyYWludHMgYmFzZWQgb24gJ25lYXJlc3QnIHZhbHVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwaWxlIGFycmF5IG9mIG9wdGlvbiBvYmplY3RzIHRvIGNvbnNpZGVyXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlIGFjdHVhbCBjb25zdHJhaW50IHZhbHVlcyB0byB1c2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0cmFpbihwaWxlKSB7XG4gICAgICAvLyBOT1RFOiBjb25zdHJhaW5XaWR0aCBhbmQgIGNvbnN0cmFpbkhlaWdodCBuZXZlciBzZXQhXG4gICAgICAvLyBOT1RFOiBmb3IgZWRnZSBsYWJlbHMsIG9ubHkgJ21heFdkdCcgc2V0XG4gICAgICAvLyBOb2RlIGxhYmVscyBjYW4gc2V0IGFsbCB0aGUgZmllbGRzXG4gICAgICB2YXIgZm9udE9wdGlvbnMgPSB7XG4gICAgICAgIGNvbnN0cmFpbldpZHRoOiBmYWxzZSxcbiAgICAgICAgbWF4V2R0OiAtMSxcbiAgICAgICAgbWluV2R0OiAtMSxcbiAgICAgICAgY29uc3RyYWluSGVpZ2h0OiBmYWxzZSxcbiAgICAgICAgbWluSGd0OiAtMSxcbiAgICAgICAgdmFsaWduOiBcIm1pZGRsZVwiXG4gICAgICB9O1xuICAgICAgdmFyIHdpZHRoQ29uc3RyYWludCA9IHRvcE1vc3QocGlsZSwgXCJ3aWR0aENvbnN0cmFpbnRcIik7XG5cbiAgICAgIGlmICh0eXBlb2Ygd2lkdGhDb25zdHJhaW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGZvbnRPcHRpb25zLm1heFdkdCA9IE51bWJlcih3aWR0aENvbnN0cmFpbnQpO1xuICAgICAgICBmb250T3B0aW9ucy5taW5XZHQgPSBOdW1iZXIod2lkdGhDb25zdHJhaW50KTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZih3aWR0aENvbnN0cmFpbnQpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciB3aWR0aENvbnN0cmFpbnRNYXhpbXVtID0gdG9wTW9zdChwaWxlLCBbXCJ3aWR0aENvbnN0cmFpbnRcIiwgXCJtYXhpbXVtXCJdKTtcblxuICAgICAgICBpZiAodHlwZW9mIHdpZHRoQ29uc3RyYWludE1heGltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBmb250T3B0aW9ucy5tYXhXZHQgPSBOdW1iZXIod2lkdGhDb25zdHJhaW50TWF4aW11bSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2lkdGhDb25zdHJhaW50TWluaW11bSA9IHRvcE1vc3QocGlsZSwgW1wid2lkdGhDb25zdHJhaW50XCIsIFwibWluaW11bVwiXSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aENvbnN0cmFpbnRNaW5pbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgZm9udE9wdGlvbnMubWluV2R0ID0gTnVtYmVyKHdpZHRoQ29uc3RyYWludE1pbmltdW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBoZWlnaHRDb25zdHJhaW50ID0gdG9wTW9zdChwaWxlLCBcImhlaWdodENvbnN0cmFpbnRcIik7XG5cbiAgICAgIGlmICh0eXBlb2YgaGVpZ2h0Q29uc3RyYWludCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBmb250T3B0aW9ucy5taW5IZ3QgPSBOdW1iZXIoaGVpZ2h0Q29uc3RyYWludCk7XG4gICAgICB9IGVsc2UgaWYgKF90eXBlb2YoaGVpZ2h0Q29uc3RyYWludCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIGhlaWdodENvbnN0cmFpbnRNaW5pbXVtID0gdG9wTW9zdChwaWxlLCBbXCJoZWlnaHRDb25zdHJhaW50XCIsIFwibWluaW11bVwiXSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHRDb25zdHJhaW50TWluaW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGZvbnRPcHRpb25zLm1pbkhndCA9IE51bWJlcihoZWlnaHRDb25zdHJhaW50TWluaW11bSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGVpZ2h0Q29uc3RyYWludFZhbGlnbiA9IHRvcE1vc3QocGlsZSwgW1wiaGVpZ2h0Q29uc3RyYWludFwiLCBcInZhbGlnblwiXSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHRDb25zdHJhaW50VmFsaWduID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKGhlaWdodENvbnN0cmFpbnRWYWxpZ24gPT09IFwidG9wXCIgfHwgaGVpZ2h0Q29uc3RyYWludFZhbGlnbiA9PT0gXCJib3R0b21cIikge1xuICAgICAgICAgICAgZm9udE9wdGlvbnMudmFsaWduID0gaGVpZ2h0Q29uc3RyYWludFZhbGlnbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvbnRPcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgb3B0aW9ucyBhbmQgdXBkYXRlIGludGVybmFsIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgb3B0aW9ucyB0byBzZXRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgcGlsZSAgICAgYXJyYXkgb2Ygb3B0aW9uIG9iamVjdHMgdG8gY29uc2lkZXIgZm9yIG9wdGlvbiAnY2hvc2VuJ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShvcHRpb25zLCBwaWxlKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucywgdHJ1ZSk7XG4gICAgICB0aGlzLnByb3BhZ2F0ZUZvbnRzKHBpbGUpO1xuICAgICAgZGVlcEV4dGVuZCh0aGlzLmZvbnRPcHRpb25zLCB0aGlzLmNvbnN0cmFpbihwaWxlKSk7XG4gICAgICB0aGlzLmZvbnRPcHRpb25zLmNob29zZXIgPSBjaG9vc2lmeShcImxhYmVsXCIsIHBpbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIG1hcmdpbnMgYXJlIHNldCBpbiBhbiBlbGVtZW50LCBhZGp1c3Qgc2l6ZXMgaXMgY2FsbGVkIHRvIHJlbW92ZSB0aGVtXG4gICAgICogZnJvbSB0aGUgd2lkdGgvaGVpZ2h0IGNvbnN0cmFpbnRzLiBUaGlzIG11c3QgYmUgZG9uZSBwcmlvciB0byBsYWJlbCBzaXppbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19IG1hcmdpbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkanVzdFNpemVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkanVzdFNpemVzKG1hcmdpbnMpIHtcbiAgICAgIHZhciB3aWR0aEJpYXMgPSBtYXJnaW5zID8gbWFyZ2lucy5yaWdodCArIG1hcmdpbnMubGVmdCA6IDA7XG5cbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLmNvbnN0cmFpbldpZHRoKSB7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMubWF4V2R0IC09IHdpZHRoQmlhcztcbiAgICAgICAgdGhpcy5mb250T3B0aW9ucy5taW5XZHQgLT0gd2lkdGhCaWFzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGVpZ2h0QmlhcyA9IG1hcmdpbnMgPyBtYXJnaW5zLnRvcCArIG1hcmdpbnMuYm90dG9tIDogMDtcblxuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuY29uc3RyYWluSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMubWluSGd0IC09IGhlaWdodEJpYXM7XG4gICAgICB9XG4gICAgfSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBNZXRob2RzIGZvciBoYW5kbGluZyBvcHRpb25zIHBpbGVzXG4gICAgLy8gRXZlbnR1YWxseSwgdGhlc2Ugd2lsbCBiZSBtb3ZlZCB0byBhIHNlcGFyYXRlIGNsYXNzXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGZvbnQgbWVtYmVycyBvZiB0aGUgcGFzc2VkIGxpc3Qgb2Ygb3B0aW9uIG9iamVjdHMgdG8gdGhlIHBpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IGRzdFBpbGUgIHBpbGUgb2Ygb3B0aW9uIG9iamVjdHMgYWRkIHRvXG4gICAgICogQHBhcmFtIHtQaWxlfSBzcmNQaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHRha2UgZm9udCBvcHRpb25zIGZyb21cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRm9udE9wdGlvbnNUb1BpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRm9udE9wdGlvbnNUb1BpbGUoZHN0UGlsZSwgc3JjUGlsZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcmNQaWxlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuYWRkRm9udFRvUGlsZShkc3RQaWxlLCBzcmNQaWxlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGdpdmVuIGZvbnQgb3B0aW9uIG9iamVjdCB0byB0aGUgbGlzdCBvZiBvYmplY3RzICh0aGUgJ3BpbGUnKSB0byBjb25zaWRlciBmb3IgZGV0ZXJtaW5pbmdcbiAgICAgKiBtdWx0aS1mb250IG9wdGlvbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IHBpbGUgIHBpbGUgb2Ygb3B0aW9uIG9iamVjdHMgdG8gdXNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgIGluc3RhbmNlIHRvIGFkZCB0byBwaWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZEZvbnRUb1BpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRm9udFRvUGlsZShwaWxlLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICBpZiAob3B0aW9ucy5mb250ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5mb250ID09PSBudWxsKSByZXR1cm47XG4gICAgICB2YXIgaXRlbSA9IG9wdGlvbnMuZm9udDtcbiAgICAgIHBpbGUucHVzaChpdGVtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGVjdCBhbGwgb3duLXByb3BlcnR5IHZhbHVlcyBmcm9tIHRoZSBmb250IHBpbGUgdGhhdCBhcmVuJ3QgbXVsdGktZm9udCBvcHRpb24gb2JqZWN0c3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IHBpbGUgIHBpbGUgb2Ygb3B0aW9uIG9iamVjdHMgdG8gdXNlXG4gICAgICogQHJldHVybnMge29iamVjdH0gb2JqZWN0IHdpdGggYWxsIGN1cnJlbnQgb3duIGJhc2ljIGZvbnQgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRCYXNpY09wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFzaWNPcHRpb25zKHBpbGUpIHtcbiAgICAgIHZhciByZXQgPSB7fTsgLy8gU2NhbnMgdGhlIHdob2xlIHBpbGUgdG8gZ2V0IGFsbCBvcHRpb25zIHByZXNlbnRcblxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBwaWxlLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIHZhciBmb250T3B0aW9ucyA9IHBpbGVbbl07IC8vIENvbnZlcnQgc2hvcnRoYW5kIGlmIG5lY2Vzc2FyeVxuXG4gICAgICAgIHZhciB0bXBTaG9ydGhhbmQgPSB7fTtcblxuICAgICAgICBpZiAoTGFiZWwucGFyc2VGb250U3RyaW5nKHRtcFNob3J0aGFuZCwgZm9udE9wdGlvbnMpKSB7XG4gICAgICAgICAgZm9udE9wdGlvbnMgPSB0bXBTaG9ydGhhbmQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JFYWNoJDEoZm9udE9wdGlvbnMsIGZ1bmN0aW9uIChvcHQsIG5hbWUpIHtcbiAgICAgICAgICBpZiAob3B0ID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gbXVsdGktZm9udCBvcHRpb24gbmVlZCBub3QgYmUgcHJlc2VudFxuXG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXQsIG5hbWUpKSByZXR1cm47IC8vIEtlZXAgZmlyc3QgdmFsdWUgd2UgZW5jb3VudGVyXG5cbiAgICAgICAgICBpZiAoaW5kZXhPZihtdWx0aUZvbnRTdHlsZSkuY2FsbChtdWx0aUZvbnRTdHlsZSwgbmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBTa2lwIG11bHRpLWZvbnQgcHJvcGVydGllcyBidXQgd2UgZG8gbmVlZCB0aGUgc3RydWN0dXJlXG4gICAgICAgICAgICByZXRbbmFtZV0gPSB7fTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0W25hbWVdID0gb3B0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgZm9yIGdpdmVuIG9wdGlvbiBmb3IgdGhlIGdpdmVuIG11bHRpLWZvbnQuXG4gICAgICpcbiAgICAgKiBBbGwgYXZhaWxhYmxlIG9wdGlvbiBvYmplY3RzIGFyZSB0cmF3bGVkIGluIHRoZSBzZXQgb3JkZXIgdG8gY29uc3RydWN0IHRoZSBvcHRpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogIyMgVHJhdmVyc2FsIG9mIHBpbGUgZm9yIG11bHRpLWZvbnRzXG4gICAgICpcbiAgICAgKiBUaGUgZGV0ZXJtaW5hdGlvbiBvZiBtdWx0aS1mb250IG9wdGlvbiB2YWx1ZXMgaXMgYSBzcGVjaWFsIGNhc2UsIGJlY2F1c2UgYW55IHZhbHVlcyBub3RcbiAgICAgKiBwcmVzZW50IGluIHRoZSBtdWx0aS1mb250IG9wdGlvbnMgc2hvdWxkIGJ5IGRlZmluaXRpb24gYmUgdGFrZW4gZnJvbSB0aGUgbWFpbiBmb250IG9wdGlvbnMsXG4gICAgICogaS5lLiBmcm9tIHRoZSBjdXJyZW50ICdwYXJlbnQnIG9iamVjdCBvZiB0aGUgbXVsdGktZm9udCBvcHRpb24uXG4gICAgICpcbiAgICAgKiAjIyMgU2VhcmNoIG9yZGVyIGZvciBtdWx0aS1mb250c1xuICAgICAqXG4gICAgICogJ2JvbGQnIHVzZWQgYXMgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgLSBzZWFyY2ggaW4gb3B0aW9uIGdyb3VwICdib2xkJyBpbiBsb2NhbCBwcm9wZXJ0aWVzXG4gICAgICogICAtIHNlYXJjaCBpbiBtYWluIGZvbnQgb3B0aW9uIGdyb3VwIGluIGxvY2FsIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7TXVsdGlGb250U3R5bGV9IG11bHRpTmFtZSBzdWIgcGF0aCBmb3IgdGhlIG11bHRpLWZvbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uICB0aGUgb3B0aW9uIHRvIHNlYXJjaCBmb3IsIGZvciB0aGUgZ2l2ZW4gbXVsdGktZm9udFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfSB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9udE9wdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb250T3B0aW9uKHBpbGUsIG11bHRpTmFtZSwgb3B0aW9uKSB7XG4gICAgICB2YXIgbXVsdGlGb250OyAvLyBTZWFyY2ggbXVsdGkgZm9udCBpbiBsb2NhbCBwcm9wZXJ0aWVzXG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgcGlsZS5sZW5ndGg7ICsrbikge1xuICAgICAgICB2YXIgZm9udE9wdGlvbnMgPSBwaWxlW25dO1xuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZm9udE9wdGlvbnMsIG11bHRpTmFtZSkpIHtcbiAgICAgICAgICBtdWx0aUZvbnQgPSBmb250T3B0aW9uc1ttdWx0aU5hbWVdO1xuICAgICAgICAgIGlmIChtdWx0aUZvbnQgPT09IHVuZGVmaW5lZCB8fCBtdWx0aUZvbnQgPT09IG51bGwpIGNvbnRpbnVlOyAvLyBDb252ZXJ0IHNob3J0aGFuZCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAvLyBUT0RPOiBpbmVmZmljaWVudCB0byBkbyB0aGlzIGNvbnZlcnNpb24gZXZlcnkgdGltZTsgZmluZCBhIGJldHRlciB3YXkuXG5cbiAgICAgICAgICB2YXIgdG1wU2hvcnRoYW5kID0ge307XG5cbiAgICAgICAgICBpZiAoTGFiZWwucGFyc2VGb250U3RyaW5nKHRtcFNob3J0aGFuZCwgbXVsdGlGb250KSkge1xuICAgICAgICAgICAgbXVsdGlGb250ID0gdG1wU2hvcnRoYW5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobXVsdGlGb250LCBvcHRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gbXVsdGlGb250W29wdGlvbl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIE9wdGlvbiBpcyBub3QgbWVudGlvbmVkIGluIHRoZSBtdWx0aSBmb250IG9wdGlvbnM7IHRha2UgaXQgZnJvbSB0aGUgcGFyZW50IGZvbnQgb3B0aW9ucy5cbiAgICAgIC8vIFRoZXNlIGhhdmUgYWxyZWFkeSBiZWVuIGNvbnZlcnRlZCB3aXRoIGdldEJhc2ljT3B0aW9ucygpLCBzbyB1c2UgdGhlIGNvbnZlcnRlZCB2YWx1ZXMuXG5cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmZvbnRPcHRpb25zLCBvcHRpb24pKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbnRPcHRpb25zW29wdGlvbl07XG4gICAgICB9IC8vIEEgdmFsdWUgKiptdXN0KiogYmUgZm91bmQ7IHlvdSBzaG91bGQgbmV2ZXIgZ2V0IGhlcmUuXG5cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCBmaW5kIHZhbHVlIGZvciBtdWx0aS1mb250IGZvciBwcm9wZXJ0eTogJ1wiICsgb3B0aW9uICsgXCInXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIG9wdGlvbnMgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gbXVsdGktZm9udC5cbiAgICAgKlxuICAgICAqIEFsbCBhdmFpbGFibGUgb3B0aW9uIG9iamVjdHMgYXJlIHRyYXdsZWQgaW4gdGhlIHNldCBvcmRlciB0byBjb25zdHJ1Y3QgdGhlIG9wdGlvbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IHBpbGUgIHBpbGUgb2Ygb3B0aW9uIG9iamVjdHMgdG8gdXNlXG4gICAgICogQHBhcmFtIHtNdWx0aUZvbnRTdHlsZX0gbXVsdGlOYW1lIHN1YiBwYXRoIGZvciB0aGUgbW9kLWZvbnRcbiAgICAgKiBAcmV0dXJucyB7TXVsdGlGb250T3B0aW9uc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9udE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9udE9wdGlvbnMocGlsZSwgbXVsdGlOYW1lKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICB2YXIgb3B0aW9uTmFtZXMgPSBbXCJjb2xvclwiLCBcInNpemVcIiwgXCJmYWNlXCIsIFwibW9kXCIsIFwidmFkanVzdFwiXTsgLy8gTGlzdCBvZiBhbGxvd2VkIG9wdGlvbnMgcGVyIG11bHRpLWZvbnRcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25OYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbW9kID0gb3B0aW9uTmFtZXNbaV07XG4gICAgICAgIHJlc3VsdFttb2RdID0gdGhpcy5nZXRGb250T3B0aW9uKHBpbGUsIG11bHRpTmFtZSwgbW9kKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEVuZCBtZXRob2RzIGZvciBoYW5kbGluZyBvcHRpb25zIHBpbGVzXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZSB0aGUgZm9udCBvcHRpb25zIGZvciB0aGUgbXVsdGktZm9udCB0byBzaW5nbGUgb2JqZWN0cywgZnJvbVxuICAgICAqIHRoZSBjaGFpbiBvZiBvcHRpb24gb2JqZWN0cyBwYXNzZWQgKHRoZSAncGlsZScpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBzZXF1ZW5jZSBvZiBvcHRpb24gb2JqZWN0cyB0byBjb25zaWRlci5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIEZpcnN0IGl0ZW0gaW4gbGlzdCBhc3N1bWVkIHRvIGJlIHRoZSBuZXdseSBzZXQgb3B0aW9ucy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByb3BhZ2F0ZUZvbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb3BhZ2F0ZUZvbnRzKHBpbGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZm9udFBpbGUgPSBbXTsgLy8gc2VxdWVuY2Ugb2YgZm9udCBvYmplY3RzIHRvIGNvbnNpZGVyLCBvcmRlciBpbXBvcnRhbnRcbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzLmVsZW1lbnRPcHRpb25zIGlzIG5vdCB1c2VkIGhlcmUuXG5cbiAgICAgIHRoaXMuYWRkRm9udE9wdGlvbnNUb1BpbGUoZm9udFBpbGUsIHBpbGUpO1xuICAgICAgdGhpcy5mb250T3B0aW9ucyA9IHRoaXMuZ2V0QmFzaWNPcHRpb25zKGZvbnRQaWxlKTsgLy8gV2Ugc2V0IG11bHRpZm9udCB2YWx1ZXMgZXZlbiBpZiBtdWx0aSA9PT0gZmFsc2UsIGZvciBjb25zaXN0ZW5jeSAodGhpbmdzIGJyZWFrIG90aGVyd2lzZSlcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICB2YXIgbW9kID0gbXVsdGlGb250U3R5bGVbaV07XG4gICAgICAgIHZhciBtb2RPcHRpb25zID0gX3RoaXMyLmZvbnRPcHRpb25zW21vZF07XG5cbiAgICAgICAgdmFyIHRtcE11bHRpRm9udE9wdGlvbnMgPSBfdGhpczIuZ2V0Rm9udE9wdGlvbnMoZm9udFBpbGUsIG1vZCk7IC8vIENvcHkgb3ZlciBmb3VuZCB2YWx1ZXNcblxuXG4gICAgICAgIGZvckVhY2gkMSh0bXBNdWx0aUZvbnRPcHRpb25zLCBmdW5jdGlvbiAob3B0aW9uLCBuKSB7XG4gICAgICAgICAgbW9kT3B0aW9uc1tuXSA9IG9wdGlvbjtcbiAgICAgICAgfSk7XG4gICAgICAgIG1vZE9wdGlvbnMuc2l6ZSA9IE51bWJlcihtb2RPcHRpb25zLnNpemUpO1xuICAgICAgICBtb2RPcHRpb25zLnZhZGp1c3QgPSBOdW1iZXIobW9kT3B0aW9ucy52YWRqdXN0KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXVsdGlGb250U3R5bGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgX2xvb3AoaSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1haW4gZnVuY3Rpb24uIFRoaXMgaXMgY2FsbGVkIGZyb20gYW55dGhpbmcgdGhhdCB3YW50cyB0byBkcmF3IGEgbGFiZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtiYXNlbGluZT0nbWlkZGxlJ11cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdmFyIGJhc2VsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBcIm1pZGRsZVwiO1xuICAgICAgLy8gaWYgbm8gbGFiZWwsIHJldHVyblxuICAgICAgaWYgKHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBjaGVjayBpZiB3ZSBoYXZlIHRvIHJlbmRlciB0aGUgbGFiZWxcblxuICAgICAgdmFyIHZpZXdGb250U2l6ZSA9IHRoaXMuZm9udE9wdGlvbnMuc2l6ZSAqIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgaWYgKHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWwgJiYgdmlld0ZvbnRTaXplIDwgdGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQgLSAxKSByZXR1cm47IC8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZXJlIHdpbGwgbm90IGJlIEhVR0UgbGV0dGVycyBvbiBzY3JlZW5cbiAgICAgIC8vIGJ5IHNldHRpbmcgYW4gdXBwZXIgbGltaXQgb24gdGhlIHZpc2libGUgdGV4dCBzaXplIChyZWdhcmRsZXNzIG9mIHpvb21MZXZlbClcblxuICAgICAgaWYgKHZpZXdGb250U2l6ZSA+PSB0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwubWF4VmlzaWJsZSkge1xuICAgICAgICB2aWV3Rm9udFNpemUgPSBOdW1iZXIodGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1heFZpc2libGUpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB9IC8vIHVwZGF0ZSB0aGUgc2l6ZSBjYWNoZSBpZiByZXF1aXJlZFxuXG5cbiAgICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxTaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCB4LCB5LCBiYXNlbGluZSk7XG5cbiAgICAgIHRoaXMuX2RyYXdCYWNrZ3JvdW5kKGN0eCk7XG5cbiAgICAgIHRoaXMuX2RyYXdUZXh0KGN0eCwgeCwgdGhpcy5zaXplLnlMaW5lLCBiYXNlbGluZSwgdmlld0ZvbnRTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGxhYmVsIGJhY2tncm91bmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdCYWNrZ3JvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3QmFja2dyb3VuZChjdHgpIHtcbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQ7XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICAgIGN0eC5maWxsUmVjdChzaXplLmxlZnQsIHNpemUudG9wLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Jhc2VsaW5lPSdtaWRkbGUnXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3Rm9udFNpemVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3VGV4dChjdHgsIHgsIHkpIHtcbiAgICAgIHZhciBiYXNlbGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJtaWRkbGVcIjtcbiAgICAgIHZhciB2aWV3Rm9udFNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIF90aGlzJF9zZXRBbGlnbm1lbnQgPSB0aGlzLl9zZXRBbGlnbm1lbnQoY3R4LCB4LCB5LCBiYXNlbGluZSk7XG5cbiAgICAgIHZhciBfdGhpcyRfc2V0QWxpZ25tZW50MiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9zZXRBbGlnbm1lbnQsIDIpO1xuXG4gICAgICB4ID0gX3RoaXMkX3NldEFsaWdubWVudDJbMF07XG4gICAgICB5ID0gX3RoaXMkX3NldEFsaWdubWVudDJbMV07XG4gICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICB4ID0geCAtIHRoaXMuc2l6ZS53aWR0aCAvIDI7IC8vIFNoaWZ0IGxhYmVsIDEvMi1kaXN0YW5jZSB0byB0aGUgbGVmdFxuXG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy52YWxpZ24gJiYgdGhpcy5zaXplLmhlaWdodCA+IHRoaXMuc2l6ZS5sYWJlbEhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5mb250T3B0aW9ucy52YWxpZ24gPT09IFwidG9wXCIpIHtcbiAgICAgICAgICB5IC09ICh0aGlzLnNpemUuaGVpZ2h0IC0gdGhpcy5zaXplLmxhYmVsSGVpZ2h0KSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mb250T3B0aW9ucy52YWxpZ24gPT09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICB5ICs9ICh0aGlzLnNpemUuaGVpZ2h0IC0gdGhpcy5zaXplLmxhYmVsSGVpZ2h0KSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZHJhdyB0aGUgdGV4dFxuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lQ291bnQ7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG5cbiAgICAgICAgaWYgKGxpbmUgJiYgbGluZS5ibG9ja3MpIHtcbiAgICAgICAgICB2YXIgd2lkdGggPSAwO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNFZGdlTGFiZWwgfHwgdGhpcy5mb250T3B0aW9ucy5hbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgICAgd2lkdGggKz0gKHRoaXMuc2l6ZS53aWR0aCAtIGxpbmUud2lkdGgpIC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgd2lkdGggKz0gdGhpcy5zaXplLndpZHRoIC0gbGluZS53aWR0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmUuYmxvY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBsaW5lLmJsb2Nrc1tqXTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gYmxvY2suZm9udDtcblxuICAgICAgICAgICAgdmFyIF90aGlzJF9nZXRDb2xvciA9IHRoaXMuX2dldENvbG9yKGJsb2NrLmNvbG9yLCB2aWV3Rm9udFNpemUsIGJsb2NrLnN0cm9rZUNvbG9yKSxcbiAgICAgICAgICAgICAgICBfdGhpcyRfZ2V0Q29sb3IyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldENvbG9yLCAyKSxcbiAgICAgICAgICAgICAgICBmb250Q29sb3IgPSBfdGhpcyRfZ2V0Q29sb3IyWzBdLFxuICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yID0gX3RoaXMkX2dldENvbG9yMlsxXTtcblxuICAgICAgICAgICAgaWYgKGJsb2NrLnN0cm9rZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gYmxvY2suc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yO1xuICAgICAgICAgICAgICBjdHgubGluZUpvaW4gPSBcInJvdW5kXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmb250Q29sb3I7XG5cbiAgICAgICAgICAgIGlmIChibG9jay5zdHJva2VXaWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQoYmxvY2sudGV4dCwgeCArIHdpZHRoLCB5ICsgYmxvY2sudmFkanVzdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChibG9jay50ZXh0LCB4ICsgd2lkdGgsIHkgKyBibG9jay52YWRqdXN0KTtcbiAgICAgICAgICAgIHdpZHRoICs9IGJsb2NrLndpZHRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHkgKz0gbGluZS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlbGluZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldEFsaWdubWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0QWxpZ25tZW50KGN0eCwgeCwgeSwgYmFzZWxpbmUpIHtcbiAgICAgIC8vIGNoZWNrIGZvciBsYWJlbCBhbGlnbm1lbnQgKGZvciBlZGdlcylcbiAgICAgIC8vIFRPRE86IG1ha2UgYWxpZ25tZW50IGZvciBub2Rlc1xuICAgICAgaWYgKHRoaXMuaXNFZGdlTGFiZWwgJiYgdGhpcy5mb250T3B0aW9ucy5hbGlnbiAhPT0gXCJob3Jpem9udGFsXCIgJiYgdGhpcy5wb2ludFRvU2VsZiA9PT0gZmFsc2UpIHtcbiAgICAgICAgeCA9IDA7XG4gICAgICAgIHkgPSAwO1xuICAgICAgICB2YXIgbGluZU1hcmdpbiA9IDI7XG5cbiAgICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gPT09IFwidG9wXCIpIHtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCI7XG4gICAgICAgICAgeSAtPSAyICogbGluZU1hcmdpbjsgLy8gZGlzdGFuY2UgZnJvbSBlZGdlLCByZXF1aXJlZCBiZWNhdXNlIHdlIHVzZSBhbHBoYWJldGljLiBBbHBoYWJldGljIGhhcyBsZXNzIGRpZmZlcmVuY2UgYmV0d2VlbiBicm93c2Vyc1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gPT09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJoYW5naW5nXCI7XG4gICAgICAgICAgeSArPSAyICogbGluZU1hcmdpbjsgLy8gZGlzdGFuY2UgZnJvbSBlZGdlLCByZXF1aXJlZCBiZWNhdXNlIHdlIHVzZSBoYW5naW5nLiBIYW5naW5nIGhhcyBsZXNzIGRpZmZlcmVuY2UgYmV0d2VlbiBicm93c2Vyc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gYmFzZWxpbmU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGZhZGUgaW4gd2hlbiByZWxhdGl2ZSBzY2FsZSBpcyBiZXR3ZWVuIHRocmVzaG9sZCBhbmQgdGhyZXNob2xkIC0gMS5cbiAgICAgKiBJZiB0aGUgcmVsYXRpdmUgc2NhbGUgd291bGQgYmUgc21hbGxlciB0aGFuIHRocmVzaG9sZCAtMSB0aGUgZHJhdyBmdW5jdGlvbiB3b3VsZCBoYXZlIHJldHVybmVkIGJlZm9yZSBjb21pbmcgaGVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAgVGhlIGZvbnQgY29sb3IgdG8gdXNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZpZXdGb250U2l6ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbml0aWFsU3Ryb2tlQ29sb3JcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGZvbnQgY29sb3IgYW5kIHN0cm9rZSBjb2xvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENvbG9yKGNvbG9yLCB2aWV3Rm9udFNpemUsIGluaXRpYWxTdHJva2VDb2xvcikge1xuICAgICAgdmFyIGZvbnRDb2xvciA9IGNvbG9yIHx8IFwiIzAwMDAwMFwiO1xuICAgICAgdmFyIHN0cm9rZUNvbG9yID0gaW5pdGlhbFN0cm9rZUNvbG9yIHx8IFwiI2ZmZmZmZlwiO1xuXG4gICAgICBpZiAodmlld0ZvbnRTaXplIDw9IHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkKSB7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgMSAtICh0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZCAtIHZpZXdGb250U2l6ZSkpKTtcbiAgICAgICAgZm9udENvbG9yID0gb3ZlcnJpZGVPcGFjaXR5KGZvbnRDb2xvciwgb3BhY2l0eSk7XG4gICAgICAgIHN0cm9rZUNvbG9yID0gb3ZlcnJpZGVPcGFjaXR5KHN0cm9rZUNvbG9yLCBvcGFjaXR5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtmb250Q29sb3IsIHN0cm9rZUNvbG9yXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFRleHRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHRTaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIHRoaXMuX3Byb2Nlc3NMYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB0aGlzLnNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5zaXplLmhlaWdodCxcbiAgICAgICAgbGluZUNvdW50OiB0aGlzLmxpbmVDb3VudFxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGRpbWVuc2lvbnMgb2YgdGhlIGxhYmVsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7cmVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2l6ZSgpIHtcbiAgICAgIHZhciBsaW5lTWFyZ2luID0gMjtcbiAgICAgIHZhciB4ID0gdGhpcy5zaXplLmxlZnQ7IC8vIGRlZmF1bHQgdmFsdWVzIHdoaWNoIG1pZ2h0IGJlIG92ZXJyaWRkZW4gYmVsb3dcblxuICAgICAgdmFyIHkgPSB0aGlzLnNpemUudG9wIC0gMC41ICogbGluZU1hcmdpbjsgLy8gaWRlbVxuXG4gICAgICBpZiAodGhpcy5pc0VkZ2VMYWJlbCkge1xuICAgICAgICB2YXIgeDIgPSAtdGhpcy5zaXplLndpZHRoICogMC41O1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5mb250T3B0aW9ucy5hbGlnbikge1xuICAgICAgICAgIGNhc2UgXCJtaWRkbGVcIjpcbiAgICAgICAgICAgIHggPSB4MjtcbiAgICAgICAgICAgIHkgPSAtdGhpcy5zaXplLmhlaWdodCAqIDAuNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICAgICAgeCA9IHgyO1xuICAgICAgICAgICAgeSA9IC0odGhpcy5zaXplLmhlaWdodCArIGxpbmVNYXJnaW4pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICB4ID0geDI7XG4gICAgICAgICAgICB5ID0gbGluZU1hcmdpbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIGxlZnQ6IHgsXG4gICAgICAgIHRvcDogeSxcbiAgICAgICAgd2lkdGg6IHRoaXMuc2l6ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLnNpemUuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAgICAgKiBAcGFyYW0geydtaWRkbGUnfCdoYW5naW5nJ30gW2Jhc2VsaW5lPSdtaWRkbGUnXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlTGFiZWxTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUxhYmVsU2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgICAgIHZhciBiYXNlbGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogXCJtaWRkbGVcIjtcblxuICAgICAgdGhpcy5fcHJvY2Vzc0xhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgdGhpcy5zaXplLmxlZnQgPSB4IC0gdGhpcy5zaXplLndpZHRoICogMC41O1xuICAgICAgdGhpcy5zaXplLnRvcCA9IHkgLSB0aGlzLnNpemUuaGVpZ2h0ICogMC41O1xuICAgICAgdGhpcy5zaXplLnlMaW5lID0geSArICgxIC0gdGhpcy5saW5lQ291bnQpICogMC41ICogdGhpcy5mb250T3B0aW9ucy5zaXplO1xuXG4gICAgICBpZiAoYmFzZWxpbmUgPT09IFwiaGFuZ2luZ1wiKSB7XG4gICAgICAgIHRoaXMuc2l6ZS50b3AgKz0gMC41ICogdGhpcy5mb250T3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLnNpemUudG9wICs9IDQ7IC8vIGRpc3RhbmNlIGZyb20gbm9kZSwgcmVxdWlyZWQgYmVjYXVzZSB3ZSB1c2UgaGFuZ2luZy4gSGFuZ2luZyBoYXMgbGVzcyBkaWZmZXJlbmNlIGJldHdlZW4gYnJvd3NlcnNcblxuICAgICAgICB0aGlzLnNpemUueUxpbmUgKz0gNDsgLy8gZGlzdGFuY2UgZnJvbSBub2RlXG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZFxuICAgICAqIEByZXR1cm5zIHt7Y29sb3IsIHNpemUsIGZhY2UsIG1vZCwgdmFkanVzdCwgc3Ryb2tlV2lkdGg6ICosIHN0cm9rZUNvbG9yOiAoKnxzdHJpbmd8YWxsT3B0aW9ucy5lZGdlcy5mb250LnN0cm9rZUNvbG9yfHtzdHJpbmd9fGFsbE9wdGlvbnMubm9kZXMuZm9udC5zdHJva2VDb2xvcnxBcnJheSl9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9ybWF0dGluZ1ZhbHVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JtYXR0aW5nVmFsdWVzKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCBtb2QpIHtcbiAgICAgIHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKGZvbnRPcHRpb25zLCBtb2QsIG9wdGlvbikge1xuICAgICAgICBpZiAobW9kID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbiA9PT0gXCJtb2RcIikgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgcmV0dXJuIGZvbnRPcHRpb25zW29wdGlvbl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9udE9wdGlvbnNbbW9kXVtvcHRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBHcnVtYmwgbGVhdmluZyBvdXQgdGVzdCBvbiB1bmRlZmluZWQgZXF1YWxzIGZhbHNlIGZvciBcIlwiXG4gICAgICAgICAgcmV0dXJuIGZvbnRPcHRpb25zW21vZF1bb3B0aW9uXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUYWtlIGZyb20gcGFyZW50IGZvbnQgb3B0aW9uXG4gICAgICAgICAgcmV0dXJuIGZvbnRPcHRpb25zW29wdGlvbl07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciB2YWx1ZXMgPSB7XG4gICAgICAgIGNvbG9yOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsIFwiY29sb3JcIiksXG4gICAgICAgIHNpemU6IGdldFZhbHVlKHRoaXMuZm9udE9wdGlvbnMsIG1vZCwgXCJzaXplXCIpLFxuICAgICAgICBmYWNlOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsIFwiZmFjZVwiKSxcbiAgICAgICAgbW9kOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsIFwibW9kXCIpLFxuICAgICAgICB2YWRqdXN0OiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsIFwidmFkanVzdFwiKSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuZm9udE9wdGlvbnMuc3Ryb2tlV2lkdGgsXG4gICAgICAgIHN0cm9rZUNvbG9yOiB0aGlzLmZvbnRPcHRpb25zLnN0cm9rZUNvbG9yXG4gICAgICB9O1xuXG4gICAgICBpZiAoc2VsZWN0ZWQgfHwgaG92ZXIpIHtcbiAgICAgICAgaWYgKG1vZCA9PT0gXCJub3JtYWxcIiAmJiB0aGlzLmZvbnRPcHRpb25zLmNob29zZXIgPT09IHRydWUgJiYgdGhpcy5lbGVtZW50T3B0aW9ucy5sYWJlbEhpZ2hsaWdodEJvbGQpIHtcbiAgICAgICAgICB2YWx1ZXMubW9kID0gXCJib2xkXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmZvbnRPcHRpb25zLmNob29zZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyKHZhbHVlcywgdGhpcy5lbGVtZW50T3B0aW9ucy5pZCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGZvbnRTdHJpbmcgPSBcIlwiO1xuXG4gICAgICBpZiAodmFsdWVzLm1vZCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlcy5tb2QgIT09IFwiXCIpIHtcbiAgICAgICAgLy8gc2FmZWd1YXJkIGZvciB1bmRlZmluZWQgLSB0aGlzIGhhcHBlbmVkXG4gICAgICAgIGZvbnRTdHJpbmcgKz0gdmFsdWVzLm1vZCArIFwiIFwiO1xuICAgICAgfVxuXG4gICAgICBmb250U3RyaW5nICs9IHZhbHVlcy5zaXplICsgXCJweCBcIiArIHZhbHVlcy5mYWNlO1xuICAgICAgY3R4LmZvbnQgPSBmb250U3RyaW5nLnJlcGxhY2UoL1wiL2csIFwiXCIpO1xuICAgICAgdmFsdWVzLmZvbnQgPSBjdHguZm9udDtcbiAgICAgIHZhbHVlcy5oZWlnaHQgPSB2YWx1ZXMuc2l6ZTtcbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpZmZlcmVudFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpZmZlcmVudFN0YXRlKHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgcmV0dXJuIHNlbGVjdGVkICE9PSB0aGlzLnNlbGVjdGVkU3RhdGUgfHwgaG92ZXIgIT09IHRoaXMuaG92ZXJTdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBleHBsb2RlcyB0aGUgcGFzc2VkIHRleHQgaW50byBsaW5lcyBhbmQgZGV0ZXJtaW5lcyB0aGUgd2lkdGgsIGhlaWdodCBhbmQgbnVtYmVyIG9mIGxpbmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluVGV4dCAgdGhlIHRleHQgdG8gZXhwbG9kZVxuICAgICAqIEByZXR1cm5zIHt7d2lkdGgsIGhlaWdodCwgbGluZXN9fCp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wcm9jZXNzTGFiZWxUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcm9jZXNzTGFiZWxUZXh0KGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCBpblRleHQpIHtcbiAgICAgIHZhciBzcGxpdHRlciA9IG5ldyBMYWJlbFNwbGl0dGVyKGN0eCwgdGhpcywgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHJldHVybiBzcGxpdHRlci5wcm9jZXNzKGluVGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZXhwbG9kZXMgdGhlIGxhYmVsIHN0cmluZyBpbnRvIGxpbmVzIGFuZCBzZXRzIHRoZSB3aWR0aCwgaGVpZ2h0IGFuZCBudW1iZXIgb2YgbGluZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Byb2Nlc3NMYWJlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJvY2Vzc0xhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAodGhpcy5sYWJlbERpcnR5ID09PSBmYWxzZSAmJiAhdGhpcy5kaWZmZXJlbnRTdGF0ZShzZWxlY3RlZCwgaG92ZXIpKSByZXR1cm47XG5cbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3Byb2Nlc3NMYWJlbFRleHQoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWwpO1xuXG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5taW5XZHQgPiAwICYmIHN0YXRlLndpZHRoIDwgdGhpcy5mb250T3B0aW9ucy5taW5XZHQpIHtcbiAgICAgICAgc3RhdGUud2lkdGggPSB0aGlzLmZvbnRPcHRpb25zLm1pbldkdDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zaXplLmxhYmVsSGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xuXG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5taW5IZ3QgPiAwICYmIHN0YXRlLmhlaWdodCA8IHRoaXMuZm9udE9wdGlvbnMubWluSGd0KSB7XG4gICAgICAgIHN0YXRlLmhlaWdodCA9IHRoaXMuZm9udE9wdGlvbnMubWluSGd0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxpbmVzID0gc3RhdGUubGluZXM7XG4gICAgICB0aGlzLmxpbmVDb3VudCA9IHN0YXRlLmxpbmVzLmxlbmd0aDtcbiAgICAgIHRoaXMuc2l6ZS53aWR0aCA9IHN0YXRlLndpZHRoO1xuICAgICAgdGhpcy5zaXplLmhlaWdodCA9IHN0YXRlLmhlaWdodDtcbiAgICAgIHRoaXMuc2VsZWN0ZWRTdGF0ZSA9IHNlbGVjdGVkO1xuICAgICAgdGhpcy5ob3ZlclN0YXRlID0gaG92ZXI7XG4gICAgICB0aGlzLmxhYmVsRGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBsYWJlbCBpcyB2aXNpYmxlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGxhYmVsIHdpbGwgYmUgc2hvdywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2aXNpYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpc2libGUoKSB7XG4gICAgICBpZiAodGhpcy5zaXplLndpZHRoID09PSAwIHx8IHRoaXMuc2l6ZS5oZWlnaHQgPT09IDAgfHwgdGhpcy5lbGVtZW50T3B0aW9ucy5sYWJlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gbm90aGluZyB0byBkaXNwbGF5XG4gICAgICB9XG5cbiAgICAgIHZhciB2aWV3Rm9udFNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemUgKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcblxuICAgICAgaWYgKHZpZXdGb250U2l6ZSA8IHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkIC0gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFRvbyBzbWFsbCBvciB0b28gZmFyIGF3YXkgdG8gc2hvd1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZUZvbnRTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VGb250U3RyaW5nKG91dE9wdGlvbnMsIGluT3B0aW9ucykge1xuICAgICAgaWYgKCFpbk9wdGlvbnMgfHwgdHlwZW9mIGluT3B0aW9ucyAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIG5ld09wdGlvbnNBcnJheSA9IGluT3B0aW9ucy5zcGxpdChcIiBcIik7XG4gICAgICBvdXRPcHRpb25zLnNpemUgPSArbmV3T3B0aW9uc0FycmF5WzBdLnJlcGxhY2UoXCJweFwiLCBcIlwiKTtcbiAgICAgIG91dE9wdGlvbnMuZmFjZSA9IG5ld09wdGlvbnNBcnJheVsxXTtcbiAgICAgIG91dE9wdGlvbnMuY29sb3IgPSBuZXdPcHRpb25zQXJyYXlbMl07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGFiZWw7XG59KCk7XG5cbi8qKlxuICogVGhlIEJhc2UgY2xhc3MgZm9yIGFsbCBOb2Rlcy5cbiAqL1xudmFyIE5vZGVCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBOb2RlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlQmFzZSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMubGFiZWxNb2R1bGUgPSBsYWJlbE1vZHVsZTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXJnaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yZWZyZXNoTmVlZGVkID0gdHJ1ZTtcbiAgICB0aGlzLmJvdW5kaW5nQm94ID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTm9kZUJhc2UsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRNYXJnaW5zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRNYXJnaW5zKGxhYmVsTW9kdWxlKSB7XG4gICAgICB0aGlzLm1hcmdpbiA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm1hcmdpbikge1xuICAgICAgICBpZiAoX3R5cGVvZih0aGlzLm9wdGlvbnMubWFyZ2luKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhpcy5tYXJnaW4udG9wID0gdGhpcy5vcHRpb25zLm1hcmdpbi50b3A7XG4gICAgICAgICAgdGhpcy5tYXJnaW4ucmlnaHQgPSB0aGlzLm9wdGlvbnMubWFyZ2luLnJpZ2h0O1xuICAgICAgICAgIHRoaXMubWFyZ2luLmJvdHRvbSA9IHRoaXMub3B0aW9ucy5tYXJnaW4uYm90dG9tO1xuICAgICAgICAgIHRoaXMubWFyZ2luLmxlZnQgPSB0aGlzLm9wdGlvbnMubWFyZ2luLmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tYXJnaW4udG9wID0gdGhpcy5vcHRpb25zLm1hcmdpbjtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5yaWdodCA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgICAgdGhpcy5tYXJnaW4uYm90dG9tID0gdGhpcy5vcHRpb25zLm1hcmdpbjtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5sZWZ0ID0gdGhpcy5vcHRpb25zLm1hcmdpbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYWJlbE1vZHVsZS5hZGp1c3RTaXplcyh0aGlzLm1hcmdpbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5hYnModGhpcy53aWR0aCAvIDIgLyBNYXRoLmNvcyhhbmdsZSkpLCBNYXRoLmFicyh0aGlzLmhlaWdodCAvIDIgLyBNYXRoLnNpbihhbmdsZSkpKSArIGJvcmRlcldpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVTaGFkb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLnNoYWRvdykge1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB2YWx1ZXMuc2hhZG93Q29sb3I7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdmFsdWVzLnNoYWRvd1NpemU7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdmFsdWVzLnNoYWRvd1g7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdmFsdWVzLnNoYWRvd1k7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVTaGFkb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5zaGFkb3cpIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJyZ2JhKDAsMCwwLDApXCI7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZUJvcmRlckRhc2hlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVCb3JkZXJEYXNoZXMoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuYm9yZGVyRGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZGFzaGVzID0gdmFsdWVzLmJvcmRlckRhc2hlcztcblxuICAgICAgICAgIGlmIChkYXNoZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGRhc2hlcyA9IFs1LCAxNV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgYm9yZGVycyBjYW5ub3QgYmUgdXNlZC5cIik7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMgPSBmYWxzZTtcbiAgICAgICAgICB2YWx1ZXMuYm9yZGVyRGFzaGVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZUJvcmRlckRhc2hlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLmJvcmRlckRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKFswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgYm9yZGVycyBjYW5ub3QgYmUgdXNlZC5cIik7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMgPSBmYWxzZTtcbiAgICAgICAgICB2YWx1ZXMuYm9yZGVyRGFzaGVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBzaGFwZSBvZiBhIG5vZGUgbmVlZHMgdG8gYmUgcmVjYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZWVkc1JlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMucmVmcmVzaE5lZWRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IG5vdCB0aGUgYmVzdCBsb2NhdGlvbiB0byByZXNldCB0aGlzIG1lbWJlci5cbiAgICAgICAgLy8gSG93ZXZlciwgaW4gdGhlIGN1cnJlbnQgbG9naWMsIGl0IGlzIHRoZSBtb3N0IGNvbnZlbmllbnQgb25lLlxuICAgICAgICB0aGlzLnJlZnJlc2hOZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSB1bmRlZmluZWQgfHwgdGhpcy5sYWJlbE1vZHVsZS5kaWZmZXJlbnRTdGF0ZShzZWxlY3RlZCwgaG92ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0Q29udGV4dEZvckRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKSB7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSB2YWx1ZXMuYm9yZGVyV2lkdGggLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1pbih0aGlzLndpZHRoLCBib3JkZXJXaWR0aCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZXMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVzLmNvbG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwZXJmb3JtU3Ryb2tlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlcmZvcm1TdHJva2UoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHZhbHVlcy5ib3JkZXJXaWR0aCAvIHRoaXMuYm9keS52aWV3LnNjYWxlOyAvL2RyYXcgZGFzaGVkIGJvcmRlciBpZiBlbmFibGVkLCBzYXZlIGFuZCByZXN0b3JlIGlzIHJlcXVpcmVkIGZvciBmaXJlZm94IG5vdCB0byBjcmFzaCBvbiB1bml4LlxuXG4gICAgICBjdHguc2F2ZSgpOyAvLyBpZiBib3JkZXJzIGFyZSB6ZXJvIHdpZHRoLCB0aGV5IHdpbGwgYmUgZHJhd24gd2l0aCB3aWR0aCAxIGJ5IGRlZmF1bHQuIFRoaXMgcHJldmVudHMgdGhhdFxuXG4gICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKTsgLy9kcmF3IHRoZSBib3JkZXJcblxuICAgICAgICBjdHguc3Ryb2tlKCk7IC8vZGlzYWJsZSBkYXNoZWQgYm9yZGVyIGZvciBvdGhlciBlbGVtZW50c1xuXG4gICAgICAgIHRoaXMuZGlzYWJsZUJvcmRlckRhc2hlcyhjdHgsIHZhbHVlcyk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBlcmZvcm1GaWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlcy5jb2xvcjsgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuXG4gICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7IC8vIGRyYXcgdGhlIGJhY2tncm91bmRcblxuICAgICAgZmlsbChjdHgpLmNhbGwoY3R4KTsgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cblxuXG4gICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMucGVyZm9ybVN0cm9rZShjdHgsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hcmdpblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQm91bmRpbmdCb3hNYXJnaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEJvdW5kaW5nQm94TWFyZ2luKG1hcmdpbikge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0IC09IG1hcmdpbjtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wIC09IG1hcmdpbjtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICs9IG1hcmdpbjtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgKz0gbWFyZ2luO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3R1YWwgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgY2FsbC5cbiAgICAgKlxuICAgICAqIERvaW5nIGl0IGxpa2UgdGhpcyBtYWtlcyBpdCBlYXNpZXIgdG8gb3ZlcnJpZGVcbiAgICAgKiBpbiB0aGUgY2hpbGQgY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmIChjdHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHRoaXMubGVmdDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0gdGhpcy50b3A7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBjYWxsLlxuICAgICAqIFRoaXMgYWN0cyBhcyBhIHN0dWIgd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBkaW1lbnNpb25zIHRvIHVzZSBmb3Igbm9kZXMgd2l0aCBhbiBpbnRlcm5hbCBsYWJlbFxuICAgICAqXG4gICAgICogQ3VycmVudGx5LCB0aGVzZSBhcmU6IENpcmNsZSwgRWxsaXBzZSwgRGF0YWJhc2UsIEJveFxuICAgICAqIFRoZSBvdGhlciBub2RlcyBoYXZlIGV4dGVybmFsIGxhYmVscywgYW5kIHdpbGwgbm90IGNhbGwgdGhpcyBtZXRob2RcbiAgICAgKlxuICAgICAqIElmIHRoZXJlIGlzIG5vIGxhYmVsLCBkZWNlbnQgZGVmYXVsdCB2YWx1ZXMgYXJlIHN1cHBsaWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6bnVtYmVyLCBoZWlnaHQ6bnVtYmVyfX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldERpbWVuc2lvbnNGcm9tTGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGltZW5zaW9uc0Zyb21MYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgLy8gTk9URTogcHJldmlvdXNseSAndGV4dFNpemUnIHdhcyBub3QgcHV0IGluICd0aGlzJyBmb3IgRWxsaXBzZVxuICAgICAgLy8gVE9ETzogZXhhbWluZSB0aGUgY29uc2VxdWVuY2VzLlxuICAgICAgdGhpcy50ZXh0U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy50ZXh0U2l6ZS53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnRleHRTaXplLmhlaWdodDtcbiAgICAgIHZhciBERUZBVUxUX1NJWkUgPSAxNDtcblxuICAgICAgaWYgKHdpZHRoID09PSAwKSB7XG4gICAgICAgIC8vIFRoaXMgaGFwcGVucyB3aGVuIHRoZXJlIGlzIG5vIGxhYmVsIHRleHQgc2V0XG4gICAgICAgIHdpZHRoID0gREVGQVVMVF9TSVpFOyAvLyB1c2UgYSBkZWNlbnQgZGVmYXVsdFxuXG4gICAgICAgIGhlaWdodCA9IERFRkFVTFRfU0laRTsgLy8gaWYgd2lkdGggemVybywgdGhlbiBoZWlnaHQgYWxzbyBhbHdheXMgemVyb1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb2RlQmFzZTtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHMoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHMoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIEJveCBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cblxudmFyIEJveCQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgX2luaGVyaXRzKEJveCwgX05vZGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHMoQm94KTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIEJveChvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCb3gpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG5cbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhCb3gsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG5cbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zRnJvbUxhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IGRpbWVuc2lvbnMud2lkdGggKyB0aGlzLm1hcmdpbi5yaWdodCArIHRoaXMubWFyZ2luLmxlZnQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQgKyB0aGlzLm1hcmdpbi50b3AgKyB0aGlzLm1hcmdpbi5ib3R0b207XG4gICAgICAgIHRoaXMucmFkaXVzID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgdGhpcy5pbml0Q29udGV4dEZvckRyYXcoY3R4LCB2YWx1ZXMpO1xuICAgICAgZHJhd1JvdW5kUmVjdChjdHgsIHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB2YWx1ZXMuYm9yZGVyUmFkaXVzKTtcbiAgICAgIHRoaXMucGVyZm9ybUZpbGwoY3R4LCB2YWx1ZXMpO1xuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB0aGlzLmxlZnQgKyB0aGlzLnRleHRTaXplLndpZHRoIC8gMiArIHRoaXMubWFyZ2luLmxlZnQsIHRoaXMudG9wICsgdGhpcy50ZXh0U2l6ZS5oZWlnaHQgLyAyICsgdGhpcy5tYXJnaW4udG9wLCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdGhpcy5fdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuXG4gICAgICB2YXIgYm9yZGVyUmFkaXVzID0gdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJSYWRpdXM7IC8vIG9ubHkgZWZmZWN0aXZlIGZvciBib3hcblxuICAgICAgdGhpcy5fYWRkQm91bmRpbmdCb3hNYXJnaW4oYm9yZGVyUmFkaXVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLmFicyh0aGlzLndpZHRoIC8gMiAvIE1hdGguY29zKGFuZ2xlKSksIE1hdGguYWJzKHRoaXMuaGVpZ2h0IC8gMiAvIE1hdGguc2luKGFuZ2xlKSkpICsgYm9yZGVyV2lkdGg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJveDtcbn0oTm9kZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRyKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIE5PVEU6IFRoaXMgaXMgYSBiYWQgYmFzZSBjbGFzc1xuICpcbiAqIENoaWxkIGNsYXNzZXMgYXJlOlxuICpcbiAqICAgSW1hZ2UgICAgICAgLSB1c2VzICpvbmx5KiBpbWFnZSBtZXRob2RzXG4gKiAgIENpcmNsZSAgICAgIC0gdXNlcyAqb25seSogX2RyYXdSYXdDaXJjbGVcbiAqICAgQ2lyY2xlSW1hZ2UgLSB1c2VzIGFsbFxuICpcbiAqIFRPRE86IFJlZmFjdG9yLCBtb3ZlIF9kcmF3UmF3Q2lyY2xlIHRvIGRpZmZlcmVudCBtb2R1bGUsIGRlcml2ZSBDaXJjbGUgZnJvbSBOb2RlQmFzZVxuICogICAgICAgUmVuYW1lIHRoaXMgdG8gSW1hZ2VCYXNlXG4gKiAgICAgICBDb25zb2xpZGF0ZSBjb21tb24gY29kZSBpbiBJbWFnZSBhbmQgQ2lyY2xlSW1hZ2UgdG8gYmFzZSBjbGFzc1xuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG5cbnZhciBDaXJjbGVJbWFnZUJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICBfaW5oZXJpdHMoQ2lyY2xlSW1hZ2VCYXNlLCBfTm9kZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkcihDaXJjbGVJbWFnZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQ2lyY2xlSW1hZ2VCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmNsZUltYWdlQmFzZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgICBfdGhpcy5sYWJlbE9mZnNldCA9IDA7XG4gICAgX3RoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbaW1hZ2VPYmpdXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbaW1hZ2VPYmpBbHRdXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENpcmNsZUltYWdlQmFzZSwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgaWYgKCEoaW1hZ2VPYmogPT09IHVuZGVmaW5lZCAmJiBpbWFnZU9iakFsdCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aGlzLnNldEltYWdlcyhpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGltYWdlcyBmb3IgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogVGhlIGltYWdlcyBjYW4gYmUgdXBkYXRlZCBhZnRlciB0aGUgaW5pdGlhbCBzZXR0aW5nIG9mIG9wdGlvbnM7XG4gICAgICogdGhlcmVmb3JlLCB0aGlzIG1ldGhvZCBuZWVkcyB0byBiZSByZWVudHJhbnQuXG4gICAgICpcbiAgICAgKiBGb3IgY29ycmVjdCB3b3JraW5nIGluIGVycm9yIGNhc2VzLCBpdCBpcyBuZWNlc3NhcnkgdG8gcHJvcGVybHkgc2V0XG4gICAgICogZmllbGQgJ25vZGVzLmJyb2tlbkltYWdlJyBpbiB0aGUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlT2JqICByZXF1aXJlZDsgbWFpbiBpbWFnZSB0byBzaG93IGZvciB0aGlzIG5vZGVcbiAgICAgKiBAcGFyYW0ge0ltYWdlfHVuZGVmaW5lZH0gaW1hZ2VPYmpBbHQgb3B0aW9uYWw7IGltYWdlIHRvIHNob3cgd2hlbiBub2RlIGlzIHNlbGVjdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRJbWFnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW1hZ2VzKGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgICAgaWYgKGltYWdlT2JqQWx0ICYmIHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5pbWFnZU9iaiA9IGltYWdlT2JqQWx0O1xuICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gaW1hZ2VPYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmltYWdlT2JqID0gaW1hZ2VPYmo7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmpBbHQgPSBpbWFnZU9iakFsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHNlbGVjdGlvbiBhbmQgc3dpdGNoIGJldHdlZW4gdGhlIGJhc2UgYW5kIHRoZSBzZWxlY3RlZCBpbWFnZS5cbiAgICAgKlxuICAgICAqIERvIHRoZSBzd2l0Y2ggb25seSBpZiBpbWFnZU9iakFsdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkIHZhbHVlIG9mIG5ldyBzZWxlY3RlZCBzdGF0ZSBmb3IgY3VycmVudCBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzd2l0Y2hJbWFnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3dpdGNoSW1hZ2VzKHNlbGVjdGVkKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uX2NoYW5nZWQgPSBzZWxlY3RlZCAmJiAhdGhpcy5zZWxlY3RlZCB8fCAhc2VsZWN0ZWQgJiYgdGhpcy5zZWxlY3RlZDtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDsgLy8gUmVtZW1iZXIgbmV3IHNlbGVjdGlvblxuXG4gICAgICBpZiAodGhpcy5pbWFnZU9iakFsdCAhPT0gdW5kZWZpbmVkICYmIHNlbGVjdGlvbl9jaGFuZ2VkKSB7XG4gICAgICAgIHZhciBpbWFnZVRtcCA9IHRoaXMuaW1hZ2VPYmo7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSB0aGlzLmltYWdlT2JqQWx0O1xuICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gaW1hZ2VUbXA7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgSW1hZ2UgUGFkZGluZyBmcm9tIG5vZGUgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMge3t0b3A6IG51bWJlcixsZWZ0OiBudW1iZXIsYm90dG9tOiBudW1iZXIscmlnaHQ6IG51bWJlcn19IGltYWdlIHBhZGRpbmcgaW5zaWRlIHRoaXMgc2hhcGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEltYWdlUGFkZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SW1hZ2VQYWRkaW5nKCkge1xuICAgICAgdmFyIGltZ1BhZGRpbmcgPSB7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgbGVmdDogMFxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZVBhZGRpbmcpIHtcbiAgICAgICAgdmFyIG9wdEltZ1BhZGRpbmcgPSB0aGlzLm9wdGlvbnMuaW1hZ2VQYWRkaW5nO1xuXG4gICAgICAgIGlmIChfdHlwZW9mKG9wdEltZ1BhZGRpbmcpID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpbWdQYWRkaW5nLnRvcCA9IG9wdEltZ1BhZGRpbmcudG9wO1xuICAgICAgICAgIGltZ1BhZGRpbmcucmlnaHQgPSBvcHRJbWdQYWRkaW5nLnJpZ2h0O1xuICAgICAgICAgIGltZ1BhZGRpbmcuYm90dG9tID0gb3B0SW1nUGFkZGluZy5ib3R0b207XG4gICAgICAgICAgaW1nUGFkZGluZy5sZWZ0ID0gb3B0SW1nUGFkZGluZy5sZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltZ1BhZGRpbmcudG9wID0gb3B0SW1nUGFkZGluZztcbiAgICAgICAgICBpbWdQYWRkaW5nLnJpZ2h0ID0gb3B0SW1nUGFkZGluZztcbiAgICAgICAgICBpbWdQYWRkaW5nLmJvdHRvbSA9IG9wdEltZ1BhZGRpbmc7XG4gICAgICAgICAgaW1nUGFkZGluZy5sZWZ0ID0gb3B0SW1nUGFkZGluZztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW1nUGFkZGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRoZSBub2RlIGRpbWVuc2lvbnMgZm9yIGEgbG9hZGVkIGltYWdlLlxuICAgICAqXG4gICAgICogUHJlOiB0aGlzLmltYWdlT2JqIGlzIHZhbGlkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVzaXplSW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZUltYWdlKCkge1xuICAgICAgdmFyIHdpZHRoLCBoZWlnaHQ7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLnVzZUltYWdlU2l6ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBzaXplIHByb3BlcnR5XG4gICAgICAgIHZhciByYXRpb193aWR0aCA9IDE7XG4gICAgICAgIHZhciByYXRpb19oZWlnaHQgPSAxOyAvLyBPbmx5IGNhbGN1bGF0ZSB0aGUgcHJvcGVyIHJhdGlvIGlmIGJvdGggd2lkdGggYW5kIGhlaWdodCBub3QgemVyb1xuXG4gICAgICAgIGlmICh0aGlzLmltYWdlT2JqLndpZHRoICYmIHRoaXMuaW1hZ2VPYmouaGVpZ2h0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuaW1hZ2VPYmoud2lkdGggPiB0aGlzLmltYWdlT2JqLmhlaWdodCkge1xuICAgICAgICAgICAgcmF0aW9fd2lkdGggPSB0aGlzLmltYWdlT2JqLndpZHRoIC8gdGhpcy5pbWFnZU9iai5oZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhdGlvX2hlaWdodCA9IHRoaXMuaW1hZ2VPYmouaGVpZ2h0IC8gdGhpcy5pbWFnZU9iai53aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aWR0aCA9IHRoaXMub3B0aW9ucy5zaXplICogMiAqIHJhdGlvX3dpZHRoO1xuICAgICAgICBoZWlnaHQgPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDIgKiByYXRpb19oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2UgdGhlIGltYWdlIHNpemUgd2l0aCBpbWFnZSBwYWRkaW5nXG4gICAgICAgIHZhciBpbWdQYWRkaW5nID0gdGhpcy5fZ2V0SW1hZ2VQYWRkaW5nKCk7XG5cbiAgICAgICAgd2lkdGggPSB0aGlzLmltYWdlT2JqLndpZHRoICsgaW1nUGFkZGluZy5sZWZ0ICsgaW1nUGFkZGluZy5yaWdodDtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5pbWFnZU9iai5oZWlnaHQgKyBpbWdQYWRkaW5nLnRvcCArIGltZ1BhZGRpbmcuYm90dG9tO1xuICAgICAgfVxuXG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3UmF3Q2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3UmF3Q2lyY2xlKGN0eCwgeCwgeSwgdmFsdWVzKSB7XG4gICAgICB0aGlzLmluaXRDb250ZXh0Rm9yRHJhdyhjdHgsIHZhbHVlcyk7XG4gICAgICBkcmF3Q2lyY2xlKGN0eCwgeCwgeSwgdmFsdWVzLnNpemUpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdJbWFnZUF0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh0aGlzLmltYWdlT2JqLndpZHRoICE9IDApIHtcbiAgICAgICAgLy8gZHJhdyB0aGUgaW1hZ2VcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdmFsdWVzLm9wYWNpdHkgIT09IHVuZGVmaW5lZCA/IHZhbHVlcy5vcGFjaXR5IDogMTsgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgICAgdmFyIGZhY3RvciA9IDE7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuaW50ZXJwb2xhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZhY3RvciA9IHRoaXMuaW1hZ2VPYmoud2lkdGggLyB0aGlzLndpZHRoIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW1nUGFkZGluZyA9IHRoaXMuX2dldEltYWdlUGFkZGluZygpO1xuXG4gICAgICAgIHZhciBpbWdQb3NMZWZ0ID0gdGhpcy5sZWZ0ICsgaW1nUGFkZGluZy5sZWZ0O1xuICAgICAgICB2YXIgaW1nUG9zVG9wID0gdGhpcy50b3AgKyBpbWdQYWRkaW5nLnRvcDtcbiAgICAgICAgdmFyIGltZ1dpZHRoID0gdGhpcy53aWR0aCAtIGltZ1BhZGRpbmcubGVmdCAtIGltZ1BhZGRpbmcucmlnaHQ7XG4gICAgICAgIHZhciBpbWdIZWlnaHQgPSB0aGlzLmhlaWdodCAtIGltZ1BhZGRpbmcudG9wIC0gaW1nUGFkZGluZy5ib3R0b207XG4gICAgICAgIHRoaXMuaW1hZ2VPYmouZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgsIGZhY3RvciwgaW1nUG9zTGVmdCwgaW1nUG9zVG9wLCBpbWdXaWR0aCwgaW1nSGVpZ2h0KTsgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cblxuICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3SW1hZ2VMYWJlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0ltYWdlTGFiZWwoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICBpZiAodGhpcy5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICAgICAgdmFyIGxhYmVsRGltZW5zaW9ucyA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuXG4gICAgICAgIGlmIChsYWJlbERpbWVuc2lvbnMubGluZUNvdW50ID49IDEpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gbGFiZWxEaW1lbnNpb25zLmhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHlMYWJlbCA9IHkgKyBvZmZzZXQ7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwpIHtcbiAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgeCwgeUxhYmVsLCBzZWxlY3RlZCwgaG92ZXIsIFwiaGFuZ2luZ1wiKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2lyY2xlSW1hZ2VCYXNlO1xufShOb2RlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRxKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHEoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRxKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBDaXJjbGUgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBDaXJjbGVJbWFnZUJhc2VcbiAqL1xuXG52YXIgQ2lyY2xlJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DaXJjbGVJbWFnZUJhc2UpIHtcbiAgX2luaGVyaXRzKENpcmNsZSwgX0NpcmNsZUltYWdlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRxKENpcmNsZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBDaXJjbGUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY2xlKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuXG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ2lyY2xlLCBbe1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmhvdmVyO1xuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHZhciBkaWFtZXRlciA9IE1hdGgubWF4KGRpbWVuc2lvbnMud2lkdGggKyB0aGlzLm1hcmdpbi5yaWdodCArIHRoaXMubWFyZ2luLmxlZnQsIGRpbWVuc2lvbnMuaGVpZ2h0ICsgdGhpcy5tYXJnaW4udG9wICsgdGhpcy5tYXJnaW4uYm90dG9tKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNpemUgPSBkaWFtZXRlciAvIDI7IC8vIE5PVEU6IHRoaXMgc2l6ZSBmaWVsZCBvbmx5IHNldCBoZXJlLCBub3QgaW4gRWxsaXBzZSwgRGF0YWJhc2UsIEJveFxuXG4gICAgICAgIHRoaXMud2lkdGggPSBkaWFtZXRlcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBkaWFtZXRlcjtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgIHRoaXMuX2RyYXdSYXdDaXJjbGUoY3R4LCB4LCB5LCB2YWx1ZXMpO1xuXG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgdGhpcy5sZWZ0ICsgdGhpcy50ZXh0U2l6ZS53aWR0aCAvIDIgKyB0aGlzLm1hcmdpbi5sZWZ0LCB5LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHkgLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHggLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgpIHtcbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiAwLjU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENpcmNsZTtcbn0oQ2lyY2xlSW1hZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHAoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHAoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIENpcmN1bGFySW1hZ2UgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBDaXJjbGVJbWFnZUJhc2VcbiAqL1xuXG52YXIgQ2lyY3VsYXJJbWFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICBfaW5oZXJpdHMoQ2lyY3VsYXJJbWFnZSwgX0NpcmNsZUltYWdlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRwKENpcmN1bGFySW1hZ2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZU9ialxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZU9iakFsdFxuICAgKi9cbiAgZnVuY3Rpb24gQ2lyY3VsYXJJbWFnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSwgaW1hZ2VPYmosIGltYWdlT2JqQWx0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmN1bGFySW1hZ2UpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG5cbiAgICBfdGhpcy5zZXRJbWFnZXMoaW1hZ2VPYmosIGltYWdlT2JqQWx0KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENpcmN1bGFySW1hZ2UsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG4gICAgICB2YXIgaW1hZ2VBYnNlbnQgPSB0aGlzLmltYWdlT2JqLnNyYyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaW1hZ2VPYmoud2lkdGggPT09IHVuZGVmaW5lZCB8fCB0aGlzLmltYWdlT2JqLmhlaWdodCA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaW1hZ2VBYnNlbnQpIHtcbiAgICAgICAgdmFyIGRpYW1ldGVyID0gdGhpcy5vcHRpb25zLnNpemUgKiAyO1xuICAgICAgICB0aGlzLndpZHRoID0gZGlhbWV0ZXI7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZGlhbWV0ZXI7XG4gICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBBdCB0aGlzIHBvaW50LCBhbiBpbWFnZSBpcyBwcmVzZW50LCBpLmUuIHRoaXMuaW1hZ2VPYmogaXMgdmFsaWQuXG5cblxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplSW1hZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnN3aXRjaEltYWdlcyhzZWxlY3RlZCk7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgdmFyIGxhYmVsWCA9IHgsXG4gICAgICAgICAgbGFiZWxZID0geTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuY29vcmRpbmF0ZU9yaWdpbiA9PT0gXCJ0b3AtbGVmdFwiKSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHg7XG4gICAgICAgIHRoaXMudG9wID0geTtcbiAgICAgICAgbGFiZWxYICs9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICBsYWJlbFkgKz0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB9IC8vIGRyYXcgdGhlIGJhY2tncm91bmQgY2lyY2xlLiBJTVBPUlRBTlQ6IHRoZSBzdHJva2UgaW4gdGhpcyBtZXRob2QgaXMgdXNlZCBieSB0aGUgY2xpcCBtZXRob2QgYmVsb3cuXG5cblxuICAgICAgdGhpcy5fZHJhd1Jhd0NpcmNsZShjdHgsIGxhYmVsWCwgbGFiZWxZLCB2YWx1ZXMpOyAvLyBub3cgd2UgZHJhdyBpbiB0aGUgY2lyY2xlLCB3ZSBzYXZlIHNvIHdlIGNhbiByZXZlcnQgdGhlIGNsaXAgb3BlcmF0aW9uIGFmdGVyIGRyYXdpbmcuXG5cblxuICAgICAgY3R4LnNhdmUoKTsgLy8gY2xpcCBpcyB1c2VkIHRvIHVzZSB0aGUgc3Ryb2tlIGluIGRyYXdSYXdDaXJjbGUgYXMgYW4gYXJlYSB0aGF0IHdlIGNhbiBkcmF3IGluLlxuXG4gICAgICBjdHguY2xpcCgpOyAvLyBkcmF3IHRoZSBpbWFnZVxuXG4gICAgICB0aGlzLl9kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgdmFsdWVzKTsgLy8gcmVzdG9yZSBzbyB3ZSBjYW4gYWdhaW4gZHJhdyBvbiB0aGUgZnVsbCBjYW52YXNcblxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICB0aGlzLl9kcmF3SW1hZ2VMYWJlbChjdHgsIGxhYmVsWCwgbGFiZWxZLCBzZWxlY3RlZCwgaG92ZXIpO1xuXG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgIH0gLy8gVE9ETzogY29tcGFyZSB3aXRoIENpcmNsZS51cGRhdGVCb3VuZGluZ0JveCgpLCBjb25zb2xpZGF0ZT8gTW9yZSBzdHVmZiBpcyBoYXBwZW5pbmcgaGVyZVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuY29vcmRpbmF0ZU9yaWdpbiA9PT0gXCJ0b3AtbGVmdFwiKSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geDtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZSAqIDI7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplICogMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgfSAvLyBUT0RPOiBjb21wYXJlIHdpdGggSW1hZ2UudXBkYXRlQm91bmRpbmdCb3goKSwgY29uc29saWRhdGU/XG5cblxuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gTWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCk7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSwgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKyB0aGlzLmxhYmVsT2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgpIHtcbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiAwLjU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENpcmN1bGFySW1hZ2U7XG59KENpcmNsZUltYWdlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRvKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG8oKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRvKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29uc3RydWN0aW5nIE5vZGUvQ2x1c3RlciBTaGFwZXMuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cblxudmFyIFNoYXBlQmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gIF9pbmhlcml0cyhTaGFwZUJhc2UsIF9Ob2RlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRvKFNoYXBlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBTaGFwZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2hhcGVCYXNlKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlcz17c2l6ZTogdGhpcy5vcHRpb25zLnNpemV9XVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTaGFwZUJhc2UsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG4gICAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7XG4gICAgICAgIHNpemU6IHRoaXMub3B0aW9ucy5zaXplXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgX3RoaXMkY3VzdG9tU2l6ZVdpZHRoLCBfdGhpcyRjdXN0b21TaXplSGVpZ2g7XG5cbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHZhciBzaXplID0gMiAqIHZhbHVlcy5zaXplO1xuICAgICAgICB0aGlzLndpZHRoID0gKF90aGlzJGN1c3RvbVNpemVXaWR0aCA9IHRoaXMuY3VzdG9tU2l6ZVdpZHRoKSAhPT0gbnVsbCAmJiBfdGhpcyRjdXN0b21TaXplV2lkdGggIT09IHZvaWQgMCA/IF90aGlzJGN1c3RvbVNpemVXaWR0aCA6IHNpemU7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gKF90aGlzJGN1c3RvbVNpemVIZWlnaCA9IHRoaXMuY3VzdG9tU2l6ZUhlaWdodCkgIT09IG51bGwgJiYgX3RoaXMkY3VzdG9tU2l6ZUhlaWdoICE9PSB2b2lkIDAgPyBfdGhpcyRjdXN0b21TaXplSGVpZ2ggOiBzaXplO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaGFwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplTXVsdGlwbGllciAtIFVudXNlZCEgVE9ETzogUmVtb3ZlIG5leHQgbWFqb3IgcmVsZWFzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd1NoYXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3U2hhcGUoY3R4LCBzaGFwZSwgc2l6ZU11bHRpcGxpZXIsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGdldFNoYXBlKHNoYXBlKShjdHgsIHgsIHksIHZhbHVlcy5zaXplKTtcbiAgICAgIHRoaXMucGVyZm9ybUZpbGwoY3R4LCB2YWx1ZXMpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmljb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmljb24uY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LmZvbnQgPSAoc2VsZWN0ZWQgPyBcImJvbGQgXCIgOiBcIlwiKSArIHRoaXMuaGVpZ2h0IC8gMiArIFwicHggXCIgKyAodGhpcy5vcHRpb25zLmljb24uZmFjZSB8fCBcIkZvbnRBd2Vzb21lXCIpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLm9wdGlvbnMuaWNvbi5jb2xvciB8fCBcImJsYWNrXCI7XG4gICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMub3B0aW9ucy5pY29uLmNvZGUsIHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRyYXdFeHRlcm5hbExhYmVsOiBmdW5jdGlvbiBkcmF3RXh0ZXJuYWxMYWJlbCgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIGNhbGwgZm9sbG93aW5nIGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHZhbHVlIGZvclxuICAgICAgICAgICAgLy8gYHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5oZWlnaHRgLlxuICAgICAgICAgICAgX3RoaXMubGFiZWxNb2R1bGUuY2FsY3VsYXRlTGFiZWxTaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCB4LCB5LCBcImhhbmdpbmdcIik7XG5cbiAgICAgICAgICAgIHZhciB5TGFiZWwgPSB5ICsgMC41ICogX3RoaXMuaGVpZ2h0ICsgMC41ICogX3RoaXMubGFiZWxNb2R1bGUuc2l6ZS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIF90aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5TGFiZWwsIHNlbGVjdGVkLCBob3ZlciwgXCJoYW5naW5nXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoID4gMCkge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSwgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hhcGVCYXNlO1xufShOb2RlQmFzZSk7XG5cbmZ1bmN0aW9uIG93bktleXMkMyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0ga2V5cyQ0KG9iamVjdCk7IGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBmaWx0ZXIoc3ltYm9scykuY2FsbChzeW1ib2xzLCBmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyhvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQzKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgX2NvbnRleHQsIF9jb250ZXh0MjsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gZm9yRWFjaCQyKF9jb250ZXh0ID0gb3duS2V5cyQzKE9iamVjdChzb3VyY2UpLCAhMCkpLmNhbGwoX2NvbnRleHQsIGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogZm9yRWFjaCQyKF9jb250ZXh0MiA9IG93bktleXMkMyhPYmplY3Qoc291cmNlKSkpLmNhbGwoX2NvbnRleHQyLCBmdW5jdGlvbiAoa2V5KSB7IGRlZmluZVByb3BlcnR5JDYodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJG4oRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG4oKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIEN1c3RvbVNoYXBlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cblxudmFyIEN1c3RvbVNoYXBlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gIF9pbmhlcml0cyhDdXN0b21TaGFwZSwgX1NoYXBlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRuKEN1c3RvbVNoYXBlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3R4UmVuZGVyZXJcbiAgICovXG4gIGZ1bmN0aW9uIEN1c3RvbVNoYXBlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlLCBjdHhSZW5kZXJlcikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdXN0b21TaGFwZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlLCBjdHhSZW5kZXJlcik7XG4gICAgX3RoaXMuY3R4UmVuZGVyZXIgPSBjdHhSZW5kZXJlcjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGRpZmZlcmVudCBsYXllcnMuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEN1c3RvbVNoYXBlLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7IC8vIEd1YXJkIHJpZ2h0IGF3YXkgYmVjYXVzZSBzb21lb25lIG1heSBqdXN0IGRyYXcgaW4gdGhlIGZ1bmN0aW9uIGl0c2VsZi5cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBkcmF3TGF0ZXIgPSB0aGlzLmN0eFJlbmRlcmVyKHtcbiAgICAgICAgY3R4OiBjdHgsXG4gICAgICAgIGlkOiB0aGlzLm9wdGlvbnMuaWQsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgICAgIGhvdmVyOiBob3ZlclxuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogX29iamVjdFNwcmVhZCQzKHt9LCB2YWx1ZXMpLFxuICAgICAgICBsYWJlbDogdGhpcy5vcHRpb25zLmxhYmVsXG4gICAgICB9KTsgLy8gUmVuZGVyIHRoZSBub2RlIHNoYXBlIGJlbGxvdyBhcnJvd3MuXG5cbiAgICAgIGlmIChkcmF3TGF0ZXIuZHJhd05vZGUgIT0gbnVsbCkge1xuICAgICAgICBkcmF3TGF0ZXIuZHJhd05vZGUoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgaWYgKGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbCkge1xuICAgICAgICAvLyBHdWFyZCB0aGUgZXh0ZXJuYWwgbGFiZWwgKGFib3ZlIGFycm93cykgZHJhd2luZyBmdW5jdGlvbi5cbiAgICAgICAgdmFyIGRyYXdFeHRlcm5hbExhYmVsID0gZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVsO1xuXG4gICAgICAgIGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIGRyYXdFeHRlcm5hbExhYmVsKCk7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRyYXdMYXRlci5ub2RlRGltZW5zaW9ucykge1xuICAgICAgICB0aGlzLmN1c3RvbVNpemVXaWR0aCA9IGRyYXdMYXRlci5ub2RlRGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgdGhpcy5jdXN0b21TaXplSGVpZ2h0ID0gZHJhd0xhdGVyLm5vZGVEaW1lbnNpb25zLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRyYXdMYXRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3VzdG9tU2hhcGU7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRtKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG0oKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRtKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBEYXRhYmFzZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cblxudmFyIERhdGFiYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgX2luaGVyaXRzKERhdGFiYXNlLCBfTm9kZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkbShEYXRhYmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBEYXRhYmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhYmFzZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcblxuICAgIF90aGlzLl9zZXRNYXJnaW5zKGxhYmVsTW9kdWxlKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRGF0YWJhc2UsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zRnJvbUxhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgICAgdmFyIHNpemUgPSBkaW1lbnNpb25zLndpZHRoICsgdGhpcy5tYXJnaW4ucmlnaHQgKyB0aGlzLm1hcmdpbi5sZWZ0O1xuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGRyYXdEYXRhYmFzZShjdHgsIHggLSB0aGlzLndpZHRoIC8gMiwgeSAtIHRoaXMuaGVpZ2h0IC8gMiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHRoaXMubGVmdCArIHRoaXMudGV4dFNpemUud2lkdGggLyAyICsgdGhpcy5tYXJnaW4ubGVmdCwgdGhpcy50b3AgKyB0aGlzLnRleHRTaXplLmhlaWdodCAvIDIgKyB0aGlzLm1hcmdpbi50b3AsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGFiYXNlO1xufShOb2RlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRsKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGwoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRsKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBEaWFtb25kIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cblxudmFyIERpYW1vbmQkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBfaW5oZXJpdHMoRGlhbW9uZCwgX1NoYXBlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRsKERpYW1vbmQpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gRGlhbW9uZChvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaWFtb25kKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKERpYW1vbmQsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHJhd1NoYXBlKGN0eCwgXCJkaWFtb25kXCIsIDQsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGlhbW9uZDtcbn0oU2hhcGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGsoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGsoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIERvdCBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIFNoYXBlQmFzZVxuICovXG5cbnZhciBEb3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgX2luaGVyaXRzKERvdCwgX1NoYXBlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRrKERvdCk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBEb3Qob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG90KTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKERvdCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3U2hhcGUoY3R4LCBcImNpcmNsZVwiLCAyLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4KSB7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRG90O1xufShTaGFwZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkaihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRqKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEFtIEVsbGlwc2UgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG5cbnZhciBFbGxpcHNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgX2luaGVyaXRzKEVsbGlwc2UsIF9Ob2RlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRqKEVsbGlwc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gRWxsaXBzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGxpcHNlKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhFbGxpcHNlLCBbe1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmhvdmVyO1xuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQgKiAyO1xuICAgICAgICB0aGlzLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCArIGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggKiAwLjU7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGRyYXdFbGxpcHNlKGN0eCwgdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYSA9IHRoaXMud2lkdGggKiAwLjU7XG4gICAgICB2YXIgYiA9IHRoaXMuaGVpZ2h0ICogMC41O1xuICAgICAgdmFyIHcgPSBNYXRoLnNpbihhbmdsZSkgKiBhO1xuICAgICAgdmFyIGggPSBNYXRoLmNvcyhhbmdsZSkgKiBiO1xuICAgICAgcmV0dXJuIGEgKiBiIC8gTWF0aC5zcXJ0KHcgKiB3ICsgaCAqIGgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFbGxpcHNlO1xufShOb2RlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRpKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGkoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRpKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQW4gaWNvbiByZXBsYWNlbWVudCBmb3IgdGhlIGRlZmF1bHQgTm9kZSBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgTm9kZUJhc2VcbiAqL1xuXG52YXIgSWNvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gIF9pbmhlcml0cyhJY29uLCBfTm9kZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkaShJY29uKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIEljb24ob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSWNvbik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcblxuICAgIF90aGlzLl9zZXRNYXJnaW5zKGxhYmVsTW9kdWxlKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIFVudXNlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhJY29uLCBbe1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB0aGlzLmljb25TaXplID0ge1xuICAgICAgICAgIHdpZHRoOiBOdW1iZXIodGhpcy5vcHRpb25zLmljb24uc2l6ZSksXG4gICAgICAgICAgaGVpZ2h0OiBOdW1iZXIodGhpcy5vcHRpb25zLmljb24uc2l6ZSlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaWNvblNpemUud2lkdGggKyB0aGlzLm1hcmdpbi5yaWdodCArIHRoaXMubWFyZ2luLmxlZnQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5pY29uU2l6ZS5oZWlnaHQgKyB0aGlzLm1hcmdpbi50b3AgKyB0aGlzLm1hcmdpbi5ib3R0b207XG4gICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLm9wdGlvbnMuaWNvbi5zaXplID0gdGhpcy5vcHRpb25zLmljb24uc2l6ZSB8fCA1MDtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgdGhpcy5faWNvbihjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHJhd0V4dGVybmFsTGFiZWw6IGZ1bmN0aW9uIGRyYXdFeHRlcm5hbExhYmVsKCkge1xuICAgICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgaWNvblRleHRTcGFjaW5nID0gNTtcblxuICAgICAgICAgICAgX3RoaXMyLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCBfdGhpczIubGVmdCArIF90aGlzMi5pY29uU2l6ZS53aWR0aCAvIDIgKyBfdGhpczIubWFyZ2luLmxlZnQsIHkgKyBfdGhpczIuaGVpZ2h0IC8gMiArIGljb25UZXh0U3BhY2luZywgc2VsZWN0ZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzMi51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHkgLSB0aGlzLm9wdGlvbnMuaWNvbi5zaXplICogMC41O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuaWNvbi5zaXplICogMC41O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoID4gMCkge1xuICAgICAgICB2YXIgaWNvblRleHRTcGFjaW5nID0gNTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gTWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodCArIGljb25UZXh0U3BhY2luZyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXIgLSBVbnVzZWRcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaWNvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaWNvbihjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB2YXIgaWNvblNpemUgPSBOdW1iZXIodGhpcy5vcHRpb25zLmljb24uc2l6ZSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWNvbi5jb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3R4LmZvbnQgPSBbdGhpcy5vcHRpb25zLmljb24ud2VpZ2h0ICE9IG51bGwgPyB0aGlzLm9wdGlvbnMuaWNvbi53ZWlnaHQgOiBzZWxlY3RlZCA/IFwiYm9sZFwiIDogXCJcIiwgLy8gSWYgdGhlIHdlaWdodCBpcyBmb3JjZWQgKGZvciBleGFtcGxlIHRvIG1ha2UgRm9udCBBd2Vzb21lIDUgd29ya1xuICAgICAgICAvLyBwcm9wZXJseSkgc3Vic3RpdHV0ZSBzbGlnaHRseSBiaWdnZXIgc2l6ZSBmb3IgYm9sZCBmb250IGZhY2UuXG4gICAgICAgICh0aGlzLm9wdGlvbnMuaWNvbi53ZWlnaHQgIT0gbnVsbCAmJiBzZWxlY3RlZCA/IDUgOiAwKSArIGljb25TaXplICsgXCJweFwiLCB0aGlzLm9wdGlvbnMuaWNvbi5mYWNlXS5qb2luKFwiIFwiKTsgLy8gZHJhdyBpY29uXG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMub3B0aW9ucy5pY29uLmNvbG9yIHx8IFwiYmxhY2tcIjtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiOyAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG5cbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgICBjdHguZmlsbFRleHQodGhpcy5vcHRpb25zLmljb24uY29kZSwgeCwgeSk7IC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXaGVuIHVzaW5nIHRoZSBpY29uIHNoYXBlLCB5b3UgbmVlZCB0byBkZWZpbmUgdGhlIGNvZGUgaW4gdGhlIGljb24gb3B0aW9ucyBvYmplY3QuIFRoaXMgY2FuIGJlIGRvbmUgcGVyIG5vZGUgb3IgZ2xvYmFsbHkuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJY29uO1xufShOb2RlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRoKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGgoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRoKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQW4gaW1hZ2UtYmFzZWQgcmVwbGFjZW1lbnQgZm9yIHRoZSBkZWZhdWx0IE5vZGUgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIENpcmNsZUltYWdlQmFzZVxuICovXG5cbnZhciBJbWFnZSQyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2lyY2xlSW1hZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhJbWFnZSwgX0NpcmNsZUltYWdlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRoKEltYWdlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpBbHRcbiAgICovXG4gIGZ1bmN0aW9uIEltYWdlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlLCBpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2UpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG5cbiAgICBfdGhpcy5zZXRJbWFnZXMoaW1hZ2VPYmosIGltYWdlT2JqQWx0KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIFVudXNlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhJbWFnZSwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcbiAgICAgIHZhciBpbWFnZUFic2VudCA9IHRoaXMuaW1hZ2VPYmouc3JjID09PSB1bmRlZmluZWQgfHwgdGhpcy5pbWFnZU9iai53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaW1hZ2VPYmouaGVpZ2h0ID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpbWFnZUFic2VudCkge1xuICAgICAgICB2YXIgc2lkZSA9IHRoaXMub3B0aW9ucy5zaXplICogMjtcbiAgICAgICAgdGhpcy53aWR0aCA9IHNpZGU7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc2lkZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB0aGlzLl9yZXNpemVJbWFnZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLnN3aXRjaEltYWdlcyhzZWxlY3RlZCk7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgdmFyIGxhYmVsWCA9IHgsXG4gICAgICAgICAgbGFiZWxZID0geTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuY29vcmRpbmF0ZU9yaWdpbiA9PT0gXCJ0b3AtbGVmdFwiKSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHg7XG4gICAgICAgIHRoaXMudG9wID0geTtcbiAgICAgICAgbGFiZWxYICs9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICBsYWJlbFkgKz0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLnVzZUJvcmRlcldpdGhJbWFnZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbmV1dHJhbGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB2YXIgc2VsZWN0aW9uTGluZVdpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWQgfHwgMiAqIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gKHNlbGVjdGVkID8gc2VsZWN0aW9uTGluZVdpZHRoIDogbmV1dHJhbGJvcmRlcldpZHRoKSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5taW4odGhpcy53aWR0aCwgYm9yZGVyV2lkdGgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciBzdHJva2VTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXIgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXIgOiB0aGlzLm9wdGlvbnMuY29sb3IuYm9yZGVyO1xuICAgICAgICB2YXIgZmlsbFN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5iYWNrZ3JvdW5kIDogdGhpcy5vcHRpb25zLmNvbG9yLmJhY2tncm91bmQ7XG5cbiAgICAgICAgaWYgKHZhbHVlcy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdHJva2VTdHlsZSA9IG92ZXJyaWRlT3BhY2l0eShzdHJva2VTdHlsZSwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICAgIGZpbGxTdHlsZSA9IG92ZXJyaWRlT3BhY2l0eShmaWxsU3R5bGUsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgICAgfSAvLyBzZXR1cCB0aGUgbGluZSBwcm9wZXJ0aWVzLlxuXG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7IC8vIHNldCBhIGZpbGxzdHlsZVxuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7IC8vIGRyYXcgYSByZWN0YW5nbGUgdG8gZm9ybSB0aGUgYm9yZGVyIGFyb3VuZC4gVGhpcyByZWN0YW5nbGUgaXMgZmlsbGVkIHNvIHRoZSBvcGFjaXR5IG9mIGEgcGljdHVyZSAoaW4gZnV0dXJlIHZpcyByZWxlYXNlcz8pIGNhbiBiZSB1c2VkIHRvIHRpbnQgdGhlIGltYWdlXG5cbiAgICAgICAgY3R4LnJlY3QodGhpcy5sZWZ0IC0gMC41ICogY3R4LmxpbmVXaWR0aCwgdGhpcy50b3AgLSAwLjUgKiBjdHgubGluZVdpZHRoLCB0aGlzLndpZHRoICsgY3R4LmxpbmVXaWR0aCwgdGhpcy5oZWlnaHQgKyBjdHgubGluZVdpZHRoKTtcblxuICAgICAgICBmaWxsKGN0eCkuY2FsbChjdHgpO1xuXG4gICAgICAgIHRoaXMucGVyZm9ybVN0cm9rZShjdHgsIHZhbHVlcyk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgsIHZhbHVlcyk7XG5cbiAgICAgIHRoaXMuX2RyYXdJbWFnZUxhYmVsKGN0eCwgbGFiZWxYLCBsYWJlbFksIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4gPT09IFwidG9wLWxlZnRcIikge1xuICAgICAgICB0aGlzLmxlZnQgPSB4O1xuICAgICAgICB0aGlzLnRvcCA9IHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gdGhpcy5sZWZ0O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gdGhpcy50b3AgKyB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoID4gMCkge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSwgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKyB0aGlzLmxhYmVsT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW1hZ2U7XG59KENpcmNsZUltYWdlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRnKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGcoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRnKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBTcXVhcmUgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xuXG52YXIgU3F1YXJlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gIF9pbmhlcml0cyhTcXVhcmUsIF9TaGFwZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkZyhTcXVhcmUpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gU3F1YXJlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNxdWFyZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTcXVhcmUsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHJhd1NoYXBlKGN0eCwgXCJzcXVhcmVcIiwgMiwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTcXVhcmU7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRmKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGYoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRmKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBIZXhhZ29uIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cblxudmFyIEhleGFnb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgX2luaGVyaXRzKEhleGFnb24sIF9TaGFwZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkZihIZXhhZ29uKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIEhleGFnb24ob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGV4YWdvbik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhIZXhhZ29uLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwiaGV4YWdvblwiLCA0LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhleGFnb247XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRlKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGUoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRlKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBTdGFyIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cblxudmFyIFN0YXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgX2luaGVyaXRzKFN0YXIsIF9TaGFwZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkZShTdGFyKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIFN0YXIob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Rhcik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTdGFyLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwic3RhclwiLCA0LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0YXI7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRkKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGQoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRkKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSB0ZXh0LWJhc2VkIHJlcGxhY2VtZW50IGZvciB0aGUgZGVmYXVsdCBOb2RlIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG5cbnZhciBUZXh0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgX2luaGVyaXRzKFRleHQsIF9Ob2RlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRkKFRleHQpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dChvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuXG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhUZXh0LCBbe1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB0aGlzLnRleHRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnRleHRTaXplLndpZHRoICsgdGhpcy5tYXJnaW4ucmlnaHQgKyB0aGlzLm1hcmdpbi5sZWZ0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMudGV4dFNpemUuaGVpZ2h0ICsgdGhpcy5tYXJnaW4udG9wICsgdGhpcy5tYXJnaW4uYm90dG9tO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyOyAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG5cbiAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHRoaXMubGVmdCArIHRoaXMudGV4dFNpemUud2lkdGggLyAyICsgdGhpcy5tYXJnaW4ubGVmdCwgdGhpcy50b3AgKyB0aGlzLnRleHRTaXplLmhlaWdodCAvIDIgKyB0aGlzLm1hcmdpbi50b3AsIHNlbGVjdGVkLCBob3Zlcik7IC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG5cbiAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dDtcbn0oTm9kZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkYyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRjKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgVHJpYW5nbGUgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xuXG52YXIgVHJpYW5nbGUkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBfaW5oZXJpdHMoVHJpYW5nbGUsIF9TaGFwZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkYyhUcmlhbmdsZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBUcmlhbmdsZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmlhbmdsZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFRyaWFuZ2xlLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwidHJpYW5nbGVcIiwgMywgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmlhbmdsZTtcbn0oU2hhcGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGIoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIGRvd253YXJkIGZhY2luZyBUcmlhbmdsZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIFNoYXBlQmFzZVxuICovXG5cbnZhciBUcmlhbmdsZURvd24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgX2luaGVyaXRzKFRyaWFuZ2xlRG93biwgX1NoYXBlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRiKFRyaWFuZ2xlRG93bik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBUcmlhbmdsZURvd24ob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJpYW5nbGVEb3duKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVHJpYW5nbGVEb3duLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwidHJpYW5nbGVEb3duXCIsIDMsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJpYW5nbGVEb3duO1xufShTaGFwZUJhc2UpO1xuXG5mdW5jdGlvbiBvd25LZXlzJDIob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IGtleXMkNChvYmplY3QpOyBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gZmlsdGVyKHN5bWJvbHMpLmNhbGwoc3ltYm9scywgZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIF9jb250ZXh0NSwgX2NvbnRleHQ2OyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBmb3JFYWNoJDIoX2NvbnRleHQ1ID0gb3duS2V5cyQyKE9iamVjdChzb3VyY2UpLCAhMCkpLmNhbGwoX2NvbnRleHQ1LCBmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IGZvckVhY2gkMihfY29udGV4dDYgPSBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpKS5jYWxsKF9jb250ZXh0NiwgZnVuY3Rpb24gKGtleSkgeyBkZWZpbmVQcm9wZXJ0eSQ2KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyhzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcbiAqIEEgbm9kZS4gQSBub2RlIGNhbiBiZSBjb25uZWN0ZWQgdG8gb3RoZXIgbm9kZXMgdmlhIG9uZSBvciBtdWx0aXBsZSBlZGdlcy5cbiAqL1xuXG52YXIgTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciB0aGUgbm9kZS4gQWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgYXJlIG9wdGlvbmFsLCBleGNlcHQgZm9yIHRoZSBpZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSBpZCAgICAgSWQgb2YgdGhlIG5vZGUuIFJlcXVpcmVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbGFiZWwgIFRleHQgbGFiZWwgZm9yIHRoZSBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0geCAgICAgIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSB5ICAgICAgVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBzaGFwZSAgTm9kZSBzaGFwZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGltYWdlICBBbiBpbWFnZSB1cmxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSB0aXRsZSAgQSB0aXRsZSB0ZXh0LCBjYW4gYmUgSFRNTFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHthbnl0eXBlfSBncm91cCBBIGdyb3VwIG5hbWUgb3IgbnVtYmVyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5ICAgICAgICAgICAgICAgU2hhcmVkIHN0YXRlIG9mIGN1cnJlbnQgbmV0d29yayBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge05ldHdvcmsuSW1hZ2VzfSBpbWFnZWxpc3QgIEEgbGlzdCB3aXRoIGltYWdlcy4gT25seSBuZWVkZWQgd2hlbiB0aGUgbm9kZSBoYXMgYW4gaW1hZ2VcbiAgICogQHBhcmFtIHtHcm91cHN9IGdyb3VwbGlzdCAgICAgICAgICBBIGxpc3Qgd2l0aCBncm91cHMuIE5lZWRlZCBmb3IgcmV0cmlldmluZyBncm91cCBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxPcHRpb25zICAgICAgQ3VycmVudCBnbG9iYWwgbm9kZSBvcHRpb25zOyB0aGVzZSBzZXJ2ZSBhcyBkZWZhdWx0cyBmb3IgdGhlIG5vZGUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRPcHRpb25zICAgICBHbG9iYWwgZGVmYXVsdCBvcHRpb25zIGZvciBub2Rlczsgbm90ZSB0aGF0IHRoaXMgaXMgYWxzbyB0aGUgcHJvdG90eXBlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHBhcmFtZXRlciBgZ2xvYmFsT3B0aW9uc2AuXG4gICAqL1xuICBmdW5jdGlvbiBOb2RlKG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ3JvdXBsaXN0LCBnbG9iYWxPcHRpb25zLCBkZWZhdWx0T3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IGJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zKTtcbiAgICB0aGlzLmdsb2JhbE9wdGlvbnMgPSBnbG9iYWxPcHRpb25zO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuZWRnZXMgPSBbXTsgLy8gYWxsIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGlzIG5vZGVcbiAgICAvLyBzZXQgZGVmYXVsdHMgZm9yIHRoZSBvcHRpb25zXG5cbiAgICB0aGlzLmlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW1hZ2VsaXN0ID0gaW1hZ2VsaXN0O1xuICAgIHRoaXMuZ3JvdXBsaXN0ID0gZ3JvdXBsaXN0OyAvLyBzdGF0ZSBvcHRpb25zXG5cbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFzZVNpemUgPSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMub3B0aW9ucy5mb250LnNpemU7XG4gICAgdGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSBmYWxzZTsgLy8gdXNlZCB0byBjaGVjayBpZiBpbml0aWFsIGZpdCBzaG91bGQganVzdCB0YWtlIHRoZSByYW5nZSBvciBhcHByb3hpbWF0ZVxuXG4gICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuaG92ZXIgPSBmYWxzZTtcbiAgICB0aGlzLmxhYmVsTW9kdWxlID0gbmV3IExhYmVsKHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLCBmYWxzZVxuICAgIC8qIE5vdCBlZGdlIGxhYmVsICovXG4gICAgKTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaCBhIGVkZ2UgdG8gdGhlIG5vZGVcbiAgICpcbiAgICogQHBhcmFtIHtFZGdlfSBlZGdlXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE5vZGUsIFt7XG4gICAga2V5OiBcImF0dGFjaEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoRWRnZShlZGdlKSB7XG4gICAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICAgIGlmIChpbmRleE9mKF9jb250ZXh0ID0gdGhpcy5lZGdlcykuY2FsbChfY29udGV4dCwgZWRnZSkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0YWNoIGEgZWRnZSBmcm9tIHRoZSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRldGFjaEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoRWRnZShlZGdlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyO1xuXG4gICAgICB2YXIgaW5kZXggPSBpbmRleE9mKF9jb250ZXh0MiA9IHRoaXMuZWRnZXMpLmNhbGwoX2NvbnRleHQyLCBlZGdlKTtcblxuICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgIHZhciBfY29udGV4dDM7XG5cbiAgICAgICAgc3BsaWNlJDEoX2NvbnRleHQzID0gdGhpcy5lZGdlcykuY2FsbChfY29udGV4dDMsIGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IG9yIG92ZXJ3cml0ZSBvcHRpb25zIGZvciB0aGUgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgYW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtudWxsfGJvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIGN1cnJlbnRTaGFwZSA9IHRoaXMub3B0aW9ucy5zaGFwZTtcblxuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjsgLy8gTm90ZSB0aGF0IHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSAndW5kZWZpbmVkJyEgVGhpcyBpcyBPSy5cbiAgICAgIH0gLy8gU2F2ZSB0aGUgY29sb3IgZm9yIGxhdGVyLlxuICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gcHJldmVudCBsb2NhbCBjb2xvciBmcm9tIGJlaW5nIG92ZXJ3cml0dGVuIGJ5IGdyb3VwIGNvbG9yLlxuICAgICAgLy8gVE9ETzogVG8gcHJldmVudCBzdWNoIHdvcmthcm91bmRzIHRoZSB3YXkgb3B0aW9ucyBhcmUgaGFuZGxlZCBzaG91bGQgYmUgcmV3cml0dGVuIGZyb20gc2NyYXRjaC5cbiAgICAgIC8vIFRoaXMgaXMgbm90IHRoZSBvbmx5IHByb2JsZW0gd2l0aCBjdXJyZW50IG9wdGlvbnMgaGFuZGxpbmcuXG5cblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbG9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsQ29sb3IgPSBvcHRpb25zLmNvbG9yO1xuICAgICAgfSAvLyBiYXNpYyBvcHRpb25zXG5cblxuICAgICAgaWYgKG9wdGlvbnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmlkID0gb3B0aW9ucy5pZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIG11c3QgaGF2ZSBhbiBpZFwiKTtcbiAgICAgIH1cblxuICAgICAgTm9kZS5jaGVja01hc3Mob3B0aW9ucywgdGhpcy5pZCk7IC8vIHNldCB0aGVzZSBvcHRpb25zIGxvY2FsbHlcbiAgICAgIC8vIGNsZWFyIHggYW5kIHkgcG9zaXRpb25zXG5cbiAgICAgIGlmIChvcHRpb25zLnggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy54ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy54ID0gX3BhcnNlSW50KG9wdGlvbnMueCk7XG4gICAgICAgICAgdGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy55ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy55ID0gX3BhcnNlSW50KG9wdGlvbnMueSk7XG4gICAgICAgICAgdGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJhc2VTaXplID0gb3B0aW9ucy5zaXplO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMudmFsdWUgPSBfcGFyc2VGbG9hdChvcHRpb25zLnZhbHVlKTtcbiAgICAgIH0gLy8gdGhpcyB0cmFuc2Zvcm1zIGFsbCBzaG9ydGhhbmRzIGludG8gZnVsbHkgZGVmaW5lZCBvcHRpb25zXG5cblxuICAgICAgTm9kZS5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCB0cnVlLCB0aGlzLmdsb2JhbE9wdGlvbnMsIHRoaXMuZ3JvdXBsaXN0KTtcbiAgICAgIHZhciBwaWxlID0gW29wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9uc107XG4gICAgICB0aGlzLmNob29zZXIgPSBjaG9vc2lmeShcIm5vZGVcIiwgcGlsZSk7XG5cbiAgICAgIHRoaXMuX2xvYWRfaW1hZ2VzKCk7XG5cbiAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucyk7IC8vIE5lZWQgdG8gc2V0IGxvY2FsIG9wYWNpdHkgYWZ0ZXIgYHRoaXMudXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucyk7YCBiZWNhdXNlIGB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKG9wdGlvbnMpO2Agb3ZlcnJpdGVzIGxvY2FsIG9wYWNpdHkgd2l0aCBncm91cCBvcGFjaXR5XG5cbiAgICAgIGlmIChvcHRpb25zLm9wYWNpdHkgIT09IHVuZGVmaW5lZCAmJiBOb2RlLmNoZWNrT3BhY2l0eShvcHRpb25zLm9wYWNpdHkpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZVNoYXBlKGN1cnJlbnRTaGFwZSk7XG4gICAgICByZXR1cm4gb3B0aW9ucy5oaWRkZW4gIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBoeXNpY3MgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgaW1hZ2VzIGZyb20gdGhlIG9wdGlvbnMsIGZvciB0aGUgbm9kZXMgdGhhdCBuZWVkIHRoZW0uXG4gICAgICpcbiAgICAgKiBJbWFnZXMgYXJlIGFsd2F5cyBsb2FkZWQsIGV2ZW4gaWYgdGhleSBhcmUgbm90IHVzZWQgaW4gdGhlIGN1cnJlbnQgc2hhcGUuXG4gICAgICogVGhlIHVzZXIgbWF5IHN3aXRjaCB0byBhbiBpbWFnZSBzaGFwZSBsYXRlciBvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbG9hZF9pbWFnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRfaW1hZ2VzKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZSA9PT0gXCJjaXJjdWxhckltYWdlXCIgfHwgdGhpcy5vcHRpb25zLnNoYXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9uIGltYWdlIG11c3QgYmUgZGVmaW5lZCBmb3Igbm9kZSB0eXBlICdcIiArIHRoaXMub3B0aW9ucy5zaGFwZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmltYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbWFnZWxpc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBFcnJvcjogTm8gaW1hZ2VzIHByb3ZpZGVkXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pbWFnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aGlzLmltYWdlT2JqID0gdGhpcy5pbWFnZWxpc3QubG9hZCh0aGlzLm9wdGlvbnMuaW1hZ2UsIHRoaXMub3B0aW9ucy5icm9rZW5JbWFnZSwgdGhpcy5pZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmltYWdlLnVuc2VsZWN0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHVuc2VsZWN0ZWQgaW1hZ2UgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmltYWdlT2JqID0gdGhpcy5pbWFnZWxpc3QubG9hZCh0aGlzLm9wdGlvbnMuaW1hZ2UudW5zZWxlY3RlZCwgdGhpcy5vcHRpb25zLmJyb2tlbkltYWdlLCB0aGlzLmlkKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmltYWdlLnNlbGVjdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gdGhpcy5pbWFnZWxpc3QubG9hZCh0aGlzLm9wdGlvbnMuaW1hZ2Uuc2VsZWN0ZWQsIHRoaXMub3B0aW9ucy5icm9rZW5JbWFnZSwgdGhpcy5pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pbWFnZU9iakFsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IG9wYWNpdHkgaXMgb25seSBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb3JtYXR0aW5nVmFsdWVzXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e2NvbG9yOiAqLCBib3JkZXJXaWR0aDogKiwgYm9yZGVyQ29sb3I6ICosIHNpemU6ICosIGJvcmRlckRhc2hlczogKGJvb2xlYW58QXJyYXl8YWxsT3B0aW9ucy5ub2Rlcy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzfHtib29sZWFuLCBhcnJheX0pLCBib3JkZXJSYWRpdXM6IChudW1iZXJ8YWxsT3B0aW9ucy5ub2Rlcy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyUmFkaXVzfHtudW1iZXJ9fEFycmF5KSwgc2hhZG93OiAqLCBzaGFkb3dDb2xvcjogKiwgc2hhZG93U2l6ZTogKiwgc2hhZG93WDogKiwgc2hhZG93WTogKn19XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB7XG4gICAgICAgIGNvbG9yOiB0aGlzLm9wdGlvbnMuY29sb3IuYmFja2dyb3VuZCxcbiAgICAgICAgb3BhY2l0eTogdGhpcy5vcHRpb25zLm9wYWNpdHksXG4gICAgICAgIGJvcmRlcldpZHRoOiB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLm9wdGlvbnMuY29sb3IuYm9yZGVyLFxuICAgICAgICBzaXplOiB0aGlzLm9wdGlvbnMuc2l6ZSxcbiAgICAgICAgYm9yZGVyRGFzaGVzOiB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlcyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlclJhZGl1cyxcbiAgICAgICAgc2hhZG93OiB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQsXG4gICAgICAgIHNoYWRvd0NvbG9yOiB0aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yLFxuICAgICAgICBzaGFkb3dTaXplOiB0aGlzLm9wdGlvbnMuc2hhZG93LnNpemUsXG4gICAgICAgIHNoYWRvd1g6IHRoaXMub3B0aW9ucy5zaGFkb3cueCxcbiAgICAgICAgc2hhZG93WTogdGhpcy5vcHRpb25zLnNoYWRvdy55XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3RlZCB8fCB0aGlzLmhvdmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNob29zZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLmJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZXMuYm9yZGVyV2lkdGggKj0gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWVzLmNvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kO1xuICAgICAgICAgICAgdmFsdWVzLmJvcmRlckNvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXI7XG4gICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5ob3Zlcikge1xuICAgICAgICAgICAgdmFsdWVzLmNvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJhY2tncm91bmQ7XG4gICAgICAgICAgICB2YWx1ZXMuYm9yZGVyQ29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYm9yZGVyO1xuICAgICAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuY2hvb3NlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5jaG9vc2VyKHZhbHVlcywgdGhpcy5vcHRpb25zLmlkLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKTtcblxuICAgICAgICAgIGlmICh2YWx1ZXMuc2hhZG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5zaGFkb3dDb2xvciAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvciB8fCB2YWx1ZXMuc2hhZG93U2l6ZSAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy5zaXplIHx8IHZhbHVlcy5zaGFkb3dYICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnggfHwgdmFsdWVzLnNoYWRvd1kgIT09IHRoaXMub3B0aW9ucy5zaGFkb3cueSkge1xuICAgICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XG4gICAgICAgIHZhbHVlcy5ib3JkZXJDb2xvciA9IG92ZXJyaWRlT3BhY2l0eSh2YWx1ZXMuYm9yZGVyQ29sb3IsIG9wYWNpdHkpO1xuICAgICAgICB2YWx1ZXMuY29sb3IgPSBvdmVycmlkZU9wYWNpdHkodmFsdWVzLmNvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgdmFsdWVzLnNoYWRvd0NvbG9yID0gb3ZlcnJpZGVPcGFjaXR5KHZhbHVlcy5zaGFkb3dDb2xvciwgb3BhY2l0eSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUxhYmVsTW9kdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsTW9kdWxlKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMubGFiZWwgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxhYmVsID0gXCJcIjtcbiAgICAgIH1cblxuICAgICAgTm9kZS51cGRhdGVHcm91cE9wdGlvbnModGhpcy5vcHRpb25zLCBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgY29sb3I6IG9wdGlvbnMgJiYgb3B0aW9ucy5jb2xvciB8fCB0aGlzLl9sb2NhbENvbG9yIHx8IHVuZGVmaW5lZFxuICAgICAgfSksIHRoaXMuZ3JvdXBsaXN0KTsgLy9cbiAgICAgIC8vIE5vdGU6VGhlIHByb3RvdHlwZSBjaGFpbiBmb3IgdGhpcy5vcHRpb25zIGlzOlxuICAgICAgLy9cbiAgICAgIC8vIHRoaXMub3B0aW9ucyAtPiAgICBOb2Rlc0hhbmRsZXIub3B0aW9ucyAgICAtPiBOb2Rlc0hhbmRsZXIuZGVmYXVsdE9wdGlvbnNcbiAgICAgIC8vICAgICAgICAgICAgICAgICAoYWxzbzogdGhpcy5nbG9iYWxPcHRpb25zKVxuICAgICAgLy9cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGUgcHJvdG90eXBlcyBhcmUgbWVudGlvbmVkIGV4cGxpY2l0bHkgaW4gdGhlIHBpbGUgbGlzdCBiZWxvdztcbiAgICAgIC8vIFdFIERPTidUIFdBTlQgVEhFIE9SREVSIE9GIFRIRSBQUk9UT1RZUEVTISEhISBBdCBsZWFzdCwgbm90IGZvciBmb250IGhhbmRsaW5nIG9mIGxhYmVscy5cbiAgICAgIC8vIFRoaXMgaXMgYSBnb29kIGluZGljYXRpb24gdGhhdCB0aGUgcHJvdG90eXBlIHVzYWdlIG9mIG9wdGlvbnMgaXMgZGVmaWNpZW50LlxuICAgICAgLy9cblxuICAgICAgdmFyIGN1cnJlbnRHcm91cCA9IHRoaXMuZ3JvdXBsaXN0LmdldCh0aGlzLm9wdGlvbnMuZ3JvdXAsIGZhbHNlKTtcbiAgICAgIHZhciBwaWxlID0gW29wdGlvbnMsIC8vIG5ldyBvcHRpb25zXG4gICAgICB0aGlzLm9wdGlvbnMsIC8vIGN1cnJlbnQgbm9kZSBvcHRpb25zLCBzZWUgY29tbWVudCBhYm92ZSBmb3IgcHJvdG90eXBlXG4gICAgICBjdXJyZW50R3JvdXAsIC8vIGdyb3VwIG9wdGlvbnMsIGlmIGFueVxuICAgICAgdGhpcy5nbG9iYWxPcHRpb25zLCAvLyBDdXJyZW50bHkgc2V0IGdsb2JhbCBub2RlIG9wdGlvbnNcbiAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgLy8gRGVmYXVsdCBnbG9iYWwgbm9kZSBvcHRpb25zXG4gICAgICBdO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS51cGRhdGUodGhpcy5vcHRpb25zLCBwaWxlKTtcblxuICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRTaGFwZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU2hhcGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2hhcGUoY3VycmVudFNoYXBlKSB7XG4gICAgICBpZiAoY3VycmVudFNoYXBlID09PSB0aGlzLm9wdGlvbnMuc2hhcGUgJiYgdGhpcy5zaGFwZSkge1xuICAgICAgICB0aGlzLnNoYXBlLnNldE9wdGlvbnModGhpcy5vcHRpb25zLCB0aGlzLmltYWdlT2JqLCB0aGlzLmltYWdlT2JqQWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNob29zZSBkcmF3IG1ldGhvZCBkZXBlbmRpbmcgb24gdGhlIHNoYXBlXG4gICAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnNoYXBlKSB7XG4gICAgICAgICAgY2FzZSBcImJveFwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBCb3gkMSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJjaXJjbGVcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgQ2lyY2xlJDEodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiY2lyY3VsYXJJbWFnZVwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBDaXJjdWxhckltYWdlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlLCB0aGlzLmltYWdlT2JqLCB0aGlzLmltYWdlT2JqQWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImN1c3RvbVwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBDdXN0b21TaGFwZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSwgdGhpcy5vcHRpb25zLmN0eFJlbmRlcmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImRhdGFiYXNlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IERhdGFiYXNlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImRpYW1vbmRcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgRGlhbW9uZCQxKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImRvdFwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBEb3QodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiZWxsaXBzZVwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBFbGxpcHNlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImljb25cIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgSWNvbih0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBJbWFnZSQyKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlLCB0aGlzLmltYWdlT2JqLCB0aGlzLmltYWdlT2JqQWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInNxdWFyZVwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBTcXVhcmUodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiaGV4YWdvblwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBIZXhhZ29uKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInN0YXJcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgU3Rhcih0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFRleHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwidHJpYW5nbGVcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgVHJpYW5nbGUkMSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ0cmlhbmdsZURvd25cIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgVHJpYW5nbGVEb3duKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgRWxsaXBzZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZWRzUmVmcmVzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgdGhpcyBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICB0aGlzLm5lZWRzUmVmcmVzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB1bnNlbGVjdCB0aGlzIG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuc2VsZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2VsZWN0KCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5uZWVkc1JlZnJlc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGNhbGN1bGF0ZWQgc2l6ZSBvZiB0aGUgbm9kZSwgZm9yY2VzIGl0IHRvIHJlY2FsY3VsYXRlIGl0cyBzaXplXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZWVkc1JlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVlZHNSZWZyZXNoKCkge1xuICAgICAgdGhpcy5zaGFwZS5yZWZyZXNoTmVlZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB0aXRsZSBvZiB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aXRsZSAgICBUaGUgdGl0bGUgb2YgdGhlIG5vZGUsIG9yIHVuZGVmaW5lZCB3aGVuIG5vIHRpdGxlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBoYXMgYmVlbiBzZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUaXRsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaXRsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgdG8gdGhlIGJvcmRlciBvZiB0aGUgTm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlICAgICAgICBBbmdsZSBpbiByYWRpYW5zXG4gICAgICogQHJldHVybnMge251bWJlcn0gZGlzdGFuY2UgICBEaXN0YW5jZSB0byB0aGUgYm9yZGVyIGluIHBpeGVsc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYXBlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgbm9kZSBoYXMgYSBmaXhlZCB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgICB0cnVlIGlmIGZpeGVkLCBmYWxzZSBpZiBub3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzRml4ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGaXhlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZml4ZWQueCAmJiB0aGlzLm9wdGlvbnMuZml4ZWQueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2hlY2sgaWYgdGhpcyBub2RlIGlzIHNlbGVjdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBzZWxlY3RlZCAgIFRydWUgaWYgbm9kZSBpcyBzZWxlY3RlZCwgZWxzZSBmYWxzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTZWxlY3RlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NlbGVjdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZS4gQ2FuIGJlIHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn0gdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGRpbWVuc2lvbnMgb2YgdGhlIGxhYmVsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7cmVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbFNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYWJlbE1vZHVsZS5zaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgdmFsdWUgcmFuZ2Ugb2YgdGhlIG5vZGUuIFRoZSBub2RlIHdpbGwgYWRqdXN0IGl0J3Mgc2l6ZVxuICAgICAqIGJhc2VkIG9uIGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRWYWx1ZVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlUmFuZ2UobWluLCBtYXgsIHRvdGFsKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5vcHRpb25zLnNjYWxpbmcuY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKG1pbiwgbWF4LCB0b3RhbCwgdGhpcy5vcHRpb25zLnZhbHVlKTtcbiAgICAgICAgdmFyIHNpemVEaWZmID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWluO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGZvbnREaWZmID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5mb250LnNpemUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW4gKyBzY2FsZSAqIGZvbnREaWZmO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLnNpemUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW4gKyBzY2FsZSAqIHNpemVEaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNpemUgPSB0aGlzLmJhc2VTaXplO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZm9udC5zaXplID0gdGhpcy5iYXNlRm9udFNpemU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhdyB0aGlzIG5vZGUgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldEZvcm1hdHRpbmdWYWx1ZXMoKTtcbiAgICAgIHJldHVybiB0aGlzLnNoYXBlLmRyYXcoY3R4LCB0aGlzLngsIHRoaXMueSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgdmFsdWVzKSB8fCB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHNoYXBlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KGN0eCkge1xuICAgICAgdGhpcy5zaGFwZS51cGRhdGVCb3VuZGluZ0JveCh0aGlzLngsIHRoaXMueSwgY3R4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGUgdGhlIHNpemUgb2YgdGhpcyBub2RlIGluIHRoZSBnaXZlbiBjYW52YXNcbiAgICAgKiBUaGUgMmQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzIGNhbiBiZSByZXRyaWV2ZWQgYnkgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldEZvcm1hdHRpbmdWYWx1ZXMoKTtcbiAgICAgIHRoaXMuc2hhcGUucmVzaXplKGN0eCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFsbCB2aXN1YWwgZWxlbWVudHMgb2YgdGhpcyBub2RlIGluc3RhbmNlLCBpbiB3aGljaCB0aGUgZ2l2ZW5cbiAgICAgKiBwb2ludCBmYWxscyB3aXRoaW4gdGhlIGJvdW5kaW5nIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG5vZGVDbGlja0l0ZW18bm9kZUxhYmVsQ2xpY2tJdGVtPn0gbGlzdCB3aXRoIHRoZSBpdGVtcyB3aGljaCBhcmUgb24gdGhlIHBvaW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRJdGVtc09uUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SXRlbXNPblBvaW50KHBvaW50KSB7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLnZpc2libGUoKSkge1xuICAgICAgICBpZiAocG9pbnRJblJlY3QodGhpcy5sYWJlbE1vZHVsZS5nZXRTaXplKCksIHBvaW50KSkge1xuICAgICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICAgIG5vZGVJZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGxhYmVsSWQ6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9pbnRJblJlY3QodGhpcy5zaGFwZS5ib3VuZGluZ0JveCwgcG9pbnQpKSB7XG4gICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICBub2RlSWQ6IHRoaXMuaWRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IGlzIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByb3ZpZGVkIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAgIGFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICAgICBUcnVlIGlmIGxvY2F0aW9uIGlzIGxvY2F0ZWQgb24gbm9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNPdmVybGFwcGluZ1dpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNPdmVybGFwcGluZ1dpdGgob2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFwZS5sZWZ0IDwgb2JqLnJpZ2h0ICYmIHRoaXMuc2hhcGUubGVmdCArIHRoaXMuc2hhcGUud2lkdGggPiBvYmoubGVmdCAmJiB0aGlzLnNoYXBlLnRvcCA8IG9iai5ib3R0b20gJiYgdGhpcy5zaGFwZS50b3AgKyB0aGlzLnNoYXBlLmhlaWdodCA+IG9iai50b3A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IGlzIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByb3ZpZGVkIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAgIGFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICAgICBUcnVlIGlmIGxvY2F0aW9uIGlzIGxvY2F0ZWQgb24gbm9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNCb3VuZGluZ0JveE92ZXJsYXBwaW5nV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0JvdW5kaW5nQm94T3ZlcmxhcHBpbmdXaXRoKG9iaikge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhcGUuYm91bmRpbmdCb3gubGVmdCA8IG9iai5yaWdodCAmJiB0aGlzLnNoYXBlLmJvdW5kaW5nQm94LnJpZ2h0ID4gb2JqLmxlZnQgJiYgdGhpcy5zaGFwZS5ib3VuZGluZ0JveC50b3AgPCBvYmouYm90dG9tICYmIHRoaXMuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tID4gb2JqLnRvcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdmFsaWQgdmFsdWVzIGZvciBtYXNzXG4gICAgICpcbiAgICAgKiBUaGUgbWFzcyBtYXkgbm90IGJlIG5lZ2F0aXZlIG9yIHplcm8uIElmIGl0IGlzLCByZXNldCB0byAxXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gaWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfV0sIFt7XG4gICAga2V5OiBcImNoZWNrT3BhY2l0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja09wYWNpdHkob3BhY2l0eSkge1xuICAgICAgcmV0dXJuIDAgPD0gb3BhY2l0eSAmJiBvcGFjaXR5IDw9IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgb3JpZ2luIGlzICdjZW50ZXInIG9yICd0b3AtbGVmdCdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrQ29vcmRpbmF0ZU9yaWdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0Nvb3JkaW5hdGVPcmlnaW4ob3JpZ2luKSB7XG4gICAgICByZXR1cm4gb3JpZ2luID09PSB1bmRlZmluZWQgfHwgb3JpZ2luID09PSBcImNlbnRlclwiIHx8IG9yaWdpbiA9PT0gXCJ0b3AtbGVmdFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3B5IGdyb3VwIG9wdGlvbiB2YWx1ZXMgaW50byB0aGUgbm9kZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogVGhlIGdyb3VwIG9wdGlvbnMgb3ZlcnJpZGUgdGhlIGdsb2JhbCBub2RlIG9wdGlvbnMsIHNvIHRoZSBjb3B5IG9mIGdyb3VwIG9wdGlvbnNcbiAgICAgKiAgbXVzdCBoYXBwZW4gKmFmdGVyKiB0aGUgZ2xvYmFsIG5vZGUgb3B0aW9ucyBoYXZlIGJlZW4gc2V0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbXVzdCBhbHNvIGJlIGNhbGxlZCBhbHNvIGlmIHRoZSBnbG9iYWwgbm9kZSBvcHRpb25zIGhhdmUgY2hhbmdlZCBhbmQgdGhlIGdyb3VwIG9wdGlvbnMgZGlkIG5vdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRPcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld09wdGlvbnMgIG5ldyB2YWx1ZXMgZm9yIHRoZSBvcHRpb25zLCBjdXJyZW50bHkgb25seSBwYXNzZWQgaW4gZm9yIGNoZWNrXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGdyb3VwTGlzdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlR3JvdXBPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUdyb3VwT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBncm91cExpc3QpIHtcbiAgICAgIHZhciBfY29udGV4dDQ7XG5cbiAgICAgIGlmIChncm91cExpc3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBObyBncm91cHMsIG5vdGhpbmcgdG8gZG9cblxuICAgICAgdmFyIGdyb3VwID0gcGFyZW50T3B0aW9ucy5ncm91cDsgLy8gcGFyYW5vaWE6IHRoZSBzZWxlY3RlZCBncm91cCBpcyBhbHJlYWR5IG1lcmdlZCBpbnRvIG5vZGUgb3B0aW9ucywgY2hlY2suXG5cbiAgICAgIGlmIChuZXdPcHRpb25zICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5ncm91cCAhPT0gdW5kZWZpbmVkICYmIGdyb3VwICE9PSBuZXdPcHRpb25zLmdyb3VwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVwZGF0ZUdyb3VwT3B0aW9uczogZ3JvdXAgdmFsdWVzIGluIG9wdGlvbnMgZG9uJ3QgbWF0Y2guXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzR3JvdXAgPSB0eXBlb2YgZ3JvdXAgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGdyb3VwID09PSBcInN0cmluZ1wiICYmIGdyb3VwICE9IFwiXCI7XG4gICAgICBpZiAoIWhhc0dyb3VwKSByZXR1cm47IC8vIGN1cnJlbnQgbm9kZSBoYXMgbm8gZ3JvdXAsIG5vIG5lZWQgdG8gbWVyZ2VcblxuICAgICAgdmFyIGdyb3VwT2JqID0gZ3JvdXBMaXN0LmdldChncm91cCk7XG5cbiAgICAgIGlmIChncm91cE9iai5vcGFjaXR5ICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5vcGFjaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFOb2RlLmNoZWNrT3BhY2l0eShncm91cE9iai5vcGFjaXR5KSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBmb3Igbm9kZSBvcGFjaXR5LiBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZm91bmQ6IFwiICsgZ3JvdXBPYmoub3BhY2l0eSk7XG4gICAgICAgICAgZ3JvdXBPYmoub3BhY2l0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBTa2lwIGFueSBuZXcgb3B0aW9uIHRvIGF2b2lkIHRoZW0gYmVpbmcgb3ZlcnJpZGRlbiBieSB0aGUgZ3JvdXAgb3B0aW9ucy5cblxuXG4gICAgICB2YXIgc2tpcFByb3BlcnRpZXMgPSBmaWx0ZXIoX2NvbnRleHQ0ID0gZ2V0T3duUHJvcGVydHlOYW1lcyhuZXdPcHRpb25zKSkuY2FsbChfY29udGV4dDQsIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBuZXdPcHRpb25zW3BdICE9IG51bGw7XG4gICAgICB9KTsgLy8gQWx3YXlzIHNraXAgbWVyZ2luZyBncm91cCBmb250IG9wdGlvbnMgaW50byBwYXJlbnQ7IHRoZXNlIGFyZSByZXF1aXJlZCB0byBiZSBkaXN0aW5jdCBmb3IgbGFiZWxzXG5cblxuICAgICAgc2tpcFByb3BlcnRpZXMucHVzaChcImZvbnRcIik7XG4gICAgICBzZWxlY3RpdmVOb3REZWVwRXh0ZW5kKHNraXBQcm9wZXJ0aWVzLCBwYXJlbnRPcHRpb25zLCBncm91cE9iaik7IC8vIHRoZSBjb2xvciBvYmplY3QgbmVlZHMgdG8gYmUgY29tcGxldGVseSBkZWZpbmVkLlxuICAgICAgLy8gU2luY2UgZ3JvdXBzIGNhbiBwYXJ0aWFsbHkgb3ZlcndyaXRlIHRoZSBjb2xvcnMsIHdlIHBhcnNlIGl0IGFnYWluLCBqdXN0IGluIGNhc2UuXG5cbiAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IgPSBwYXJzZUNvbG9yKHBhcmVudE9wdGlvbnMuY29sb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHByb2Nlc3MgYWxsIHBvc3NpYmxlIHNob3J0aGFuZHMgaW4gdGhlIG5ldyBvcHRpb25zIGFuZCBtYWtlcyBzdXJlIHRoYXQgdGhlIHBhcmVudE9wdGlvbnMgYXJlIGZ1bGx5IGRlZmluZWQuXG4gICAgICogU3RhdGljIHNvIGl0IGNhbiBhbHNvIGJlIHVzZWQgYnkgdGhlIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdPcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWxsb3dEZWxldGlvbj1mYWxzZV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2dsb2JhbE9wdGlvbnM9e31dXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtncm91cExpc3RdXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gICAgICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgICB2YXIgZ3JvdXBMaXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgZmllbGRzID0gW1wiY29sb3JcIiwgXCJmaXhlZFwiLCBcInNoYWRvd1wiXTtcbiAgICAgIHNlbGVjdGl2ZU5vdERlZXBFeHRlbmQoZmllbGRzLCBwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgIE5vZGUuY2hlY2tNYXNzKG5ld09wdGlvbnMpO1xuXG4gICAgICBpZiAocGFyZW50T3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFOb2RlLmNoZWNrT3BhY2l0eShwYXJlbnRPcHRpb25zLm9wYWNpdHkpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIG9wYWNpdHkuIFZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBmb3VuZDogXCIgKyBwYXJlbnRPcHRpb25zLm9wYWNpdHkpO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMub3BhY2l0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV3T3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFOb2RlLmNoZWNrT3BhY2l0eShuZXdPcHRpb25zLm9wYWNpdHkpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIG9wYWNpdHkuIFZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBmb3VuZDogXCIgKyBuZXdPcHRpb25zLm9wYWNpdHkpO1xuICAgICAgICAgIG5ld09wdGlvbnMub3BhY2l0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV3T3B0aW9ucy5zaGFwZVByb3BlcnRpZXMgJiYgIU5vZGUuY2hlY2tDb29yZGluYXRlT3JpZ2luKG5ld09wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4pKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBmb3Igbm9kZSBjb29yZGluYXRlT3JpZ2luLCBmb3VuZDogXCIgKyBuZXdPcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luKTtcbiAgICAgIH0gLy8gbWVyZ2UgdGhlIHNoYWRvdyBvcHRpb25zIGludG8gdGhlIHBhcmVudC5cblxuXG4gICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgXCJzaGFkb3dcIiwgZ2xvYmFsT3B0aW9ucyk7IC8vIGluZGl2aWR1YWwgc2hhcGUgbmV3T3B0aW9uc1xuXG4gICAgICBpZiAobmV3T3B0aW9ucy5jb2xvciAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuY29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHBhcnNlZENvbG9yID0gcGFyc2VDb2xvcihuZXdPcHRpb25zLmNvbG9yKTtcbiAgICAgICAgZmlsbElmRGVmaW5lZChwYXJlbnRPcHRpb25zLmNvbG9yLCBwYXJzZWRDb2xvcik7XG4gICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5jb2xvciA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yID0gYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuY29sb3IpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgfSAvLyBoYW5kbGUgdGhlIGZpeGVkIG9wdGlvbnNcblxuXG4gICAgICBpZiAobmV3T3B0aW9ucy5maXhlZCAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZml4ZWQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdPcHRpb25zLmZpeGVkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueCA9IG5ld09wdGlvbnMuZml4ZWQ7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5maXhlZC55ID0gbmV3T3B0aW9ucy5maXhlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobmV3T3B0aW9ucy5maXhlZC54ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG5ld09wdGlvbnMuZml4ZWQueCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueCA9IG5ld09wdGlvbnMuZml4ZWQueDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV3T3B0aW9ucy5maXhlZC55ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG5ld09wdGlvbnMuZml4ZWQueSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueSA9IG5ld09wdGlvbnMuZml4ZWQueTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5mb250ID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZm9udCA9IGJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zLmZvbnQpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgfVxuXG4gICAgICBOb2RlLnVwZGF0ZUdyb3VwT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBncm91cExpc3QpOyAvLyBoYW5kbGUgdGhlIHNjYWxpbmcgb3B0aW9ucywgc3BlY2lmaWNhbGx5IHRoZSBsYWJlbCBwYXJ0XG5cbiAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5zY2FsaW5nLCBuZXdPcHRpb25zLnNjYWxpbmcsIFwibGFiZWxcIiwgZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tNYXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrTWFzcyhvcHRpb25zLCBpZCkge1xuICAgICAgaWYgKG9wdGlvbnMubWFzcyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMubWFzcyA8PSAwKSB7XG4gICAgICAgIHZhciBzdHJJZCA9IFwiXCI7XG5cbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdHJJZCA9IFwiIGluIG5vZGUgaWQ6IFwiICsgaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmVycm9yKFwiJWNOZWdhdGl2ZSBvciB6ZXJvIG1hc3MgZGlzYWxsb3dlZFwiICsgc3RySWQgKyBcIiwgc2V0dGluZyBtYXNzIHRvIDEuXCIsIFZBTElEQVRPUl9QUklOVF9TVFlMRSk7XG4gICAgICAgIG9wdGlvbnMubWFzcyA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGU7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDYobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIHN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChpc0FycmF5JDIobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDYobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNihvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0NDsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDYobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZShfY29udGV4dDQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQ0LCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tJDMobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNihvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDYoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG4vKipcbiAqIEhhbmRsZXIgZm9yIE5vZGVzXG4gKi9cblxudmFyIE5vZGVzSGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0ltYWdlc30gaW1hZ2VzXG4gICAqIEBwYXJhbSB7QXJyYXkuPEdyb3VwPn0gZ3JvdXBzXG4gICAqIEBwYXJhbSB7TGF5b3V0RW5naW5lfSBsYXlvdXRFbmdpbmVcbiAgICovXG4gIGZ1bmN0aW9uIE5vZGVzSGFuZGxlcihib2R5LCBpbWFnZXMsIGdyb3VwcywgbGF5b3V0RW5naW5lKSB7XG4gICAgdmFyIF9jb250ZXh0LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZXNIYW5kbGVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5pbWFnZXMgPSBpbWFnZXM7XG4gICAgdGhpcy5ncm91cHMgPSBncm91cHM7XG4gICAgdGhpcy5sYXlvdXRFbmdpbmUgPSBsYXlvdXRFbmdpbmU7IC8vIGNyZWF0ZSB0aGUgbm9kZSBBUEkgaW4gdGhlIGJvZHkgY29udGFpbmVyXG5cbiAgICB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUgPSBiaW5kJDYoX2NvbnRleHQgPSB0aGlzLmNyZWF0ZSkuY2FsbChfY29udGV4dCwgdGhpcyk7XG4gICAgdGhpcy5ub2Rlc0xpc3RlbmVycyA9IHtcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMuYWRkKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy51cGRhdGUocGFyYW1zLml0ZW1zLCBwYXJhbXMuZGF0YSwgcGFyYW1zLm9sZERhdGEpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMucmVtb3ZlKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICBib3JkZXJXaWR0aFNlbGVjdGVkOiB1bmRlZmluZWQsXG4gICAgICBicm9rZW5JbWFnZTogdW5kZWZpbmVkLFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgYm9yZGVyOiBcIiMyQjdDRTlcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjOTdDMkZDXCIsXG4gICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgIGJvcmRlcjogXCIjMkI3Q0U5XCIsXG4gICAgICAgICAgYmFja2dyb3VuZDogXCIjRDJFNUZGXCJcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBib3JkZXI6IFwiIzJCN0NFOVwiLFxuICAgICAgICAgIGJhY2tncm91bmQ6IFwiI0QyRTVGRlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB1bmRlZmluZWQsXG4gICAgICAvLyBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICBmaXhlZDoge1xuICAgICAgICB4OiBmYWxzZSxcbiAgICAgICAgeTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBmb250OiB7XG4gICAgICAgIGNvbG9yOiBcIiMzNDM0MzRcIixcbiAgICAgICAgc2l6ZTogMTQsXG4gICAgICAgIC8vIHB4XG4gICAgICAgIGZhY2U6IFwiYXJpYWxcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCJub25lXCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgICAvLyBweFxuICAgICAgICBzdHJva2VDb2xvcjogXCIjZmZmZmZmXCIsXG4gICAgICAgIGFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICB2YWRqdXN0OiAwLFxuICAgICAgICBtdWx0aTogZmFsc2UsXG4gICAgICAgIGJvbGQ6IHtcbiAgICAgICAgICBtb2Q6IFwiYm9sZFwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvbGRpdGFsOiB7XG4gICAgICAgICAgbW9kOiBcImJvbGQgaXRhbGljXCJcbiAgICAgICAgfSxcbiAgICAgICAgaXRhbDoge1xuICAgICAgICAgIG1vZDogXCJpdGFsaWNcIlxuICAgICAgICB9LFxuICAgICAgICBtb25vOiB7XG4gICAgICAgICAgbW9kOiBcIlwiLFxuICAgICAgICAgIHNpemU6IDE1LFxuICAgICAgICAgIC8vIHB4XG4gICAgICAgICAgZmFjZTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgICB2YWRqdXN0OiAyXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBncm91cDogdW5kZWZpbmVkLFxuICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgIGljb246IHtcbiAgICAgICAgZmFjZTogXCJGb250QXdlc29tZVwiLFxuICAgICAgICAvLydGb250QXdlc29tZScsXG4gICAgICAgIGNvZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8nXFx1ZjAwNycsXG4gICAgICAgIHNpemU6IDUwLFxuICAgICAgICAvLzUwLFxuICAgICAgICBjb2xvcjogXCIjMkI3Q0U5XCIgLy8nI2FhMDBmZidcblxuICAgICAgfSxcbiAgICAgIGltYWdlOiB1bmRlZmluZWQsXG4gICAgICAvLyAtLT4gVVJMXG4gICAgICBpbWFnZVBhZGRpbmc6IHtcbiAgICAgICAgLy8gb25seSBmb3IgaW1hZ2Ugc2hhcGVcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBsZWZ0OiAwXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHVuZGVmaW5lZCxcbiAgICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogdHJ1ZSxcbiAgICAgIGxldmVsOiB1bmRlZmluZWQsXG4gICAgICBtYXJnaW46IHtcbiAgICAgICAgdG9wOiA1LFxuICAgICAgICByaWdodDogNSxcbiAgICAgICAgYm90dG9tOiA1LFxuICAgICAgICBsZWZ0OiA1XG4gICAgICB9LFxuICAgICAgbWFzczogMSxcbiAgICAgIHBoeXNpY3M6IHRydWUsXG4gICAgICBzY2FsaW5nOiB7XG4gICAgICAgIG1pbjogMTAsXG4gICAgICAgIG1heDogMzAsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgbWluOiAxNCxcbiAgICAgICAgICBtYXg6IDMwLFxuICAgICAgICAgIG1heFZpc2libGU6IDMwLFxuICAgICAgICAgIGRyYXdUaHJlc2hvbGQ6IDVcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOiBmdW5jdGlvbiBjdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gMSAvIChtYXggLSBtaW4pO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsICh2YWx1ZSAtIG1pbikgKiBzY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogXCJyZ2JhKDAsMCwwLDAuNSlcIixcbiAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgIHg6IDUsXG4gICAgICAgIHk6IDVcbiAgICAgIH0sXG4gICAgICBzaGFwZTogXCJlbGxpcHNlXCIsXG4gICAgICBzaGFwZVByb3BlcnRpZXM6IHtcbiAgICAgICAgYm9yZGVyRGFzaGVzOiBmYWxzZSxcbiAgICAgICAgLy8gb25seSBmb3IgYm9yZGVyc1xuICAgICAgICBib3JkZXJSYWRpdXM6IDYsXG4gICAgICAgIC8vIG9ubHkgZm9yIGJveCBzaGFwZVxuICAgICAgICBpbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAvLyBvbmx5IGZvciBpbWFnZSBhbmQgY2lyY3VsYXJJbWFnZSBzaGFwZXNcbiAgICAgICAgdXNlSW1hZ2VTaXplOiBmYWxzZSxcbiAgICAgICAgLy8gb25seSBmb3IgaW1hZ2UgYW5kIGNpcmN1bGFySW1hZ2Ugc2hhcGVzXG4gICAgICAgIHVzZUJvcmRlcldpdGhJbWFnZTogZmFsc2UsXG4gICAgICAgIC8vIG9ubHkgZm9yIGltYWdlIHNoYXBlXG4gICAgICAgIGNvb3JkaW5hdGVPcmlnaW46IFwiY2VudGVyXCIgLy8gb25seSBmb3IgaW1hZ2UgYW5kIGNpcmN1bGFySW1hZ2Ugc2hhcGVzXG5cbiAgICAgIH0sXG4gICAgICBzaXplOiAyNSxcbiAgICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgeDogdW5kZWZpbmVkLFxuICAgICAgeTogdW5kZWZpbmVkXG4gICAgfTsgLy8gUHJvdGVjdCBmcm9tIGlkaW9jeVxuXG4gICAgaWYgKHRoaXMuZGVmYXVsdE9wdGlvbnMubWFzcyA8PSAwKSB7XG4gICAgICB0aHJvdyBcIkludGVybmFsIGVycm9yOiBtYXNzIGluIGRlZmF1bHRPcHRpb25zIG9mIE5vZGVzSGFuZGxlciBtYXkgbm90IGJlIHplcm8gb3IgbmVnYXRpdmVcIjtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBicmlkZ2VPYmplY3QodGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE5vZGVzSGFuZGxlciwgW3tcbiAgICBrZXk6IFwiYmluZEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfY29udGV4dDIsXG4gICAgICAgICAgX2NvbnRleHQzLFxuICAgICAgICAgIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIHJlZnJlc2ggdGhlIG5vZGVzLiBVc2VkIHdoZW4gcmV2ZXJ0aW5nIGZyb20gaGllcmFyY2hpY2FsIGxheW91dFxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZWZyZXNoTm9kZXNcIiwgYmluZCQ2KF9jb250ZXh0MiA9IHRoaXMucmVmcmVzaCkuY2FsbChfY29udGV4dDIsIHRoaXMpKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVmcmVzaFwiLCBiaW5kJDYoX2NvbnRleHQzID0gdGhpcy5yZWZyZXNoKS5jYWxsKF9jb250ZXh0MywgdGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yRWFjaCQxKF90aGlzMi5ub2Rlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgIGlmIChfdGhpczIuYm9keS5kYXRhLm5vZGVzKSBfdGhpczIuYm9keS5kYXRhLm5vZGVzLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLm5vZGVzTGlzdGVuZXJzLmFkZDtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycy51cGRhdGU7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnMucmVtb3ZlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLm5vZGVzTGlzdGVuZXJzO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIE5vZGUucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7IC8vIE5lZWQgdG8gc2V0IG9wYWNpdHkgaGVyZSBiZWNhdXNlIE5vZGUucGFyc2VPcHRpb25zIGlzIGFsc28gdXNlZCBmb3IgZ3JvdXBzLFxuICAgICAgICAvLyBpZiB5b3Ugc2V0IG9wYWNpdHkgaW4gTm9kZS5wYXJzZU9wdGlvbnMgaXQgb3ZlcndyaXRlcyBncm91cCBvcGFjaXR5LlxuXG4gICAgICAgIGlmIChvcHRpb25zLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChpc05hbihvcHRpb25zLm9wYWNpdHkpIHx8ICFfaXNGaW5pdGUob3B0aW9ucy5vcGFjaXR5KSB8fCBvcHRpb25zLm9wYWNpdHkgPCAwIHx8IG9wdGlvbnMub3BhY2l0eSA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBmb3Igbm9kZSBvcGFjaXR5LiBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZm91bmQ6IFwiICsgb3B0aW9ucy5vcGFjaXR5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHVwZGF0ZSB0aGUgc2hhcGUgaW4gYWxsIG5vZGVzXG5cblxuICAgICAgICBpZiAob3B0aW9ucy5zaGFwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0udXBkYXRlU2hhcGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVXBkYXRlIHRoZSBsYWJlbHMgb2Ygbm9kZXMgaWYgYW55IHJlbGV2YW50IG9wdGlvbnMgY2hhbmdlZC5cblxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mb250ICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBvcHRpb25zLndpZHRoQ29uc3RyYWludCAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygb3B0aW9ucy5oZWlnaHRDb25zdHJhaW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGtleXMgPSBrZXlzJDQodGhpcy5ib2R5Lm5vZGVzKTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX25vZGVJZCA9IF9PYmplY3Qka2V5c1tfaV07XG5cbiAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkXS51cGRhdGVMYWJlbE1vZHVsZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbX25vZGVJZF0ubmVlZHNSZWZyZXNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHVwZGF0ZSB0aGUgc2hhcGUgc2l6ZSBpbiBhbGwgbm9kZXNcblxuXG4gICAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIF9ub2RlSWQyKSkge1xuICAgICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbX25vZGVJZDJdLm5lZWRzUmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSB2YXJpYWJsZXMgaWYgbmVlZGVkXG5cblxuICAgICAgICBpZiAob3B0aW9ucy5oaWRkZW4gIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBoeXNpY3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgZGF0YSBzZXQgd2l0aCBub2RlcyBmb3IgdGhlIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IG5vZGVzICAgICAgICAgVGhlIGRhdGEgY29udGFpbmluZyB0aGUgbm9kZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RFbWl0PWZhbHNlXSAtIFN1cHByZXNzIGRhdGEgY2hhbmdlZCBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRhKG5vZGVzKSB7XG4gICAgICB2YXIgZG9Ob3RFbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBvbGROb2Rlc0RhdGEgPSB0aGlzLmJvZHkuZGF0YS5ub2RlcztcblxuICAgICAgaWYgKGlzRGF0YVZpZXdMaWtlKFwiaWRcIiwgbm9kZXMpKSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzID0gbm9kZXM7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkkMihub2RlcykpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5hZGQobm9kZXMpO1xuICAgICAgfSBlbHNlIGlmICghbm9kZXMpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5IG9yIERhdGFTZXQgZXhwZWN0ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvbGROb2Rlc0RhdGEpIHtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBvbGQgZGF0YXNldFxuICAgICAgICBmb3JFYWNoJDEodGhpcy5ub2Rlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgIG9sZE5vZGVzRGF0YS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIHJlbW92ZSBkcmF3biBub2Rlc1xuXG5cbiAgICAgIHRoaXMuYm9keS5ub2RlcyA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5ib2R5LmRhdGEubm9kZXMpIHtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGZvckVhY2gkMSh0aGlzLm5vZGVzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgbWUuYm9keS5kYXRhLm5vZGVzLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pOyAvLyBkcmF3IGFsbCBuZXcgbm9kZXNcblxuICAgICAgICB2YXIgaWRzID0gdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0SWRzKCk7XG4gICAgICAgIHRoaXMuYWRkKGlkcywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb05vdEVtaXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb05vdEVtaXQ9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoaWRzKSB7XG4gICAgICB2YXIgZG9Ob3RFbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBpZDtcbiAgICAgIHZhciBuZXdOb2RlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZCA9IGlkc1tpXTtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXQoaWQpO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlKHByb3BlcnRpZXMpO1xuICAgICAgICBuZXdOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLmJvZHkubm9kZXNbaWRdID0gbm9kZTsgLy8gbm90ZTogdGhpcyBtYXkgcmVwbGFjZSBhbiBleGlzdGluZyBub2RlXG4gICAgICB9XG5cbiAgICAgIHRoaXMubGF5b3V0RW5naW5lLnBvc2l0aW9uSW5pdGlhbGx5KG5ld05vZGVzKTtcblxuICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGV4aXN0aW5nIG5vZGVzLCBvciBjcmVhdGUgdGhlbSB3aGVuIG5vdCB5ZXQgZXhpc3RpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzIGlkJ3Mgb2YgY2hhbmdlZCBub2Rlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNoYW5nZWREYXRhIGFycmF5IHdpdGggY2hhbmdlZCBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheXx1bmRlZmluZWR9IG9sZERhdGEgb3B0aW9uYWw7IGFycmF5IHdpdGggcHJldmlvdXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGlkcywgY2hhbmdlZERhdGEsIG9sZERhdGEpIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaWRdO1xuICAgICAgICB2YXIgZGF0YSA9IGNoYW5nZWREYXRhW2ldO1xuXG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB1cGRhdGUgbm9kZVxuICAgICAgICAgIGlmIChub2RlLnNldE9wdGlvbnMoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlOyAvLyBjcmVhdGUgbm9kZVxuXG4gICAgICAgICAgbm9kZSA9IHRoaXMuY3JlYXRlKGRhdGEpO1xuICAgICAgICAgIG5vZGVzW2lkXSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhQ2hhbmdlZCAmJiBvbGREYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGFueSBjaGFuZ2VzIHdoaWNoIHNob3VsZCB0cmlnZ2VyIGEgbGF5b3V0IHJlY2FsY3VsYXRpb25cbiAgICAgICAgLy8gRm9yIG5vdywgdGhpcyBpcyBqdXN0ICdsZXZlbCcgZm9yIGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgICAgICAgLy8gQXNzdW1wdGlvbjogb2xkIGFuZCBuZXcgZGF0YSBhcnJhbmdlZCBpbiBzYW1lIG9yZGVyOyBhdCB0aW1lIG9mIHdyaXRpbmcsIHRoaXMgaG9sZHMuXG4gICAgICAgIGRhdGFDaGFuZ2VkID0gc29tZShjaGFuZ2VkRGF0YSkuY2FsbChjaGFuZ2VkRGF0YSwgZnVuY3Rpb24gKG5ld1ZhbHVlLCBpbmRleCkge1xuICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IG9sZERhdGFbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiBvbGRWYWx1ZSAmJiBvbGRWYWx1ZS5sZXZlbCAhPT0gbmV3VmFsdWUubGV2ZWw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YUNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YVVwZGF0ZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBleGlzdGluZyBub2Rlcy4gSWYgbm9kZXMgZG8gbm90IGV4aXN0LCB0aGUgbWV0aG9kIHdpbGwganVzdCBpZ25vcmUgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IGlkc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGlkcykge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIGRlbGV0ZSBub2Rlc1tpZF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtjbGFzc30gW2NvbnN0cnVjdG9yQ2xhc3M9Tm9kZS5kZWZhdWx0XVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgY29uc3RydWN0b3JDbGFzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogTm9kZTtcbiAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3JDbGFzcyhwcm9wZXJ0aWVzLCB0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3VwcywgdGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGVhclBvc2l0aW9ucz1mYWxzZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgY2xlYXJQb3NpdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICAgZm9yRWFjaCQxKHRoaXMuYm9keS5ub2RlcywgZnVuY3Rpb24gKG5vZGUsIG5vZGVJZCkge1xuICAgICAgICB2YXIgZGF0YSA9IF90aGlzMy5ib2R5LmRhdGEubm9kZXMuZ2V0KG5vZGVJZCk7XG5cbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjbGVhclBvc2l0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm9kZS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgeDogbnVsbCxcbiAgICAgICAgICAgICAgeTogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIGZpeGVkOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG5vZGUuc2V0T3B0aW9ucyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlLmlkPiB8IHN0cmluZ30gW2lkc10gIC0tPiBvcHRpb25hbCwgY2FuIGJlIGFycmF5IG9mIG5vZGVJZHMsIGNhbiBiZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb3NpdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb25zKGlkcykge1xuICAgICAgdmFyIGRhdGFBcnJheSA9IHt9O1xuXG4gICAgICBpZiAoaWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkkMihpZHMpID09PSB0cnVlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbaWRzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW2lkc1tpXV07XG4gICAgICAgICAgICAgIGRhdGFBcnJheVtpZHNbaV1dID0ge1xuICAgICAgICAgICAgICAgIHg6IE1hdGgucm91bmQobm9kZS54KSxcbiAgICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKG5vZGUueSlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tpZHNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBfbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZHNdO1xuICAgICAgICAgICAgZGF0YUFycmF5W2lkc10gPSB7XG4gICAgICAgICAgICAgIHg6IE1hdGgucm91bmQoX25vZGUueCksXG4gICAgICAgICAgICAgIHk6IE1hdGgucm91bmQoX25vZGUueSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBfbm9kZTIgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW19pMl1dO1xuICAgICAgICAgIGRhdGFBcnJheVt0aGlzLmJvZHkubm9kZUluZGljZXNbX2kyXV0gPSB7XG4gICAgICAgICAgICB4OiBNYXRoLnJvdW5kKF9ub2RlMi54KSxcbiAgICAgICAgICAgIHk6IE1hdGgucm91bmQoX25vZGUyLnkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YUFycmF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHggeSBwb3NpdGlvbiBvZiBhIHNwZWNpZmljIGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCB0byByZXRyaWV2ZS5cbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIG5vIGlkIGlzIGluY2x1ZGVkLlxuICAgICAqIEB0aHJvd3Mge1JlZmVyZW5jZUVycm9yfSBJZiBhbiBpbnZhbGlkIGlkIGlzIHByb3ZpZGVkLlxuICAgICAqIEByZXR1cm5zIHt7IHg6IG51bWJlciwgeTogbnVtYmVyIH19IFJldHVybnMgWCwgWSBjYW52YXMgcG9zaXRpb24gb2YgdGhlIG5vZGUgd2l0aCBnaXZlbiBpZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKGlkKSB7XG4gICAgICBpZiAoaWQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBpZCB3YXMgc3BlY2lmaWVkIGZvciBnZXRQb3NpdGlvbiBtZXRob2QuXCIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmJvZHkubm9kZXNbaWRdID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJOb2RlSWQgcHJvdmlkZWQgZm9yIGdldFBvc2l0aW9uIGRvZXMgbm90IGV4aXN0LiBQcm92aWRlZDogXCIuY29uY2F0KGlkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IE1hdGgucm91bmQodGhpcy5ib2R5Lm5vZGVzW2lkXS54KSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKHRoaXMuYm9keS5ub2Rlc1tpZF0ueSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgWFkgcG9zaXRpb25zIG9mIHRoZSBub2RlcyBpbnRvIHRoZSBkYXRhc2V0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcmVQb3NpdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcmVQb3NpdGlvbnMoKSB7XG4gICAgICAvLyB0b2RvOiBhZGQgc3VwcG9ydCBmb3IgY2x1c3RlcnMgYW5kIGhpZXJhcmNoaWNhbC5cbiAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgIHZhciBkYXRhc2V0ID0gdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNihkYXRhc2V0LmdldCgpKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgZHNOb2RlID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIGlkID0gZHNOb2RlLmlkO1xuICAgICAgICAgIHZhciBib2R5Tm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZF07XG4gICAgICAgICAgdmFyIHggPSBNYXRoLnJvdW5kKGJvZHlOb2RlLngpO1xuICAgICAgICAgIHZhciB5ID0gTWF0aC5yb3VuZChib2R5Tm9kZS55KTtcblxuICAgICAgICAgIGlmIChkc05vZGUueCAhPT0geCB8fCBkc05vZGUueSAhPT0geSkge1xuICAgICAgICAgICAgZGF0YUFycmF5LnB1c2goe1xuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICBkYXRhc2V0LnVwZGF0ZShkYXRhQXJyYXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGJvdW5kaW5nIGJveCBvZiBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtqfCp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveChub2RlSWQpIHtcbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS5zaGFwZS5ib3VuZGluZ0JveDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBJZHMgb2Ygbm9kZXMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHBhcmFtIHsndG8nfCdmcm9tJ3x1bmRlZmluZWR9IGRpcmVjdGlvbiB2YWx1ZXMgJ2Zyb20nIGFuZCAndG8nIHNlbGVjdCByZXNwZWN0aXZlbHkgcGFyZW50IGFuZCBjaGlsZCBub2RlcyBvbmx5LlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW55IG90aGVyIHZhbHVlIHJldHVybnMgYm90aCBwYXJlbnQgYW5kIGNoaWxkIG5vZGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldENvbm5lY3RlZE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbm5lY3RlZE5vZGVzKG5vZGVJZCwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgbm9kZUxpc3QgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgdmFyIG5vZGVPYmogPSB7fTsgLy8gdXNlZCB0byBxdWlja2x5IGNoZWNrIGlmIG5vZGUgYWxyZWFkeSBleGlzdHNcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IG5vZGUuZWRnZXNbaV07XG5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSBcInRvXCIgJiYgZWRnZS50b0lkID09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBkb3VibGUgZXF1YWxzIHNpbmNlIGlkcyBjYW4gYmUgbnVtZXJpYyBvciBzdHJpbmdcbiAgICAgICAgICAgIGlmIChub2RlT2JqW2VkZ2UuZnJvbUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS5mcm9tSWQpO1xuICAgICAgICAgICAgICBub2RlT2JqW2VkZ2UuZnJvbUlkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gIT09IFwiZnJvbVwiICYmIGVkZ2UuZnJvbUlkID09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBkb3VibGUgZXF1YWxzIHNpbmNlIGlkcyBjYW4gYmUgbnVtZXJpYyBvciBzdHJpbmdcbiAgICAgICAgICAgIGlmIChub2RlT2JqW2VkZ2UudG9JZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UudG9JZCk7XG4gICAgICAgICAgICAgIG5vZGVPYmpbZWRnZS50b0lkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlTGlzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpZHMgb2YgdGhlIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29ubmVjdGVkRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29ubmVjdGVkRWRnZXMobm9kZUlkKSB7XG4gICAgICB2YXIgZWRnZUxpc3QgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlZGdlTGlzdC5wdXNoKG5vZGUuZWRnZXNbaV0uaWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTm9kZUlkIHByb3ZpZGVkIGZvciBnZXRDb25uZWN0ZWRFZGdlcyBkb2VzIG5vdCBleGlzdC4gUHJvdmlkZWQ6IFwiLCBub2RlSWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWRnZUxpc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmUgYSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlTm9kZShub2RlSWQsIHgsIHkpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS54ID0gTnVtYmVyKHgpO1xuICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS55ID0gTnVtYmVyKHkpO1xuXG4gICAgICAgIHNldFRpbWVvdXQkMShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM0LmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOb2RlIGlkIHN1cHBsaWVkIHRvIG1vdmVOb2RlIGRvZXMgbm90IGV4aXN0LiBQcm92aWRlZDogXCIsIG5vZGVJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGVzSGFuZGxlcjtcbn0oKTtcblxudmFyIGhhc093biQxID0gaGFzT3duUHJvcGVydHlfMTtcblxudmFyIGlzRGF0YURlc2NyaXB0b3IkMSA9IGZ1bmN0aW9uIChkZXNjcmlwdG9yKSB7XG4gIHJldHVybiBkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQgJiYgKGhhc093biQxKGRlc2NyaXB0b3IsICd2YWx1ZScpIHx8IGhhc093biQxKGRlc2NyaXB0b3IsICd3cml0YWJsZScpKTtcbn07XG5cbnZhciAkJDIgPSBfZXhwb3J0O1xudmFyIGNhbGwgPSBmdW5jdGlvbkNhbGw7XG52YXIgaXNPYmplY3QkMiA9IGlzT2JqZWN0JGo7XG52YXIgYW5PYmplY3QkMSA9IGFuT2JqZWN0JGQ7XG52YXIgaXNEYXRhRGVzY3JpcHRvciA9IGlzRGF0YURlc2NyaXB0b3IkMTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBvYmplY3RHZXRQcm90b3R5cGVPZjsgLy8gYFJlZmxlY3QuZ2V0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVmbGVjdC5nZXRcblxuZnVuY3Rpb24gZ2V0JDUodGFyZ2V0LCBwcm9wZXJ0eUtleVxuLyogLCByZWNlaXZlciAqL1xuKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdO1xuICB2YXIgZGVzY3JpcHRvciwgcHJvdG90eXBlO1xuICBpZiAoYW5PYmplY3QkMSh0YXJnZXQpID09PSByZWNlaXZlcikgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZih0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgaWYgKGRlc2NyaXB0b3IpIHJldHVybiBpc0RhdGFEZXNjcmlwdG9yKGRlc2NyaXB0b3IpID8gZGVzY3JpcHRvci52YWx1ZSA6IGRlc2NyaXB0b3IuZ2V0ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjYWxsKGRlc2NyaXB0b3IuZ2V0LCByZWNlaXZlcik7XG4gIGlmIChpc09iamVjdCQyKHByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSByZXR1cm4gZ2V0JDUocHJvdG90eXBlLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpO1xufVxuXG4kJDIoe1xuICB0YXJnZXQ6ICdSZWZsZWN0JyxcbiAgc3RhdDogdHJ1ZVxufSwge1xuICBnZXQ6IGdldCQ1XG59KTtcblxudmFyIHBhdGgkMyA9IHBhdGgkeTtcbnZhciBnZXQkNCA9IHBhdGgkMy5SZWZsZWN0LmdldDtcblxudmFyIHBhcmVudCQ3ID0gZ2V0JDQ7XG52YXIgZ2V0JDMgPSBwYXJlbnQkNztcblxudmFyIHBhcmVudCQ2ID0gZ2V0JDM7XG52YXIgZ2V0JDIgPSBwYXJlbnQkNjtcblxudmFyIHBhcmVudCQ1ID0gZ2V0JDI7XG52YXIgZ2V0JDEgPSBwYXJlbnQkNTtcblxudmFyIGdldCA9IGdldCQxO1xuXG52YXIgcGFyZW50JDQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNDtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiA9IHBhcmVudCQ0O1xuXG52YXIgcGFyZW50JDMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMjtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IHBhcmVudCQzO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDE7XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIF9nZXQoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXQpIHtcbiAgICBfZ2V0ID0gZ2V0O1xuICB9IGVsc2Uge1xuICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG5cbiAgICAgIHZhciBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyICQkMSA9IF9leHBvcnQ7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1tYXRoLWh5cG90IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cbnZhciAkaHlwb3QgPSBNYXRoLmh5cG90O1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7IC8vIENocm9tZSA3NyBidWdcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTk1NDZcblxudmFyIEJVR0dZID0gISEkaHlwb3QgJiYgJGh5cG90KEluZmluaXR5LCBOYU4pICE9PSBJbmZpbml0eTsgLy8gYE1hdGguaHlwb3RgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLmh5cG90XG5cbiQkMSh7XG4gIHRhcmdldDogJ01hdGgnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IEJVR0dZXG59LCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMikge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGxhcmcgPSAwO1xuICAgIHZhciBhcmcsIGRpdjtcblxuICAgIHdoaWxlIChpIDwgYUxlbikge1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcblxuICAgICAgaWYgKGxhcmcgPCBhcmcpIHtcbiAgICAgICAgZGl2ID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnID4gMCkge1xuICAgICAgICBkaXYgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogc3FydChzdW0pO1xuICB9XG59KTtcblxudmFyIHBhdGgkMiA9IHBhdGgkeTtcbnZhciBoeXBvdCQyID0gcGF0aCQyLk1hdGguaHlwb3Q7XG5cbnZhciBwYXJlbnQkMiA9IGh5cG90JDI7XG52YXIgaHlwb3QkMSA9IHBhcmVudCQyO1xuXG52YXIgaHlwb3QgPSBoeXBvdCQxO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkYShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRhKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcclxuICogQ29tbW9uIG1ldGhvZHMgZm9yIGVuZHBvaW50c1xyXG4gKlxyXG4gKiBAY2xhc3NcclxuICovXG5cbnZhciBFbmRQb2ludCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVuZFBvaW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbmRQb2ludCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRW5kUG9pbnQsIG51bGwsIFt7XG4gICAga2V5OiBcInRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgdHJhbnNmb3JtYXRpb24gb24gcG9pbnRzIGZvciBkaXNwbGF5LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBmb2xsb3dpbmcgaXMgZG9uZTpcclxuICAgICAqIC0gcm90YXRlIGJ5IHRoZSBzcGVjaWZpZWQgYW5nbGVcclxuICAgICAqIC0gbXVsdGlwbHkgdGhlIChub3JtYWxpemVkKSBjb29yZGluYXRlcyBieSB0aGUgcGFzc2VkIGxlbmd0aFxyXG4gICAgICogLSBvZmZzZXQgYnkgdGhlIHRhcmdldCBjb29yZGluYXRlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2ludHMgLSBUaGUgcG9pbnQocykgdG8gYmUgdHJhbnNmb3JtZWQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgdHJhbnNmb3JtYXRpb24uXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpIHtcbiAgICAgIGlmICghaXNBcnJheSQyKHBvaW50cykpIHtcbiAgICAgICAgcG9pbnRzID0gW3BvaW50c107XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gYXJyb3dEYXRhLnBvaW50Lng7XG4gICAgICB2YXIgeSA9IGFycm93RGF0YS5wb2ludC55O1xuICAgICAgdmFyIGFuZ2xlID0gYXJyb3dEYXRhLmFuZ2xlO1xuICAgICAgdmFyIGxlbmd0aCA9IGFycm93RGF0YS5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgICAgICB2YXIgeHQgPSBwLnggKiBNYXRoLmNvcyhhbmdsZSkgLSBwLnkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIHZhciB5dCA9IHAueCAqIE1hdGguc2luKGFuZ2xlKSArIHAueSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgcC54ID0geCArIGxlbmd0aCAqIHh0O1xuICAgICAgICBwLnkgPSB5ICsgbGVuZ3RoICogeXQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGNsb3NlZCBwYXRoIHVzaW5nIHRoZSBnaXZlbiByZWFsIGNvb3JkaW5hdGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgcGF0aCB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIHBvaW50cyAtIFRoZSBwb2ludHMgb2YgdGhlIHBhdGguXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdQYXRoKGN0eCwgcG9pbnRzKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnRzW2ldLngsIHBvaW50c1tpXS55KTtcbiAgICAgIH1cblxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFbmRQb2ludDtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBhcnJvdyBlbmRwb2ludC5cclxuICovXG5cblxudmFyIEltYWdlJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbmRQb2ludCkge1xuICBfaW5oZXJpdHMoSW1hZ2UsIF9FbmRQb2ludCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRhKEltYWdlKTtcblxuICBmdW5jdGlvbiBJbWFnZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2UpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEltYWdlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIEZhbHNlIGFzIHRoZXJlIGlzIG5vIHdheSB0byBmaWxsIGFuIGltYWdlLlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgaWYgKGFycm93RGF0YS5pbWFnZSkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKGFycm93RGF0YS5wb2ludC54LCBhcnJvd0RhdGEucG9pbnQueSk7XG4gICAgICAgIGN0eC5yb3RhdGUoTWF0aC5QSSAvIDIgKyBhcnJvd0RhdGEuYW5nbGUpO1xuICAgICAgICB2YXIgd2lkdGggPSBhcnJvd0RhdGEuaW1hZ2VXaWR0aCAhPSBudWxsID8gYXJyb3dEYXRhLmltYWdlV2lkdGggOiBhcnJvd0RhdGEuaW1hZ2Uud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBhcnJvd0RhdGEuaW1hZ2VIZWlnaHQgIT0gbnVsbCA/IGFycm93RGF0YS5pbWFnZUhlaWdodCA6IGFycm93RGF0YS5pbWFnZS5oZWlnaHQ7XG4gICAgICAgIGFycm93RGF0YS5pbWFnZS5kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgMSwgLy8gc2NhbGVcbiAgICAgICAgLXdpZHRoIC8gMiwgLy8geFxuICAgICAgICAwLCAvLyB5XG4gICAgICAgIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEltYWdlO1xufShFbmRQb2ludCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgYXJyb3cgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBBcnJvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VuZFBvaW50Mikge1xuICBfaW5oZXJpdHMoQXJyb3csIF9FbmRQb2ludDIpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyJGEoQXJyb3cpO1xuXG4gIGZ1bmN0aW9uIEFycm93KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcnJvdyk7XG5cbiAgICByZXR1cm4gX3N1cGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFycm93LCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAtMC45LFxuICAgICAgICB5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXJyb3c7XG59KEVuZFBvaW50KTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBjcm93IGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgQ3JvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENyb3coKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENyb3cpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENyb3csIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjQsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogLTAuM1xuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENyb3c7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgY3VydmUgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBDdXJ2ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEN1cnZlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdXJ2ZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ3VydmUsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgIHg6IC0wLjQsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnQsIGFycm93RGF0YSk7IC8vIFVwZGF0ZSBlbmRwb2ludCBzdHlsZSBmb3IgZHJhd2luZyB0cmFuc3BhcmVudCBhcmMuXG5cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDApXCI7IC8vIERlZmluZSBjdXJ2ZSBlbmRwb2ludCBhcyBzZW1pY2lyY2xlLlxuXG4gICAgICB2YXIgcGkgPSBNYXRoLlBJO1xuICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBhcnJvd0RhdGEuYW5nbGUgLSBwaSAvIDI7XG4gICAgICB2YXIgZW5kQW5nbGUgPSBhcnJvd0RhdGEuYW5nbGUgKyBwaSAvIDI7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIGFycm93RGF0YS5sZW5ndGggKiAwLjQsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBmYWxzZSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3VydmU7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgaW52ZXJ0ZWQgY3VydmUgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBJbnZlcnRlZEN1cnZlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW52ZXJ0ZWRDdXJ2ZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW52ZXJ0ZWRDdXJ2ZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW52ZXJ0ZWRDdXJ2ZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgeDogLTAuMyxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludCwgYXJyb3dEYXRhKTsgLy8gVXBkYXRlIGVuZHBvaW50IHN0eWxlIGZvciBkcmF3aW5nIHRyYW5zcGFyZW50IGFyYy5cblxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMCwgMCwgMCwgMClcIjsgLy8gRGVmaW5lIGludmVydGVkIGN1cnZlIGVuZHBvaW50IGFzIHNlbWljaXJjbGUuXG5cbiAgICAgIHZhciBwaSA9IE1hdGguUEk7XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IGFycm93RGF0YS5hbmdsZSArIHBpIC8gMjtcbiAgICAgIHZhciBlbmRBbmdsZSA9IGFycm93RGF0YS5hbmdsZSArIDMgKiBwaSAvIDI7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIGFycm93RGF0YS5sZW5ndGggKiAwLjQsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBmYWxzZSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW52ZXJ0ZWRDdXJ2ZTtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSB0cmluYWdsZSBlbmRwb2ludC5cclxuICovXG5cblxudmFyIFRyaWFuZ2xlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJpYW5nbGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyaWFuZ2xlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUcmlhbmdsZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAwLjAyLFxuICAgICAgICB5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IC0wLjNcbiAgICAgIH1dO1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmlhbmdsZTtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBpbnZlcnRlZCB0cmluYWdsZSBlbmRwb2ludC5cclxuICovXG5cblxudmFyIEludmVydGVkVHJpYW5nbGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnZlcnRlZFRyaWFuZ2xlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnZlcnRlZFRyaWFuZ2xlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbnZlcnRlZFRyaWFuZ2xlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW52ZXJ0ZWRUcmlhbmdsZTtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBjaXJjbGUgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBDaXJjbGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmNsZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2lyY2xlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICB4OiAtMC40LFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50LCBhcnJvd0RhdGEpO1xuICAgICAgZHJhd0NpcmNsZShjdHgsIHBvaW50LngsIHBvaW50LnksIGFycm93RGF0YS5sZW5ndGggKiAwLjQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENpcmNsZTtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBiYXIgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBCYXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFyLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLypcclxuICAgICAgdmFyIHBvaW50cyA9IFtcclxuICAgICAgICB7eDowLCB5OjAuNX0sXHJcbiAgICAgICAge3g6MCwgeTotMC41fVxyXG4gICAgICBdO1xyXG4gICAgICAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xyXG4gICAgICBjdHgubGluZVRvKHBvaW50c1sxXS54LCBwb2ludHNbMV0ueSk7XHJcbiAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgKi9cbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLjVcbiAgICAgIH0sIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogLTAuNVxuICAgICAgfSwge1xuICAgICAgICB4OiAtMC4xNSxcbiAgICAgICAgeTogLTAuNVxuICAgICAgfSwge1xuICAgICAgICB4OiAtMC4xNSxcbiAgICAgICAgeTogMC41XG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFyO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGJveCBlbmRwb2ludC5cclxuICovXG5cblxudmFyIEJveCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJveCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQm94KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCb3gsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IC0wLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuNixcbiAgICAgICAgeTogLTAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAtMC42LFxuICAgICAgICB5OiAwLjNcbiAgICAgIH1dO1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCb3g7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgZGlhbW9uZCBlbmRwb2ludC5cclxuICovXG5cblxudmFyIERpYW1vbmQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEaWFtb25kKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaWFtb25kKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEaWFtb25kLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuNSxcbiAgICAgICAgeTogLTAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAtMC41LFxuICAgICAgICB5OiAwLjNcbiAgICAgIH1dO1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEaWFtb25kO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIHZlZSBlbmRwb2ludC5cclxuICovXG5cblxudmFyIFZlZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZlZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmVlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhWZWUsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAtMC41LFxuICAgICAgICB5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH1dO1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWZWU7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgZW5kcG9pbnRzLlxyXG4gKi9cblxuXG52YXIgRW5kUG9pbnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRW5kUG9pbnRzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbmRQb2ludHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVuZFBvaW50cywgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhbiBlbmRwb2ludC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgdHlwZTtcblxuICAgICAgaWYgKGFycm93RGF0YS50eXBlKSB7XG4gICAgICAgIHR5cGUgPSBhcnJvd0RhdGEudHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgICAgcmV0dXJuIEltYWdlJDEuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgICAgIHJldHVybiBDaXJjbGUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcImJveFwiOlxuICAgICAgICAgIHJldHVybiBCb3guZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcImNyb3dcIjpcbiAgICAgICAgICByZXR1cm4gQ3Jvdy5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgICBjYXNlIFwiY3VydmVcIjpcbiAgICAgICAgICByZXR1cm4gQ3VydmUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcImRpYW1vbmRcIjpcbiAgICAgICAgICByZXR1cm4gRGlhbW9uZC5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgICBjYXNlIFwiaW52X2N1cnZlXCI6XG4gICAgICAgICAgcmV0dXJuIEludmVydGVkQ3VydmUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcInRyaWFuZ2xlXCI6XG4gICAgICAgICAgcmV0dXJuIFRyaWFuZ2xlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJpbnZfdHJpYW5nbGVcIjpcbiAgICAgICAgICByZXR1cm4gSW52ZXJ0ZWRUcmlhbmdsZS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgICBjYXNlIFwiYmFyXCI6XG4gICAgICAgICAgcmV0dXJuIEJhci5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgICBjYXNlIFwidmVlXCI6XG4gICAgICAgICAgcmV0dXJuIFZlZS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgICBjYXNlIFwiYXJyb3dcIjogLy8gZmFsbC10aHJvdWdoXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gQXJyb3cuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVuZFBvaW50cztcbn0oKTtcblxuZnVuY3Rpb24gb3duS2V5cyQxKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBrZXlzJDQob2JqZWN0KTsgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IGZpbHRlcihzeW1ib2xzKS5jYWxsKHN5bWJvbHMsIGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBfY29udGV4dDIsIF9jb250ZXh0MzsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gZm9yRWFjaCQyKF9jb250ZXh0MiA9IG93bktleXMkMShPYmplY3Qoc291cmNlKSwgITApKS5jYWxsKF9jb250ZXh0MiwgZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBmb3JFYWNoJDIoX2NvbnRleHQzID0gb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKSkuY2FsbChfY29udGV4dDMsIGZ1bmN0aW9uIChrZXkpIHsgZGVmaW5lUHJvcGVydHkkNih0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMoc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuLyoqXHJcbiAqIFRoZSBCYXNlIENsYXNzIGZvciBhbGwgZWRnZXMuXHJcbiAqL1xuXG52YXIgRWRnZUJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBvZiBnaXZlbiBlZGdlLlxyXG4gICAqIEBwYXJhbSBfYm9keSAtIFRoZSBib2R5IG9mIHRoZSBuZXR3b3JrLlxyXG4gICAqIEBwYXJhbSBfbGFiZWxNb2R1bGUgLSBMYWJlbCBtb2R1bGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEVkZ2VCYXNlKG9wdGlvbnMsIF9ib2R5LCBfbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZUJhc2UpO1xuXG4gICAgdGhpcy5fYm9keSA9IF9ib2R5O1xuICAgIHRoaXMuX2xhYmVsTW9kdWxlID0gX2xhYmVsTW9kdWxlO1xuICAgIHRoaXMuY29sb3IgPSB7fTtcbiAgICB0aGlzLmNvbG9yRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuaG92ZXJXaWR0aCA9IDEuNTtcbiAgICB0aGlzLnNlbGVjdGlvbldpZHRoID0gMjtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5mcm9tUG9pbnQgPSB0aGlzLmZyb207XG4gICAgdGhpcy50b1BvaW50ID0gdGhpcy50bztcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhFZGdlQmFzZSwgW3tcbiAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICAgdGhpcy5mcm9tID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFudXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbmV3IGVkZ2Ugb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBuZXcgZWRnZSBvcHRpb25zIG9iamVjdC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLmZyb20gPSB0aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy5mcm9tXTtcbiAgICAgIHRoaXMudG8gPSB0aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG4gICAgICB0aGlzLmlkID0gdGhpcy5vcHRpb25zLmlkO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMaW5lKGN0eCwgdmFsdWVzLCBfc2VsZWN0ZWQsIF9ob3Zlcikge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRoaXMuZ2V0VmlhTm9kZSgpO1xuICAgICAgLy8gc2V0IHN0eWxlXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmdldENvbG9yKGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB2YWx1ZXMud2lkdGg7XG5cbiAgICAgIGlmICh2YWx1ZXMuZGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9kcmF3RGFzaGVkTGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kcmF3TGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGxpbmUgd2l0aCBnaXZlbiBzdHlsZSBiZXR3ZWVuIHR3byBub2RlcyB0aHJvdWdoIHN1cHBsaWVkIG5vZGUocykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gRm9ybWF0dGluZyB2YWx1ZXMgbGlrZSBjb2xvciwgb3BhY2l0eSBvciBzaGFkb3cuXHJcbiAgICAgKiBAcGFyYW0gdmlhTm9kZSAtIEFkZGl0aW9uYWwgY29udHJvbCBwb2ludChzKSBmb3IgdGhlIGVkZ2UuXHJcbiAgICAgKiBAcGFyYW0gZnJvbVBvaW50IC0gVE9ETzogU2VlbXMgaWdub3JlZCwgcmVtb3ZlP1xyXG4gICAgICogQHBhcmFtIHRvUG9pbnQgLSBUT0RPOiBTZWVtcyBpZ25vcmVkLCByZW1vdmU/XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3TGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUsIGZyb21Qb2ludCwgdG9Qb2ludCkge1xuICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgIC8vIGRyYXcgbGluZVxuICAgICAgICB0aGlzLl9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlLCBmcm9tUG9pbnQsIHRvUG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF90aGlzJF9nZXRDaXJjbGVEYXRhID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGEyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldENpcmNsZURhdGEsIDMpLFxuICAgICAgICAgICAgeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlswXSxcbiAgICAgICAgICAgIHkgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTJbMV0sXG4gICAgICAgICAgICByYWRpdXMgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTJbMl07XG5cbiAgICAgICAgdGhpcy5fY2lyY2xlKGN0eCwgdmFsdWVzLCB4LCB5LCByYWRpdXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIERyYXcgYSBkYXNoZWQgbGluZSB3aXRoIGdpdmVuIHN0eWxlIGJldHdlZW4gdHdvIG5vZGVzIHRocm91Z2ggc3VwcGxpZWQgbm9kZShzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBGb3JtYXR0aW5nIHZhbHVlcyBsaWtlIGNvbG9yLCBvcGFjaXR5IG9yIHNoYWRvdy5cclxuICAgICAqIEBwYXJhbSB2aWFOb2RlIC0gQWRkaXRpb25hbCBjb250cm9sIHBvaW50KHMpIGZvciB0aGUgZWRnZS5cclxuICAgICAqIEBwYXJhbSBfZnJvbVBvaW50IC0gSWdub3JlZCAoVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUpLlxyXG4gICAgICogQHBhcmFtIF90b1BvaW50IC0gSWdub3JlZCAoVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUpLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0Rhc2hlZExpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdEYXNoZWRMaW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlLCBfZnJvbVBvaW50LCBfdG9Qb2ludCkge1xuICAgICAgY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XG4gICAgICB2YXIgcGF0dGVybiA9IGlzQXJyYXkkMih2YWx1ZXMuZGFzaGVzKSA/IHZhbHVlcy5kYXNoZXMgOiBbNSwgNV07IC8vIG9ubHkgZmlyZWZveCBhbmQgY2hyb21lIHN1cHBvcnQgdGhpcyBtZXRob2QsIGVsc2Ugd2UgdXNlIHRoZSBsZWdhY3kgb25lLlxuXG4gICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3R4LnNhdmUoKTsgLy8gc2V0IGRhc2ggc2V0dGluZ3MgZm9yIGNocm9tZSBvciBmaXJlZm94XG5cbiAgICAgICAgY3R4LnNldExpbmVEYXNoKHBhdHRlcm4pO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSAwOyAvLyBkcmF3IHRoZSBsaW5lXG5cbiAgICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgICAgLy8gZHJhdyBsaW5lXG4gICAgICAgICAgdGhpcy5fbGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF90aGlzJF9nZXRDaXJjbGVEYXRhMyA9IHRoaXMuX2dldENpcmNsZURhdGEoY3R4KSxcbiAgICAgICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGE0ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldENpcmNsZURhdGEzLCAzKSxcbiAgICAgICAgICAgICAgeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhNFswXSxcbiAgICAgICAgICAgICAgeSA9IF90aGlzJF9nZXRDaXJjbGVEYXRhNFsxXSxcbiAgICAgICAgICAgICAgcmFkaXVzID0gX3RoaXMkX2dldENpcmNsZURhdGE0WzJdO1xuXG4gICAgICAgICAgdGhpcy5fY2lyY2xlKGN0eCwgdmFsdWVzLCB4LCB5LCByYWRpdXMpO1xuICAgICAgICB9IC8vIHJlc3RvcmUgdGhlIGRhc2ggc2V0dGluZ3MuXG5cblxuICAgICAgICBjdHguc2V0TGluZURhc2goWzBdKTtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVuc3VwcG9ydGluZyBzbW9vdGggbGluZXNcbiAgICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgICAgLy8gZHJhdyBsaW5lXG4gICAgICAgICAgZHJhd0Rhc2hlZExpbmUoY3R4LCB0aGlzLmZyb20ueCwgdGhpcy5mcm9tLnksIHRoaXMudG8ueCwgdGhpcy50by55LCBwYXR0ZXJuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGE1ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgICBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTYgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YTUsIDMpLFxuICAgICAgICAgICAgICBfeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhNlswXSxcbiAgICAgICAgICAgICAgX3kgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTZbMV0sXG4gICAgICAgICAgICAgIF9yYWRpdXMgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTZbMl07XG5cbiAgICAgICAgICB0aGlzLl9jaXJjbGUoY3R4LCB2YWx1ZXMsIF94LCBfeSwgX3JhZGl1cyk7XG4gICAgICAgIH0gLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuXG5cbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7IC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgYm9yZGVyIG9mIHRoZSBub2RlIGFuZCB0aGUgZWRnZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIChlaXRoZXIgZnJvbSBvciB0byBub2RlIG9mIHRoZSBlZGdlKS5cclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgb2YgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUgYW5kIHRoZSBlZGdlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQm9yZGVyUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEJvcmRlclBvc2l0aW9uKG5vZGUsIGN0eCwgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24obm9kZSwgY3R4LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUobm9kZSwgY3R4LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQm9yZGVyUG9zaXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRCb3JkZXJQb3NpdGlvbnMoY3R4KSB7XG4gICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmcm9tOiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24odGhpcy5mcm9tLCBjdHgpLFxuICAgICAgICAgIHRvOiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24odGhpcy50bywgY3R4KVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICAgIHZhciBfdGhpcyRfZ2V0Q2lyY2xlRGF0YSQgPSBzbGljZShfY29udGV4dCA9IHRoaXMuX2dldENpcmNsZURhdGEoY3R4KSkuY2FsbChfY29udGV4dCwgMCwgMiksXG4gICAgICAgICAgICBfdGhpcyRfZ2V0Q2lyY2xlRGF0YSQyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldENpcmNsZURhdGEkLCAyKSxcbiAgICAgICAgICAgIHggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YSQyWzBdLFxuICAgICAgICAgICAgeSA9IF90aGlzJF9nZXRDaXJjbGVEYXRhJDJbMV07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmcm9tOiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLCBjdHgsIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgbG93OiAwLjI1LFxuICAgICAgICAgICAgaGlnaDogMC42LFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAtMVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRvOiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLCBjdHgsIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgbG93OiAwLjYsXG4gICAgICAgICAgICBoaWdoOiAwLjgsXG4gICAgICAgICAgICBkaXJlY3Rpb246IDFcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgdGhlIGNlbnRlciBwb2ludCBhbmQgcmFkaXVzIG9mIGFuIGVkZ2UgY29ubmVjdGVkIHRvIHRoZSBzYW1lIG5vZGUgYXQgYm90aCBlbmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHJldHVybnMgYFt4LCB5LCByYWRpdXNdYFxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q2lyY2xlRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2lyY2xlRGF0YShjdHgpIHtcbiAgICAgIHZhciByYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplO1xuXG4gICAgICBpZiAoY3R4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5zaGFwZS53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5mcm9tLnNoYXBlLnJlc2l6ZShjdHgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGdldCBjaXJjbGUgY29vcmRpbmF0ZXNcblxuXG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZXRTZWxmUmVmQ29vcmRpbmF0ZXMoY3R4LCB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSwgcmFkaXVzLCB0aGlzLmZyb20pO1xuICAgICAgcmV0dXJuIFtjb29yZGluYXRlcy54LCBjb29yZGluYXRlcy55LCByYWRpdXNdO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldCBhIHBvaW50IG9uIGEgY2lyY2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB4IC0gQ2VudGVyIG9mIHRoZSBjaXJjbGUgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5IC0gQ2VudGVyIG9mIHRoZSBjaXJjbGUgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSByYWRpdXMgLSBSYWRpdXMgb2YgdGhlIGNpcmNsZS5cclxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAtIFZhbHVlIGJldHdlZW4gMCAobGluZSBzdGFydCkgYW5kIDEgKGxpbmUgZW5kKS5cclxuICAgICAqIEByZXR1cm5zIENhcnRlc2lhbiBjb29yZGluYXRlcyBvZiByZXF1ZXN0ZWQgcG9pbnQgb24gdGhlIGNpcmNsZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BvaW50T25DaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBwb3NpdGlvbikge1xuICAgICAgdmFyIGFuZ2xlID0gcG9zaXRpb24gKiAyICogTWF0aC5QSTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHk6IHkgLSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSlcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIGJvcmRlciBvZiB0aGUgbm9kZSBhbmQgdGhlIGVkZ2UuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gdXNlcyBiaW5hcnkgc2VhcmNoIHRvIGxvb2sgZm9yIHRoZSBwb2ludCB3aGVyZSB0aGUgY2lyY2xlIGNyb3NzZXMgdGhlIGJvcmRlciBvZiB0aGUgbm9kZS5cclxuICAgICAqIEBwYXJhbSBuZWFyTm9kZSAtIFRoZSBub2RlIChlaXRoZXIgZnJvbSBvciB0byBub2RlIG9mIHRoZSBlZGdlKS5cclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgb2YgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUgYW5kIHRoZSBlZGdlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUobmVhck5vZGUsIGN0eCwgb3B0aW9ucykge1xuICAgICAgdmFyIHggPSBvcHRpb25zLng7XG4gICAgICB2YXIgeSA9IG9wdGlvbnMueTtcbiAgICAgIHZhciBsb3cgPSBvcHRpb25zLmxvdztcbiAgICAgIHZhciBoaWdoID0gb3B0aW9ucy5oaWdoO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgICAgIHZhciByYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplO1xuICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMDU7XG4gICAgICB2YXIgcG9zO1xuICAgICAgdmFyIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAqIDAuNTtcbiAgICAgIHZhciBlbmRQb2ludE9mZnNldCA9IDA7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgICAgZW5kUG9pbnRPZmZzZXQgPSB0aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgICBlbmRQb2ludE9mZnNldCA9IHRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldC50bztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0aW9uID0gMDtcblxuICAgICAgZG8ge1xuICAgICAgICBtaWRkbGUgPSAobG93ICsgaGlnaCkgKiAwLjU7XG4gICAgICAgIHBvcyA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBtaWRkbGUpO1xuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKG5lYXJOb2RlLnkgLSBwb3MueSwgbmVhck5vZGUueCAtIHBvcy54KTtcbiAgICAgICAgdmFyIGRpc3RhbmNlVG9Cb3JkZXIgPSBuZWFyTm9kZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpICsgZW5kUG9pbnRPZmZzZXQ7XG4gICAgICAgIHZhciBkaXN0YW5jZVRvUG9pbnQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocG9zLnggLSBuZWFyTm9kZS54LCAyKSArIE1hdGgucG93KHBvcy55IC0gbmVhck5vZGUueSwgMikpO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IGRpc3RhbmNlVG9Cb3JkZXIgLSBkaXN0YW5jZVRvUG9pbnQ7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGRpZmZlcmVuY2UpIDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgYnJlYWs7IC8vIGZvdW5kXG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZmVyZW5jZSA+IDApIHtcbiAgICAgICAgICAvLyBkaXN0YW5jZSB0byBub2RlcyBpcyBsYXJnZXIgdGhhbiBkaXN0YW5jZSB0byBib3JkZXIgLS0+IHQgbmVlZHMgdG8gYmUgYmlnZ2VyIGlmIHdlJ3JlIGxvb2tpbmcgYXQgdGhlIHRvIG5vZGUuXG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICArK2l0ZXJhdGlvbjtcbiAgICAgIH0gd2hpbGUgKGxvdyA8PSBoaWdoICYmIGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnMpO1xuXG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgcG9zKSwge30sIHtcbiAgICAgICAgdDogbWlkZGxlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGxpbmUgd2lkdGggb2YgdGhlIGVkZ2UuIERlcGVuZHMgb24gd2lkdGggYW5kIHdoZXRoZXIgb25lIG9mIHRoZSBjb25uZWN0ZWQgbm9kZXMgaXMgc2VsZWN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNlbGVjdGVkIC0gRGV0ZXJtaW5lcyB3aGV0ZXIgdGhlIGxpbmUgaXMgc2VsZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gaG92ZXIgLSBEZXRlcm1pbmVzIHdoZXRlciB0aGUgbGluZSBpcyBiZWluZyBob3ZlcmVkLCBvbmx5IGFwcGxpZXMgaWYgc2VsZWN0ZWQgaXMgZmFsc2UuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgd2lkdGggb2YgdGhlIGxpbmUuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldExpbmVXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMaW5lV2lkdGgoc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAoc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuc2VsZWN0aW9uV2lkdGgsIDAuMyAvIHRoaXMuX2JvZHkudmlldy5zY2FsZSk7XG4gICAgICB9IGVsc2UgaWYgKGhvdmVyID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmhvdmVyV2lkdGgsIDAuMyAvIHRoaXMuX2JvZHkudmlldy5zY2FsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5vcHRpb25zLndpZHRoLCAwLjMgLyB0aGlzLl9ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgdGhlIGNvbG9yIG9yIGdyYWRpZW50IGZvciBnaXZlbiBlZGdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGxpa2UgY29sb3IsIG9wYWNpdHkgb3Igc2hhZG93LlxyXG4gICAgICogQHBhcmFtIF9zZWxlY3RlZCAtIElnbm9yZWQgKFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlKS5cclxuICAgICAqIEBwYXJhbSBfaG92ZXIgLSBJZ25vcmVkIChUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSkuXHJcbiAgICAgKiBAcmV0dXJucyBDb2xvciBzdHJpbmcgaWYgc2luZ2xlIGNvbG9yIGlzIGluaGVyaXRlZCBvciBncmFkaWVudCBpZiB0d28uXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldENvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbG9yKGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLmluaGVyaXRzQ29sb3IgIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIHdoZW4gdGhpcyBpcyBhIGxvb3AgZWRnZSwganVzdCB1c2UgdGhlICdmcm9tJyBtZXRob2RcbiAgICAgICAgaWYgKHZhbHVlcy5pbmhlcml0c0NvbG9yID09PSBcImJvdGhcIiAmJiB0aGlzLmZyb20uaWQgIT09IHRoaXMudG8uaWQpIHtcbiAgICAgICAgICB2YXIgZ3JkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHRoaXMuZnJvbS54LCB0aGlzLmZyb20ueSwgdGhpcy50by54LCB0aGlzLnRvLnkpO1xuICAgICAgICAgIHZhciBmcm9tQ29sb3IgPSB0aGlzLmZyb20ub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyO1xuICAgICAgICAgIHZhciB0b0NvbG9yID0gdGhpcy50by5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXI7XG5cbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnNlbGVjdGVkID09PSBmYWxzZSAmJiB0aGlzLnRvLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZnJvbUNvbG9yID0gb3ZlcnJpZGVPcGFjaXR5KHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmJvcmRlciwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICAgICAgdG9Db2xvciA9IG92ZXJyaWRlT3BhY2l0eSh0aGlzLnRvLm9wdGlvbnMuY29sb3IuYm9yZGVyLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20uc2VsZWN0ZWQgPT09IHRydWUgJiYgdGhpcy50by5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRvQ29sb3IgPSB0aGlzLnRvLm9wdGlvbnMuY29sb3IuYm9yZGVyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnNlbGVjdGVkID09PSBmYWxzZSAmJiB0aGlzLnRvLnNlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBmcm9tQ29sb3IgPSB0aGlzLmZyb20ub3B0aW9ucy5jb2xvci5ib3JkZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ3JkLmFkZENvbG9yU3RvcCgwLCBmcm9tQ29sb3IpO1xuICAgICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMSwgdG9Db2xvcik7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIHRoaXMgcmV0dXJucyAtLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gICAgICAgICAgcmV0dXJuIGdyZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZXMuaW5oZXJpdHNDb2xvciA9PT0gXCJ0b1wiKSB7XG4gICAgICAgICAgcmV0dXJuIG92ZXJyaWRlT3BhY2l0eSh0aGlzLnRvLm9wdGlvbnMuY29sb3IuYm9yZGVyLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gXCJmcm9tXCJcbiAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVPcGFjaXR5KHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmJvcmRlciwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3ZlcnJpZGVPcGFjaXR5KHZhbHVlcy5jb2xvciwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIERyYXcgYSBsaW5lIGZyb20gYSBub2RlIHRvIGl0c2VsZiwgYSBjaXJjbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gRm9ybWF0dGluZyB2YWx1ZXMgbGlrZSBjb2xvciwgb3BhY2l0eSBvciBzaGFkb3cuXHJcbiAgICAgKiBAcGFyYW0geCAtIENlbnRlciBvZiB0aGUgY2lyY2xlIG9uIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geSAtIENlbnRlciBvZiB0aGUgY2lyY2xlIG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0gcmFkaXVzIC0gUmFkaXVzIG9mIHRoZSBjaXJjbGUuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NpcmNsZShjdHgsIHZhbHVlcywgeCwgeSwgcmFkaXVzKSB7XG4gICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7IC8vZnVsbCBjaXJjbGVcblxuICAgICAgdmFyIGFuZ2xlRnJvbSA9IDA7XG4gICAgICB2YXIgYW5nbGVUbyA9IE1hdGguUEkgKiAyO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLnJlbmRlckJlaGluZFRoZU5vZGUpIHtcbiAgICAgICAgLy9yZW5kZXIgb25seSBwYXJ0cyB3aGljaCBhcmUgbm90IG92ZXJsYXBpbmcgd2l0aCBwYXJlbnQgbm9kZVxuICAgICAgICAvL25lZWQgdG8gZmluZCB4LHkgb2YgZnJvbSBwb2ludCBhbmQgeCx5IHRvIHBvaW50XG4gICAgICAgIC8vY2FsY3VsYXRpbmcgcmFkaWFuc1xuICAgICAgICB2YXIgbG93ID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGU7XG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUgKyBNYXRoLlBJO1xuXG4gICAgICAgIHZhciBwb2ludFRGcm9tID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIGxvdzogbG93LFxuICAgICAgICAgIGhpZ2g6IGhpZ2gsXG4gICAgICAgICAgZGlyZWN0aW9uOiAtMVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcG9pbnRUVG8gPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLCBjdHgsIHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgbG93OiBsb3csXG4gICAgICAgICAgaGlnaDogaGlnaCxcbiAgICAgICAgICBkaXJlY3Rpb246IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYW5nbGVGcm9tID0gTWF0aC5hdGFuMihwb2ludFRGcm9tLnkgLSB5LCBwb2ludFRGcm9tLnggLSB4KTtcbiAgICAgICAgYW5nbGVUbyA9IE1hdGguYXRhbjIocG9pbnRUVG8ueSAtIHksIHBvaW50VFRvLnggLSB4KTtcbiAgICAgIH0gLy8gZHJhdyBhIGNpcmNsZVxuXG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCBhbmdsZUZyb20sIGFuZ2xlVG8sIGZhbHNlKTtcbiAgICAgIGN0eC5zdHJva2UoKTsgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cblxuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBAaW5oZXJpdERvY1xyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ5MjExL3Nob3J0ZXN0LWRpc3RhbmNhZS1iZXR3ZWVuLWEtcG9pbnQtYW5kLWEtbGluZS1zZWdtZW50XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldERpc3RhbmNlVG9FZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGE3ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YSh1bmRlZmluZWQpLFxuICAgICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGE4ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldENpcmNsZURhdGE3LCAzKSxcbiAgICAgICAgICAgIHggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YThbMF0sXG4gICAgICAgICAgICB5ID0gX3RoaXMkX2dldENpcmNsZURhdGE4WzFdLFxuICAgICAgICAgICAgcmFkaXVzID0gX3RoaXMkX2dldENpcmNsZURhdGE4WzJdO1xuXG4gICAgICAgIHZhciBkeCA9IHggLSB4MztcbiAgICAgICAgdmFyIGR5ID0geSAtIHkzO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSAtIHJhZGl1cyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgKHgzLCB5MykgYW5kIGEgbGluZSBzZWdtZW50IGZyb20gKHgxLCB5MSkgdG8gKHgyLCB5MikuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHgxIC0gRmlyc3QgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5MSAtIEZpcnN0IGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geDIgLSBTZWNvbmQgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeSBheGlzLlxyXG4gICAgICogQHBhcmFtIHgzIC0gUG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geTMgLSBQb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsaW5lIHNlZ21lbnQgYW5kIHRoZSBwb2ludC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9MaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvTGluZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICB2YXIgcHggPSB4MiAtIHgxO1xuICAgICAgdmFyIHB5ID0geTIgLSB5MTtcbiAgICAgIHZhciBzb21ldGhpbmcgPSBweCAqIHB4ICsgcHkgKiBweTtcbiAgICAgIHZhciB1ID0gKCh4MyAtIHgxKSAqIHB4ICsgKHkzIC0geTEpICogcHkpIC8gc29tZXRoaW5nO1xuXG4gICAgICBpZiAodSA+IDEpIHtcbiAgICAgICAgdSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHUgPCAwKSB7XG4gICAgICAgIHUgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IHgxICsgdSAqIHB4O1xuICAgICAgdmFyIHkgPSB5MSArIHUgKiBweTtcbiAgICAgIHZhciBkeCA9IHggLSB4MztcbiAgICAgIHZhciBkeSA9IHkgLSB5MzsgLy8jIE5vdGU6IElmIHRoZSBhY3R1YWwgZGlzdGFuY2UgZG9lcyBub3QgbWF0dGVyLFxuICAgICAgLy8jIGlmIHlvdSBvbmx5IHdhbnQgdG8gY29tcGFyZSB3aGF0IHRoaXMgZnVuY3Rpb25cbiAgICAgIC8vIyByZXR1cm5zIHRvIG90aGVyIHJlc3VsdHMgb2YgdGhpcyBmdW5jdGlvbiwgeW91XG4gICAgICAvLyMgY2FuIGp1c3QgcmV0dXJuIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGluc3RlYWRcbiAgICAgIC8vIyAoaS5lLiByZW1vdmUgdGhlIHNxcnQpIHRvIGdhaW4gYSBsaXR0bGUgcGVyZm9ybWFuY2VcblxuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXJyb3dEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFycm93RGF0YShjdHgsIHBvc2l0aW9uLCB2aWFOb2RlLCBfc2VsZWN0ZWQsIF9ob3ZlciwgdmFsdWVzKSB7XG4gICAgICAvLyBzZXQgbGV0c1xuICAgICAgdmFyIGFuZ2xlO1xuICAgICAgdmFyIGFycm93UG9pbnQ7XG4gICAgICB2YXIgbm9kZTE7XG4gICAgICB2YXIgbm9kZTI7XG4gICAgICB2YXIgcmV2ZXJzZWQ7XG4gICAgICB2YXIgc2NhbGVGYWN0b3I7XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIHZhciBsaW5lV2lkdGggPSB2YWx1ZXMud2lkdGg7XG5cbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJmcm9tXCIpIHtcbiAgICAgICAgbm9kZTEgPSB0aGlzLmZyb207XG4gICAgICAgIG5vZGUyID0gdGhpcy50bztcbiAgICAgICAgcmV2ZXJzZWQgPSB2YWx1ZXMuZnJvbUFycm93U2NhbGUgPCAwO1xuICAgICAgICBzY2FsZUZhY3RvciA9IE1hdGguYWJzKHZhbHVlcy5mcm9tQXJyb3dTY2FsZSk7XG4gICAgICAgIHR5cGUgPSB2YWx1ZXMuZnJvbUFycm93VHlwZTtcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwidG9cIikge1xuICAgICAgICBub2RlMSA9IHRoaXMudG87XG4gICAgICAgIG5vZGUyID0gdGhpcy5mcm9tO1xuICAgICAgICByZXZlcnNlZCA9IHZhbHVlcy50b0Fycm93U2NhbGUgPCAwO1xuICAgICAgICBzY2FsZUZhY3RvciA9IE1hdGguYWJzKHZhbHVlcy50b0Fycm93U2NhbGUpO1xuICAgICAgICB0eXBlID0gdmFsdWVzLnRvQXJyb3dUeXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZTEgPSB0aGlzLnRvO1xuICAgICAgICBub2RlMiA9IHRoaXMuZnJvbTtcbiAgICAgICAgcmV2ZXJzZWQgPSB2YWx1ZXMubWlkZGxlQXJyb3dTY2FsZSA8IDA7XG4gICAgICAgIHNjYWxlRmFjdG9yID0gTWF0aC5hYnModmFsdWVzLm1pZGRsZUFycm93U2NhbGUpO1xuICAgICAgICB0eXBlID0gdmFsdWVzLm1pZGRsZUFycm93VHlwZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IDE1ICogc2NhbGVGYWN0b3IgKyAzICogbGluZVdpZHRoOyAvLyAzKiBsaW5lV2lkdGggaXMgdGhlIHdpZHRoIG9mIHRoZSBlZGdlLlxuICAgICAgLy8gaWYgbm90IGNvbm5lY3RlZCB0byBpdHNlbGZcblxuICAgICAgaWYgKG5vZGUxICE9IG5vZGUyKSB7XG4gICAgICAgIHZhciBhcHByb3hpbWF0ZUVkZ2VMZW5ndGggPSBoeXBvdChub2RlMS54IC0gbm9kZTIueCwgbm9kZTEueSAtIG5vZGUyLnkpO1xuXG4gICAgICAgIHZhciByZWxhdGl2ZUxlbmd0aCA9IGxlbmd0aCAvIGFwcHJveGltYXRlRWRnZUxlbmd0aDtcblxuICAgICAgICBpZiAocG9zaXRpb24gIT09IFwibWlkZGxlXCIpIHtcbiAgICAgICAgICAvLyBkcmF3IGFycm93IGhlYWRcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNtb290aC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRUID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKG5vZGUxLCBjdHgsIHtcbiAgICAgICAgICAgICAgdmlhOiB2aWFOb2RlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGd1aWRlUG9zID0gdGhpcy5nZXRQb2ludChwb2ludFQudCArIHJlbGF0aXZlTGVuZ3RoICogKHBvc2l0aW9uID09PSBcImZyb21cIiA/IDEgOiAtMSksIHZpYU5vZGUpO1xuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKHBvaW50VC55IC0gZ3VpZGVQb3MueSwgcG9pbnRULnggLSBndWlkZVBvcy54KTtcbiAgICAgICAgICAgIGFycm93UG9pbnQgPSBwb2ludFQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihub2RlMS55IC0gbm9kZTIueSwgbm9kZTEueCAtIG5vZGUyLngpO1xuICAgICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbihub2RlMSwgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTmVnYXRpdmUgaGFsZiBsZW5ndGggcmV2ZXJzZXMgYXJyb3cgZGlyZWN0aW9uLlxuICAgICAgICAgIHZhciBoYWxmTGVuZ3RoID0gKHJldmVyc2VkID8gLXJlbGF0aXZlTGVuZ3RoIDogcmVsYXRpdmVMZW5ndGgpIC8gMjtcbiAgICAgICAgICB2YXIgZ3VpZGVQb3MxID0gdGhpcy5nZXRQb2ludCgwLjUgKyBoYWxmTGVuZ3RoLCB2aWFOb2RlKTtcbiAgICAgICAgICB2YXIgZ3VpZGVQb3MyID0gdGhpcy5nZXRQb2ludCgwLjUgLSBoYWxmTGVuZ3RoLCB2aWFOb2RlKTtcbiAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoZ3VpZGVQb3MxLnkgLSBndWlkZVBvczIueSwgZ3VpZGVQb3MxLnggLSBndWlkZVBvczIueCk7XG4gICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuZ2V0UG9pbnQoMC41LCB2aWFOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZHJhdyBjaXJjbGVcbiAgICAgICAgdmFyIF90aGlzJF9nZXRDaXJjbGVEYXRhOSA9IHRoaXMuX2dldENpcmNsZURhdGEoY3R4KSxcbiAgICAgICAgICAgIF90aGlzJF9nZXRDaXJjbGVEYXRhMTAgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YTksIDMpLFxuICAgICAgICAgICAgeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMTBbMF0sXG4gICAgICAgICAgICB5ID0gX3RoaXMkX2dldENpcmNsZURhdGExMFsxXSxcbiAgICAgICAgICAgIHJhZGl1cyA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMTBbMl07XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSBcImZyb21cIikge1xuICAgICAgICAgIHZhciBsb3cgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZTtcbiAgICAgICAgICB2YXIgaGlnaCA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlICsgTWF0aC5QSTtcblxuICAgICAgICAgIHZhciBfcG9pbnRUID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIGxvdzogbG93LFxuICAgICAgICAgICAgaGlnaDogaGlnaCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogLTFcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGFuZ2xlID0gX3BvaW50VC50ICogLTIgKiBNYXRoLlBJICsgMS41ICogTWF0aC5QSSArIDAuMSAqIE1hdGguUEk7XG4gICAgICAgICAgYXJyb3dQb2ludCA9IF9wb2ludFQ7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwidG9cIikge1xuICAgICAgICAgIHZhciBfbG93ID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGU7XG5cbiAgICAgICAgICB2YXIgX2hpZ2ggPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSArIE1hdGguUEk7XG5cbiAgICAgICAgICB2YXIgX3BvaW50VDIgPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLCBjdHgsIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgbG93OiBfbG93LFxuICAgICAgICAgICAgaGlnaDogX2hpZ2gsXG4gICAgICAgICAgICBkaXJlY3Rpb246IDFcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGFuZ2xlID0gX3BvaW50VDIudCAqIC0yICogTWF0aC5QSSArIDEuNSAqIE1hdGguUEkgLSAxLjEgKiBNYXRoLlBJO1xuICAgICAgICAgIGFycm93UG9pbnQgPSBfcG9pbnRUMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcG9zID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLl9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgcG9zKTtcbiAgICAgICAgICBhbmdsZSA9IHBvcyAqIC0yICogTWF0aC5QSSArIDEuNSAqIE1hdGguUEkgKyAwLjEgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB4aSA9IGFycm93UG9pbnQueCAtIGxlbmd0aCAqIDAuOSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHZhciB5aSA9IGFycm93UG9pbnQueSAtIGxlbmd0aCAqIDAuOSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHZhciBhcnJvd0NvcmUgPSB7XG4gICAgICAgIHg6IHhpLFxuICAgICAgICB5OiB5aVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiBhcnJvd1BvaW50LFxuICAgICAgICBjb3JlOiBhcnJvd0NvcmUsXG4gICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0Fycm93SGVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QXJyb3dIZWFkKGN0eCwgdmFsdWVzLCBfc2VsZWN0ZWQsIF9ob3ZlciwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBzZXQgc3R5bGVcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZ2V0Q29sb3IoY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB2YWx1ZXMud2lkdGg7XG4gICAgICB2YXIgY2FuRmlsbCA9IEVuZFBvaW50cy5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgaWYgKGNhbkZpbGwpIHtcbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG5cbiAgICAgICAgZmlsbChjdHgpLmNhbGwoY3R4KTsgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cblxuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBzaGFkb3cgZm9ybWF0dGluZyB2YWx1ZXMgaW4gdGhlIGNvbnRleHQgaWYgZW5hYmxlZCwgZG8gbm90aGluZyBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gRm9ybWF0dGluZyB2YWx1ZXMgZm9yIHRoZSBzaGFkb3cuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVNoYWRvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuc2hhZG93ID09PSB0cnVlKSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHZhbHVlcy5zaGFkb3dDb2xvcjtcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB2YWx1ZXMuc2hhZG93U2l6ZTtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB2YWx1ZXMuc2hhZG93WDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB2YWx1ZXMuc2hhZG93WTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgc2hhZG93IGZvcm1hdHRpbmcgdmFsdWVzIGluIHRoZSBjb250ZXh0IGlmIGVuYWJsZWQsIGRvIG5vdGhpbmcgb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGZvciB0aGUgc2hhZG93LlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlU2hhZG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuc2hhZG93ID09PSB0cnVlKSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwicmdiYSgwLDAsMCwwKVwiO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlbmRlciB0aGUgYmFja2dyb3VuZCBhY2NvcmRpbmcgdG8gdGhlIGZvcm1hdHRpbmcgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGZvciB0aGUgYmFja2dyb3VuZC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0JhY2tncm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0JhY2tncm91bmQoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuYmFja2dyb3VuZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gc2F2ZSBvcmlnaW5hbCBsaW5lIGF0dHJzXG4gICAgICAgIHZhciBvcmlnQ3R4QXR0ciA9IHtcbiAgICAgICAgICBzdHJva2VTdHlsZTogY3R4LnN0cm9rZVN0eWxlLFxuICAgICAgICAgIGxpbmVXaWR0aDogY3R4LmxpbmVXaWR0aCxcbiAgICAgICAgICBkYXNoZXM6IGN0eC5kYXNoZXNcbiAgICAgICAgfTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHZhbHVlcy5iYWNrZ3JvdW5kU2l6ZTtcbiAgICAgICAgdGhpcy5zZXRTdHJva2VEYXNoZWQoY3R4LCB2YWx1ZXMuYmFja2dyb3VuZERhc2hlcyk7XG4gICAgICAgIGN0eC5zdHJva2UoKTsgLy8gcmVzdG9yZSBvcmlnaW5hbCBsaW5lIGF0dHJzXG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3JpZ0N0eEF0dHIuc3Ryb2tlU3R5bGU7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcmlnQ3R4QXR0ci5saW5lV2lkdGg7XG4gICAgICAgIGN0eC5kYXNoZXMgPSBvcmlnQ3R4QXR0ci5kYXNoZXM7XG4gICAgICAgIHRoaXMuc2V0U3Ryb2tlRGFzaGVkKGN0eCwgdmFsdWVzLmRhc2hlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBsaW5lIGRhc2ggcGF0dGVybiBpZiBzdXBwb3J0ZWQuIExvZ3MgYSB3YXJuaW5nIHRvIHRoZSBjb25zb2xlIGlmIGl0IGlzbid0IHN1cHBvcnRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSBkYXNoZXMgLSBUaGUgcGF0dGVybiBbbGluZSwgc3BhY2UsIGxpbmXigKZdLCB0cnVlIGZvciBkZWZhdWx0IGRhc2hlZCBsaW5lIG9yIGZhbHNlIGZvciBub3JtYWwgbGluZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U3Ryb2tlRGFzaGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0cm9rZURhc2hlZChjdHgsIGRhc2hlcykge1xuICAgICAgaWYgKGRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBpc0FycmF5JDIoZGFzaGVzKSA/IGRhc2hlcyA6IFs1LCA1XTtcbiAgICAgICAgICBjdHguc2V0TGluZURhc2gocGF0dGVybik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgc3Ryb2tlIGNhbm5vdCBiZSB1c2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBzdHJva2UgY2Fubm90IGJlIHVzZWQuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVkZ2VCYXNlO1xufSgpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBrZXlzJDQob2JqZWN0KTsgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IGZpbHRlcihzeW1ib2xzKS5jYWxsKHN5bWJvbHMsIGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgX2NvbnRleHQsIF9jb250ZXh0MjsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gZm9yRWFjaCQyKF9jb250ZXh0ID0gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApKS5jYWxsKF9jb250ZXh0LCBmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IGZvckVhY2gkMihfY29udGV4dDIgPSBvd25LZXlzKE9iamVjdChzb3VyY2UpKSkuY2FsbChfY29udGV4dDIsIGZ1bmN0aW9uIChrZXkpIHsgZGVmaW5lUHJvcGVydHkkNih0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMoc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkOShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ5KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkOSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcclxuICogVGhlIEJhc2UgQ2xhc3MgZm9yIGFsbCBCZXppZXIgZWRnZXMuXHJcbiAqIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWwgc21vb3RoIGdyYWR1YWwgY3VydmVzIGluIHBhdGhzIGJldHdlZW4gbm9kZXMuXHJcbiAqL1xuXG52YXIgQmV6aWVyRWRnZUJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FZGdlQmFzZSkge1xuICBfaW5oZXJpdHMoQmV6aWVyRWRnZUJhc2UsIF9FZGdlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ5KEJlemllckVkZ2VCYXNlKTtcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBvZiBnaXZlbiBlZGdlLlxyXG4gICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIGxhYmVsTW9kdWxlIC0gTGFiZWwgbW9kdWxlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBCZXppZXJFZGdlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCZXppZXJFZGdlQmFzZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUgYW5kIHRoZSBlZGdlLlxyXG4gICAqXHJcbiAgICogQHJlbWFya3NcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYmluYXJ5IHNlYXJjaCB0byBsb29rIGZvciB0aGUgcG9pbnQgd2hlcmUgdGhlIGJlemllciBjdXJ2ZSBjcm9zc2VzIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUuXHJcbiAgICogQHBhcmFtIG5lYXJOb2RlIC0gVGhlIG5vZGUgKGVpdGhlciBmcm9tIG9yIHRvIG5vZGUgb2YgdGhlIGVkZ2UpLlxyXG4gICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAqIEBwYXJhbSB2aWFOb2RlIC0gQWRkaXRpb25hbCBub2RlKHMpIHRoZSBlZGdlIHBhc3NlcyB0aHJvdWdoLlxyXG4gICAqIEByZXR1cm5zIENhcnRlc2lhbiBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIGJvcmRlciBvZiB0aGUgbm9kZSBhbmQgdGhlIGVkZ2UuXHJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQmV6aWVyRWRnZUJhc2UsIFt7XG4gICAga2V5OiBcIl9maW5kQm9yZGVyUG9zaXRpb25CZXppZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKTtcbiAgICAgIHZhciBtYXhJdGVyYXRpb25zID0gMTA7XG4gICAgICB2YXIgdGhyZXNob2xkID0gMC4yO1xuICAgICAgdmFyIGZyb20gPSBmYWxzZTtcbiAgICAgIHZhciBoaWdoID0gMTtcbiAgICAgIHZhciBsb3cgPSAwO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnRvO1xuICAgICAgdmFyIHBvcztcbiAgICAgIHZhciBtaWRkbGU7XG4gICAgICB2YXIgZW5kUG9pbnRPZmZzZXQgPSB0aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQgPyB0aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG8gOiAwO1xuXG4gICAgICBpZiAobmVhck5vZGUuaWQgPT09IHRoaXMuZnJvbS5pZCkge1xuICAgICAgICBub2RlID0gdGhpcy5mcm9tO1xuICAgICAgICBmcm9tID0gdHJ1ZTtcbiAgICAgICAgZW5kUG9pbnRPZmZzZXQgPSB0aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQgPyB0aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSA6IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoID09PSBmYWxzZSkge1xuICAgICAgICBlbmRQb2ludE9mZnNldCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRpb24gPSAwO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAqIDAuNTtcbiAgICAgICAgcG9zID0gdGhpcy5nZXRQb2ludChtaWRkbGUsIHZpYU5vZGUpO1xuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUueSAtIHBvcy55LCBub2RlLnggLSBwb3MueCk7XG4gICAgICAgIHZhciBkaXN0YW5jZVRvQm9yZGVyID0gbm9kZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpICsgZW5kUG9pbnRPZmZzZXQ7XG4gICAgICAgIHZhciBkaXN0YW5jZVRvUG9pbnQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocG9zLnggLSBub2RlLngsIDIpICsgTWF0aC5wb3cocG9zLnkgLSBub2RlLnksIDIpKTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSBkaXN0YW5jZVRvQm9yZGVyIC0gZGlzdGFuY2VUb1BvaW50O1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhkaWZmZXJlbmNlKSA8IHRocmVzaG9sZCkge1xuICAgICAgICAgIGJyZWFrOyAvLyBmb3VuZFxuICAgICAgICB9IGVsc2UgaWYgKGRpZmZlcmVuY2UgPCAwKSB7XG4gICAgICAgICAgLy8gZGlzdGFuY2UgdG8gbm9kZXMgaXMgbGFyZ2VyIHRoYW4gZGlzdGFuY2UgdG8gYm9yZGVyIC0tPiB0IG5lZWRzIHRvIGJlIGJpZ2dlciBpZiB3ZSdyZSBsb29raW5nIGF0IHRoZSB0byBub2RlLlxuICAgICAgICAgIGlmIChmcm9tID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbG93ID0gbWlkZGxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZnJvbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICArK2l0ZXJhdGlvbjtcbiAgICAgIH0gd2hpbGUgKGxvdyA8PSBoaWdoICYmIGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnMpO1xuXG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwb3MpLCB7fSwge1xuICAgICAgICB0OiBtaWRkbGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIHBvaW50ICh4Myx5MykgYW5kIGEgbGluZSBzZWdtZW50IGZyb20gKHgxLHkxKSB0byAoeDIseTIpLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0OTIxMS9zaG9ydGVzdC1kaXN0YW5jYWUtYmV0d2Vlbi1hLXBvaW50LWFuZC1hLWxpbmUtc2VnbWVudFxyXG4gICAgICogQHBhcmFtIHgxIC0gRmlyc3QgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5MSAtIEZpcnN0IGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geDIgLSBTZWNvbmQgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeSBheGlzLlxyXG4gICAgICogQHBhcmFtIHgzIC0gUG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geTMgLSBQb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSB2aWEgLSBUaGUgY29udHJvbCBwb2ludCBmb3IgdGhlIGVkZ2UuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGluZSBzZWdtZW50IGFuZCB0aGUgcG9pbnQuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhKSB7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHZhciBtaW5EaXN0YW5jZSA9IDFlOTtcbiAgICAgIHZhciBkaXN0YW5jZTtcbiAgICAgIHZhciBpLCB0LCB4LCB5O1xuICAgICAgdmFyIGxhc3RYID0geDE7XG4gICAgICB2YXIgbGFzdFkgPSB5MTtcblxuICAgICAgZm9yIChpID0gMTsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgdCA9IDAuMSAqIGk7XG4gICAgICAgIHggPSBNYXRoLnBvdygxIC0gdCwgMikgKiB4MSArIDIgKiB0ICogKDEgLSB0KSAqIHZpYS54ICsgTWF0aC5wb3codCwgMikgKiB4MjtcbiAgICAgICAgeSA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHkxICsgMiAqIHQgKiAoMSAtIHQpICogdmlhLnkgKyBNYXRoLnBvdyh0LCAyKSAqIHkyO1xuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGRpc3RhbmNlID0gdGhpcy5fZ2V0RGlzdGFuY2VUb0xpbmUobGFzdFgsIGxhc3RZLCB4LCB5LCB4MywgeTMpO1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSA/IGRpc3RhbmNlIDogbWluRGlzdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pbkRpc3RhbmNlO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlbmRlciBhIGJlemllciBjdXJ2ZSBiZXR3ZWVuIHR3byBub2Rlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogVGhlIG1ldGhvZCBhY2NlcHRzIHplcm8sIG9uZSBvciB0d28gY29udHJvbCBwb2ludHMuXHJcbiAgICAgKiBQYXNzaW5nIHplcm8gY29udHJvbCBwb2ludHMganVzdCBkcmF3cyBhIHN0cmFpZ2h0IGxpbmUuXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBTdHlsZSBvcHRpb25zIGZvciBlZGdlIGRyYXdpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmlhTm9kZTEgLSBGaXJzdCBjb250cm9sIHBvaW50IGZvciBjdXJ2ZSBkcmF3aW5nLlxyXG4gICAgICogQHBhcmFtIHZpYU5vZGUyIC0gU2Vjb25kIGNvbnRyb2wgcG9pbnQgZm9yIGN1cnZlIGRyYXdpbmcuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9iZXppZXJDdXJ2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmV6aWVyQ3VydmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUxLCB2aWFOb2RlMikge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh0aGlzLmZyb21Qb2ludC54LCB0aGlzLmZyb21Qb2ludC55KTtcblxuICAgICAgaWYgKHZpYU5vZGUxICE9IG51bGwgJiYgdmlhTm9kZTEueCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh2aWFOb2RlMiAhPSBudWxsICYmIHZpYU5vZGUyLnggIT0gbnVsbCkge1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHZpYU5vZGUxLngsIHZpYU5vZGUxLnksIHZpYU5vZGUyLngsIHZpYU5vZGUyLnksIHRoaXMudG9Qb2ludC54LCB0aGlzLnRvUG9pbnQueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8odmlhTm9kZTEueCwgdmlhTm9kZTEueSwgdGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gbm9ybWFsIHN0cmFpZ2h0IGVkZ2VcbiAgICAgICAgY3R4LmxpbmVUbyh0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpO1xuICAgICAgfSAvLyBkcmF3IGEgYmFja2dyb3VuZFxuXG5cbiAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQoY3R4LCB2YWx1ZXMpOyAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG5cbiAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmlhTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJlemllckVkZ2VCYXNlO1xufShFZGdlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQ4KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDgoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ4KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBBIER5bmFtaWMgQmV6aWVyIEVkZ2UuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWwgc21vb3RoIGdyYWR1YWxcclxuICogY3VydmVzIGluIHBhdGhzIGJldHdlZW4gbm9kZXMuIFRoZSBEeW5hbWljIHBpZWNlIHJlZmVycyB0byBob3cgdGhlIGN1cnZlXHJcbiAqIHJlYWN0cyB0byBwaHlzaWNzIGNoYW5nZXMuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBCZXppZXJFZGdlQmFzZVxyXG4gKi9cblxudmFyIEJlemllckVkZ2VEeW5hbWljID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmV6aWVyRWRnZUJhc2UpIHtcbiAgX2luaGVyaXRzKEJlemllckVkZ2VEeW5hbWljLCBfQmV6aWVyRWRnZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkOChCZXppZXJFZGdlRHluYW1pYyk7XG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3Qgb2YgZ2l2ZW4gZWRnZS5cclxuICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSBuZXR3b3JrLlxyXG4gICAqIEBwYXJhbSBsYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gQmV6aWVyRWRnZUR5bmFtaWMob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmV6aWVyRWRnZUR5bmFtaWMpO1xuXG4gICAgLy90aGlzLnZpYSA9IHVuZGVmaW5lZDsgLy8gSGVyZSBmb3IgY29tcGxldGVuZXNzIGJ1dCBub3QgYWxsb3dlZCB0byBkZWZpbmVkIGJlZm9yZSBzdXBlcigpIGlzIGludm9rZWQuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7IC8vIC0tPiB0aGlzIGNhbGxzIHRoZSBzZXRPcHRpb25zIGJlbG93XG5cbiAgICBfdGhpcy52aWEgPSBfdGhpcy52aWE7IC8vIGNvbnN0cnVjdG9yIOKGkiBzdXBlciDihpIgc3VwZXIg4oaSIHNldE9wdGlvbnMg4oaSIHNldHVwU3VwcG9ydE5vZGVcblxuICAgIF90aGlzLl9ib3VuZEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucG9zaXRpb25CZXppZXJOb2RlKCk7XG4gICAgfTtcblxuICAgIF90aGlzLl9ib2R5LmVtaXR0ZXIub24oXCJfcmVwb3NpdGlvbkJlemllck5vZGVzXCIsIF90aGlzLl9ib3VuZEZ1bmN0aW9uKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhCZXppZXJFZGdlRHluYW1pYywgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEJlemllckVkZ2VEeW5hbWljLnByb3RvdHlwZSksIFwic2V0T3B0aW9uc1wiLCB0aGlzKS5jYWxsKHRoaXMsIG9wdGlvbnMpOyAvLyBjaGVjayBpZiB0aGUgcGh5c2ljcyBoYXMgY2hhbmdlZC5cblxuXG4gICAgICB2YXIgcGh5c2ljc0NoYW5nZSA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBoeXNpY3MgIT09IG9wdGlvbnMucGh5c2ljcykge1xuICAgICAgICBwaHlzaWNzQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIH0gLy8gc2V0IHRoZSBvcHRpb25zIGFuZCB0aGUgdG8gYW5kIGZyb20gbm9kZXNcblxuXG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZDtcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dO1xuICAgICAgdGhpcy50byA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXTsgLy8gc2V0dXAgdGhlIHN1cHBvcnQgbm9kZSBhbmQgY29ubmVjdFxuXG4gICAgICB0aGlzLnNldHVwU3VwcG9ydE5vZGUoKTtcbiAgICAgIHRoaXMuY29ubmVjdCgpOyAvLyB3aGVuIHdlIGNoYW5nZSB0aGUgcGh5c2ljcyBzdGF0ZSBvZiB0aGUgZWRnZSwgd2UgcmVwb3NpdGlvbiB0aGUgc3VwcG9ydCBub2RlLlxuXG4gICAgICBpZiAocGh5c2ljc0NoYW5nZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHtcbiAgICAgICAgICBwaHlzaWNzOiB0aGlzLm9wdGlvbnMucGh5c2ljc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkJlemllck5vZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICB0aGlzLmZyb20gPSB0aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy5mcm9tXTtcbiAgICAgIHRoaXMudG8gPSB0aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG5cbiAgICAgIGlmICh0aGlzLmZyb20gPT09IHVuZGVmaW5lZCB8fCB0aGlzLnRvID09PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLnBoeXNpY3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMudmlhLnNldE9wdGlvbnMoe1xuICAgICAgICAgIHBoeXNpY3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZml4IHdlaXJkIGJlaGF2aW91ciB3aGVyZSBhIHNlbGYgcmVmZXJlbmNpbmcgbm9kZSBoYXMgcGh5c2ljcyBlbmFibGVkXG4gICAgICAgIGlmICh0aGlzLmZyb20uaWQgPT09IHRoaXMudG8uaWQpIHtcbiAgICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIHBoeXNpY3M6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52aWEuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBwaHlzaWNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGVhbnVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICB0aGlzLl9ib2R5LmVtaXR0ZXIub2ZmKFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiLCB0aGlzLl9ib3VuZEZ1bmN0aW9uKTtcblxuICAgICAgaWYgKHRoaXMudmlhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2JvZHkubm9kZXNbdGhpcy52aWEuaWRdO1xuICAgICAgICB0aGlzLnZpYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW5kIGFkZCBhIHN1cHBvcnQgbm9kZSBpZiBub3QgYWxyZWFkeSBwcmVzZW50LlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBCZXppZXIgY3VydmVzIHJlcXVpcmUgYW4gYW5jaG9yIHBvaW50IHRvIGNhbGN1bGF0ZSB0aGUgc21vb3RoIGZsb3cuXHJcbiAgICAgKiBUaGVzZSBwb2ludHMgYXJlIG5vZGVzLlxyXG4gICAgICogVGhlc2Ugbm9kZXMgYXJlIGludmlzaWJsZSBidXQgYXJlIHVzZWQgZm9yIHRoZSBmb3JjZSBjYWxjdWxhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgY2hhbmdlZCBkYXRhIGlzIG5vdCBjYWxsZWQsIGlmIG5lZWRlZCwgaXQgaXMgcmV0dXJuZWQgYnkgdGhlIG1haW4gZWRnZSBjb25zdHJ1Y3Rvci5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBTdXBwb3J0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFN1cHBvcnROb2RlKCkge1xuICAgICAgaWYgKHRoaXMudmlhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IFwiZWRnZUlkOlwiICsgdGhpcy5pZDtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2JvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUoe1xuICAgICAgICAgIGlkOiBub2RlSWQsXG4gICAgICAgICAgc2hhcGU6IFwiY2lyY2xlXCIsXG4gICAgICAgICAgcGh5c2ljczogdHJ1ZSxcbiAgICAgICAgICBoaWRkZW46IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYm9keS5ub2Rlc1tub2RlSWRdID0gbm9kZTtcbiAgICAgICAgdGhpcy52aWEgPSBub2RlO1xuICAgICAgICB0aGlzLnZpYS5wYXJlbnRFZGdlSWQgPSB0aGlzLmlkO1xuICAgICAgICB0aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFBvc2l0aW9uIGJlemllciBub2RlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwb3NpdGlvbkJlemllck5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb25CZXppZXJOb2RlKCkge1xuICAgICAgaWYgKHRoaXMudmlhICE9PSB1bmRlZmluZWQgJiYgdGhpcy5mcm9tICE9PSB1bmRlZmluZWQgJiYgdGhpcy50byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudmlhLnggPSAwLjUgKiAodGhpcy5mcm9tLnggKyB0aGlzLnRvLngpO1xuICAgICAgICB0aGlzLnZpYS55ID0gMC41ICogKHRoaXMuZnJvbS55ICsgdGhpcy50by55KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy52aWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZpYS54ID0gMDtcbiAgICAgICAgdGhpcy52aWEueSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpIHtcbiAgICAgIHRoaXMuX2JlemllckN1cnZlKGN0eCwgdmFsdWVzLCB2aWFOb2RlKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VmlhQ29vcmRpbmF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZpYUNvb3JkaW5hdGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlhO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZpYU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpYTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludChwb3NpdGlvbikge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMudmlhO1xuXG4gICAgICBpZiAodGhpcy5mcm9tID09PSB0aGlzLnRvKSB7XG4gICAgICAgIHZhciBfdGhpcyRfZ2V0Q2lyY2xlRGF0YSA9IHRoaXMuX2dldENpcmNsZURhdGEoKSxcbiAgICAgICAgICAgIF90aGlzJF9nZXRDaXJjbGVEYXRhMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRDaXJjbGVEYXRhLCAzKSxcbiAgICAgICAgICAgIGN4ID0gX3RoaXMkX2dldENpcmNsZURhdGEyWzBdLFxuICAgICAgICAgICAgY3kgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTJbMV0sXG4gICAgICAgICAgICBjciA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlsyXTtcblxuICAgICAgICB2YXIgYSA9IDIgKiBNYXRoLlBJICogKDEgLSBwb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogY3ggKyBjciAqIE1hdGguc2luKGEpLFxuICAgICAgICAgIHk6IGN5ICsgY3IgLSBjciAqICgxIC0gTWF0aC5jb3MoYSkpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IE1hdGgucG93KDEgLSBwb3NpdGlvbiwgMikgKiB0aGlzLmZyb21Qb2ludC54ICsgMiAqIHBvc2l0aW9uICogKDEgLSBwb3NpdGlvbikgKiB2aWFOb2RlLnggKyBNYXRoLnBvdyhwb3NpdGlvbiwgMikgKiB0aGlzLnRvUG9pbnQueCxcbiAgICAgICAgICB5OiBNYXRoLnBvdygxIC0gcG9zaXRpb24sIDIpICogdGhpcy5mcm9tUG9pbnQueSArIDIgKiBwb3NpdGlvbiAqICgxIC0gcG9zaXRpb24pICogdmlhTm9kZS55ICsgTWF0aC5wb3cocG9zaXRpb24sIDIpICogdGhpcy50b1BvaW50LnlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcihuZWFyTm9kZSwgY3R4LCB0aGlzLnZpYSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9FZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0aGlzLnZpYSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJlemllckVkZ2VEeW5hbWljO1xufShCZXppZXJFZGdlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQ3KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDcoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ3KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBBIFN0YXRpYyBCZXppZXIgRWRnZS4gQmV6aWVyIGN1cnZlcyBhcmUgdXNlZCB0byBtb2RlbCBzbW9vdGggZ3JhZHVhbCBjdXJ2ZXMgaW4gcGF0aHMgYmV0d2VlbiBub2Rlcy5cclxuICovXG5cbnZhciBCZXppZXJFZGdlU3RhdGljID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmV6aWVyRWRnZUJhc2UpIHtcbiAgX2luaGVyaXRzKEJlemllckVkZ2VTdGF0aWMsIF9CZXppZXJFZGdlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ3KEJlemllckVkZ2VTdGF0aWMpO1xuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgbmV0d29yay5cclxuICAgKiBAcGFyYW0gbGFiZWxNb2R1bGUgLSBMYWJlbCBtb2R1bGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEJlemllckVkZ2VTdGF0aWMob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmV6aWVyRWRnZVN0YXRpYyk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEJlemllckVkZ2VTdGF0aWMsIFt7XG4gICAga2V5OiBcIl9saW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlKSB7XG4gICAgICB0aGlzLl9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmlhTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHZpYSBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBXZSBkbyBub3QgdXNlIHRoZSB0byBhbmQgZnJvbVBvaW50cyBoZXJlIHRvIG1ha2UgdGhlIHZpYSBub2RlcyB0aGUgc2FtZSBhcyBlZGdlcyB3aXRob3V0IGFycm93cy5cclxuICAgICAqIEByZXR1cm5zIENhcnRlc2lhbiBjb29yZGluYXRlcyBvZiB0aGUgdmlhIG5vZGUuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWaWFDb29yZGluYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmlhQ29vcmRpbmF0ZXMoKSB7XG4gICAgICAvLyBBc3N1bXB0aW9uOiB4L3kgY29vcmRpbmF0ZXMgaW4gZnJvbS90byBhbHdheXMgZGVmaW5lZFxuICAgICAgdmFyIGZhY3RvciA9IHRoaXMub3B0aW9ucy5zbW9vdGgucm91bmRuZXNzO1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLm9wdGlvbnMuc21vb3RoLnR5cGU7XG4gICAgICB2YXIgZHggPSBNYXRoLmFicyh0aGlzLmZyb20ueCAtIHRoaXMudG8ueCk7XG4gICAgICB2YXIgZHkgPSBNYXRoLmFicyh0aGlzLmZyb20ueSAtIHRoaXMudG8ueSk7XG5cbiAgICAgIGlmICh0eXBlID09PSBcImRpc2NyZXRlXCIgfHwgdHlwZSA9PT0gXCJkaWFnb25hbENyb3NzXCIpIHtcbiAgICAgICAgdmFyIHN0ZXBYO1xuICAgICAgICB2YXIgc3RlcFk7XG5cbiAgICAgICAgaWYgKGR4IDw9IGR5KSB7XG4gICAgICAgICAgc3RlcFggPSBzdGVwWSA9IGZhY3RvciAqIGR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ZXBYID0gc3RlcFkgPSBmYWN0b3IgKiBkeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZyb20ueCA+IHRoaXMudG8ueCkge1xuICAgICAgICAgIHN0ZXBYID0gLXN0ZXBYO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZnJvbS55ID49IHRoaXMudG8ueSkge1xuICAgICAgICAgIHN0ZXBZID0gLXN0ZXBZO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhWaWEgPSB0aGlzLmZyb20ueCArIHN0ZXBYO1xuICAgICAgICB2YXIgeVZpYSA9IHRoaXMuZnJvbS55ICsgc3RlcFk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZGlzY3JldGVcIikge1xuICAgICAgICAgIGlmIChkeCA8PSBkeSkge1xuICAgICAgICAgICAgeFZpYSA9IGR4IDwgZmFjdG9yICogZHkgPyB0aGlzLmZyb20ueCA6IHhWaWE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlWaWEgPSBkeSA8IGZhY3RvciAqIGR4ID8gdGhpcy5mcm9tLnkgOiB5VmlhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeFZpYSxcbiAgICAgICAgICB5OiB5VmlhXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic3RyYWlnaHRDcm9zc1wiKSB7XG4gICAgICAgIHZhciBfc3RlcFggPSAoMSAtIGZhY3RvcikgKiBkeDtcblxuICAgICAgICB2YXIgX3N0ZXBZID0gKDEgLSBmYWN0b3IpICogZHk7XG5cbiAgICAgICAgaWYgKGR4IDw9IGR5KSB7XG4gICAgICAgICAgLy8gdXAgLSBkb3duXG4gICAgICAgICAgX3N0ZXBYID0gMDtcblxuICAgICAgICAgIGlmICh0aGlzLmZyb20ueSA8IHRoaXMudG8ueSkge1xuICAgICAgICAgICAgX3N0ZXBZID0gLV9zdGVwWTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGVmdCAtIHJpZ2h0XG4gICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDwgdGhpcy50by54KSB7XG4gICAgICAgICAgICBfc3RlcFggPSAtX3N0ZXBYO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9zdGVwWSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRoaXMudG8ueCArIF9zdGVwWCxcbiAgICAgICAgICB5OiB0aGlzLnRvLnkgKyBfc3RlcFlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgdmFyIF9zdGVwWDIgPSAoMSAtIGZhY3RvcikgKiBkeDtcblxuICAgICAgICBpZiAodGhpcy5mcm9tLnggPCB0aGlzLnRvLngpIHtcbiAgICAgICAgICBfc3RlcFgyID0gLV9zdGVwWDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRoaXMudG8ueCArIF9zdGVwWDIsXG4gICAgICAgICAgeTogdGhpcy5mcm9tLnlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgIHZhciBfc3RlcFkyID0gKDEgLSBmYWN0b3IpICogZHk7XG5cbiAgICAgICAgaWYgKHRoaXMuZnJvbS55IDwgdGhpcy50by55KSB7XG4gICAgICAgICAgX3N0ZXBZMiA9IC1fc3RlcFkyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0aGlzLmZyb20ueCxcbiAgICAgICAgICB5OiB0aGlzLnRvLnkgKyBfc3RlcFkyXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY3VydmVkQ1dcIikge1xuICAgICAgICBkeCA9IHRoaXMudG8ueCAtIHRoaXMuZnJvbS54O1xuICAgICAgICBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgdmFyIHBpID0gTWF0aC5QSTtcbiAgICAgICAgdmFyIG9yaWdpbmFsQW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgICAgIHZhciBteUFuZ2xlID0gKG9yaWdpbmFsQW5nbGUgKyAoZmFjdG9yICogMC41ICsgMC41KSAqIHBpKSAlICgyICogcGkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRoaXMuZnJvbS54ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiByYWRpdXMgKiBNYXRoLnNpbihteUFuZ2xlKSxcbiAgICAgICAgICB5OiB0aGlzLmZyb20ueSArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogcmFkaXVzICogTWF0aC5jb3MobXlBbmdsZSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjdXJ2ZWRDQ1dcIikge1xuICAgICAgICBkeCA9IHRoaXMudG8ueCAtIHRoaXMuZnJvbS54O1xuICAgICAgICBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuXG4gICAgICAgIHZhciBfcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICB2YXIgX3BpID0gTWF0aC5QSTtcblxuICAgICAgICB2YXIgX29yaWdpbmFsQW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG5cbiAgICAgICAgdmFyIF9teUFuZ2xlID0gKF9vcmlnaW5hbEFuZ2xlICsgKC1mYWN0b3IgKiAwLjUgKyAwLjUpICogX3BpKSAlICgyICogX3BpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRoaXMuZnJvbS54ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiBfcmFkaXVzICogTWF0aC5zaW4oX215QW5nbGUpLFxuICAgICAgICAgIHk6IHRoaXMuZnJvbS55ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiBfcmFkaXVzICogTWF0aC5jb3MoX215QW5nbGUpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb250aW51b3VzXG4gICAgICAgIHZhciBfc3RlcFgzO1xuXG4gICAgICAgIHZhciBfc3RlcFkzO1xuXG4gICAgICAgIGlmIChkeCA8PSBkeSkge1xuICAgICAgICAgIF9zdGVwWDMgPSBfc3RlcFkzID0gZmFjdG9yICogZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3N0ZXBYMyA9IF9zdGVwWTMgPSBmYWN0b3IgKiBkeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZyb20ueCA+IHRoaXMudG8ueCkge1xuICAgICAgICAgIF9zdGVwWDMgPSAtX3N0ZXBYMztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZyb20ueSA+PSB0aGlzLnRvLnkpIHtcbiAgICAgICAgICBfc3RlcFkzID0gLV9zdGVwWTM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3hWaWEgPSB0aGlzLmZyb20ueCArIF9zdGVwWDM7XG5cbiAgICAgICAgdmFyIF95VmlhID0gdGhpcy5mcm9tLnkgKyBfc3RlcFkzO1xuXG4gICAgICAgIGlmIChkeCA8PSBkeSkge1xuICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8PSB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgIF94VmlhID0gdGhpcy50by54IDwgX3hWaWEgPyB0aGlzLnRvLnggOiBfeFZpYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3hWaWEgPSB0aGlzLnRvLnggPiBfeFZpYSA/IHRoaXMudG8ueCA6IF94VmlhO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnkgPj0gdGhpcy50by55KSB7XG4gICAgICAgICAgICBfeVZpYSA9IHRoaXMudG8ueSA+IF95VmlhID8gdGhpcy50by55IDogX3lWaWE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF95VmlhID0gdGhpcy50by55IDwgX3lWaWEgPyB0aGlzLnRvLnkgOiBfeVZpYTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IF94VmlhLFxuICAgICAgICAgIHk6IF95VmlhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRCb3JkZXJQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCwgb3B0aW9ucy52aWEpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaXN0YW5jZVRvRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWFOb2RlKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludChwb3NpdGlvbikge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgICB2YXIgdCA9IHBvc2l0aW9uO1xuICAgICAgdmFyIHggPSBNYXRoLnBvdygxIC0gdCwgMikgKiB0aGlzLmZyb21Qb2ludC54ICsgMiAqIHQgKiAoMSAtIHQpICogdmlhTm9kZS54ICsgTWF0aC5wb3codCwgMikgKiB0aGlzLnRvUG9pbnQueDtcbiAgICAgIHZhciB5ID0gTWF0aC5wb3coMSAtIHQsIDIpICogdGhpcy5mcm9tUG9pbnQueSArIDIgKiB0ICogKDEgLSB0KSAqIHZpYU5vZGUueSArIE1hdGgucG93KHQsIDIpICogdGhpcy50b1BvaW50Lnk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCZXppZXJFZGdlU3RhdGljO1xufShCZXppZXJFZGdlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQ2KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDYoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ2KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBBIEJhc2UgQ2xhc3MgZm9yIGFsbCBDdWJpYyBCZXppZXIgRWRnZXMuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWxcclxuICogc21vb3RoIGdyYWR1YWwgY3VydmVzIGluIHBhdGhzIGJldHdlZW4gbm9kZXMuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBCZXppZXJFZGdlQmFzZVxyXG4gKi9cblxudmFyIEN1YmljQmV6aWVyRWRnZUJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CZXppZXJFZGdlQmFzZSkge1xuICBfaW5oZXJpdHMoQ3ViaWNCZXppZXJFZGdlQmFzZSwgX0JlemllckVkZ2VCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDYoQ3ViaWNCZXppZXJFZGdlQmFzZSk7XG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3Qgb2YgZ2l2ZW4gZWRnZS5cclxuICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSBuZXR3b3JrLlxyXG4gICAqIEBwYXJhbSBsYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gQ3ViaWNCZXppZXJFZGdlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdWJpY0JlemllckVkZ2VCYXNlKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgKHgzLHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbSAoeDEseTEpIHRvICh4Mix5MikuXHJcbiAgICpcclxuICAgKiBAcmVtYXJrc1xyXG4gICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ5MjExL3Nob3J0ZXN0LWRpc3RhbmNhZS1iZXR3ZWVuLWEtcG9pbnQtYW5kLWEtbGluZS1zZWdtZW50XHJcbiAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQiVDMyVBOXppZXJfY3VydmVcclxuICAgKiBAcGFyYW0geDEgLSBGaXJzdCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAqIEBwYXJhbSB5MSAtIEZpcnN0IGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICogQHBhcmFtIHgyIC0gU2Vjb25kIGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICogQHBhcmFtIHkyIC0gU2Vjb25kIGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICogQHBhcmFtIHgzIC0gUG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICogQHBhcmFtIHkzIC0gUG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICogQHBhcmFtIHZpYTEgLSBUaGUgZmlyc3QgcG9pbnQgdGhpcyBlZGdlIHBhc3NlcyB0aHJvdWdoLlxyXG4gICAqIEBwYXJhbSB2aWEyIC0gVGhlIHNlY29uZCBwb2ludCB0aGlzIGVkZ2UgcGFzc2VzIHRocm91Z2guXHJcbiAgICogQHJldHVybnMgVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGxpbmUgc2VnbWVudCBhbmQgdGhlIHBvaW50LlxyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEN1YmljQmV6aWVyRWRnZUJhc2UsIFt7XG4gICAga2V5OiBcIl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZTJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9CZXppZXJFZGdlMih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWExLCB2aWEyKSB7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHZhciBtaW5EaXN0YW5jZSA9IDFlOTtcbiAgICAgIHZhciBsYXN0WCA9IHgxO1xuICAgICAgdmFyIGxhc3RZID0geTE7XG4gICAgICB2YXIgdmVjID0gWzAsIDAsIDAsIDBdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgdmFyIHQgPSAwLjEgKiBpO1xuICAgICAgICB2ZWNbMF0gPSBNYXRoLnBvdygxIC0gdCwgMyk7XG4gICAgICAgIHZlY1sxXSA9IDMgKiB0ICogTWF0aC5wb3coMSAtIHQsIDIpO1xuICAgICAgICB2ZWNbMl0gPSAzICogTWF0aC5wb3codCwgMikgKiAoMSAtIHQpO1xuICAgICAgICB2ZWNbM10gPSBNYXRoLnBvdyh0LCAzKTtcbiAgICAgICAgdmFyIHggPSB2ZWNbMF0gKiB4MSArIHZlY1sxXSAqIHZpYTEueCArIHZlY1syXSAqIHZpYTIueCArIHZlY1szXSAqIHgyO1xuICAgICAgICB2YXIgeSA9IHZlY1swXSAqIHkxICsgdmVjWzFdICogdmlhMS55ICsgdmVjWzJdICogdmlhMi55ICsgdmVjWzNdICogeTI7XG5cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlID0gdGhpcy5fZ2V0RGlzdGFuY2VUb0xpbmUobGFzdFgsIGxhc3RZLCB4LCB5LCB4MywgeTMpO1xuXG4gICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZSA8IG1pbkRpc3RhbmNlID8gZGlzdGFuY2UgOiBtaW5EaXN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWluRGlzdGFuY2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1YmljQmV6aWVyRWRnZUJhc2U7XG59KEJlemllckVkZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDUoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDUoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIEEgQ3ViaWMgQmV6aWVyIEVkZ2UuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWwgc21vb3RoIGdyYWR1YWwgY3VydmVzIGluIHBhdGhzIGJldHdlZW4gbm9kZXMuXHJcbiAqL1xuXG52YXIgQ3ViaWNCZXppZXJFZGdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ3ViaWNCZXppZXJFZGdlQmFzZSkge1xuICBfaW5oZXJpdHMoQ3ViaWNCZXppZXJFZGdlLCBfQ3ViaWNCZXppZXJFZGdlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ1KEN1YmljQmV6aWVyRWRnZSk7XG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3Qgb2YgZ2l2ZW4gZWRnZS5cclxuICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSBuZXR3b3JrLlxyXG4gICAqIEBwYXJhbSBsYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gQ3ViaWNCZXppZXJFZGdlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1YmljQmV6aWVyRWRnZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEN1YmljQmV6aWVyRWRnZSwgW3tcbiAgICBrZXk6IFwiX2xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGVzKSB7XG4gICAgICAvLyBnZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBzdXBwb3J0IHBvaW50cy5cbiAgICAgIHZhciB2aWExID0gdmlhTm9kZXNbMF07XG4gICAgICB2YXIgdmlhMiA9IHZpYU5vZGVzWzFdO1xuXG4gICAgICB0aGlzLl9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhMSwgdmlhMik7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSB0aGUgYWRkaXRpb25hbCBwb2ludHMgdGhlIGVkZ2UgcGFzc2VzIHRocm91Z2guXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludHMgdGhlIGVkZ2UgcGFzc2VzIHRocm91Z2guXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWaWFDb29yZGluYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmlhQ29vcmRpbmF0ZXMoKSB7XG4gICAgICB2YXIgZHggPSB0aGlzLmZyb20ueCAtIHRoaXMudG8ueDtcbiAgICAgIHZhciBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuICAgICAgdmFyIHgxO1xuICAgICAgdmFyIHkxO1xuICAgICAgdmFyIHgyO1xuICAgICAgdmFyIHkyO1xuICAgICAgdmFyIHJvdW5kbmVzcyA9IHRoaXMub3B0aW9ucy5zbW9vdGgucm91bmRuZXNzOyAvLyBob3Jpem9udGFsIGlmIHggPiB5IG9yIGlmIGRpcmVjdGlvbiBpcyBmb3JjZWQgb3IgaWYgZGlyZWN0aW9uIGlzIGhvcml6b250YWxcblxuICAgICAgaWYgKChNYXRoLmFicyhkeCkgPiBNYXRoLmFicyhkeSkgfHwgdGhpcy5vcHRpb25zLnNtb290aC5mb3JjZURpcmVjdGlvbiA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMuc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIikgJiYgdGhpcy5vcHRpb25zLnNtb290aC5mb3JjZURpcmVjdGlvbiAhPT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgIHkxID0gdGhpcy5mcm9tLnk7XG4gICAgICAgIHkyID0gdGhpcy50by55O1xuICAgICAgICB4MSA9IHRoaXMuZnJvbS54IC0gcm91bmRuZXNzICogZHg7XG4gICAgICAgIHgyID0gdGhpcy50by54ICsgcm91bmRuZXNzICogZHg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5MSA9IHRoaXMuZnJvbS55IC0gcm91bmRuZXNzICogZHk7XG4gICAgICAgIHkyID0gdGhpcy50by55ICsgcm91bmRuZXNzICogZHk7XG4gICAgICAgIHgxID0gdGhpcy5mcm9tLng7XG4gICAgICAgIHgyID0gdGhpcy50by54O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgeDogeDEsXG4gICAgICAgIHk6IHkxXG4gICAgICB9LCB7XG4gICAgICAgIHg6IHgyLFxuICAgICAgICB5OiB5MlxuICAgICAgfV07XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmlhTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRCb3JkZXJQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9FZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKSxcbiAgICAgICAgICBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgIHZpYTEgPSBfcmVmMlswXSxcbiAgICAgICAgICB2aWEyID0gX3JlZjJbMV07XG5cbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9CZXppZXJFZGdlMih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWExLCB2aWEyKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludChwb3NpdGlvbikge1xuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpLFxuICAgICAgICAgIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgICAgIHZpYTEgPSBfcmVmNFswXSxcbiAgICAgICAgICB2aWEyID0gX3JlZjRbMV07XG5cbiAgICAgIHZhciB0ID0gcG9zaXRpb247XG4gICAgICB2YXIgdmVjID0gW01hdGgucG93KDEgLSB0LCAzKSwgMyAqIHQgKiBNYXRoLnBvdygxIC0gdCwgMiksIDMgKiBNYXRoLnBvdyh0LCAyKSAqICgxIC0gdCksIE1hdGgucG93KHQsIDMpXTtcbiAgICAgIHZhciB4ID0gdmVjWzBdICogdGhpcy5mcm9tUG9pbnQueCArIHZlY1sxXSAqIHZpYTEueCArIHZlY1syXSAqIHZpYTIueCArIHZlY1szXSAqIHRoaXMudG9Qb2ludC54O1xuICAgICAgdmFyIHkgPSB2ZWNbMF0gKiB0aGlzLmZyb21Qb2ludC55ICsgdmVjWzFdICogdmlhMS55ICsgdmVjWzJdICogdmlhMi55ICsgdmVjWzNdICogdGhpcy50b1BvaW50Lnk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDdWJpY0JlemllckVkZ2U7XG59KEN1YmljQmV6aWVyRWRnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkNChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcclxuICogQSBTdHJhaWdodCBFZGdlLlxyXG4gKi9cblxudmFyIFN0cmFpZ2h0RWRnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VkZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhTdHJhaWdodEVkZ2UsIF9FZGdlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ0KFN0cmFpZ2h0RWRnZSk7XG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3Qgb2YgZ2l2ZW4gZWRnZS5cclxuICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSBuZXR3b3JrLlxyXG4gICAqIEBwYXJhbSBsYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gU3RyYWlnaHRFZGdlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmFpZ2h0RWRnZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFN0cmFpZ2h0RWRnZSwgW3tcbiAgICBrZXk6IFwiX2xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIC8vIGRyYXcgYSBzdHJhaWdodCBsaW5lXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHRoaXMuZnJvbVBvaW50LngsIHRoaXMuZnJvbVBvaW50LnkpO1xuICAgICAgY3R4LmxpbmVUbyh0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpOyAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG5cbiAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmlhTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludChwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKDEgLSBwb3NpdGlvbikgKiB0aGlzLmZyb21Qb2ludC54ICsgcG9zaXRpb24gKiB0aGlzLnRvUG9pbnQueCxcbiAgICAgICAgeTogKDEgLSBwb3NpdGlvbikgKiB0aGlzLmZyb21Qb2ludC55ICsgcG9zaXRpb24gKiB0aGlzLnRvUG9pbnQueVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgdmFyIG5vZGUxID0gdGhpcy50bztcbiAgICAgIHZhciBub2RlMiA9IHRoaXMuZnJvbTtcblxuICAgICAgaWYgKG5lYXJOb2RlLmlkID09PSB0aGlzLmZyb20uaWQpIHtcbiAgICAgICAgbm9kZTEgPSB0aGlzLmZyb207XG4gICAgICAgIG5vZGUyID0gdGhpcy50bztcbiAgICAgIH1cblxuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihub2RlMS55IC0gbm9kZTIueSwgbm9kZTEueCAtIG5vZGUyLngpO1xuICAgICAgdmFyIGR4ID0gbm9kZTEueCAtIG5vZGUyLng7XG4gICAgICB2YXIgZHkgPSBub2RlMS55IC0gbm9kZTIueTtcbiAgICAgIHZhciBlZGdlU2VnbWVudExlbmd0aCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICB2YXIgdG9Cb3JkZXJEaXN0ID0gbmVhck5vZGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIHZhciB0b0JvcmRlclBvaW50ID0gKGVkZ2VTZWdtZW50TGVuZ3RoIC0gdG9Cb3JkZXJEaXN0KSAvIGVkZ2VTZWdtZW50TGVuZ3RoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKDEgLSB0b0JvcmRlclBvaW50KSAqIG5vZGUyLnggKyB0b0JvcmRlclBvaW50ICogbm9kZTEueCxcbiAgICAgICAgeTogKDEgLSB0b0JvcmRlclBvaW50KSAqIG5vZGUyLnkgKyB0b0JvcmRlclBvaW50ICogbm9kZTEueSxcbiAgICAgICAgdDogMFxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGlzdGFuY2VUb0VkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9MaW5lKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHJhaWdodEVkZ2U7XG59KEVkZ2VCYXNlKTtcblxuLyoqXG4gKiBBbiBlZGdlIGNvbm5lY3RzIHR3byBub2RlcyBhbmQgaGFzIGEgc3BlY2lmaWMgZGlyZWN0aW9uLlxuICovXG5cbnZhciBFZGdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgICB2YWx1ZXMgc3BlY2lmaWMgdG8gdGhpcyBlZGdlLCBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJ2Zyb20nIGFuZCAndG8nXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5ICAgICAgICAgICBzaGFyZWQgc3RhdGUgZnJvbSBOZXR3b3JrIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TmV0d29yay5JbWFnZXN9IGltYWdlbGlzdCAgQSBsaXN0IHdpdGggaW1hZ2VzLiBPbmx5IG5lZWRlZCB3aGVuIHRoZSBlZGdlIGhhcyBpbWFnZSBhcnJvd3MuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxPcHRpb25zICBvcHRpb25zIGZyb20gdGhlIEVkZ2VzSGFuZGxlciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge29iamVjdH0gZGVmYXVsdE9wdGlvbnMgZGVmYXVsdCBvcHRpb25zIGZyb20gdGhlIEVkZ2VIYW5kbGVyIGluc3RhbmNlLiBWYWx1ZSBhbmQgcmVmZXJlbmNlIGFyZSBjb25zdGFudFxuICAgKi9cbiAgZnVuY3Rpb24gRWRnZShvcHRpb25zLCBib2R5LCBpbWFnZWxpc3QsIGdsb2JhbE9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2UpO1xuXG4gICAgaWYgKGJvZHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYm9keSBwcm92aWRlZFwiKTtcbiAgICB9IC8vIFNpbmNlIGdsb2JhbE9wdGlvbnMgaXMgY29uc3RhbnQgaW4gdmFsdWVzIGFzIHdlbGwgYXMgcmVmZXJlbmNlLFxuICAgIC8vIEZvbGxvd2luZyBuZWVkcyB0byBiZSBkb25lIG9ubHkgb25jZS5cblxuXG4gICAgdGhpcy5vcHRpb25zID0gYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMpO1xuICAgIHRoaXMuZ2xvYmFsT3B0aW9ucyA9IGdsb2JhbE9wdGlvbnM7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5pbWFnZWxpc3QgPSBpbWFnZWxpc3Q7IC8vIGluaXRpYWxpemUgdmFyaWFibGVzXG5cbiAgICB0aGlzLmlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnJvbUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9JZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5ob3ZlciA9IGZhbHNlO1xuICAgIHRoaXMubGFiZWxEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5iYXNlV2lkdGggPSB0aGlzLm9wdGlvbnMud2lkdGg7XG4gICAgdGhpcy5iYXNlRm9udFNpemUgPSB0aGlzLm9wdGlvbnMuZm9udC5zaXplO1xuICAgIHRoaXMuZnJvbSA9IHVuZGVmaW5lZDsgLy8gYSBub2RlXG5cbiAgICB0aGlzLnRvID0gdW5kZWZpbmVkOyAvLyBhIG5vZGVcblxuICAgIHRoaXMuZWRnZVR5cGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxhYmVsTW9kdWxlID0gbmV3IExhYmVsKHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLCB0cnVlXG4gICAgLyogSXQncyBhbiBlZGdlIGxhYmVsICovXG4gICAgKTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBvciBvdmVyd3JpdGUgb3B0aW9ucyBmb3IgdGhlIGVkZ2VcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgIGFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAgICogQHJldHVybnMge3VuZGVmaW5lZHxib29sZWFufSB1bmRlZmluZWQgaWYgbm8gb3B0aW9ucywgdHJ1ZSBpZiBsYXlvdXQgYWZmZWN0aW5nIGRhdGEgY2hhbmdlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhFZGdlLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRm9sbG93aW5nIG9wdGlvbnMgaWYgY2hhbmdlZCBhZmZlY3QgdGhlIGxheW91dC5cblxuXG4gICAgICB2YXIgYWZmZWN0c0xheW91dCA9IHR5cGVvZiBvcHRpb25zLnBoeXNpY3MgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5vcHRpb25zLnBoeXNpY3MgIT09IG9wdGlvbnMucGh5c2ljcyB8fCB0eXBlb2Ygb3B0aW9ucy5oaWRkZW4gIT09IFwidW5kZWZpbmVkXCIgJiYgKHRoaXMub3B0aW9ucy5oaWRkZW4gfHwgZmFsc2UpICE9PSAob3B0aW9ucy5oaWRkZW4gfHwgZmFsc2UpIHx8IHR5cGVvZiBvcHRpb25zLmZyb20gIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5vcHRpb25zLmZyb20gIT09IG9wdGlvbnMuZnJvbSB8fCB0eXBlb2Ygb3B0aW9ucy50byAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0aGlzLm9wdGlvbnMudG8gIT09IG9wdGlvbnMudG87XG4gICAgICBFZGdlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRydWUsIHRoaXMuZ2xvYmFsT3B0aW9ucyk7XG5cbiAgICAgIGlmIChvcHRpb25zLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmZyb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmZyb21JZCA9IG9wdGlvbnMuZnJvbTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRvSWQgPSBvcHRpb25zLnRvO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50aXRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSBvcHRpb25zLnRpdGxlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMudmFsdWUgPSBfcGFyc2VGbG9hdChvcHRpb25zLnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBpbGUgPSBbb3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zXTtcbiAgICAgIHRoaXMuY2hvb3NlciA9IGNob29zaWZ5KFwiZWRnZVwiLCBwaWxlKTsgLy8gdXBkYXRlIGxhYmVsIE1vZHVsZVxuXG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKG9wdGlvbnMpOyAvLyBVcGRhdGUgZWRnZSB0eXBlLCB0aGlzIGlmIGNoYW5nZWQgYWZmZWN0cyB0aGUgbGF5b3V0LlxuXG4gICAgICBhZmZlY3RzTGF5b3V0ID0gdGhpcy51cGRhdGVFZGdlVHlwZSgpIHx8IGFmZmVjdHNMYXlvdXQ7IC8vIGlmIGFueXRoaW5nIGhhcyBiZWVuIHVwZGF0ZXMsIHJlc2V0IHRoZSBzZWxlY3Rpb24gd2lkdGggYW5kIHRoZSBob3ZlciB3aWR0aFxuXG4gICAgICB0aGlzLl9zZXRJbnRlcmFjdGlvbldpZHRocygpOyAvLyBBIG5vZGUgaXMgY29ubmVjdGVkIHdoZW4gaXQgaGFzIGEgZnJvbSBhbmQgdG8gbm9kZSB0aGF0IGJvdGggZXhpc3QgaW4gdGhlIG5ldHdvcmsuYm9keS5ub2Rlcy5cblxuXG4gICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgIHJldHVybiBhZmZlY3RzTGF5b3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRPcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld09wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd0RlbGV0aW9uPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZ2xvYmFsT3B0aW9ucz17fV1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb3B5RnJvbUdsb2JhbHM9ZmFsc2VdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb3JtYXR0aW5nVmFsdWVzXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyb3dPcHRpb25zfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZvcm1hdHRpbmdWYWx1ZXMoKSB7XG4gICAgICB2YXIgdG9BcnJvdyA9IHRoaXMub3B0aW9ucy5hcnJvd3MudG8gPT09IHRydWUgfHwgdGhpcy5vcHRpb25zLmFycm93cy50by5lbmFibGVkID09PSB0cnVlO1xuICAgICAgdmFyIGZyb21BcnJvdyA9IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbSA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uZW5hYmxlZCA9PT0gdHJ1ZTtcbiAgICAgIHZhciBtaWRkbGVBcnJvdyA9IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLmVuYWJsZWQgPT09IHRydWU7XG4gICAgICB2YXIgaW5oZXJpdHNDb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5pbmhlcml0O1xuICAgICAgdmFyIHZhbHVlcyA9IHtcbiAgICAgICAgdG9BcnJvdzogdG9BcnJvdyxcbiAgICAgICAgdG9BcnJvd1NjYWxlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLnNjYWxlRmFjdG9yLFxuICAgICAgICB0b0Fycm93VHlwZTogdGhpcy5vcHRpb25zLmFycm93cy50by50eXBlLFxuICAgICAgICB0b0Fycm93U3JjOiB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLnNyYyxcbiAgICAgICAgdG9BcnJvd0ltYWdlV2lkdGg6IHRoaXMub3B0aW9ucy5hcnJvd3MudG8uaW1hZ2VXaWR0aCxcbiAgICAgICAgdG9BcnJvd0ltYWdlSGVpZ2h0OiB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLmltYWdlSGVpZ2h0LFxuICAgICAgICBtaWRkbGVBcnJvdzogbWlkZGxlQXJyb3csXG4gICAgICAgIG1pZGRsZUFycm93U2NhbGU6IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLnNjYWxlRmFjdG9yLFxuICAgICAgICBtaWRkbGVBcnJvd1R5cGU6IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLnR5cGUsXG4gICAgICAgIG1pZGRsZUFycm93U3JjOiB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5zcmMsXG4gICAgICAgIG1pZGRsZUFycm93SW1hZ2VXaWR0aDogdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuaW1hZ2VXaWR0aCxcbiAgICAgICAgbWlkZGxlQXJyb3dJbWFnZUhlaWdodDogdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuaW1hZ2VIZWlnaHQsXG4gICAgICAgIGZyb21BcnJvdzogZnJvbUFycm93LFxuICAgICAgICBmcm9tQXJyb3dTY2FsZTogdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLnNjYWxlRmFjdG9yLFxuICAgICAgICBmcm9tQXJyb3dUeXBlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20udHlwZSxcbiAgICAgICAgZnJvbUFycm93U3JjOiB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uc3JjLFxuICAgICAgICBmcm9tQXJyb3dJbWFnZVdpZHRoOiB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uaW1hZ2VXaWR0aCxcbiAgICAgICAgZnJvbUFycm93SW1hZ2VIZWlnaHQ6IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5pbWFnZUhlaWdodCxcbiAgICAgICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB0aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoLFxuICAgICAgICBjb2xvcjogaW5oZXJpdHNDb2xvciA/IHVuZGVmaW5lZCA6IHRoaXMub3B0aW9ucy5jb2xvci5jb2xvcixcbiAgICAgICAgaW5oZXJpdHNDb2xvcjogaW5oZXJpdHNDb2xvcixcbiAgICAgICAgb3BhY2l0eTogdGhpcy5vcHRpb25zLmNvbG9yLm9wYWNpdHksXG4gICAgICAgIGhpZGRlbjogdGhpcy5vcHRpb25zLmhpZGRlbixcbiAgICAgICAgbGVuZ3RoOiB0aGlzLm9wdGlvbnMubGVuZ3RoLFxuICAgICAgICBzaGFkb3c6IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZCxcbiAgICAgICAgc2hhZG93Q29sb3I6IHRoaXMub3B0aW9ucy5zaGFkb3cuY29sb3IsXG4gICAgICAgIHNoYWRvd1NpemU6IHRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZSxcbiAgICAgICAgc2hhZG93WDogdGhpcy5vcHRpb25zLnNoYWRvdy54LFxuICAgICAgICBzaGFkb3dZOiB0aGlzLm9wdGlvbnMuc2hhZG93LnksXG4gICAgICAgIGRhc2hlczogdGhpcy5vcHRpb25zLmRhc2hlcyxcbiAgICAgICAgd2lkdGg6IHRoaXMub3B0aW9ucy53aWR0aCxcbiAgICAgICAgYmFja2dyb3VuZDogdGhpcy5vcHRpb25zLmJhY2tncm91bmQuZW5hYmxlZCxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZC5jb2xvcixcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kLnNpemUsXG4gICAgICAgIGJhY2tncm91bmREYXNoZXM6IHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kLmRhc2hlc1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQgfHwgdGhpcy5ob3Zlcikge1xuICAgICAgICBpZiAodGhpcy5jaG9vc2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZFdpZHRoID0gdGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdGVkV2lkdGggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICB2YWx1ZXMud2lkdGggPSBzZWxlY3RlZFdpZHRoKHZhbHVlcy53aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RlZFdpZHRoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy53aWR0aCArPSBzZWxlY3RlZFdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZXMud2lkdGggPSBNYXRoLm1heCh2YWx1ZXMud2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgICAgICAgIHZhbHVlcy5jb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQ7XG4gICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5ob3Zlcikge1xuICAgICAgICAgICAgdmFyIGhvdmVyV2lkdGggPSB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBob3ZlcldpZHRoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLndpZHRoID0gaG92ZXJXaWR0aCh2YWx1ZXMud2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaG92ZXJXaWR0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICB2YWx1ZXMud2lkdGggKz0gaG92ZXJXaWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWVzLndpZHRoID0gTWF0aC5tYXgodmFsdWVzLndpZHRoLCAwLjMgLyB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICAgICAgICB2YWx1ZXMuY29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXI7XG4gICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jaG9vc2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmNob29zZXIodmFsdWVzLCB0aGlzLm9wdGlvbnMuaWQsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuXG4gICAgICAgICAgaWYgKHZhbHVlcy5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZXMuaW5oZXJpdHNDb2xvciA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZXMuc2hhZG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5zaGFkb3dDb2xvciAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvciB8fCB2YWx1ZXMuc2hhZG93U2l6ZSAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy5zaXplIHx8IHZhbHVlcy5zaGFkb3dYICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnggfHwgdmFsdWVzLnNoYWRvd1kgIT09IHRoaXMub3B0aW9ucy5zaGFkb3cueSkge1xuICAgICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgIHZhbHVlcy53aWR0aCA9IE1hdGgubWF4KHZhbHVlcy53aWR0aCwgMC4zIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIG9wdGlvbnMgaW4gdGhlIGxhYmVsIG1vZHVsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUxhYmVsTW9kdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsTW9kdWxlKG9wdGlvbnMpIHtcbiAgICAgIHZhciBwaWxlID0gW29wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5nbG9iYWxPcHRpb25zLCAvLyBDdXJyZW50bHkgc2V0IGdsb2JhbCBlZGdlIG9wdGlvbnNcbiAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnNdO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS51cGRhdGUodGhpcy5vcHRpb25zLCBwaWxlKTtcblxuICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgZWRnZSB0eXBlLCBzZXQgdGhlIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRWRnZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRWRnZVR5cGUoKSB7XG4gICAgICB2YXIgc21vb3RoID0gdGhpcy5vcHRpb25zLnNtb290aDtcbiAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgdmFyIGNoYW5nZUluVHlwZSA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLmVkZ2VUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBCZXppZXJFZGdlRHluYW1pYyAmJiBzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGgudHlwZSA9PT0gXCJkeW5hbWljXCIgfHwgdGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIEN1YmljQmV6aWVyRWRnZSAmJiBzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGgudHlwZSA9PT0gXCJjdWJpY0JlemllclwiIHx8IHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBCZXppZXJFZGdlU3RhdGljICYmIHNtb290aC5lbmFibGVkID09PSB0cnVlICYmIHNtb290aC50eXBlICE9PSBcImR5bmFtaWNcIiAmJiBzbW9vdGgudHlwZSAhPT0gXCJjdWJpY0JlemllclwiIHx8IHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBTdHJhaWdodEVkZ2UgJiYgc21vb3RoLnR5cGUuZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjaGFuZ2VJblR5cGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VJblR5cGUgPT09IHRydWUpIHtcbiAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRoaXMuY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VJblR5cGUgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHNtb290aC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHNtb290aC50eXBlID09PSBcImR5bmFtaWNcIikge1xuICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBCZXppZXJFZGdlRHluYW1pYyh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzbW9vdGgudHlwZSA9PT0gXCJjdWJpY0JlemllclwiKSB7XG4gICAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IEN1YmljQmV6aWVyRWRnZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWRnZVR5cGUgPSBuZXcgQmV6aWVyRWRnZVN0YXRpYyh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWRnZVR5cGUgPSBuZXcgU3RyYWlnaHRFZGdlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgbm90aGluZyBjaGFuZ2VzLCB3ZSBqdXN0IHNldCB0aGUgb3B0aW9ucy5cbiAgICAgICAgdGhpcy5lZGdlVHlwZS5zZXRPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhQ2hhbmdlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCBhbiBlZGdlIHRvIGl0cyBub2Rlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLmZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5mcm9tSWRdIHx8IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudG8gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50b0lkXSB8fCB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IHRoaXMuZnJvbSAhPT0gdW5kZWZpbmVkICYmIHRoaXMudG8gIT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZnJvbS5hdHRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB0aGlzLnRvLmF0dGFjaEVkZ2UodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5mcm9tKSB7XG4gICAgICAgICAgdGhpcy5mcm9tLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50bykge1xuICAgICAgICAgIHRoaXMudG8uZGV0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVkZ2VUeXBlLmNvbm5lY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBhbiBlZGdlIGZyb20gaXRzIG5vZGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgICBpZiAodGhpcy5mcm9tKSB7XG4gICAgICAgIHRoaXMuZnJvbS5kZXRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB0aGlzLmZyb20gPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRvKSB7XG4gICAgICAgIHRoaXMudG8uZGV0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgdGhpcy50byA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB0aXRsZSBvZiB0aGlzIGVkZ2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aXRsZSAgICBUaGUgdGl0bGUgb2YgdGhlIGVkZ2UsIG9yIHVuZGVmaW5lZCB3aGVuIG5vIHRpdGxlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBoYXMgYmVlbiBzZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUaXRsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaXRsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjaGVjayBpZiB0aGlzIG5vZGUgaXMgc2VsZWN0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHNlbGVjdGVkICAgVHJ1ZSBpZiBub2RlIGlzIHNlbGVjdGVkLCBlbHNlIGZhbHNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc1NlbGVjdGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2VsZWN0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIHZhbHVlIG9mIHRoZSBlZGdlLiBDYW4gYmUgdW5kZWZpbmVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIHZhbHVlIHJhbmdlIG9mIHRoZSBlZGdlLiBUaGUgZWRnZSB3aWxsIGFkanVzdCBpdCdzIHdpZHRoXG4gICAgICogYmFzZWQgb24gaXRzIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFZhbHVlUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWVSYW5nZShtaW4sIG1heCwgdG90YWwpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5jdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB0aGlzLm9wdGlvbnMudmFsdWUpO1xuICAgICAgICB2YXIgd2lkdGhEaWZmID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWluO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGZvbnREaWZmID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5mb250LnNpemUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW4gKyBzY2FsZSAqIGZvbnREaWZmO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLndpZHRoID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWluICsgc2NhbGUgKiB3aWR0aERpZmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB0aGlzLmJhc2VXaWR0aDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMuYmFzZUZvbnRTaXplO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRJbnRlcmFjdGlvbldpZHRocygpO1xuXG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRJbnRlcmFjdGlvbldpZHRoc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0SW50ZXJhY3Rpb25XaWR0aHMoKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5ob3ZlcldpZHRoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5ob3ZlcldpZHRoID0gdGhpcy5vcHRpb25zLmhvdmVyV2lkdGgodGhpcy5vcHRpb25zLndpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWRnZVR5cGUuaG92ZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ob3ZlcldpZHRoICsgdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMuZWRnZVR5cGUuc2VsZWN0aW9uV2lkdGggPSB0aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGgodGhpcy5vcHRpb25zLndpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWRnZVR5cGUuc2VsZWN0aW9uV2lkdGggPSB0aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGggKyB0aGlzLm9wdGlvbnMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhIGVkZ2VcbiAgICAgKiBEcmF3IHRoaXMgZWRnZSBpbiB0aGUgZ2l2ZW4gY2FudmFzXG4gICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldEZvcm1hdHRpbmdWYWx1ZXMoKTtcblxuICAgICAgaWYgKHZhbHVlcy5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBnZXQgdGhlIHZpYSBub2RlIGZyb20gdGhlIGVkZ2UgdHlwZVxuXG5cbiAgICAgIHZhciB2aWFOb2RlID0gdGhpcy5lZGdlVHlwZS5nZXRWaWFOb2RlKCk7IC8vIGRyYXcgbGluZSBhbmQgbGFiZWxcblxuICAgICAgdGhpcy5lZGdlVHlwZS5kcmF3TGluZShjdHgsIHZhbHVlcywgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgdmlhTm9kZSk7XG4gICAgICB0aGlzLmRyYXdMYWJlbChjdHgsIHZpYU5vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYXJyb3dzXG4gICAgICogRHJhdyB0aGlzIGFycm93cyBpbiB0aGUgZ2l2ZW4gY2FudmFzXG4gICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdBcnJvd3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0Fycm93cyhjdHgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldEZvcm1hdHRpbmdWYWx1ZXMoKTtcblxuICAgICAgaWYgKHZhbHVlcy5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBnZXQgdGhlIHZpYSBub2RlIGZyb20gdGhlIGVkZ2UgdHlwZVxuXG5cbiAgICAgIHZhciB2aWFOb2RlID0gdGhpcy5lZGdlVHlwZS5nZXRWaWFOb2RlKCk7XG4gICAgICB2YXIgYXJyb3dEYXRhID0ge307IC8vIHJlc3RvcmUgZWRnZSB0YXJnZXRzIHRvIGRlZmF1bHRzXG5cbiAgICAgIHRoaXMuZWRnZVR5cGUuZnJvbVBvaW50ID0gdGhpcy5lZGdlVHlwZS5mcm9tO1xuICAgICAgdGhpcy5lZGdlVHlwZS50b1BvaW50ID0gdGhpcy5lZGdlVHlwZS50bzsgLy8gZnJvbSBhbmQgdG8gYXJyb3dzIGdpdmUgYSBkaWZmZXJlbnQgZW5kIHBvaW50IGZvciBlZGdlcy4gd2Ugc2V0IHRoZW0gaGVyZVxuXG4gICAgICBpZiAodmFsdWVzLmZyb21BcnJvdykge1xuICAgICAgICBhcnJvd0RhdGEuZnJvbSA9IHRoaXMuZWRnZVR5cGUuZ2V0QXJyb3dEYXRhKGN0eCwgXCJmcm9tXCIsIHZpYU5vZGUsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZhbHVlcyk7XG4gICAgICAgIGlmICh2YWx1ZXMuYXJyb3dTdHJpa2V0aHJvdWdoID09PSBmYWxzZSkgdGhpcy5lZGdlVHlwZS5mcm9tUG9pbnQgPSBhcnJvd0RhdGEuZnJvbS5jb3JlO1xuXG4gICAgICAgIGlmICh2YWx1ZXMuZnJvbUFycm93U3JjKSB7XG4gICAgICAgICAgYXJyb3dEYXRhLmZyb20uaW1hZ2UgPSB0aGlzLmltYWdlbGlzdC5sb2FkKHZhbHVlcy5mcm9tQXJyb3dTcmMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcy5mcm9tQXJyb3dJbWFnZVdpZHRoKSB7XG4gICAgICAgICAgYXJyb3dEYXRhLmZyb20uaW1hZ2VXaWR0aCA9IHZhbHVlcy5mcm9tQXJyb3dJbWFnZVdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcy5mcm9tQXJyb3dJbWFnZUhlaWdodCkge1xuICAgICAgICAgIGFycm93RGF0YS5mcm9tLmltYWdlSGVpZ2h0ID0gdmFsdWVzLmZyb21BcnJvd0ltYWdlSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZXMudG9BcnJvdykge1xuICAgICAgICBhcnJvd0RhdGEudG8gPSB0aGlzLmVkZ2VUeXBlLmdldEFycm93RGF0YShjdHgsIFwidG9cIiwgdmlhTm9kZSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgdmFsdWVzKTtcbiAgICAgICAgaWYgKHZhbHVlcy5hcnJvd1N0cmlrZXRocm91Z2ggPT09IGZhbHNlKSB0aGlzLmVkZ2VUeXBlLnRvUG9pbnQgPSBhcnJvd0RhdGEudG8uY29yZTtcblxuICAgICAgICBpZiAodmFsdWVzLnRvQXJyb3dTcmMpIHtcbiAgICAgICAgICBhcnJvd0RhdGEudG8uaW1hZ2UgPSB0aGlzLmltYWdlbGlzdC5sb2FkKHZhbHVlcy50b0Fycm93U3JjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZXMudG9BcnJvd0ltYWdlV2lkdGgpIHtcbiAgICAgICAgICBhcnJvd0RhdGEudG8uaW1hZ2VXaWR0aCA9IHZhbHVlcy50b0Fycm93SW1hZ2VXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZXMudG9BcnJvd0ltYWdlSGVpZ2h0KSB7XG4gICAgICAgICAgYXJyb3dEYXRhLnRvLmltYWdlSGVpZ2h0ID0gdmFsdWVzLnRvQXJyb3dJbWFnZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfSAvLyB0aGUgbWlkZGxlIGFycm93IGRlcGVuZHMgb24gdGhlIGxpbmUsIHdoaWNoIGNhbiBkZXBlbmQgb24gdGhlIHRvIGFuZCBmcm9tIGFycm93cyBzbyB3ZSBkbyB0aGlzIG9uZSBsYXN0bHkuXG5cblxuICAgICAgaWYgKHZhbHVlcy5taWRkbGVBcnJvdykge1xuICAgICAgICBhcnJvd0RhdGEubWlkZGxlID0gdGhpcy5lZGdlVHlwZS5nZXRBcnJvd0RhdGEoY3R4LCBcIm1pZGRsZVwiLCB2aWFOb2RlLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuXG4gICAgICAgIGlmICh2YWx1ZXMubWlkZGxlQXJyb3dTcmMpIHtcbiAgICAgICAgICBhcnJvd0RhdGEubWlkZGxlLmltYWdlID0gdGhpcy5pbWFnZWxpc3QubG9hZCh2YWx1ZXMubWlkZGxlQXJyb3dTcmMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcy5taWRkbGVBcnJvd0ltYWdlV2lkdGgpIHtcbiAgICAgICAgICBhcnJvd0RhdGEubWlkZGxlLmltYWdlV2lkdGggPSB2YWx1ZXMubWlkZGxlQXJyb3dJbWFnZVdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcy5taWRkbGVBcnJvd0ltYWdlSGVpZ2h0KSB7XG4gICAgICAgICAgYXJyb3dEYXRhLm1pZGRsZS5pbWFnZUhlaWdodCA9IHZhbHVlcy5taWRkbGVBcnJvd0ltYWdlSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZXMuZnJvbUFycm93KSB7XG4gICAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0Fycm93SGVhZChjdHgsIHZhbHVlcywgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgYXJyb3dEYXRhLmZyb20pO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWVzLm1pZGRsZUFycm93KSB7XG4gICAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0Fycm93SGVhZChjdHgsIHZhbHVlcywgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgYXJyb3dEYXRhLm1pZGRsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZXMudG9BcnJvdykge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmRyYXdBcnJvd0hlYWQoY3R4LCB2YWx1ZXMsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIGFycm93RGF0YS50byk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdmlhTm9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0xhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMYWJlbChjdHgsIHZpYU5vZGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBzZXQgc3R5bGVcbiAgICAgICAgdmFyIG5vZGUxID0gdGhpcy5mcm9tO1xuICAgICAgICB2YXIgbm9kZTIgPSB0aGlzLnRvO1xuXG4gICAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLmRpZmZlcmVudFN0YXRlKHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpKSB7XG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvaW50O1xuXG4gICAgICAgIGlmIChub2RlMS5pZCAhPSBub2RlMi5pZCkge1xuICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUucG9pbnRUb1NlbGYgPSBmYWxzZTtcbiAgICAgICAgICBwb2ludCA9IHRoaXMuZWRnZVR5cGUuZ2V0UG9pbnQoMC41LCB2aWFOb2RlKTtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgdmFyIHJvdGF0aW9uUG9pbnQgPSB0aGlzLl9nZXRSb3RhdGlvbihjdHgpO1xuXG4gICAgICAgICAgaWYgKHJvdGF0aW9uUG9pbnQuYW5nbGUgIT0gMCkge1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShyb3RhdGlvblBvaW50LngsIHJvdGF0aW9uUG9pbnQueSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKHJvdGF0aW9uUG9pbnQuYW5nbGUpO1xuICAgICAgICAgIH0gLy8gZHJhdyB0aGUgbGFiZWxcblxuXG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG4gICAgICAgICAgLypcbiAgICAgICAgICAvLyBVc2VmdWwgZGVidWcgY29kZTogZHJhdyBhIGJvcmRlciBhcm91bmQgdGhlIGxhYmVsXG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgKipub3QqKiBiZSBlbmFibGVkIGluIHByb2R1Y3Rpb24hXG4gICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmdldFNpemUoKTs7IC8vIDs7IGludGVudGlvbmFsIHNvIGxpbnQgY2F0Y2hlcyBpdFxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiI2ZmMDAwMFwiO1xuICAgICAgICAgIGN0eC5zdHJva2VSZWN0KHNpemUubGVmdCwgc2l6ZS50b3AsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAvLyBFbmQgIGRlYnVnIGNvZGVcbiAgICAgICAgICAqL1xuXG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZ25vcmUgdGhlIG9yaWVudGF0aW9ucy5cbiAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLnBvaW50VG9TZWxmID0gdHJ1ZTsgLy8gZ2V0IGNpcmNsZSBjb29yZGluYXRlc1xuXG4gICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gZ2V0U2VsZlJlZkNvb3JkaW5hdGVzKGN0eCwgdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUsIHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLnNpemUsIG5vZGUxKTtcbiAgICAgICAgICBwb2ludCA9IHRoaXMuX3BvaW50T25DaXJjbGUoY29vcmRpbmF0ZXMueCwgY29vcmRpbmF0ZXMueSwgdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2Uuc2l6ZSwgdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUpO1xuICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHBvaW50LngsIHBvaW50LnksIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBhbGwgdmlzdWFsIGVsZW1lbnRzIG9mIHRoaXMgZWRnZSBpbnN0YW5jZSwgaW4gd2hpY2ggdGhlIGdpdmVuXG4gICAgICogcG9pbnQgZmFsbHMgd2l0aGluIHRoZSBib3VuZGluZyBzaGFwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7cG9pbnR9IHBvaW50XG4gICAgICogQHJldHVybnMge0FycmF5LjxlZGdlQ2xpY2tJdGVtfGVkZ2VMYWJlbENsaWNrSXRlbT59IGxpc3Qgd2l0aCB0aGUgaXRlbXMgd2hpY2ggYXJlIG9uIHRoZSBwb2ludFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SXRlbXNPblBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEl0ZW1zT25Qb2ludChwb2ludCkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS52aXNpYmxlKCkpIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uUG9pbnQgPSB0aGlzLl9nZXRSb3RhdGlvbigpO1xuXG4gICAgICAgIGlmIChwb2ludEluUmVjdCh0aGlzLmxhYmVsTW9kdWxlLmdldFNpemUoKSwgcG9pbnQsIHJvdGF0aW9uUG9pbnQpKSB7XG4gICAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgZWRnZUlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgbGFiZWxJZDogMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBvYmogPSB7XG4gICAgICAgIGxlZnQ6IHBvaW50LngsXG4gICAgICAgIHRvcDogcG9pbnQueVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuaXNPdmVybGFwcGluZ1dpdGgob2JqKSkge1xuICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgZWRnZUlkOiB0aGlzLmlkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBpcyBvdmVybGFwcGluZyB3aXRoIHRoZSBwcm92aWRlZCBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogICBhbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAgICAgVHJ1ZSBpZiBsb2NhdGlvbiBpcyBsb2NhdGVkIG9uIHRoZSBlZGdlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc092ZXJsYXBwaW5nV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc092ZXJsYXBwaW5nV2l0aChvYmopIHtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICB2YXIgZGlzdE1heCA9IDEwO1xuICAgICAgICB2YXIgeEZyb20gPSB0aGlzLmZyb20ueDtcbiAgICAgICAgdmFyIHlGcm9tID0gdGhpcy5mcm9tLnk7XG4gICAgICAgIHZhciB4VG8gPSB0aGlzLnRvLng7XG4gICAgICAgIHZhciB5VG8gPSB0aGlzLnRvLnk7XG4gICAgICAgIHZhciB4T2JqID0gb2JqLmxlZnQ7XG4gICAgICAgIHZhciB5T2JqID0gb2JqLnRvcDtcbiAgICAgICAgdmFyIGRpc3QgPSB0aGlzLmVkZ2VUeXBlLmdldERpc3RhbmNlVG9FZGdlKHhGcm9tLCB5RnJvbSwgeFRvLCB5VG8sIHhPYmosIHlPYmopO1xuICAgICAgICByZXR1cm4gZGlzdCA8IGRpc3RNYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgcm90YXRpb24gcG9pbnQsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBbY3R4XSBpZiBwYXNzZWQsIGRvIGEgcmVjYWxjdWxhdGlvbiBvZiB0aGUgbGFiZWwgc2l6ZVxuICAgICAqIEByZXR1cm5zIHtyb3RhdGlvblBvaW50fSB0aGUgcG9pbnQgdG8gcm90YXRlIGFyb3VuZCBhbmQgdGhlIGFuZ2xlIGluIHJhZGlhbnMgdG8gcm90YXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRSb3RhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Um90YXRpb24oY3R4KSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IHRoaXMuZWRnZVR5cGUuZ2V0VmlhTm9kZSgpO1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5lZGdlVHlwZS5nZXRQb2ludCgwLjUsIHZpYU5vZGUpO1xuXG4gICAgICBpZiAoY3R4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5jYWxjdWxhdGVMYWJlbFNpemUoY3R4LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBwb2ludC54LCBwb2ludC55KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgeTogdGhpcy5sYWJlbE1vZHVsZS5zaXplLnlMaW5lLFxuICAgICAgICBhbmdsZTogMFxuICAgICAgfTtcblxuICAgICAgaWYgKCF0aGlzLmxhYmVsTW9kdWxlLnZpc2libGUoKSkge1xuICAgICAgICByZXR1cm4gcmV0OyAvLyBEb24ndCBldmVuIGJvdGhlciBkb2luZyB0aGUgYXRhbjIsIHRoZXJlJ3Mgbm90aGluZyB0byBkcmF3XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9udC5hbGlnbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgcmV0dXJuIHJldDsgLy8gTm8gbmVlZCB0byBjYWxjdWxhdGUgYW5nbGVcbiAgICAgIH1cblxuICAgICAgdmFyIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG4gICAgICB2YXIgZHggPSB0aGlzLmZyb20ueCAtIHRoaXMudG8ueDtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZHksIGR4KTsgLy8gcmFkaWFuc1xuICAgICAgLy8gcm90YXRlIHNvIHRoYXQgbGFiZWwgaXMgcmVhZGFibGVcblxuICAgICAgaWYgKGFuZ2xlIDwgLTEgJiYgZHggPCAwIHx8IGFuZ2xlID4gMCAmJiBkeCA8IDApIHtcbiAgICAgICAgYW5nbGUgKz0gTWF0aC5QSTtcbiAgICAgIH1cblxuICAgICAgcmV0LmFuZ2xlID0gYW5nbGU7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBwb2ludCBvbiBhIGNpcmNsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcG9pbnRPbkNpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcG9pbnRPbkNpcmNsZSh4LCB5LCByYWRpdXMsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5OiB5IC0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGVkIHN0YXRlIHRvIHRydWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3QoKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBzZWxlY3RlZCBzdGF0ZSB0byBmYWxzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5zZWxlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZWxlY3QoKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNsZWFucyBhbGwgcmVxdWlyZWQgdGhpbmdzIG9uIGRlbGV0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGVhbnVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGdlVHlwZS5jbGVhbnVwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBlZGdlIGZyb20gdGhlIGxpc3QgYW5kIHBlcmZvcm0gbmVjZXNzYXJ5IGNsZWFudXAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5pZF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGJvdGggY29ubmVjdGluZyBub2RlcyBleGlzdFxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbmRQb2ludHNWYWxpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRQb2ludHNWYWxpZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbdGhpcy5mcm9tSWRdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ib2R5Lm5vZGVzW3RoaXMudG9JZF0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgICAgIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciBnbG9iYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAgIHZhciBjb3B5RnJvbUdsb2JhbHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuICAgICAgdmFyIGZpZWxkcyA9IFtcImVuZFBvaW50T2Zmc2V0XCIsIFwiYXJyb3dTdHJpa2V0aHJvdWdoXCIsIFwiaWRcIiwgXCJmcm9tXCIsIFwiaGlkZGVuXCIsIFwiaG92ZXJXaWR0aFwiLCBcImxhYmVsSGlnaGxpZ2h0Qm9sZFwiLCBcImxlbmd0aFwiLCBcImxpbmVcIiwgXCJvcGFjaXR5XCIsIFwicGh5c2ljc1wiLCBcInNjYWxpbmdcIiwgXCJzZWxlY3Rpb25XaWR0aFwiLCBcInNlbGZSZWZlcmVuY2VTaXplXCIsIFwic2VsZlJlZmVyZW5jZVwiLCBcInRvXCIsIFwidGl0bGVcIiwgXCJ2YWx1ZVwiLCBcIndpZHRoXCIsIFwiZm9udFwiLCBcImNob3NlblwiLCBcIndpZHRoQ29uc3RyYWludFwiXTsgLy8gb25seSBkZWVwIGV4dGVuZCB0aGUgaXRlbXMgaW4gdGhlIGZpZWxkIGFycmF5LiBUaGVzZSBkbyBub3QgaGF2ZSBzaG9ydGhhbmQuXG5cbiAgICAgIHNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCBwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBhbGxvd0RlbGV0aW9uKTsgLy8gT25seSB1c2UgZW5kUG9pbnRPZmZzZXQgdmFsdWVzIChmcm9tIGFuZCB0bykgaWYgaXQncyB2YWxpZCB2YWx1ZXNcblxuICAgICAgaWYgKG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoX2lzRmluaXRlKG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSkpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb20gPSBuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb207XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tID0gZ2xvYmFsT3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tICE9PSB1bmRlZmluZWQgPyBnbG9iYWxPcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb20gOiAwO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJlbmRQb2ludE9mZnNldC5mcm9tIGlzIG5vdCBhIHZhbGlkIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoX2lzRmluaXRlKG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG8pKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5lbmRQb2ludE9mZnNldC50byA9IG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5lbmRQb2ludE9mZnNldC50byA9IGdsb2JhbE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG8gIT09IHVuZGVmaW5lZCA/IGdsb2JhbE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG8gOiAwO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJlbmRQb2ludE9mZnNldC50byBpcyBub3QgYSB2YWxpZCBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gT25seSBjb3B5IGxhYmVsIGlmIGl0J3MgYSBsZWdhbCB2YWx1ZS5cblxuXG4gICAgICBpZiAoaXNWYWxpZExhYmVsKG5ld09wdGlvbnMubGFiZWwpKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMubGFiZWwgPSBuZXdPcHRpb25zLmxhYmVsO1xuICAgICAgfSBlbHNlIGlmICghaXNWYWxpZExhYmVsKHBhcmVudE9wdGlvbnMubGFiZWwpKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMubGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBcInNtb290aFwiLCBnbG9iYWxPcHRpb25zKTtcbiAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBcInNoYWRvd1wiLCBnbG9iYWxPcHRpb25zKTtcbiAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBcImJhY2tncm91bmRcIiwgZ2xvYmFsT3B0aW9ucyk7XG5cbiAgICAgIGlmIChuZXdPcHRpb25zLmRhc2hlcyAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZGFzaGVzICE9PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZGFzaGVzID0gbmV3T3B0aW9ucy5kYXNoZXM7XG4gICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5kYXNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5kYXNoZXMgPSBjcmVhdGUkNShnbG9iYWxPcHRpb25zLmRhc2hlcyk7IC8vIHRoaXMgc2V0cyB0aGUgcG9pbnRlciBvZiB0aGUgb3B0aW9uIGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb24uXG4gICAgICB9IC8vIHNldCB0aGUgc2NhbGluZyBuZXdPcHRpb25zXG5cblxuICAgICAgaWYgKG5ld09wdGlvbnMuc2NhbGluZyAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuc2NhbGluZyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobmV3T3B0aW9ucy5zY2FsaW5nLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5zY2FsaW5nLm1pbiA9IG5ld09wdGlvbnMuc2NhbGluZy5taW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3T3B0aW9ucy5zY2FsaW5nLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5zY2FsaW5nLm1heCA9IG5ld09wdGlvbnMuc2NhbGluZy5tYXg7XG4gICAgICAgIH1cblxuICAgICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5zY2FsaW5nLCBuZXdPcHRpb25zLnNjYWxpbmcsIFwibGFiZWxcIiwgZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTtcbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLnNjYWxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5zY2FsaW5nID0gY3JlYXRlJDUoZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTsgLy8gdGhpcyBzZXRzIHRoZSBwb2ludGVyIG9mIHRoZSBvcHRpb24gYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbi5cbiAgICAgIH0gLy8gaGFuZGxlIG11bHRpcGxlIGlucHV0IGNhc2VzIGZvciBhcnJvd3NcblxuXG4gICAgICBpZiAobmV3T3B0aW9ucy5hcnJvd3MgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmFycm93cyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld09wdGlvbnMuYXJyb3dzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdmFyIGFycm93cyA9IG5ld09wdGlvbnMuYXJyb3dzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5hcnJvd3MudG8uZW5hYmxlZCA9IGluZGV4T2YoYXJyb3dzKS5jYWxsKGFycm93cywgXCJ0b1wiKSAhPSAtMTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cy5taWRkbGUuZW5hYmxlZCA9IGluZGV4T2YoYXJyb3dzKS5jYWxsKGFycm93cywgXCJtaWRkbGVcIikgIT0gLTE7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5hcnJvd3MuZnJvbS5lbmFibGVkID0gaW5kZXhPZihhcnJvd3MpLmNhbGwoYXJyb3dzLCBcImZyb21cIikgIT0gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihuZXdPcHRpb25zLmFycm93cykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5hcnJvd3MsIG5ld09wdGlvbnMuYXJyb3dzLCBcInRvXCIsIGdsb2JhbE9wdGlvbnMuYXJyb3dzKTtcbiAgICAgICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5hcnJvd3MsIG5ld09wdGlvbnMuYXJyb3dzLCBcIm1pZGRsZVwiLCBnbG9iYWxPcHRpb25zLmFycm93cyk7XG4gICAgICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuYXJyb3dzLCBuZXdPcHRpb25zLmFycm93cywgXCJmcm9tXCIsIGdsb2JhbE9wdGlvbnMuYXJyb3dzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJyb3cgbmV3T3B0aW9ucyBjYW4gb25seSBiZSBhbiBvYmplY3Qgb3IgYSBzdHJpbmcuIFJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uLiBZb3UgdXNlZDpcIiArIHN0cmluZ2lmeSQxKG5ld09wdGlvbnMuYXJyb3dzKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmFycm93cyA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cyA9IGNyZWF0ZSQ1KGdsb2JhbE9wdGlvbnMuYXJyb3dzKTsgLy8gdGhpcyBzZXRzIHRoZSBwb2ludGVyIG9mIHRoZSBvcHRpb24gYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbi5cbiAgICAgIH0gLy8gaGFuZGxlIG11bHRpcGxlIGlucHV0IGNhc2VzIGZvciBjb2xvclxuXG5cbiAgICAgIGlmIChuZXdPcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5jb2xvciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZnJvbUNvbG9yID0gaXNTdHJpbmcobmV3T3B0aW9ucy5jb2xvcikgPyB7XG4gICAgICAgICAgY29sb3I6IG5ld09wdGlvbnMuY29sb3IsXG4gICAgICAgICAgaGlnaGxpZ2h0OiBuZXdPcHRpb25zLmNvbG9yLFxuICAgICAgICAgIGhvdmVyOiBuZXdPcHRpb25zLmNvbG9yLFxuICAgICAgICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfSA6IG5ld09wdGlvbnMuY29sb3I7XG4gICAgICAgIHZhciB0b0NvbG9yID0gcGFyZW50T3B0aW9ucy5jb2xvcjsgLy8gSWYgcGFzc2VkLCBmaWxsIGluIHZhbHVlcyBmcm9tIGRlZmF1bHQgb3B0aW9ucyAtIHJlcXVpcmVkIGluIHRoZSBjYXNlIG9mIG5vIHByb3RvdHlwZSBicmlkZ2luZ1xuXG4gICAgICAgIGlmIChjb3B5RnJvbUdsb2JhbHMpIHtcbiAgICAgICAgICBkZWVwRXh0ZW5kKHRvQ29sb3IsIGdsb2JhbE9wdGlvbnMuY29sb3IsIGZhbHNlLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDbGVhciBsb2NhbCBwcm9wZXJ0aWVzIC0gbmVlZCB0byBkbyBpdCBsaWtlIHRoaXMgaW4gb3JkZXIgdG8gcmV0YWluIHByb3RvdHlwZSBicmlkZ2VzXG4gICAgICAgICAgZm9yICh2YXIgaSBpbiB0b0NvbG9yKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRvQ29sb3IsIGkpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0b0NvbG9yW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1N0cmluZyh0b0NvbG9yKSkge1xuICAgICAgICAgIHRvQ29sb3IuY29sb3IgPSB0b0NvbG9yO1xuICAgICAgICAgIHRvQ29sb3IuaGlnaGxpZ2h0ID0gdG9Db2xvcjtcbiAgICAgICAgICB0b0NvbG9yLmhvdmVyID0gdG9Db2xvcjtcbiAgICAgICAgICB0b0NvbG9yLmluaGVyaXQgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChmcm9tQ29sb3Iub3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0b0NvbG9yLm9wYWNpdHkgPSAxLjA7IC8vIHNldCBkZWZhdWx0XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjb2xvcnNEZWZpbmVkID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3IuY29sb3IgPSBmcm9tQ29sb3IuY29sb3I7XG4gICAgICAgICAgICBjb2xvcnNEZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLmhpZ2hsaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0b0NvbG9yLmhpZ2hsaWdodCA9IGZyb21Db2xvci5oaWdobGlnaHQ7XG4gICAgICAgICAgICBjb2xvcnNEZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLmhvdmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3IuaG92ZXIgPSBmcm9tQ29sb3IuaG92ZXI7XG4gICAgICAgICAgICBjb2xvcnNEZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLmluaGVyaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5pbmhlcml0ID0gZnJvbUNvbG9yLmluaGVyaXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZyb21Db2xvci5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3Iub3BhY2l0eSA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGZyb21Db2xvci5vcGFjaXR5KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbG9yc0RlZmluZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRvQ29sb3IuaW5oZXJpdCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodG9Db2xvci5pbmhlcml0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdG9Db2xvci5pbmhlcml0ID0gXCJmcm9tXCI7IC8vIFNldCBkZWZhdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5jb2xvciA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yID0gYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuY29sb3IpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmZvbnQgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5mb250ID0gYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuZm9udCk7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV3T3B0aW9ucywgXCJzZWxmUmVmZXJlbmNlU2l6ZVwiKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgc2VsZlJlZmVyZW5jZVNpemUgcHJvcGVydHkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBzZWxmUmVmZXJlbmNlIHByb3BlcnR5IGluc3RlYWQuIFRoZSBzZWxmUmVmZXJlbmNlIGNhbiBiZSBzZXQgbGlrZSB0aGlzZSBzZWxmUmVmZXJlbmNlOntzaXplOjMwLCBhbmdsZTpNYXRoLlBJIC8gNH1cIik7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplID0gbmV3T3B0aW9ucy5zZWxmUmVmZXJlbmNlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRWRnZTtcbn0oKTtcblxuLyoqXG4gKiBIYW5kbGVyIGZvciBFZGdlc1xuICovXG5cbnZhciBFZGdlc0hhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtBcnJheS48SW1hZ2U+fSBpbWFnZXNcbiAgICogQHBhcmFtIHtBcnJheS48R3JvdXA+fSBncm91cHNcbiAgICovXG4gIGZ1bmN0aW9uIEVkZ2VzSGFuZGxlcihib2R5LCBpbWFnZXMsIGdyb3Vwcykge1xuICAgIHZhciBfY29udGV4dCxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VzSGFuZGxlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzOyAvLyBjcmVhdGUgdGhlIGVkZ2UgQVBJIGluIHRoZSBib2R5IGNvbnRhaW5lclxuXG4gICAgdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVFZGdlID0gYmluZCQ2KF9jb250ZXh0ID0gdGhpcy5jcmVhdGUpLmNhbGwoX2NvbnRleHQsIHRoaXMpO1xuICAgIHRoaXMuZWRnZXNMaXN0ZW5lcnMgPSB7XG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIF90aGlzLmFkZChwYXJhbXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMudXBkYXRlKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy5yZW1vdmUocGFyYW1zLml0ZW1zKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBhcnJvd3M6IHtcbiAgICAgICAgdG86IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBzY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICB0eXBlOiBcImFycm93XCJcbiAgICAgICAgfSxcbiAgICAgICAgLy8gYm9vbGVhbiAvIHthcnJvd1NjYWxlRmFjdG9yOjF9IC8ge2VuYWJsZWQ6IGZhbHNlLCBhcnJvd1NjYWxlRmFjdG9yOjF9XG4gICAgICAgIG1pZGRsZToge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIHNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIHR5cGU6IFwiYXJyb3dcIlxuICAgICAgICB9LFxuICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgc2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgdHlwZTogXCJhcnJvd1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbmRQb2ludE9mZnNldDoge1xuICAgICAgICBmcm9tOiAwLFxuICAgICAgICB0bzogMFxuICAgICAgfSxcbiAgICAgIGFycm93U3RyaWtldGhyb3VnaDogdHJ1ZSxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIGNvbG9yOiBcIiM4NDg0ODRcIixcbiAgICAgICAgaGlnaGxpZ2h0OiBcIiM4NDg0ODRcIixcbiAgICAgICAgaG92ZXI6IFwiIzg0ODQ4NFwiLFxuICAgICAgICBpbmhlcml0OiBcImZyb21cIixcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9LFxuICAgICAgZGFzaGVzOiBmYWxzZSxcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgY29sb3I6IFwiIzM0MzQzNFwiLFxuICAgICAgICBzaXplOiAxNCxcbiAgICAgICAgLy8gcHhcbiAgICAgICAgZmFjZTogXCJhcmlhbFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIm5vbmVcIixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgIC8vIHB4XG4gICAgICAgIHN0cm9rZUNvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgYWxpZ246IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICBtdWx0aTogZmFsc2UsXG4gICAgICAgIHZhZGp1c3Q6IDAsXG4gICAgICAgIGJvbGQ6IHtcbiAgICAgICAgICBtb2Q6IFwiYm9sZFwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvbGRpdGFsOiB7XG4gICAgICAgICAgbW9kOiBcImJvbGQgaXRhbGljXCJcbiAgICAgICAgfSxcbiAgICAgICAgaXRhbDoge1xuICAgICAgICAgIG1vZDogXCJpdGFsaWNcIlxuICAgICAgICB9LFxuICAgICAgICBtb25vOiB7XG4gICAgICAgICAgbW9kOiBcIlwiLFxuICAgICAgICAgIHNpemU6IDE1LFxuICAgICAgICAgIC8vIHB4XG4gICAgICAgICAgZmFjZTogXCJjb3VyaWVyIG5ld1wiLFxuICAgICAgICAgIHZhZGp1c3Q6IDJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICBob3ZlcldpZHRoOiAxLjUsXG4gICAgICBsYWJlbDogdW5kZWZpbmVkLFxuICAgICAgbGFiZWxIaWdobGlnaHRCb2xkOiB0cnVlLFxuICAgICAgbGVuZ3RoOiB1bmRlZmluZWQsXG4gICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgc2NhbGluZzoge1xuICAgICAgICBtaW46IDEsXG4gICAgICAgIG1heDogMTUsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBtaW46IDE0LFxuICAgICAgICAgIG1heDogMzAsXG4gICAgICAgICAgbWF4VmlzaWJsZTogMzAsXG4gICAgICAgICAgZHJhd1RocmVzaG9sZDogNVxuICAgICAgICB9LFxuICAgICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IGZ1bmN0aW9uIGN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSAxIC8gKG1heCAtIG1pbik7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgKHZhbHVlIC0gbWluKSAqIHNjYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZWxlY3Rpb25XaWR0aDogMS41LFxuICAgICAgc2VsZlJlZmVyZW5jZToge1xuICAgICAgICBzaXplOiAyMCxcbiAgICAgICAgYW5nbGU6IE1hdGguUEkgLyA0LFxuICAgICAgICByZW5kZXJCZWhpbmRUaGVOb2RlOiB0cnVlXG4gICAgICB9LFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogXCJyZ2JhKDAsMCwwLDAuNSlcIixcbiAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgIHg6IDUsXG4gICAgICAgIHk6IDVcbiAgICAgIH0sXG4gICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogXCJyZ2JhKDExMSwxMTEsMTExLDEpXCIsXG4gICAgICAgIHNpemU6IDEwLFxuICAgICAgICBkYXNoZXM6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc21vb3RoOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHR5cGU6IFwiZHluYW1pY1wiLFxuICAgICAgICBmb3JjZURpcmVjdGlvbjogXCJub25lXCIsXG4gICAgICAgIHJvdW5kbmVzczogMC41XG4gICAgICB9LFxuICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgZGVlcEV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmRzIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhFZGdlc0hhbmRsZXIsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcyxcbiAgICAgICAgICBfY29udGV4dDIsXG4gICAgICAgICAgX2NvbnRleHQzO1xuXG4gICAgICAvLyB0aGlzIGFsbG93cyBleHRlcm5hbCBtb2R1bGVzIHRvIGZvcmNlIGFsbCBkeW5hbWljIGN1cnZlcyB0byB0dXJuIHN0YXRpYy5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXNcIiwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICAgICAgdHlwZSA9IFwiY29udGludW91c1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIF90aGlzMi5ib2R5LmVkZ2VzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfdGhpczIuYm9keS5lZGdlcywgZWRnZUlkKSkge1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSBfdGhpczIuYm9keS5lZGdlc1tlZGdlSWRdO1xuXG4gICAgICAgICAgICB2YXIgZWRnZURhdGEgPSBfdGhpczIuYm9keS5kYXRhLmVkZ2VzLmdldChlZGdlSWQpOyAvLyBvbmx5IGZvcmNpYmx5IHJlbW92ZSB0aGUgc21vb3RoIGN1cnZlIGlmIHRoZSBkYXRhIGhhcyBiZWVuIHNldCBvZiB0aGUgZWRnZSBoYXMgdGhlIHNtb290aCBjdXJ2ZXMgZGVmaW5lZC5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBhIGNoYW5nZSBpbiB0aGUgZ2xvYmFsIHdvdWxkIG5vdCBhZmZlY3QgdGhlc2UgY3VydmVzLlxuXG5cbiAgICAgICAgICAgIGlmIChlZGdlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBzbW9vdGhPcHRpb25zID0gZWRnZURhdGEuc21vb3RoO1xuXG4gICAgICAgICAgICAgIGlmIChzbW9vdGhPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoT3B0aW9ucy5lbmFibGVkID09PSB0cnVlICYmIHNtb290aE9wdGlvbnMudHlwZSA9PT0gXCJkeW5hbWljXCIpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICBzbW9vdGg6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVtaXQgPT09IHRydWUgJiYgZGF0YUNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyB0aGlzIGlzIGNhbGxlZCB3aGVuIG9wdGlvbnMgb2YgRVhJU1RJTkcgbm9kZXMgb3IgZWRnZXMgaGF2ZSBjaGFuZ2VkLlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IE5vdCB0cnVlLCBjYWxsZWQgd2hlbiBvcHRpb25zIGhhdmUgTk9UIGNoYW5nZWQsIGZvciBib3RoIGV4aXN0aW5nIGFzIHdlbGwgYXMgbmV3IG5vZGVzLlxuICAgICAgLy8gICAgICAgU2VlIHVwZGF0ZSgpIGZvciBsb2dpYy5cbiAgICAgIC8vIFRPRE86IFZlcmlmeSBhbmQgZXhhbWluZSB0aGUgY29uc2VxdWVuY2VzIG9mIHRoaXMuIEl0IG1pZ2h0IHN0aWxsIHRyaWdnZXIgd2hlblxuICAgICAgLy8gICAgICAgbm9uLW9wdGlvbiBmaWVsZHMgaGF2ZSBjaGFuZ2VkLCBidXQgdGhlbiByZWNvbm5lY3RpbmcgZWRnZXMgaXMgc3RpbGwgdXNlbGVzcy5cbiAgICAgIC8vICAgICAgIEFsdGVybmF0aXZlbHksIGl0IG1pZ2h0IGFsc28gYmUgY2FsbGVkIHdoZW4gZWRnZXMgYXJlIHJlbW92ZWQuXG4gICAgICAvL1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhVXBkYXRlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5yZWNvbm5lY3RFZGdlcygpO1xuICAgICAgfSk7IC8vIHJlZnJlc2ggdGhlIGVkZ2VzLiBVc2VkIHdoZW4gcmV2ZXJ0aW5nIGZyb20gaGllcmFyY2hpY2FsIGxheW91dFxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlZnJlc2hFZGdlc1wiLCBiaW5kJDYoX2NvbnRleHQyID0gdGhpcy5yZWZyZXNoKS5jYWxsKF9jb250ZXh0MiwgdGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZWZyZXNoXCIsIGJpbmQkNihfY29udGV4dDMgPSB0aGlzLnJlZnJlc2gpLmNhbGwoX2NvbnRleHQzLCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3JFYWNoJDEoX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5ib2R5LmRhdGEuZWRnZXMpIF90aGlzMi5ib2R5LmRhdGEuZWRnZXMub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2U7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnMuYWRkO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLnVwZGF0ZTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5lZGdlc0xpc3RlbmVycy5yZW1vdmU7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnM7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdXNlIHRoZSBwYXJzZXIgZnJvbSB0aGUgRWRnZSBjbGFzcyB0byBmaWxsIGluIGFsbCBzaG9ydGhhbmQgbm90YXRpb25zXG4gICAgICAgIEVkZ2UucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgdHJ1ZSwgdGhpcy5kZWZhdWx0T3B0aW9ucywgdHJ1ZSk7IC8vIHVwZGF0ZSBzbW9vdGggc2V0dGluZ3MgaW4gYWxsIGVkZ2VzXG5cbiAgICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc21vb3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5ib2R5LmVkZ2VzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5lZGdlcywgZWRnZUlkKSkge1xuICAgICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdLnVwZGF0ZUVkZ2VUeXBlKCkgfHwgZGF0YUNoYW5nZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHVwZGF0ZSBmb250cyBpbiBhbGwgZWRnZXNcblxuXG4gICAgICAgIGlmIChvcHRpb25zLmZvbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIF9lZGdlSWQgaW4gdGhpcy5ib2R5LmVkZ2VzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5lZGdlcywgX2VkZ2VJZCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW19lZGdlSWRdLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIHZhcmlhYmxlcyBpZiBuZWVkZWRcblxuXG4gICAgICAgIGlmIChvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkIHx8IGRhdGFDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkIGVkZ2VzIGJ5IHJlYWRpbmcgdGhlIGRhdGEgdGFibGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IGVkZ2VzICAgIFRoZSBkYXRhIGNvbnRhaW5pbmcgdGhlIGVkZ2VzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90RW1pdD1mYWxzZV0gLSBTdXBwcmVzcyBkYXRhIGNoYW5nZWQgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGF0YShlZGdlcykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIG9sZEVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuXG4gICAgICBpZiAoaXNEYXRhVmlld0xpa2UoXCJpZFwiLCBlZGdlcykpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBlZGdlcztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSQyKGVkZ2VzKSkge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcyA9IG5ldyBEYXRhU2V0KCk7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmFkZChlZGdlcyk7XG4gICAgICB9IGVsc2UgaWYgKCFlZGdlcykge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcyA9IG5ldyBEYXRhU2V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXkgb3IgRGF0YVNldCBleHBlY3RlZFwiKTtcbiAgICAgIH0gLy8gVE9ETzogaXMgdGhpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBmYWxzZT9cblxuXG4gICAgICBpZiAob2xkRWRnZXNEYXRhKSB7XG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gb2xkIGRhdGFzZXRcbiAgICAgICAgZm9yRWFjaCQxKHRoaXMuZWRnZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBvbGRFZGdlc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyByZW1vdmUgZHJhd24gZWRnZXNcblxuXG4gICAgICB0aGlzLmJvZHkuZWRnZXMgPSB7fTsgLy8gVE9ETzogaXMgdGhpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBmYWxzZT9cblxuICAgICAgaWYgKHRoaXMuYm9keS5kYXRhLmVkZ2VzKSB7XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgICAgICBmb3JFYWNoJDEodGhpcy5lZGdlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmRhdGEuZWRnZXMub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7IC8vIGRyYXcgYWxsIG5ldyBub2Rlc1xuXG4gICAgICAgIHZhciBpZHMgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXRJZHMoKTtcbiAgICAgICAgdGhpcy5hZGQoaWRzLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dFwiKTtcblxuICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IGlkc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90RW1pdD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChpZHMpIHtcbiAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBvbGRFZGdlID0gZWRnZXNbaWRdO1xuXG4gICAgICAgIGlmIChvbGRFZGdlKSB7XG4gICAgICAgICAgb2xkRWRnZS5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IGVkZ2VzRGF0YS5nZXQoaWQsIHtcbiAgICAgICAgICBzaG93SW50ZXJuYWxJZHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGVkZ2VzW2lkXSA9IHRoaXMuY3JlYXRlKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2FkanVzdEVkZ2VzRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIpO1xuXG4gICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZXhpc3RpbmcgZWRnZXMsIG9yIGNyZWF0ZSB0aGVtIHdoZW4gbm90IHlldCBleGlzdGluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShpZHMpIHtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBlZGdlc0RhdGEgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcztcbiAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBkYXRhID0gZWRnZXNEYXRhLmdldChpZCk7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaWRdO1xuXG4gICAgICAgIGlmIChlZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB1cGRhdGUgZWRnZVxuICAgICAgICAgIGVkZ2UuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIGRhdGFDaGFuZ2VkID0gZWRnZS5zZXRPcHRpb25zKGRhdGEpIHx8IGRhdGFDaGFuZ2VkOyAvLyBpZiBhIHN1cHBvcnQgbm9kZSBpcyBhZGRlZCwgZGF0YSBjYW4gYmUgY2hhbmdlZC5cblxuICAgICAgICAgIGVkZ2UuY29ubmVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNyZWF0ZSBlZGdlXG4gICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW2lkXSA9IHRoaXMuY3JlYXRlKGRhdGEpO1xuICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YUNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dFwiKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YVVwZGF0ZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBleGlzdGluZyBlZGdlcy4gTm9uIGV4aXN0aW5nIGlkcyB3aWxsIGJlIGlnbm9yZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZW1pdD10cnVlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGlkcykge1xuICAgICAgdmFyIGVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuOyAvLyBlYXJseSBvdXRcblxuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgZm9yRWFjaCQxKGlkcywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaWRdO1xuXG4gICAgICAgIGlmIChlZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGdlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGVtaXQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIEVkZ2UgSGFuZGxlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGZvckVhY2gkMSh0aGlzLmJvZHkuZWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBlZGdlSWQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBfdGhpczQuYm9keS5kYXRhLmVkZ2VzLmdldChlZGdlSWQpO1xuXG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGdlLnNldE9wdGlvbnMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybnMge0VkZ2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgRWRnZShwcm9wZXJ0aWVzLCB0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvbm5lY3QgYWxsIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVjb25uZWN0RWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb25uZWN0RWRnZXMoKSB7XG4gICAgICB2YXIgaWQ7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG5cbiAgICAgIGZvciAoaWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlcywgaWQpKSB7XG4gICAgICAgICAgbm9kZXNbaWRdLmVkZ2VzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpZCBpbiBlZGdlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVkZ2VzLCBpZCkpIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2lkXTtcbiAgICAgICAgICBlZGdlLmZyb20gPSBudWxsO1xuICAgICAgICAgIGVkZ2UudG8gPSBudWxsO1xuICAgICAgICAgIGVkZ2UuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFZGdlLmlkfSBlZGdlSWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb25uZWN0ZWROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0ZWROb2RlcyhlZGdlSWQpIHtcbiAgICAgIHZhciBub2RlTGlzdCA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdO1xuXG4gICAgICAgIGlmIChlZGdlLmZyb21JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9kZUxpc3QucHVzaChlZGdlLmZyb21JZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWRnZS50b0lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UudG9JZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGVMaXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGVyZSBpcyBubyBkaXJlY3QgcmVsYXRpb24gYmV0d2VlbiB0aGUgbm9kZXMgYW5kIHRoZSBlZGdlcyBEYXRhU2V0LFxuICAgICAqIHNvIHRoZSByaWdodCBwbGFjZSB0byBkbyBjYWxsIHRoaXMgaXMgaW4gdGhlIGhhbmRsZXIgZm9yIGV2ZW50IGBfZGF0YVVwZGF0ZWRgLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVTdGF0ZSgpIHtcbiAgICAgIHRoaXMuX2FkZE1pc3NpbmdFZGdlcygpO1xuXG4gICAgICB0aGlzLl9yZW1vdmVJbnZhbGlkRWRnZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NhbiBmb3IgbWlzc2luZyBub2RlcyBhbmQgcmVtb3ZlIGNvcnJlc3BvbmRpbmcgZWRnZXMsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlSW52YWxpZEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVJbnZhbGlkRWRnZXMoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGVkZ2VzVG9EZWxldGUgPSBbXTtcbiAgICAgIGZvckVhY2gkMSh0aGlzLmJvZHkuZWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBpZCkge1xuICAgICAgICB2YXIgdG9Ob2RlID0gX3RoaXM1LmJvZHkubm9kZXNbZWRnZS50b0lkXTtcbiAgICAgICAgdmFyIGZyb21Ob2RlID0gX3RoaXM1LmJvZHkubm9kZXNbZWRnZS5mcm9tSWRdOyAvLyBTa2lwIGNsdXN0ZXJpbmcgZWRnZXMgaGVyZSwgbGV0IHRoZSBDbHVzdGVyaW5nIG1vZHVsZSBoYW5kbGUgdGhvc2VcblxuICAgICAgICBpZiAodG9Ob2RlICE9PSB1bmRlZmluZWQgJiYgdG9Ob2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSB8fCBmcm9tTm9kZSAhPT0gdW5kZWZpbmVkICYmIGZyb21Ob2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b05vZGUgPT09IHVuZGVmaW5lZCB8fCBmcm9tTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWRnZXNUb0RlbGV0ZS5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnJlbW92ZShlZGdlc1RvRGVsZXRlLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFkZCBhbGwgZWRnZXMgZnJvbSBkYXRhc2V0IHRoYXQgYXJlIG5vdCBpbiB0aGUgY2FjaGVkIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZE1pc3NpbmdFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkTWlzc2luZ0VkZ2VzKCkge1xuICAgICAgdmFyIGVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuXG4gICAgICBpZiAoZWRnZXNEYXRhID09PSB1bmRlZmluZWQgfHwgZWRnZXNEYXRhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjsgLy8gTm8gZWRnZXMgRGF0YVNldCB5ZXQ7IGNhbiBoYXBwZW4gb24gc3RhcnR1cFxuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgYWRkSWRzID0gW107XG5cbiAgICAgIGZvckVhY2gkMihlZGdlc0RhdGEpLmNhbGwoZWRnZXNEYXRhLCBmdW5jdGlvbiAoZWRnZURhdGEsIGVkZ2VJZCkge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJZF07XG5cbiAgICAgICAgaWYgKGVkZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFkZElkcy5wdXNoKGVkZ2VJZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmFkZChhZGRJZHMsIHRydWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFZGdlc0hhbmRsZXI7XG59KCk7XG5cbi8qKlxuICogQmFybmVzIEh1dCBTb2x2ZXJcbiAqL1xuXG52YXIgQmFybmVzSHV0U29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEJhcm5lc0h1dFNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXJuZXNIdXRTb2x2ZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5iYXJuZXNIdXRUcmVlO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLl9ybmcgPSBBbGVhKFwiQkFSTkVTIEhVVCBTT0xWRVJcIik7IC8vIGRlYnVnOiBzaG93IGdyaWRcbiAgICAvLyB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFmdGVyRHJhd2luZ1wiLCAoY3R4KSA9PiB7dGhpcy5fZGVidWcoY3R4LCcjZmYwMDAwJyl9KVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhCYXJuZXNIdXRTb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy50aGV0YUludmVyc2VkID0gMSAvIHRoaXMub3B0aW9ucy50aGV0YTsgLy8gaWYgMSB0aGVuIG1pbiBkaXN0YW5jZSA9IDAuNSwgaWYgMC41IHRoZW4gbWluIGRpc3RhbmNlID0gMC41ICsgMC41Km5vZGUuc2hhcGUucmFkaXVzXG5cbiAgICAgIHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciA9IDEgLSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0aGlzLm9wdGlvbnMuYXZvaWRPdmVybGFwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgZm9yY2VzIHRoZSBub2RlcyBhcHBseSBvbiBlYWNoIG90aGVyIGJhc2VkIG9uIGEgZ3Jhdml0YXRpb25hbCBtb2RlbC5cbiAgICAgKiBUaGUgQmFybmVzIEh1dCBtZXRob2QgaXMgdXNlZCB0byBzcGVlZCB1cCB0aGlzIE4tYm9keSBzaW11bGF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ncmF2aXRhdGlvbmFsQ29uc3RhbnQgIT09IDAgJiYgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgICAgdmFyIG5vZGVDb3VudCA9IG5vZGVJbmRpY2VzLmxlbmd0aDsgLy8gY3JlYXRlIHRoZSB0cmVlXG5cbiAgICAgICAgdmFyIGJhcm5lc0h1dFRyZWUgPSB0aGlzLl9mb3JtQmFybmVzSHV0VHJlZShub2Rlcywgbm9kZUluZGljZXMpOyAvLyBmb3IgZGVidWdnaW5nXG5cblxuICAgICAgICB0aGlzLmJhcm5lc0h1dFRyZWUgPSBiYXJuZXNIdXRUcmVlOyAvLyBwbGFjZSB0aGUgbm9kZXMgb25lIGJ5IG9uZSByZWN1cnNpdmVseVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUNvdW50OyBpKyspIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuXG4gICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgICAgLy8gc3RhcnRpbmcgd2l0aCByb290IGlzIGlycmVsZXZhbnQsIGl0IG5ldmVyIHBhc3NlcyB0aGUgQmFybmVzSHV0U29sdmVyIGNvbmRpdGlvblxuICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb25zKGJhcm5lc0h1dFRyZWUucm9vdCwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEZvcmNlQ29udHJpYnV0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Rm9yY2VDb250cmlidXRpb25zKHBhcmVudEJyYW5jaCwgbm9kZSkge1xuICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLk5XLCBub2RlKTtcblxuICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLk5FLCBub2RlKTtcblxuICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLlNXLCBub2RlKTtcblxuICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLlNFLCBub2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgdGhlIGJhcm5lc0h1dFRyZWUuIEl0IGNoZWNrcyB3aGVuIGl0IGNhbiBhcHByb3hpbWF0ZSBkaXN0YW50IG5vZGVzIHdpdGggdGhlaXIgY2VudGVyIG9mIG1hc3MuXG4gICAgICogSWYgYSByZWdpb24gY29udGFpbnMgYSBzaW5nbGUgbm9kZSwgd2UgY2hlY2sgaWYgaXQgaXMgbm90IGl0c2VsZiwgdGhlbiB3ZSBhcHBseSB0aGUgZm9yY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRGb3JjZUNvbnRyaWJ1dGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLCBub2RlKSB7XG4gICAgICAvLyB3ZSBnZXQgbm8gZm9yY2UgY29udHJpYnV0aW9uIGZyb20gYW4gZW1wdHkgcmVnaW9uXG4gICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPiAwKSB7XG4gICAgICAgIC8vIGdldCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIG9mIG1hc3MgdG8gdGhlIG5vZGUuXG4gICAgICAgIHZhciBkeCA9IHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueCAtIG5vZGUueDtcbiAgICAgICAgdmFyIGR5ID0gcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy55IC0gbm9kZS55O1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpOyAvLyBCYXJuZXNIdXRTb2x2ZXIgY29uZGl0aW9uXG4gICAgICAgIC8vIG9yaWdpbmFsIGNvbmRpdGlvbiA6IHMvZCA8IHRoZXRhID0gcGFzc2VkICA9PT0gIGQvcyA+IDEvdGhldGEgPSBwYXNzZWRcbiAgICAgICAgLy8gY2FsY1NpemUgPSAxL3MgLS0+IGQgKiAxL3MgPiAxL3RoZXRhID0gcGFzc2VkXG5cbiAgICAgICAgaWYgKGRpc3RhbmNlICogcGFyZW50QnJhbmNoLmNhbGNTaXplID4gdGhpcy50aGV0YUludmVyc2VkKSB7XG4gICAgICAgICAgdGhpcy5fY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIG5vZGUsIHBhcmVudEJyYW5jaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGlkIG5vdCBwYXNzIHRoZSBjb25kaXRpb24sIGdvIGludG8gY2hpbGRyZW4gaWYgYXZhaWxhYmxlXG4gICAgICAgICAgaWYgKHBhcmVudEJyYW5jaC5jaGlsZHJlbkNvdW50ID09PSA0KSB7XG4gICAgICAgICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbnMocGFyZW50QnJhbmNoLCBub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFyZW50QnJhbmNoIG11c3QgaGF2ZSBvbmx5IG9uZSBub2RlLCBpZiBpdCB3YXMgZW1wdHkgd2Ugd291bGRudCBiZSBoZXJlXG4gICAgICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuLmRhdGEuaWQgIT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBub3Qgc2VsZlxuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgbm9kZSwgcGFyZW50QnJhbmNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgYmFzZWQgb24gdGhlIGRpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgbm9kZSwgcGFyZW50QnJhbmNoKSB7XG4gICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgZGlzdGFuY2UgPSAwLjE7XG4gICAgICAgIGR4ID0gZGlzdGFuY2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgPCAxICYmIG5vZGUuc2hhcGUucmFkaXVzKSB7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5tYXgoMC4xICsgdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yICogbm9kZS5zaGFwZS5yYWRpdXMsIGRpc3RhbmNlIC0gbm9kZS5zaGFwZS5yYWRpdXMpO1xuICAgICAgfSAvLyB0aGUgZGl2aWRpbmcgYnkgdGhlIGRpc3RhbmNlIGN1YmVkIGluc3RlYWQgb2Ygc3F1YXJlZCBhbGxvd3MgdXMgdG8gZ2V0IHRoZSBmeCBhbmQgZnkgY29tcG9uZW50cyB3aXRob3V0IHNpbmVzIGFuZCBjb3NpbmVzXG4gICAgICAvLyBpdCBpcyBzaG9ydGhhbmQgZm9yIGdyYXZpdHlmb3JjZSB3aXRoIGRpc3RhbmNlIHNxdWFyZWQgYW5kIGZ4ID0gZHgvZGlzdGFuY2UgKiBncmF2aXR5Rm9yY2VcblxuXG4gICAgICB2YXIgZ3Jhdml0eUZvcmNlID0gdGhpcy5vcHRpb25zLmdyYXZpdGF0aW9uYWxDb25zdGFudCAqIHBhcmVudEJyYW5jaC5tYXNzICogbm9kZS5vcHRpb25zLm1hc3MgLyBNYXRoLnBvdyhkaXN0YW5jZSwgMyk7XG4gICAgICB2YXIgZnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIHZhciBmeSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueCArPSBmeDtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnkgKz0gZnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY29uc3RydWN0cyB0aGUgYmFybmVzSHV0IHRyZWUgcmVjdXJzaXZlbHkuIEl0IGNyZWF0ZXMgdGhlIHJvb3QsIHNwbGl0cyBpdCBhbmQgc3RhcnRzIHBsYWNpbmcgdGhlIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbm9kZUluZGljZXNcbiAgICAgKiBAcmV0dXJucyB7e3Jvb3Q6IHtjZW50ZXJPZk1hc3M6IHt4OiBudW1iZXIsIHk6IG51bWJlcn0sIG1hc3M6IG51bWJlciwgcmFuZ2U6IHttaW5YOiBudW1iZXIsIG1heFg6IG51bWJlciwgbWluWTogbnVtYmVyLCBtYXhZOiBudW1iZXJ9LCBzaXplOiBudW1iZXIsIGNhbGNTaXplOiBudW1iZXIsIGNoaWxkcmVuOiB7ZGF0YTogbnVsbH0sIG1heFdpZHRoOiBudW1iZXIsIGxldmVsOiBudW1iZXIsIGNoaWxkcmVuQ291bnQ6IG51bWJlcn19fSBCYXJuZXNIdXRUcmVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9mb3JtQmFybmVzSHV0VHJlZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZm9ybUJhcm5lc0h1dFRyZWUobm9kZXMsIG5vZGVJbmRpY2VzKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHZhciBub2RlQ291bnQgPSBub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICB2YXIgbWluWCA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS54O1xuICAgICAgdmFyIG1pblkgPSBub2Rlc1tub2RlSW5kaWNlc1swXV0ueTtcbiAgICAgIHZhciBtYXhYID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLng7XG4gICAgICB2YXIgbWF4WSA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS55OyAvLyBnZXQgdGhlIHJhbmdlIG9mIHRoZSBub2Rlc1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG5vZGVDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBfbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgdmFyIHggPSBfbm9kZS54O1xuICAgICAgICB2YXIgeSA9IF9ub2RlLnk7XG5cbiAgICAgICAgaWYgKF9ub2RlLm9wdGlvbnMubWFzcyA+IDApIHtcbiAgICAgICAgICBpZiAoeCA8IG1pblgpIHtcbiAgICAgICAgICAgIG1pblggPSB4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh4ID4gbWF4WCkge1xuICAgICAgICAgICAgbWF4WCA9IHg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgICAgIG1heFkgPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBtYWtlIHRoZSByYW5nZSBhIHNxdWFyZVxuXG5cbiAgICAgIHZhciBzaXplRGlmZiA9IE1hdGguYWJzKG1heFggLSBtaW5YKSAtIE1hdGguYWJzKG1heFkgLSBtaW5ZKTsgLy8gZGlmZmVyZW5jZSBiZXR3ZWVuIFggYW5kIFlcblxuICAgICAgaWYgKHNpemVEaWZmID4gMCkge1xuICAgICAgICBtaW5ZIC09IDAuNSAqIHNpemVEaWZmO1xuICAgICAgICBtYXhZICs9IDAuNSAqIHNpemVEaWZmO1xuICAgICAgfSAvLyB4U2l6ZSA+IHlTaXplXG4gICAgICBlbHNlIHtcbiAgICAgICAgbWluWCArPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgICAgbWF4WCAtPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgIH0gLy8geFNpemUgPCB5U2l6ZVxuXG5cbiAgICAgIHZhciBtaW5pbXVtVHJlZVNpemUgPSAxZS01O1xuICAgICAgdmFyIHJvb3RTaXplID0gTWF0aC5tYXgobWluaW11bVRyZWVTaXplLCBNYXRoLmFicyhtYXhYIC0gbWluWCkpO1xuICAgICAgdmFyIGhhbGZSb290U2l6ZSA9IDAuNSAqIHJvb3RTaXplO1xuICAgICAgdmFyIGNlbnRlclggPSAwLjUgKiAobWluWCArIG1heFgpLFxuICAgICAgICAgIGNlbnRlclkgPSAwLjUgKiAobWluWSArIG1heFkpOyAvLyBjb25zdHJ1Y3QgdGhlIGJhcm5lc0h1dFRyZWVcblxuICAgICAgdmFyIGJhcm5lc0h1dFRyZWUgPSB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICBjZW50ZXJPZk1hc3M6IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXNzOiAwLFxuICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICBtaW5YOiBjZW50ZXJYIC0gaGFsZlJvb3RTaXplLFxuICAgICAgICAgICAgbWF4WDogY2VudGVyWCArIGhhbGZSb290U2l6ZSxcbiAgICAgICAgICAgIG1pblk6IGNlbnRlclkgLSBoYWxmUm9vdFNpemUsXG4gICAgICAgICAgICBtYXhZOiBjZW50ZXJZICsgaGFsZlJvb3RTaXplXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaXplOiByb290U2l6ZSxcbiAgICAgICAgICBjYWxjU2l6ZTogMSAvIHJvb3RTaXplLFxuICAgICAgICAgIGNoaWxkcmVuOiB7XG4gICAgICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXhXaWR0aDogMCxcbiAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICBjaGlsZHJlbkNvdW50OiA0XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3NwbGl0QnJhbmNoKGJhcm5lc0h1dFRyZWUucm9vdCk7IC8vIHBsYWNlIHRoZSBub2RlcyBvbmUgYnkgb25lIHJlY3Vyc2l2ZWx5XG5cblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVDb3VudDsgX2krKykge1xuICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbX2ldXTtcblxuICAgICAgICBpZiAobm9kZS5vcHRpb25zLm1hc3MgPiAwKSB7XG4gICAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUoYmFybmVzSHV0VHJlZS5yb290LCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBtYWtlIGdsb2JhbFxuXG5cbiAgICAgIHJldHVybiBiYXJuZXNIdXRUcmVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGlzIHVwZGF0ZXMgdGhlIG1hc3Mgb2YgYSBicmFuY2guIHRoaXMgaXMgaW5jcmVhc2VkIGJ5IGFkZGluZyBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVCcmFuY2hNYXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCcmFuY2hNYXNzKHBhcmVudEJyYW5jaCwgbm9kZSkge1xuICAgICAgdmFyIGNlbnRlck9mTWFzcyA9IHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3M7XG4gICAgICB2YXIgdG90YWxNYXNzID0gcGFyZW50QnJhbmNoLm1hc3MgKyBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgIHZhciB0b3RhbE1hc3NJbnYgPSAxIC8gdG90YWxNYXNzO1xuICAgICAgY2VudGVyT2ZNYXNzLnggPSBjZW50ZXJPZk1hc3MueCAqIHBhcmVudEJyYW5jaC5tYXNzICsgbm9kZS54ICogbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICBjZW50ZXJPZk1hc3MueCAqPSB0b3RhbE1hc3NJbnY7XG4gICAgICBjZW50ZXJPZk1hc3MueSA9IGNlbnRlck9mTWFzcy55ICogcGFyZW50QnJhbmNoLm1hc3MgKyBub2RlLnkgKiBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgIGNlbnRlck9mTWFzcy55ICo9IHRvdGFsTWFzc0ludjtcbiAgICAgIHBhcmVudEJyYW5jaC5tYXNzID0gdG90YWxNYXNzO1xuICAgICAgdmFyIGJpZ2dlc3RTaXplID0gTWF0aC5tYXgoTWF0aC5tYXgobm9kZS5oZWlnaHQsIG5vZGUucmFkaXVzKSwgbm9kZS53aWR0aCk7XG4gICAgICBwYXJlbnRCcmFuY2gubWF4V2lkdGggPSBwYXJlbnRCcmFuY2gubWF4V2lkdGggPCBiaWdnZXN0U2l6ZSA/IGJpZ2dlc3RTaXplIDogcGFyZW50QnJhbmNoLm1heFdpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBkZXRlcm1pbmUgaW4gd2hpY2ggYnJhbmNoIHRoZSBub2RlIHdpbGwgYmUgcGxhY2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2tpcE1hc3NVcGRhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BsYWNlSW5UcmVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wbGFjZUluVHJlZShwYXJlbnRCcmFuY2gsIG5vZGUsIHNraXBNYXNzVXBkYXRlKSB7XG4gICAgICBpZiAoc2tpcE1hc3NVcGRhdGUgIT0gdHJ1ZSB8fCBza2lwTWFzc1VwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgbWFzcyBvZiB0aGUgYnJhbmNoLlxuICAgICAgICB0aGlzLl91cGRhdGVCcmFuY2hNYXNzKHBhcmVudEJyYW5jaCwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZSA9IHBhcmVudEJyYW5jaC5jaGlsZHJlbi5OVy5yYW5nZTtcbiAgICAgIHZhciByZWdpb247XG5cbiAgICAgIGlmIChyYW5nZS5tYXhYID4gbm9kZS54KSB7XG4gICAgICAgIC8vIGluIE5XIG9yIFNXXG4gICAgICAgIGlmIChyYW5nZS5tYXhZID4gbm9kZS55KSB7XG4gICAgICAgICAgcmVnaW9uID0gXCJOV1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZ2lvbiA9IFwiU1dcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW4gTkUgb3IgU0VcbiAgICAgICAgaWYgKHJhbmdlLm1heFkgPiBub2RlLnkpIHtcbiAgICAgICAgICByZWdpb24gPSBcIk5FXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnaW9uID0gXCJTRVwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BsYWNlSW5SZWdpb24ocGFyZW50QnJhbmNoLCBub2RlLCByZWdpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhY3R1YWxseSBwbGFjZSB0aGUgbm9kZSBpbiBhIHJlZ2lvbiAob3IgYnJhbmNoKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7J05XJ3wgJ05FJyB8ICdTVycgfCAnU0UnfSByZWdpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BsYWNlSW5SZWdpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYWNlSW5SZWdpb24ocGFyZW50QnJhbmNoLCBub2RlLCByZWdpb24pIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudEJyYW5jaC5jaGlsZHJlbltyZWdpb25dO1xuXG4gICAgICBzd2l0Y2ggKGNoaWxkcmVuLmNoaWxkcmVuQ291bnQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIC8vIHBsYWNlIG5vZGUgaGVyZVxuICAgICAgICAgIGNoaWxkcmVuLmNoaWxkcmVuLmRhdGEgPSBub2RlO1xuICAgICAgICAgIGNoaWxkcmVuLmNoaWxkcmVuQ291bnQgPSAxO1xuXG4gICAgICAgICAgdGhpcy5fdXBkYXRlQnJhbmNoTWFzcyhjaGlsZHJlbiwgbm9kZSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgLy8gY29udmVydCBpbnRvIGNoaWxkcmVuXG4gICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIHR3byBub2RlcyBleGFjdGx5IG92ZXJsYXBwaW5nIChvbiBpbml0LCBvbiBvcGVuaW5nIG9mIGNsdXN0ZXIgZXRjLilcbiAgICAgICAgICAvLyB3ZSBtb3ZlIG9uZSBub2RlIGEgbGl0dGxlIGJpdCBhbmQgd2UgZG8gbm90IHB1dCBpdCBpbiB0aGUgdHJlZS5cbiAgICAgICAgICBpZiAoY2hpbGRyZW4uY2hpbGRyZW4uZGF0YS54ID09PSBub2RlLnggJiYgY2hpbGRyZW4uY2hpbGRyZW4uZGF0YS55ID09PSBub2RlLnkpIHtcbiAgICAgICAgICAgIG5vZGUueCArPSB0aGlzLl9ybmcoKTtcbiAgICAgICAgICAgIG5vZGUueSArPSB0aGlzLl9ybmcoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3BsaXRCcmFuY2goY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICB0aGlzLl9wbGFjZUluVHJlZShjaGlsZHJlbiwgbm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIC8vIHBsYWNlIGluIGJyYW5jaFxuICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKGNoaWxkcmVuLCBub2RlKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHNwbGl0cyBhIGJyYW5jaCBpbnRvIDQgc3ViIGJyYW5jaGVzLiBJZiB0aGUgYnJhbmNoIGNvbnRhaW5lZCBhIG5vZGUsIHdlIHBsYWNlIGl0IGluIHRoZSBzdWJicmFuY2hcbiAgICAgKiBhZnRlciB0aGUgc3BsaXQgaXMgY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zcGxpdEJyYW5jaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3BsaXRCcmFuY2gocGFyZW50QnJhbmNoKSB7XG4gICAgICAvLyBpZiB0aGUgYnJhbmNoIGlzIHNoYWRlZCB3aXRoIGEgbm9kZSwgcmVwbGFjZSB0aGUgbm9kZSBpbiB0aGUgbmV3IHN1YnNldC5cbiAgICAgIHZhciBjb250YWluZWROb2RlID0gbnVsbDtcblxuICAgICAgaWYgKHBhcmVudEJyYW5jaC5jaGlsZHJlbkNvdW50ID09PSAxKSB7XG4gICAgICAgIGNvbnRhaW5lZE5vZGUgPSBwYXJlbnRCcmFuY2guY2hpbGRyZW4uZGF0YTtcbiAgICAgICAgcGFyZW50QnJhbmNoLm1hc3MgPSAwO1xuICAgICAgICBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnggPSAwO1xuICAgICAgICBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnkgPSAwO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW5Db3VudCA9IDQ7XG4gICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW4uZGF0YSA9IG51bGw7XG5cbiAgICAgIHRoaXMuX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIFwiTldcIik7XG5cbiAgICAgIHRoaXMuX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIFwiTkVcIik7XG5cbiAgICAgIHRoaXMuX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIFwiU1dcIik7XG5cbiAgICAgIHRoaXMuX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIFwiU0VcIik7XG5cbiAgICAgIGlmIChjb250YWluZWROb2RlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUocGFyZW50QnJhbmNoLCBjb250YWluZWROb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzdWJkaXZpZGVzIHRoZSByZWdpb24gaW50byBmb3VyIG5ldyBzZWdtZW50cy5cbiAgICAgKiBTcGVjaWZpY2FsbHksIHRoaXMgaW5zZXJ0cyBhIHNpbmdsZSBuZXcgc2VnbWVudC5cbiAgICAgKiBJdCBmaWxscyB0aGUgY2hpbGRyZW4gc2VjdGlvbiBvZiB0aGUgcGFyZW50QnJhbmNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHBhcmFtIHsnTlcnfCAnTkUnIHwgJ1NXJyB8ICdTRSd9IHJlZ2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5zZXJ0UmVnaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCByZWdpb24pIHtcbiAgICAgIHZhciBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZO1xuICAgICAgdmFyIGNoaWxkU2l6ZSA9IDAuNSAqIHBhcmVudEJyYW5jaC5zaXplO1xuXG4gICAgICBzd2l0Y2ggKHJlZ2lvbikge1xuICAgICAgICBjYXNlIFwiTldcIjpcbiAgICAgICAgICBtaW5YID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblg7XG4gICAgICAgICAgbWF4WCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1pblkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWTtcbiAgICAgICAgICBtYXhZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblkgKyBjaGlsZFNpemU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIk5FXCI6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WDtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblk7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJTV1wiOlxuICAgICAgICAgIG1pblggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWDtcbiAgICAgICAgICBtYXhYID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblggKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWluWSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1heFkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiU0VcIjpcbiAgICAgICAgICBtaW5YID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblggKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWF4WCA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhYO1xuICAgICAgICAgIG1pblkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWSArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtYXhZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1heFk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudEJyYW5jaC5jaGlsZHJlbltyZWdpb25dID0ge1xuICAgICAgICBjZW50ZXJPZk1hc3M6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgbWFzczogMCxcbiAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICBtaW5YOiBtaW5YLFxuICAgICAgICAgIG1heFg6IG1heFgsXG4gICAgICAgICAgbWluWTogbWluWSxcbiAgICAgICAgICBtYXhZOiBtYXhZXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IDAuNSAqIHBhcmVudEJyYW5jaC5zaXplLFxuICAgICAgICBjYWxjU2l6ZTogMiAqIHBhcmVudEJyYW5jaC5jYWxjU2l6ZSxcbiAgICAgICAgY2hpbGRyZW46IHtcbiAgICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIG1heFdpZHRoOiAwLFxuICAgICAgICBsZXZlbDogcGFyZW50QnJhbmNoLmxldmVsICsgMSxcbiAgICAgICAgY2hpbGRyZW5Db3VudDogMFxuICAgICAgfTtcbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBERUJVR0dJTkcgQkVMT1cgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZWQsIGl0IGRyYXdzIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVidWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlYnVnKGN0eCwgY29sb3IpIHtcbiAgICAgIGlmICh0aGlzLmJhcm5lc0h1dFRyZWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcblxuICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKHRoaXMuYmFybmVzSHV0VHJlZS5yb290LCBjdHgsIGNvbG9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLiBJdCBkcmF3cyB0aGUgYnJhbmNoZXMgcmVjdXJzaXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYnJhbmNoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0JyYW5jaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0JyYW5jaChicmFuY2gsIGN0eCwgY29sb3IpIHtcbiAgICAgIGlmIChjb2xvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbG9yID0gXCIjRkYwMDAwXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChicmFuY2guY2hpbGRyZW5Db3VudCA9PT0gNCkge1xuICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKGJyYW5jaC5jaGlsZHJlbi5OVywgY3R4KTtcblxuICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKGJyYW5jaC5jaGlsZHJlbi5ORSwgY3R4KTtcblxuICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKGJyYW5jaC5jaGlsZHJlbi5TRSwgY3R4KTtcblxuICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKGJyYW5jaC5jaGlsZHJlbi5TVywgY3R4KTtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKGJyYW5jaC5yYW5nZS5taW5YLCBicmFuY2gucmFuZ2UubWluWSk7XG4gICAgICBjdHgubGluZVRvKGJyYW5jaC5yYW5nZS5tYXhYLCBicmFuY2gucmFuZ2UubWluWSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKGJyYW5jaC5yYW5nZS5tYXhYLCBicmFuY2gucmFuZ2UubWluWSk7XG4gICAgICBjdHgubGluZVRvKGJyYW5jaC5yYW5nZS5tYXhYLCBicmFuY2gucmFuZ2UubWF4WSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKGJyYW5jaC5yYW5nZS5tYXhYLCBicmFuY2gucmFuZ2UubWF4WSk7XG4gICAgICBjdHgubGluZVRvKGJyYW5jaC5yYW5nZS5taW5YLCBicmFuY2gucmFuZ2UubWF4WSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKGJyYW5jaC5yYW5nZS5taW5YLCBicmFuY2gucmFuZ2UubWF4WSk7XG4gICAgICBjdHgubGluZVRvKGJyYW5jaC5yYW5nZS5taW5YLCBicmFuY2gucmFuZ2UubWluWSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAvKlxuICAgICAgIGlmIChicmFuY2gubWFzcyA+IDApIHtcbiAgICAgICBjdHguY2lyY2xlKGJyYW5jaC5jZW50ZXJPZk1hc3MueCwgYnJhbmNoLmNlbnRlck9mTWFzcy55LCAzKmJyYW5jaC5tYXNzKTtcbiAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgfVxuICAgICAgICovXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhcm5lc0h1dFNvbHZlcjtcbn0oKTtcblxuLyoqXG4gKiBSZXB1bHNpb24gU29sdmVyXG4gKi9cblxudmFyIFJlcHVsc2lvblNvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBSZXB1bHNpb25Tb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVwdWxzaW9uU29sdmVyKTtcblxuICAgIHRoaXMuX3JuZyA9IEFsZWEoXCJSRVBVTFNJT04gU09MVkVSXCIpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUmVwdWxzaW9uU29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgdGhlIG5vZGVzIGFwcGx5IG9uIGVhY2ggb3RoZXIgYmFzZWQgb24gYSByZXB1bHNpb24gZmllbGQuXG4gICAgICogVGhpcyBmaWVsZCBpcyBsaW5lYXJseSBhcHByb3hpbWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgZHgsIGR5LCBkaXN0YW5jZSwgZngsIGZ5LCByZXB1bHNpbmdGb3JjZSwgbm9kZTEsIG5vZGUyO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgZm9yY2VzID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXM7IC8vIHJlcHVsc2luZyBmb3JjZXMgYmV0d2VlbiBub2Rlc1xuXG4gICAgICB2YXIgbm9kZURpc3RhbmNlID0gdGhpcy5vcHRpb25zLm5vZGVEaXN0YW5jZTsgLy8gYXBwcm94aW1hdGlvbiBjb25zdGFudHNcblxuICAgICAgdmFyIGEgPSAtMiAvIDMgLyBub2RlRGlzdGFuY2U7XG4gICAgICB2YXIgYiA9IDQgLyAzOyAvLyB3ZSBsb29wIGZyb20gaSBvdmVyIGFsbCBidXQgdGhlIGxhc3QgZW50cmVlIGluIHRoZSBhcnJheVxuICAgICAgLy8gaiBsb29wcyBmcm9tIGkrMSB0byB0aGUgbGFzdC4gVGhpcyB3YXkgd2UgZG8gbm90IGRvdWJsZSBjb3VudCBhbnkgb2YgdGhlIGluZGljZXMsIG5vciBpID09PSBqXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIG5vZGUxID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuXG4gICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbm9kZTIgPSBub2Rlc1tub2RlSW5kaWNlc1tqXV07XG4gICAgICAgICAgZHggPSBub2RlMi54IC0gbm9kZTEueDtcbiAgICAgICAgICBkeSA9IG5vZGUyLnkgLSBub2RlMS55O1xuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTsgLy8gc2FtZSBjb25kaXRpb24gYXMgQmFybmVzSHV0U29sdmVyLCBtYWtpbmcgc3VyZSBub2RlcyBhcmUgbmV2ZXIgMTAwJSBvdmVybGFwcGluZy5cblxuICAgICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgZGlzdGFuY2UgPSAwLjEgKiB0aGlzLl9ybmcoKTtcbiAgICAgICAgICAgIGR4ID0gZGlzdGFuY2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlIDwgMiAqIG5vZGVEaXN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgMC41ICogbm9kZURpc3RhbmNlKSB7XG4gICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gMS4wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSBhICogZGlzdGFuY2UgKyBiOyAvLyBsaW5lYXIgYXBwcm94IG9mICAxIC8gKDEgKyBNYXRoLmV4cCgoZGlzdGFuY2UgLyBub2RlRGlzdGFuY2UgLSAxKSAqIHN0ZWVwbmVzcykpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gcmVwdWxzaW5nRm9yY2UgLyBkaXN0YW5jZTtcbiAgICAgICAgICAgIGZ4ID0gZHggKiByZXB1bHNpbmdGb3JjZTtcbiAgICAgICAgICAgIGZ5ID0gZHkgKiByZXB1bHNpbmdGb3JjZTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueCAtPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueSAtPSBmeTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueCArPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueSArPSBmeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVwdWxzaW9uU29sdmVyO1xufSgpO1xuXG4vKipcbiAqIEhpZXJhcmNoaWNhbCBSZXB1bHNpb24gU29sdmVyXG4gKi9cbnZhciBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0aGlzLm9wdGlvbnMuYXZvaWRPdmVybGFwIHx8IDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgdGhlIG5vZGVzIGFwcGx5IG9uIGVhY2ggb3RoZXIgYmFzZWQgb24gYSByZXB1bHNpb24gZmllbGQuXG4gICAgICogVGhpcyBmaWVsZCBpcyBsaW5lYXJseSBhcHByb3hpbWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlczsgLy8gcmVwdWxzaW5nIGZvcmNlcyBiZXR3ZWVuIG5vZGVzXG5cbiAgICAgIHZhciBub2RlRGlzdGFuY2UgPSB0aGlzLm9wdGlvbnMubm9kZURpc3RhbmNlOyAvLyB3ZSBsb29wIGZyb20gaSBvdmVyIGFsbCBidXQgdGhlIGxhc3QgZW50cmVlIGluIHRoZSBhcnJheVxuICAgICAgLy8gaiBsb29wcyBmcm9tIGkrMSB0byB0aGUgbGFzdC4gVGhpcyB3YXkgd2UgZG8gbm90IGRvdWJsZSBjb3VudCBhbnkgb2YgdGhlIGluZGljZXMsIG5vciBpID09PSBqXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlMSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBub2RlSW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBub2RlMiA9IG5vZGVzW25vZGVJbmRpY2VzW2pdXTsgLy8gbm9kZXMgb25seSBhZmZlY3Qgbm9kZXMgb24gdGhlaXIgbGV2ZWxcblxuICAgICAgICAgIGlmIChub2RlMS5sZXZlbCA9PT0gbm9kZTIubGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciB0aGVzZU5vZGVzRGlzdGFuY2UgPSBub2RlRGlzdGFuY2UgKyB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgKiAoKG5vZGUxLnNoYXBlLnJhZGl1cyB8fCAwKSAvIDIgKyAobm9kZTIuc2hhcGUucmFkaXVzIHx8IDApIC8gMik7XG4gICAgICAgICAgICB2YXIgZHggPSBub2RlMi54IC0gbm9kZTEueDtcbiAgICAgICAgICAgIHZhciBkeSA9IG5vZGUyLnkgLSBub2RlMS55O1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgIHZhciBzdGVlcG5lc3MgPSAwLjA1O1xuICAgICAgICAgICAgdmFyIHJlcHVsc2luZ0ZvcmNlID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCB0aGVzZU5vZGVzRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSAtTWF0aC5wb3coc3RlZXBuZXNzICogZGlzdGFuY2UsIDIpICsgTWF0aC5wb3coc3RlZXBuZXNzICogdGhlc2VOb2Rlc0Rpc3RhbmNlLCAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gMDtcbiAgICAgICAgICAgIH0gLy8gbm9ybWFsaXplIGZvcmNlIHdpdGhcblxuXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgIT09IDApIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSByZXB1bHNpbmdGb3JjZSAvIGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZnggPSBkeCAqIHJlcHVsc2luZ0ZvcmNlO1xuICAgICAgICAgICAgdmFyIGZ5ID0gZHkgKiByZXB1bHNpbmdGb3JjZTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueCAtPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueSAtPSBmeTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueCArPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueSArPSBmeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyO1xufSgpO1xuXG4vKipcbiAqIFNwcmluZyBTb2x2ZXJcbiAqL1xudmFyIFNwcmluZ1NvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBTcHJpbmdTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3ByaW5nU29sdmVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoU3ByaW5nU29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBzcHJpbmdmb3JjZXMgb24gdGhlIG5vZGVzLCBhY2NvdW50aW5nIGZvciB0aGUgc3VwcG9ydCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIHZhciBlZGdlTGVuZ3RoLCBlZGdlO1xuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzRWRnZUluZGljZXM7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgbm9kZTEsIG5vZGUyLCBub2RlMzsgLy8gZm9yY2VzIGNhdXNlZCBieSB0aGUgZWRnZXMsIG1vZGVsbGVkIGFzIHNwcmluZ3NcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbaV1dO1xuXG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSAmJiBlZGdlLnRvSWQgIT09IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgLy8gb25seSBjYWxjdWxhdGUgZm9yY2VzIGlmIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBzZWN0b3JcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkubm9kZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChlZGdlLmVkZ2VUeXBlLnZpYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGVkZ2VMZW5ndGggPSBlZGdlLm9wdGlvbnMubGVuZ3RoID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc3ByaW5nTGVuZ3RoIDogZWRnZS5vcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgbm9kZTEgPSBlZGdlLnRvO1xuICAgICAgICAgICAgICBub2RlMiA9IGVkZ2UuZWRnZVR5cGUudmlhO1xuICAgICAgICAgICAgICBub2RlMyA9IGVkZ2UuZnJvbTtcblxuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMSwgbm9kZTIsIDAuNSAqIGVkZ2VMZW5ndGgpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlKG5vZGUyLCBub2RlMywgMC41ICogZWRnZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyB0aGUgKiAxLjUgaXMgaGVyZSBzbyB0aGUgZWRnZSBsb29rcyBhcyBsYXJnZSBhcyBhIHNtb290aCBlZGdlLiBJdCBkb2VzIG5vdCBpbml0aWFsbHkgYmVjYXVzZSB0aGUgc21vb3RoIGVkZ2VzIHVzZVxuICAgICAgICAgICAgICAvLyB0aGUgc3VwcG9ydCBub2RlcyB3aGljaCBleGVydCBhIHJlcHVsc2l2ZSBmb3JjZSBvbiB0aGUgdG8gYW5kIGZyb20gbm9kZXMsIG1ha2luZyB0aGUgZWRnZSBhcHBlYXIgbGFyZ2VyLlxuICAgICAgICAgICAgICBlZGdlTGVuZ3RoID0gZWRnZS5vcHRpb25zLmxlbmd0aCA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnNwcmluZ0xlbmd0aCAqIDEuNSA6IGVkZ2Uub3B0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlU3ByaW5nRm9yY2UoZWRnZS5mcm9tLCBlZGdlLnRvLCBlZGdlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgY29kZSBhY3R1YWxseSBwZXJmb3JtaW5nIHRoZSBjYWxjdWxhdGlvbiBmb3IgdGhlIGZ1bmN0aW9uIGFib3ZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlMVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZWRnZUxlbmd0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlU3ByaW5nRm9yY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlKG5vZGUxLCBub2RlMiwgZWRnZUxlbmd0aCkge1xuICAgICAgdmFyIGR4ID0gbm9kZTEueCAtIG5vZGUyLng7XG4gICAgICB2YXIgZHkgPSBub2RlMS55IC0gbm9kZTIueTtcbiAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGgubWF4KE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSksIDAuMDEpOyAvLyB0aGUgMS9kaXN0YW5jZSBpcyBzbyB0aGUgZnggYW5kIGZ5IGNhbiBiZSBjYWxjdWxhdGVkIHdpdGhvdXQgc2luZSBvciBjb3NpbmUuXG5cbiAgICAgIHZhciBzcHJpbmdGb3JjZSA9IHRoaXMub3B0aW9ucy5zcHJpbmdDb25zdGFudCAqIChlZGdlTGVuZ3RoIC0gZGlzdGFuY2UpIC8gZGlzdGFuY2U7XG4gICAgICB2YXIgZnggPSBkeCAqIHNwcmluZ0ZvcmNlO1xuICAgICAgdmFyIGZ5ID0gZHkgKiBzcHJpbmdGb3JjZTsgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIG9uZSBub2RlIGlzIG5vdCBwYXJ0IG9mIHRoZSBwaHlzY2lzXG5cbiAgICAgIGlmICh0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMS5pZF0ueCArPSBmeDtcbiAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTEuaWRdLnkgKz0gZnk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMi5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMi5pZF0ueCAtPSBmeDtcbiAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTIuaWRdLnkgLT0gZnk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNwcmluZ1NvbHZlcjtcbn0oKTtcblxuLyoqXG4gKiBIaWVyYXJjaGljYWwgU3ByaW5nIFNvbHZlclxuICovXG52YXIgSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIHNwcmluZ2ZvcmNlcyBvbiB0aGUgbm9kZXMsIGFjY291bnRpbmcgZm9yIHRoZSBzdXBwb3J0IG5vZGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgdmFyIGVkZ2VMZW5ndGgsIGVkZ2U7XG4gICAgICB2YXIgZHgsIGR5LCBmeCwgZnksIHNwcmluZ0ZvcmNlLCBkaXN0YW5jZTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBmYWN0b3IgPSAwLjU7XG4gICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzOyAvLyBpbml0aWFsaXplIHRoZSBzcHJpbmcgZm9yY2UgY291bnRlcnNcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUluZGljZXNbaV07XG4gICAgICAgIGZvcmNlc1tub2RlSWRdLnNwcmluZ0Z4ID0gMDtcbiAgICAgICAgZm9yY2VzW25vZGVJZF0uc3ByaW5nRnkgPSAwO1xuICAgICAgfSAvLyBmb3JjZXMgY2F1c2VkIGJ5IHRoZSBlZGdlcywgbW9kZWxsZWQgYXMgc3ByaW5nc1xuXG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlZGdlSW5kaWNlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW19pXV07XG5cbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgZWRnZUxlbmd0aCA9IGVkZ2Uub3B0aW9ucy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGggOiBlZGdlLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgICAgIGR4ID0gZWRnZS5mcm9tLnggLSBlZGdlLnRvLng7XG4gICAgICAgICAgZHkgPSBlZGdlLmZyb20ueSAtIGVkZ2UudG8ueTtcbiAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZSA9PT0gMCA/IDAuMDEgOiBkaXN0YW5jZTsgLy8gdGhlIDEvZGlzdGFuY2UgaXMgc28gdGhlIGZ4IGFuZCBmeSBjYW4gYmUgY2FsY3VsYXRlZCB3aXRob3V0IHNpbmUgb3IgY29zaW5lLlxuXG4gICAgICAgICAgc3ByaW5nRm9yY2UgPSB0aGlzLm9wdGlvbnMuc3ByaW5nQ29uc3RhbnQgKiAoZWRnZUxlbmd0aCAtIGRpc3RhbmNlKSAvIGRpc3RhbmNlO1xuICAgICAgICAgIGZ4ID0gZHggKiBzcHJpbmdGb3JjZTtcbiAgICAgICAgICBmeSA9IGR5ICogc3ByaW5nRm9yY2U7XG5cbiAgICAgICAgICBpZiAoZWRnZS50by5sZXZlbCAhPSBlZGdlLmZyb20ubGV2ZWwpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnNwcmluZ0Z4IC09IGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS50b0lkXS5zcHJpbmdGeSAtPSBmeTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvcmNlc1tlZGdlLmZyb21JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS5mcm9tSWRdLnNwcmluZ0Z4ICs9IGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS5mcm9tSWRdLnNwcmluZ0Z5ICs9IGZ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9yY2VzW2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS50b0lkXS54IC09IGZhY3RvciAqIGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS50b0lkXS55IC09IGZhY3RvciAqIGZ5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm9yY2VzW2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLmZyb21JZF0ueCArPSBmYWN0b3IgKiBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS55ICs9IGZhY3RvciAqIGZ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBub3JtYWxpemUgc3ByaW5nIGZvcmNlc1xuXG5cbiAgICAgIHNwcmluZ0ZvcmNlID0gMTtcbiAgICAgIHZhciBzcHJpbmdGeCwgc3ByaW5nRnk7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIF9ub2RlSWQgPSBub2RlSW5kaWNlc1tfaTJdO1xuICAgICAgICBzcHJpbmdGeCA9IE1hdGgubWluKHNwcmluZ0ZvcmNlLCBNYXRoLm1heCgtc3ByaW5nRm9yY2UsIGZvcmNlc1tfbm9kZUlkXS5zcHJpbmdGeCkpO1xuICAgICAgICBzcHJpbmdGeSA9IE1hdGgubWluKHNwcmluZ0ZvcmNlLCBNYXRoLm1heCgtc3ByaW5nRm9yY2UsIGZvcmNlc1tfbm9kZUlkXS5zcHJpbmdGeSkpO1xuICAgICAgICBmb3JjZXNbX25vZGVJZF0ueCArPSBzcHJpbmdGeDtcbiAgICAgICAgZm9yY2VzW19ub2RlSWRdLnkgKz0gc3ByaW5nRnk7XG4gICAgICB9IC8vIHJldGFpbiBlbmVyZ3kgYmFsYW5jZVxuXG5cbiAgICAgIHZhciB0b3RhbEZ4ID0gMDtcbiAgICAgIHZhciB0b3RhbEZ5ID0gMDtcblxuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICB2YXIgX25vZGVJZDIgPSBub2RlSW5kaWNlc1tfaTNdO1xuICAgICAgICB0b3RhbEZ4ICs9IGZvcmNlc1tfbm9kZUlkMl0ueDtcbiAgICAgICAgdG90YWxGeSArPSBmb3JjZXNbX25vZGVJZDJdLnk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb3JyZWN0aW9uRnggPSB0b3RhbEZ4IC8gbm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgdmFyIGNvcnJlY3Rpb25GeSA9IHRvdGFsRnkgLyBub2RlSW5kaWNlcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgdmFyIF9ub2RlSWQzID0gbm9kZUluZGljZXNbX2k0XTtcbiAgICAgICAgZm9yY2VzW19ub2RlSWQzXS54IC09IGNvcnJlY3Rpb25GeDtcbiAgICAgICAgZm9yY2VzW19ub2RlSWQzXS55IC09IGNvcnJlY3Rpb25GeTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyO1xufSgpO1xuXG4vKipcbiAqIENlbnRyYWwgR3Jhdml0eSBTb2x2ZXJcbiAqL1xudmFyIENlbnRyYWxHcmF2aXR5U29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIENlbnRyYWxHcmF2aXR5U29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENlbnRyYWxHcmF2aXR5U29sdmVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ2VudHJhbEdyYXZpdHlTb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGZvcmNlcyBmb3IgZWFjaCBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIHZhciBkeCwgZHksIGRpc3RhbmNlLCBub2RlO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgZm9yY2VzID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJbmRpY2VzW2ldO1xuICAgICAgICBub2RlID0gbm9kZXNbbm9kZUlkXTtcbiAgICAgICAgZHggPSAtbm9kZS54O1xuICAgICAgICBkeSA9IC1ub2RlLnk7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgZm9yY2VzLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgYmFzZWQgb24gdGhlIGRpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gICAgICogQHBhcmFtIHtvYmplY3Q8Tm9kZS5pZCwgdmlzLk5vZGU+fSBmb3JjZXNcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZUZvcmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIGZvcmNlcywgbm9kZSkge1xuICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IGRpc3RhbmNlID09PSAwID8gMCA6IHRoaXMub3B0aW9ucy5jZW50cmFsR3Jhdml0eSAvIGRpc3RhbmNlO1xuICAgICAgZm9yY2VzW25vZGUuaWRdLnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIGZvcmNlc1tub2RlLmlkXS55ID0gZHkgKiBncmF2aXR5Rm9yY2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENlbnRyYWxHcmF2aXR5U29sdmVyO1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkMyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQzKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEBhdWdtZW50cyBCYXJuZXNIdXRTb2x2ZXJcbiAqL1xuXG52YXIgRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhcm5lc0h1dFNvbHZlcikge1xuICBfaW5oZXJpdHMoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciwgX0Jhcm5lc0h1dFNvbHZlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQzKEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgX3RoaXMuX3JuZyA9IEFsZWEoXCJGT1JDRSBBVExBUyAyIEJBU0VEIFJFUFVMU0lPTiBTT0xWRVJcIik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIsIFt7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVGb3JjZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpIHtcbiAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICBkaXN0YW5jZSA9IDAuMSAqIHRoaXMuX3JuZygpO1xuICAgICAgICBkeCA9IGRpc3RhbmNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yIDwgMSAmJiBub2RlLnNoYXBlLnJhZGl1cykge1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGgubWF4KDAuMSArIHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciAqIG5vZGUuc2hhcGUucmFkaXVzLCBkaXN0YW5jZSAtIG5vZGUuc2hhcGUucmFkaXVzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlZ3JlZSA9IG5vZGUuZWRnZXMubGVuZ3RoICsgMTsgLy8gdGhlIGRpdmlkaW5nIGJ5IHRoZSBkaXN0YW5jZSBjdWJlZCBpbnN0ZWFkIG9mIHNxdWFyZWQgYWxsb3dzIHVzIHRvIGdldCB0aGUgZnggYW5kIGZ5IGNvbXBvbmVudHMgd2l0aG91dCBzaW5lcyBhbmQgY29zaW5lc1xuICAgICAgLy8gaXQgaXMgc2hvcnRoYW5kIGZvciBncmF2aXR5Zm9yY2Ugd2l0aCBkaXN0YW5jZSBzcXVhcmVkIGFuZCBmeCA9IGR4L2Rpc3RhbmNlICogZ3Jhdml0eUZvcmNlXG5cbiAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSB0aGlzLm9wdGlvbnMuZ3Jhdml0YXRpb25hbENvbnN0YW50ICogcGFyZW50QnJhbmNoLm1hc3MgKiBub2RlLm9wdGlvbnMubWFzcyAqIGRlZ3JlZSAvIE1hdGgucG93KGRpc3RhbmNlLCAyKTtcbiAgICAgIHZhciBmeCA9IGR4ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgdmFyIGZ5ID0gZHkgKiBncmF2aXR5Rm9yY2U7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlLmlkXS54ICs9IGZ4O1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueSArPSBmeTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcjtcbn0oQmFybmVzSHV0U29sdmVyKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDIoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBAYXVnbWVudHMgQ2VudHJhbEdyYXZpdHlTb2x2ZXJcbiAqL1xuXG52YXIgRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2VudHJhbEdyYXZpdHlTb2x2ZXIpIHtcbiAgX2luaGVyaXRzKEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlciwgX0NlbnRyYWxHcmF2aXR5U29sdmVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDIoRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gICAqIEBwYXJhbSB7b2JqZWN0PE5vZGUuaWQsIE5vZGU+fSBmb3JjZXNcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlciwgW3tcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZUZvcmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIGZvcmNlcywgbm9kZSkge1xuICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICB2YXIgZGVncmVlID0gbm9kZS5lZGdlcy5sZW5ndGggKyAxO1xuICAgICAgICB2YXIgZ3Jhdml0eUZvcmNlID0gdGhpcy5vcHRpb25zLmNlbnRyYWxHcmF2aXR5ICogZGVncmVlICogbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICAgIGZvcmNlc1tub2RlLmlkXS54ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICAgIGZvcmNlc1tub2RlLmlkXS55ID0gZHkgKiBncmF2aXR5Rm9yY2U7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcjtcbn0oQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuXG4vKipcbiAqIFRoZSBwaHlzaWNzIGVuZ2luZVxuICovXG5cbnZhciBQaHlzaWNzRW5naW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqL1xuICBmdW5jdGlvbiBQaHlzaWNzRW5naW5lKGJvZHkpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGh5c2ljc0VuZ2luZSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSB7XG4gICAgICBwaHlzaWNzTm9kZUluZGljZXM6IFtdLFxuICAgICAgcGh5c2ljc0VkZ2VJbmRpY2VzOiBbXSxcbiAgICAgIGZvcmNlczoge30sXG4gICAgICB2ZWxvY2l0aWVzOiB7fVxuICAgIH07XG4gICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5zaW11bGF0aW9uSW50ZXJ2YWwgPSAxMDAwIC8gNjA7XG4gICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgIHRoaXMucHJldmlvdXNTdGF0ZXMgPSB7fTtcbiAgICB0aGlzLnJlZmVyZW5jZVN0YXRlID0ge307XG4gICAgdGhpcy5mcmVlemVDYWNoZSA9IHt9O1xuICAgIHRoaXMucmVuZGVyVGltZXIgPSB1bmRlZmluZWQ7IC8vIHBhcmFtZXRlcnMgZm9yIHRoZSBhZGFwdGl2ZSB0aW1lc3RlcFxuXG4gICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRpdmVDb3VudGVyID0gMDtcbiAgICB0aGlzLmFkYXB0aXZlSW50ZXJ2YWwgPSAzO1xuICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zID0gMDtcbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7IC8vIHdpbGwgYmUgc2V0IHRvIHRydWUgaWYgdGhlIHN0YWJpbGl6ZVxuICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBiYXJuZXNIdXQ6IHtcbiAgICAgICAgdGhldGE6IDAuNSxcbiAgICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiAtMjAwMCxcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMyxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiA5NSxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDQsXG4gICAgICAgIGRhbXBpbmc6IDAuMDksXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogMFxuICAgICAgfSxcbiAgICAgIGZvcmNlQXRsYXMyQmFzZWQ6IHtcbiAgICAgICAgdGhldGE6IDAuNSxcbiAgICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiAtNTAsXG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjAxLFxuICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wOCxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiAxMDAsXG4gICAgICAgIGRhbXBpbmc6IDAuNCxcbiAgICAgICAgYXZvaWRPdmVybGFwOiAwXG4gICAgICB9LFxuICAgICAgcmVwdWxzaW9uOiB7XG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjIsXG4gICAgICAgIHNwcmluZ0xlbmd0aDogMjAwLFxuICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wNSxcbiAgICAgICAgbm9kZURpc3RhbmNlOiAxMDAsXG4gICAgICAgIGRhbXBpbmc6IDAuMDksXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogMFxuICAgICAgfSxcbiAgICAgIGhpZXJhcmNoaWNhbFJlcHVsc2lvbjoge1xuICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4wLFxuICAgICAgICBzcHJpbmdMZW5ndGg6IDEwMCxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDEsXG4gICAgICAgIG5vZGVEaXN0YW5jZTogMTIwLFxuICAgICAgICBkYW1waW5nOiAwLjA5XG4gICAgICB9LFxuICAgICAgbWF4VmVsb2NpdHk6IDUwLFxuICAgICAgbWluVmVsb2NpdHk6IDAuNzUsXG4gICAgICAvLyBweC9zXG4gICAgICBzb2x2ZXI6IFwiYmFybmVzSHV0XCIsXG4gICAgICBzdGFiaWxpemF0aW9uOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGl0ZXJhdGlvbnM6IDEwMDAsXG4gICAgICAgIC8vIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbiB0byBzdGFiaWxpemVcbiAgICAgICAgdXBkYXRlSW50ZXJ2YWw6IDUwLFxuICAgICAgICBvbmx5RHluYW1pY0VkZ2VzOiBmYWxzZSxcbiAgICAgICAgZml0OiB0cnVlXG4gICAgICB9LFxuICAgICAgdGltZXN0ZXA6IDAuNSxcbiAgICAgIGFkYXB0aXZlVGltZXN0ZXA6IHRydWUsXG4gICAgICB3aW5kOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgYXNzaWduJDIodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMudGltZXN0ZXAgPSAwLjU7XG4gICAgdGhpcy5sYXlvdXRGYWlsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUGh5c2ljc0VuZ2luZSwgW3tcbiAgICBrZXk6IFwiYmluZEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFBoeXNpY3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5pbml0UGh5c2ljcygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9sYXlvdXRGYWlsZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5sYXlvdXRGYWlsZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlc2V0UGh5c2ljc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnN0b3BTaW11bGF0aW9uKCk7XG5cbiAgICAgICAgX3RoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkaXNhYmxlUGh5c2ljc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnBoeXNpY3NFbmFibGVkID0gZmFsc2U7XG5cbiAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZXN0b3JlUGh5c2ljc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnNldE9wdGlvbnMoX3RoaXMub3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKF90aGlzLnJlYWR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgX3RoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJzdGFydFNpbXVsYXRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMucmVhZHkgPT09IHRydWUpIHtcbiAgICAgICAgICBfdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInN0b3BTaW11bGF0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oZmFsc2UpO1xuXG4gICAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5vZmYoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBOb2RlcyBhbmQvb3IgZWRnZXMgaGF2ZSBiZWVuIGFkZGVkIG9yIHJlbW92ZWQsIHVwZGF0ZSBzaG9ydGN1dCBsaXN0cy5cbiAgICAgICAgX3RoaXMudXBkYXRlUGh5c2ljc0RhdGEoKTtcbiAgICAgIH0pOyAvLyBkZWJ1Zzogc2hvdyBmb3JjZXNcbiAgICAgIC8vIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiYWZ0ZXJEcmF3aW5nXCIsIChjdHgpID0+IHt0aGlzLl9kcmF3Rm9yY2VzKGN0eCk7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgcGh5c2ljcyBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICBzZWxlY3RpdmVOb3REZWVwRXh0ZW5kKFtcInN0YWJpbGl6YXRpb25cIl0sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgXCJzdGFiaWxpemF0aW9uXCIpO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB3aW5kID0gdGhpcy5vcHRpb25zLndpbmQ7XG5cbiAgICAgICAgICBpZiAod2luZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kLnggIT09IFwibnVtYmVyXCIgfHwgaXNOYW4od2luZC54KSkge1xuICAgICAgICAgICAgICB3aW5kLnggPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmQueSAhPT0gXCJudW1iZXJcIiB8fCBpc05hbih3aW5kLnkpKSB7XG4gICAgICAgICAgICAgIHdpbmQueSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBzZXQgdGhlIHRpbWVzdGVwXG5cblxuICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSB0aGlzLm9wdGlvbnMudGltZXN0ZXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNvbmZpZ3VyZSB0aGUgZW5naW5lLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIG9wdGlvbnM7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc29sdmVyID09PSBcImZvcmNlQXRsYXMyQmFzZWRcIikge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLmZvcmNlQXRsYXMyQmFzZWQ7XG4gICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IFNwcmluZ1NvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zb2x2ZXIgPT09IFwicmVwdWxzaW9uXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5yZXB1bHNpb247XG4gICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgUmVwdWxzaW9uU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIgPSBuZXcgU3ByaW5nU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlciA9IG5ldyBDZW50cmFsR3Jhdml0eVNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc29sdmVyID09PSBcImhpZXJhcmNoaWNhbFJlcHVsc2lvblwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsUmVwdWxzaW9uO1xuICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgQ2VudHJhbEdyYXZpdHlTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGJhcm5lc0h1dFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLmJhcm5lc0h1dDtcbiAgICAgICAgdGhpcy5ub2Rlc1NvbHZlciA9IG5ldyBCYXJuZXNIdXRTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5lZGdlc1NvbHZlciA9IG5ldyBTcHJpbmdTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ncmF2aXR5U29sdmVyID0gbmV3IENlbnRyYWxHcmF2aXR5U29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubW9kZWxPcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogaW5pdGlhbGl6ZSB0aGUgZW5naW5lXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0UGh5c2ljc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0UGh5c2ljcygpIHtcbiAgICAgIGlmICh0aGlzLnBoeXNpY3NFbmFibGVkID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zdGFiaWxpemUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZml0XCIsIHt9LCB0aGlzLmxheW91dEZhaWxlZCk7IC8vIGlmIHRoZSBsYXlvdXQgZmFpbGVkLCB3ZSB1c2UgdGhlIGFwcHJveGltYXRpb24gZm9yIHRoZSB6b29tXG5cbiAgICAgICAgICB0aGlzLnN0YXJ0U2ltdWxhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImZpdFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIHNpbXVsYXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0U2ltdWxhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydFNpbXVsYXRpb24oKSB7XG4gICAgICBpZiAodGhpcy5waHlzaWNzRW5hYmxlZCA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBmYWxzZTsgLy8gd2hlbiB2aXNpYmxlLCBhZGFwdGl2aXR5IGlzIGRpc2FibGVkLlxuXG4gICAgICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcCA9IGZhbHNlOyAvLyB0aGlzIHNldHMgdGhlIHdpZHRoIG9mIGFsbCBub2RlcyBpbml0aWFsbHkgd2hpY2ggY291bGQgYmUgcmVxdWlyZWQgZm9yIHRoZSBhdm9pZE92ZXJsYXBcblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2l6ZU5vZGVzXCIpO1xuXG4gICAgICAgIGlmICh0aGlzLnZpZXdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSBiaW5kJDYoX2NvbnRleHQgPSB0aGlzLnNpbXVsYXRpb25TdGVwKS5jYWxsKF9jb250ZXh0LCB0aGlzKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RhcnRSZW5kZXJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSBzaW11bGF0aW9uLCBmb3JjZSBzdGFiaWxpemF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZW1pdD10cnVlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFNpbXVsYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcFNpbXVsYXRpb24oKSB7XG4gICAgICB2YXIgZW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHRoaXMuc3RhYmlsaXplZCA9IHRydWU7XG5cbiAgICAgIGlmIChlbWl0ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2VtaXRTdGFiaWxpemVkKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnZpZXdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RvcFJlbmRlcmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdmlld0Z1bmN0aW9uIGluc2VydHMgdGhpcyBzdGVwIGludG8gZWFjaCByZW5kZXIgbG9vcC4gSXQgY2FsbHMgdGhlIHBoeXNpY3MgdGljayBhbmQgaGFuZGxlcyB0aGUgY2xlYW51cCBhdCBzdGFiaWxpemVkLlxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaW11bGF0aW9uU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaW11bGF0aW9uU3RlcCgpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBwaHlzaWNzIGhhdmUgc2V0dGxlZFxuICAgICAgdmFyIHN0YXJ0VGltZSA9IG5vdyQxKCk7XG5cbiAgICAgIHRoaXMucGh5c2ljc1RpY2soKTtcbiAgICAgIHZhciBwaHlzaWNzVGltZSA9IG5vdyQxKCkgLSBzdGFydFRpbWU7IC8vIHJ1biBkb3VibGUgc3BlZWQgaWYgaXQgaXMgYSBsaXR0bGUgZ3JhcGhcblxuICAgICAgaWYgKChwaHlzaWNzVGltZSA8IDAuNCAqIHRoaXMuc2ltdWxhdGlvbkludGVydmFsIHx8IHRoaXMucnVuRG91YmxlU3BlZWQgPT09IHRydWUpICYmIHRoaXMuc3RhYmlsaXplZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5waHlzaWNzVGljaygpOyAvLyB0aGlzIG1ha2VzIHN1cmUgdGhlcmUgaXMgbm8gaml0dGVyLiBUaGUgZGVjaXNpb24gaXMgdGFrZW4gb25jZSB0byBydW4gaXQgYXQgZG91YmxlIHNwZWVkLlxuXG4gICAgICAgIHRoaXMucnVuRG91YmxlU3BlZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJpZ2dlciB0aGUgc3RhYmlsaXplZCBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYW1vdW50T2ZJdGVyYXRpb25zPXRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnNdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0U3RhYmlsaXplZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFN0YWJpbGl6ZWQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGFtb3VudE9mSXRlcmF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucztcblxuICAgICAgaWYgKHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPiAxIHx8IHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgc2V0VGltZW91dCQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFiaWxpemVkXCIsIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbnM6IGFtb3VudE9mSXRlcmF0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgX3RoaXMyLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMyLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zID0gMDtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGZvciBvbmUgcGh5c2ljcyBpdGVyYXRpb24gYW5kIG1vdmUgdGhlIG5vZGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBoeXNpY3NTdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBoeXNpY3NTdGVwKCkge1xuICAgICAgdGhpcy5ncmF2aXR5U29sdmVyLnNvbHZlKCk7XG4gICAgICB0aGlzLm5vZGVzU29sdmVyLnNvbHZlKCk7XG4gICAgICB0aGlzLmVkZ2VzU29sdmVyLnNvbHZlKCk7XG4gICAgICB0aGlzLm1vdmVOb2RlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlIGR5bmFtaWMgYWRqdXN0bWVudHMgdG8gdGhlIHRpbWVzdGVwLCBiYXNlZCBvbiBjdXJyZW50IHN0YXRlLlxuICAgICAqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBwaHlzaWNzVGljaygpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkanVzdFRpbWVTdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkanVzdFRpbWVTdGVwKCkge1xuICAgICAgdmFyIGZhY3RvciA9IDEuMjsgLy8gRmFjdG9yIGZvciBpbmNyZWFzaW5nIHRoZSB0aW1lc3RlcCBvbiBzdWNjZXNzLlxuICAgICAgLy8gd2UgY29tcGFyZSB0aGUgdHdvIHN0ZXBzLiBpZiBpdCBpcyBhY2NlcHRhYmxlIHdlIGRvdWJsZSB0aGUgc3RlcC5cblxuICAgICAgaWYgKHRoaXMuX2V2YWx1YXRlU3RlcFF1YWxpdHkoKSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnRpbWVzdGVwID0gZmFjdG9yICogdGhpcy50aW1lc3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIG5vdCwgd2UgZGVjcmVhc2UgdGhlIHN0ZXAgdG8gYSBtaW5pbXVtIG9mIHRoZSBvcHRpb25zIHRpbWVzdGVwLlxuICAgICAgICAvLyBpZiB0aGUgZGVjcmVhc2VkIHRpbWVzdGVwIGlzIHNtYWxsZXIgdGhhbiB0aGUgb3B0aW9ucyBzdGVwLCB3ZSBkbyBub3QgcmVzZXQgdGhlIGNvdW50ZXJcbiAgICAgICAgLy8gd2UgYXNzdW1lIHRoYXQgdGhlIG9wdGlvbnMgdGltZXN0ZXAgaXMgc3RhYmxlIGVub3VnaC5cbiAgICAgICAgaWYgKHRoaXMudGltZXN0ZXAgLyBmYWN0b3IgPCB0aGlzLm9wdGlvbnMudGltZXN0ZXApIHtcbiAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gdGhpcy5vcHRpb25zLnRpbWVzdGVwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIHRoZSB0aW1lc3RlcCB3YXMgbGFyZ2VyIHRoYW4gMiB0aW1lcyB0aGUgb3B0aW9uIG9uZSB3ZSBjaGVjayB0aGUgYWRhcHRpdml0eSBhZ2FpbiB0byBlbnN1cmVcbiAgICAgICAgICAvLyB0aGF0IGxhcmdlIGluc3RhYmlsaXRpZXMgZG8gbm90IGZvcm0uXG4gICAgICAgICAgdGhpcy5hZGFwdGl2ZUNvdW50ZXIgPSAtMTsgLy8gY2hlY2sgYWdhaW4gbmV4dCBpdGVyYXRpb25cblxuICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSBNYXRoLm1heCh0aGlzLm9wdGlvbnMudGltZXN0ZXAsIHRoaXMudGltZXN0ZXAgLyBmYWN0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc2luZ2xlIHNpbXVsYXRpb24gc3RlcCAob3IgJ3RpY2snKSBpbiB0aGUgcGh5c2ljcyBzaW11bGF0aW9uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGh5c2ljc1RpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGh5c2ljc1RpY2soKSB7XG4gICAgICB0aGlzLl9zdGFydFN0YWJpbGl6aW5nKCk7IC8vIHRoaXMgZW5zdXJlcyB0aGF0IHRoZXJlIGlzIG5vIHN0YXJ0IGV2ZW50IHdoZW4gdGhlIG5ldHdvcmsgaXMgYWxyZWFkeSBzdGFibGUuXG5cblxuICAgICAgaWYgKHRoaXMuc3RhYmlsaXplZCA9PT0gdHJ1ZSkgcmV0dXJuOyAvLyBhZGFwdGl2aXR5IG1lYW5zIHRoZSB0aW1lc3RlcCBhZGFwdHMgdG8gdGhlIHNpdHVhdGlvbiwgb25seSBhcHBsaWNhYmxlIGZvciBzdGFiaWxpemF0aW9uXG5cbiAgICAgIGlmICh0aGlzLmFkYXB0aXZlVGltZXN0ZXAgPT09IHRydWUgJiYgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyB0aW1lc3RlcCByZW1haW5zIHN0YWJsZSBmb3IgXCJpbnRlcnZhbFwiIGl0ZXJhdGlvbnMuXG4gICAgICAgIHZhciBkb0FkYXB0aXZlID0gdGhpcy5hZGFwdGl2ZUNvdW50ZXIgJSB0aGlzLmFkYXB0aXZlSW50ZXJ2YWwgPT09IDA7XG5cbiAgICAgICAgaWYgKGRvQWRhcHRpdmUpIHtcbiAgICAgICAgICAvLyBmaXJzdCB0aGUgYmlnIHN0ZXAgYW5kIHJldmVydC5cbiAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gMiAqIHRoaXMudGltZXN0ZXA7XG4gICAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpO1xuICAgICAgICAgIHRoaXMucmV2ZXJ0KCk7IC8vIHNhdmVzIHRoZSByZWZlcmVuY2Ugc3RhdGVcbiAgICAgICAgICAvLyBub3cgdGhlIG5vcm1hbCBzdGVwLiBTaW5jZSB0aGlzIGlzIHRoZSBsYXN0IHN0ZXAsIGl0IGlzIHRoZSBtb3JlIHN0YWJsZSBvbmUgYW5kIHdlIHdpbGwgdGFrZSB0aGlzLlxuXG4gICAgICAgICAgdGhpcy50aW1lc3RlcCA9IDAuNSAqIHRoaXMudGltZXN0ZXA7IC8vIHNpbmNlIGl0J3MgaGFsZiB0aGUgc3RlcCwgd2UgZG8gaXQgdHdpY2UuXG5cbiAgICAgICAgICB0aGlzLnBoeXNpY3NTdGVwKCk7XG4gICAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpO1xuICAgICAgICAgIHRoaXMuYWRqdXN0VGltZVN0ZXAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NTdGVwKCk7IC8vIG5vcm1hbCBzdGVwLCBrZWVwaW5nIHRpbWVzdGVwIGNvbnN0YW50XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkYXB0aXZlQ291bnRlciArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2FzZSBmb3IgdGhlIHN0YXRpYyB0aW1lc3RlcCwgd2UgcmVzZXQgaXQgdG8gdGhlIG9uZSBpbiBvcHRpb25zIGFuZCB0YWtlIGEgbm9ybWFsIHN0ZXAuXG4gICAgICAgIHRoaXMudGltZXN0ZXAgPSB0aGlzLm9wdGlvbnMudGltZXN0ZXA7XG4gICAgICAgIHRoaXMucGh5c2ljc1N0ZXAoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhYmlsaXplZCA9PT0gdHJ1ZSkgdGhpcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMrKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9kZXMgYW5kIGVkZ2VzIGNhbiBoYXZlIHRoZSBwaHlzaWNzIHRvZ2dsZXMgb24gb3Igb2ZmLiBBIGNvbGxlY3Rpb24gb2YgaW5kaWNlcyBpcyBjcmVhdGVkIGhlcmUgc28gd2UgY2FuIHNraXAgdGhlIGNoZWNrIGFsbCB0aGUgdGltZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVQaHlzaWNzRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQaHlzaWNzRGF0YSgpIHtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzID0ge307XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcyA9IFtdO1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzRWRnZUluZGljZXMgPSBbXTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlczsgLy8gZ2V0IG5vZGUgaW5kaWNlcyBmb3IgcGh5c2ljc1xuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgIGlmIChub2Rlc1tub2RlSWRdLm9wdGlvbnMucGh5c2ljcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMucHVzaChub2Rlc1tub2RlSWRdLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZ2V0IGVkZ2UgaW5kaWNlcyBmb3IgcGh5c2ljc1xuXG5cbiAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBlZGdlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICAgICAgaWYgKGVkZ2VzW2VkZ2VJZF0ub3B0aW9ucy5waHlzaWNzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcy5wdXNoKGVkZ2VzW2VkZ2VJZF0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBnZXQgdGhlIHZlbG9jaXR5IGFuZCB0aGUgZm9yY2VzIHZlY3RvclxuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9ub2RlSWQgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlc1tpXTtcbiAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbX25vZGVJZF0gPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07IC8vIGZvcmNlcyBjYW4gYmUgcmVzZXQgYmVjYXVzZSB0aGV5IGFyZSByZWNhbGN1bGF0ZWQuIFZlbG9jaXRpZXMgaGF2ZSB0byBwZXJzaXN0LlxuXG4gICAgICAgIGlmICh0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXNbX25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tfbm9kZUlkXSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBjbGVhbiBkZWxldGVkIG5vZGVzIGZyb20gdGhlIHZlbG9jaXR5IHZlY3RvclxuXG5cbiAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllcykge1xuICAgICAgICBpZiAobm9kZXNbX25vZGVJZDJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW19ub2RlSWQyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXZlcnQgdGhlIHNpbXVsYXRpb24gb25lIHN0ZXAuIFRoaXMgaXMgZG9uZSBzbyBhZnRlciBzdGFiaWxpemF0aW9uLCBldmVyeSBuZXcgc3RhcnQgb2YgdGhlIHNpbXVsYXRpb24gd2lsbCBhbHNvIHNheSBzdGFiaWxpemVkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmV2ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVydCgpIHtcbiAgICAgIHZhciBub2RlSWRzID0ga2V5cyQ0KHRoaXMucHJldmlvdXNTdGF0ZXMpO1xuXG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgdmVsb2NpdGllcyA9IHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllcztcbiAgICAgIHRoaXMucmVmZXJlbmNlU3RhdGUgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlSWRzW2ldO1xuXG4gICAgICAgIGlmIChub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobm9kZXNbbm9kZUlkXS5vcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlU3RhdGVbbm9kZUlkXSA9IHtcbiAgICAgICAgICAgICAgcG9zaXRpb25zOiB7XG4gICAgICAgICAgICAgICAgeDogbm9kZXNbbm9kZUlkXS54LFxuICAgICAgICAgICAgICAgIHk6IG5vZGVzW25vZGVJZF0ueVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmVsb2NpdGllc1tub2RlSWRdLnggPSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0udng7XG4gICAgICAgICAgICB2ZWxvY2l0aWVzW25vZGVJZF0ueSA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS52eTtcbiAgICAgICAgICAgIG5vZGVzW25vZGVJZF0ueCA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS54O1xuICAgICAgICAgICAgbm9kZXNbbm9kZUlkXS55ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBjb21wYXJlcyB0aGUgcmVmZXJlbmNlIHN0YXRlIHRvIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2YWx1YXRlU3RlcFF1YWxpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2YWx1YXRlU3RlcFF1YWxpdHkoKSB7XG4gICAgICB2YXIgZHgsIGR5LCBkcG9zO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIHJlZmVyZW5jZSA9IHRoaXMucmVmZXJlbmNlU3RhdGU7XG4gICAgICB2YXIgcG9zVGhyZXNob2xkID0gMC4zO1xuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5yZWZlcmVuY2VTdGF0ZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucmVmZXJlbmNlU3RhdGUsIG5vZGVJZCkgJiYgbm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZHggPSBub2Rlc1tub2RlSWRdLnggLSByZWZlcmVuY2Vbbm9kZUlkXS5wb3NpdGlvbnMueDtcbiAgICAgICAgICBkeSA9IG5vZGVzW25vZGVJZF0ueSAtIHJlZmVyZW5jZVtub2RlSWRdLnBvc2l0aW9ucy55O1xuICAgICAgICAgIGRwb3MgPSBNYXRoLnNxcnQoTWF0aC5wb3coZHgsIDIpICsgTWF0aC5wb3coZHksIDIpKTtcblxuICAgICAgICAgIGlmIChkcG9zID4gcG9zVGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtb3ZlIHRoZSBub2RlcyBvbmUgdGltZXN0ZXAgYW5kIGNoZWNrIGlmIHRoZXkgYXJlIHN0YWJpbGl6ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVOb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlTm9kZXMoKSB7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgIHZhciBtYXhOb2RlVmVsb2NpdHkgPSAwO1xuICAgICAgdmFyIGF2ZXJhZ2VOb2RlVmVsb2NpdHkgPSAwOyAvLyB0aGUgdmVsb2NpdHkgdGhyZXNob2xkIChlbmVyZ3kgaW4gdGhlIHN5c3RlbSkgZm9yIHRoZSBhZGFwdGl2aXR5IHRvZ2dsZVxuXG4gICAgICB2YXIgdmVsb2NpdHlBZGFwdGl2ZVRocmVzaG9sZCA9IDU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJbmRpY2VzW2ldO1xuXG4gICAgICAgIHZhciBub2RlVmVsb2NpdHkgPSB0aGlzLl9wZXJmb3JtU3RlcChub2RlSWQpOyAvLyBzdGFiaWxpemVkIGlzIHRydWUgaWYgc3RhYmlsaXplZCBpcyB0cnVlIGFuZCB2ZWxvY2l0eSBpcyBzbWFsbGVyIHRoYW4gdm1pbiAtLT4gYWxsIG5vZGVzIG11c3QgYmUgc3RhYmlsaXplZFxuXG5cbiAgICAgICAgbWF4Tm9kZVZlbG9jaXR5ID0gTWF0aC5tYXgobWF4Tm9kZVZlbG9jaXR5LCBub2RlVmVsb2NpdHkpO1xuICAgICAgICBhdmVyYWdlTm9kZVZlbG9jaXR5ICs9IG5vZGVWZWxvY2l0eTtcbiAgICAgIH0gLy8gZXZhbHVhdGluZyB0aGUgc3RhYmlsaXplZCBhbmQgYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQgY29uZGl0aW9uc1xuXG5cbiAgICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQgPSBhdmVyYWdlTm9kZVZlbG9jaXR5IC8gbm9kZUluZGljZXMubGVuZ3RoIDwgdmVsb2NpdHlBZGFwdGl2ZVRocmVzaG9sZDtcbiAgICAgIHRoaXMuc3RhYmlsaXplZCA9IG1heE5vZGVWZWxvY2l0eSA8IHRoaXMub3B0aW9ucy5taW5WZWxvY2l0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIG5ldyB2ZWxvY2l0eSBmb3IgYSBjb29yZGluYXRlIGRpcmVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHYgIHZlbG9jaXR5IGZvciBjdXJyZW50IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZiAgcmVndWxhciBmb3JjZSBmb3IgY3VycmVudCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG0gIG1hc3Mgb2YgY3VycmVudCBub2RlXG4gICAgICogQHJldHVybnMge251bWJlcn0gbmV3IHZlbG9jaXR5IGZvciBjdXJyZW50IGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlQ29tcG9uZW50VmVsb2NpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlQ29tcG9uZW50VmVsb2NpdHkodiwgZiwgbSkge1xuICAgICAgdmFyIGRmID0gdGhpcy5tb2RlbE9wdGlvbnMuZGFtcGluZyAqIHY7IC8vIGRhbXBpbmcgZm9yY2VcblxuICAgICAgdmFyIGEgPSAoZiAtIGRmKSAvIG07IC8vIGFjY2VsZXJhdGlvblxuXG4gICAgICB2ICs9IGEgKiB0aGlzLnRpbWVzdGVwOyAvLyBQdXQgYSBsaW1pdCBvbiB0aGUgdmVsb2NpdGllcyBpZiBpdCBpcyByZWFsbHkgaGlnaFxuXG4gICAgICB2YXIgbWF4ViA9IHRoaXMub3B0aW9ucy5tYXhWZWxvY2l0eSB8fCAxZTk7XG5cbiAgICAgIGlmIChNYXRoLmFicyh2KSA+IG1heFYpIHtcbiAgICAgICAgdiA9IHYgPiAwID8gbWF4ViA6IC1tYXhWO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSB0aGUgYWN0dWFsIHN0ZXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge251bWJlcn0gdGhlIG5ldyB2ZWxvY2l0eSBvZiBnaXZlbiBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wZXJmb3JtU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybVN0ZXAobm9kZUlkKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgdmFyIGZvcmNlID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZUlkXTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy53aW5kKSB7XG4gICAgICAgIGZvcmNlLnggKz0gdGhpcy5vcHRpb25zLndpbmQueDtcbiAgICAgICAgZm9yY2UueSArPSB0aGlzLm9wdGlvbnMud2luZC55O1xuICAgICAgfVxuXG4gICAgICB2YXIgdmVsb2NpdHkgPSB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXNbbm9kZUlkXTsgLy8gc3RvcmUgdGhlIHN0YXRlIHNvIHdlIGNhbiByZXZlcnRcblxuICAgICAgdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdID0ge1xuICAgICAgICB4OiBub2RlLngsXG4gICAgICAgIHk6IG5vZGUueSxcbiAgICAgICAgdng6IHZlbG9jaXR5LngsXG4gICAgICAgIHZ5OiB2ZWxvY2l0eS55XG4gICAgICB9O1xuXG4gICAgICBpZiAobm9kZS5vcHRpb25zLmZpeGVkLnggPT09IGZhbHNlKSB7XG4gICAgICAgIHZlbG9jaXR5LnggPSB0aGlzLmNhbGN1bGF0ZUNvbXBvbmVudFZlbG9jaXR5KHZlbG9jaXR5LngsIGZvcmNlLngsIG5vZGUub3B0aW9ucy5tYXNzKTtcbiAgICAgICAgbm9kZS54ICs9IHZlbG9jaXR5LnggKiB0aGlzLnRpbWVzdGVwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yY2UueCA9IDA7XG4gICAgICAgIHZlbG9jaXR5LnggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5vcHRpb25zLmZpeGVkLnkgPT09IGZhbHNlKSB7XG4gICAgICAgIHZlbG9jaXR5LnkgPSB0aGlzLmNhbGN1bGF0ZUNvbXBvbmVudFZlbG9jaXR5KHZlbG9jaXR5LnksIGZvcmNlLnksIG5vZGUub3B0aW9ucy5tYXNzKTtcbiAgICAgICAgbm9kZS55ICs9IHZlbG9jaXR5LnkgKiB0aGlzLnRpbWVzdGVwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yY2UueSA9IDA7XG4gICAgICAgIHZlbG9jaXR5LnkgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG90YWxWZWxvY2l0eSA9IE1hdGguc3FydChNYXRoLnBvdyh2ZWxvY2l0eS54LCAyKSArIE1hdGgucG93KHZlbG9jaXR5LnksIDIpKTtcbiAgICAgIHJldHVybiB0b3RhbFZlbG9jaXR5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIGluaXRpYWxpemluZyBhbmQgc3RhYmlsaXppbmcsIHdlIGNhbiBmcmVlemUgbm9kZXMgd2l0aCBhIHByZWRlZmluZWQgcG9zaXRpb24uXG4gICAgICogVGhpcyBncmVhdGx5IHNwZWVkcyB1cCBzdGFiaWxpemF0aW9uIGJlY2F1c2Ugb25seSB0aGUgc3VwcG9ydG5vZGVzIGZvciB0aGUgc21vb3RoQ3VydmVzIGhhdmUgdG8gc2V0dGxlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9mcmVlemVOb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZnJlZXplTm9kZXMoKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG5cbiAgICAgIGZvciAodmFyIGlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIGlkKSkge1xuICAgICAgICAgIGlmIChub2Rlc1tpZF0ueCAmJiBub2Rlc1tpZF0ueSkge1xuICAgICAgICAgICAgdmFyIGZpeGVkID0gbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQ7XG4gICAgICAgICAgICB0aGlzLmZyZWV6ZUNhY2hlW2lkXSA9IHtcbiAgICAgICAgICAgICAgeDogZml4ZWQueCxcbiAgICAgICAgICAgICAgeTogZml4ZWQueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZpeGVkLnggPSB0cnVlO1xuICAgICAgICAgICAgZml4ZWQueSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuZnJlZXplcyB0aGUgbm9kZXMgdGhhdCBoYXZlIGJlZW4gZnJvemVuIGJ5IF9mcmVlemVEZWZpbmVkTm9kZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc3RvcmVGcm96ZW5Ob2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzdG9yZUZyb3plbk5vZGVzKCkge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBpZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVzLCBpZCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5mcmVlemVDYWNoZVtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueCA9IHRoaXMuZnJlZXplQ2FjaGVbaWRdLng7XG4gICAgICAgICAgICBub2Rlc1tpZF0ub3B0aW9ucy5maXhlZC55ID0gdGhpcy5mcmVlemVDYWNoZVtpZF0ueTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5mcmVlemVDYWNoZSA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgc3RhYmxlIHBvc2l0aW9uIGZvciBhbGwgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaXRlcmF0aW9ucz10aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5pdGVyYXRpb25zXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhYmlsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YWJpbGl6ZSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9ucztcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRpb25zICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMgPSB0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5pdGVyYXRpb25zO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlIHN0YWJpbGl6ZSBtZXRob2QgbmVlZHMgYSBudW1lcmljIGFtb3VudCBvZiBpdGVyYXRpb25zLiBTd2l0Y2hpbmcgdG8gZGVmYXVsdDogXCIsIGl0ZXJhdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGVuYWJsZSBhZGFwdGl2ZSB0aW1lc3RlcHNcblxuXG4gICAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXAgPSB0aGlzLm9wdGlvbnMuYWRhcHRpdmVUaW1lc3RlcDsgLy8gdGhpcyBzZXRzIHRoZSB3aWR0aCBvZiBhbGwgbm9kZXMgaW5pdGlhbGx5IHdoaWNoIGNvdWxkIGJlIHJlcXVpcmVkIGZvciB0aGUgYXZvaWRPdmVybGFwXG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzaXplTm9kZXNcIik7XG4gICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7IC8vIHN0b3AgdGhlIHJlbmRlciBsb29wXG5cbiAgICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlOyAvLyBibG9jayByZWRyYXcgcmVxdWVzdHNcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9ibG9ja1JlZHJhd1wiKTtcbiAgICAgIHRoaXMudGFyZ2V0SXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnM7IC8vIHN0YXJ0IHRoZSBzdGFiaWxpemF0aW9uXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5vbmx5RHluYW1pY0VkZ2VzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2ZyZWV6ZU5vZGVzKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgICBzZXRUaW1lb3V0JDEoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLl9zdGFiaWxpemF0aW9uQmF0Y2goKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBub3QgYWxyZWFkeSBzdGFiaWxpemluZywgc3RhcnQgaXQgYW5kIGVtaXQgYSBzdGFydCBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHN0YWJpbGl6YXRpb24gc3RhcnRlZCB3aXRoIHRoaXMgY2FsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3RhcnRTdGFiaWxpemluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRTdGFiaWxpemluZygpIHtcbiAgICAgIGlmICh0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID09PSB0cnVlKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTdGFiaWxpemluZ1wiKTtcbiAgICAgIHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uZSBiYXRjaCBvZiBzdGFiaWxpemF0aW9uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YWJpbGl6YXRpb25CYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhYmlsaXphdGlvbkJhdGNoKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBydW5uaW5nID0gZnVuY3Rpb24gcnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5zdGFiaWxpemVkID09PSBmYWxzZSAmJiBfdGhpczQuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPCBfdGhpczQudGFyZ2V0SXRlcmF0aW9ucztcbiAgICAgIH07XG5cbiAgICAgIHZhciBzZW5kUHJvZ3Jlc3MgPSBmdW5jdGlvbiBzZW5kUHJvZ3Jlc3MoKSB7XG4gICAgICAgIF90aGlzNC5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YWJpbGl6YXRpb25Qcm9ncmVzc1wiLCB7XG4gICAgICAgICAgaXRlcmF0aW9uczogX3RoaXM0LnN0YWJpbGl6YXRpb25JdGVyYXRpb25zLFxuICAgICAgICAgIHRvdGFsOiBfdGhpczQudGFyZ2V0SXRlcmF0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9zdGFydFN0YWJpbGl6aW5nKCkpIHtcbiAgICAgICAgc2VuZFByb2dyZXNzKCk7IC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBzdGFydCBldmVudC5cbiAgICAgIH1cblxuICAgICAgdmFyIGNvdW50ID0gMDtcblxuICAgICAgd2hpbGUgKHJ1bm5pbmcoKSAmJiBjb3VudCA8IHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLnVwZGF0ZUludGVydmFsKSB7XG4gICAgICAgIHRoaXMucGh5c2ljc1RpY2soKTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cblxuICAgICAgc2VuZFByb2dyZXNzKCk7XG5cbiAgICAgIGlmIChydW5uaW5nKCkpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MjtcblxuICAgICAgICBzZXRUaW1lb3V0JDEoYmluZCQ2KF9jb250ZXh0MiA9IHRoaXMuX3N0YWJpbGl6YXRpb25CYXRjaCkuY2FsbChfY29udGV4dDIsIHRoaXMpLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplU3RhYmlsaXphdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcmFwIHVwIHRoZSBzdGFiaWxpemF0aW9uLCBmaXQgYW5kIGVtaXQgdGhlIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmluYWxpemVTdGFiaWxpemF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5hbGl6ZVN0YWJpbGl6YXRpb24oKSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2FsbG93UmVkcmF3XCIpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uZml0ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJmaXRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5vbmx5RHluYW1pY0VkZ2VzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3Jlc3RvcmVGcm96ZW5Ob2RlcygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhYmlsaXphdGlvbkl0ZXJhdGlvbnNEb25lXCIpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuXG4gICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2VtaXRTdGFiaWxpemVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0U2ltdWxhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBERUJVR0dJTkcgQkVMT1cgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiBEZWJ1ZyBmdW5jdGlvbiB0aGF0IGRpc3BsYXkgYXJyb3dzIGZvciB0aGUgZm9yY2VzIGN1cnJlbnRseSBhY3RpdmUgaW4gdGhlIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyB3aGVuIGRlYnVnZ2luZyBvbmx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0ZvcmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0ZvcmNlcyhjdHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXNbaV07XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW2luZGV4XTtcbiAgICAgICAgdmFyIGZvcmNlID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbaW5kZXhdO1xuICAgICAgICB2YXIgZmFjdG9yID0gMjA7XG4gICAgICAgIHZhciBjb2xvckZhY3RvciA9IDAuMDM7XG4gICAgICAgIHZhciBmb3JjZVNpemUgPSBNYXRoLnNxcnQoTWF0aC5wb3coZm9yY2UueCwgMikgKyBNYXRoLnBvdyhmb3JjZS54LCAyKSk7XG4gICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oTWF0aC5tYXgoNSwgZm9yY2VTaXplKSwgMTUpO1xuICAgICAgICB2YXIgYXJyb3dTaXplID0gMyAqIHNpemU7XG4gICAgICAgIHZhciBjb2xvciA9IEhTVlRvSGV4KCgxODAgLSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBjb2xvckZhY3RvciAqIGZvcmNlU2l6ZSkpICogMTgwKSAvIDM2MCwgMSwgMSk7XG4gICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICB4OiBub2RlLnggKyBmYWN0b3IgKiBmb3JjZS54LFxuICAgICAgICAgIHk6IG5vZGUueSArIGZhY3RvciAqIGZvcmNlLnlcbiAgICAgICAgfTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8obm9kZS54LCBub2RlLnkpO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZm9yY2UueSwgZm9yY2UueCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgRW5kUG9pbnRzLmRyYXcoY3R4LCB7XG4gICAgICAgICAgdHlwZTogXCJhcnJvd1wiLFxuICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgICAgbGVuZ3RoOiBhcnJvd1NpemVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZmlsbChjdHgpLmNhbGwoY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGh5c2ljc0VuZ2luZTtcbn0oKTtcblxuLyoqXG4gKiBVdGlsaXR5IENsYXNzXG4gKi9cblxudmFyIE5ldHdvcmtVdGlsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIE5ldHdvcmtVdGlsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOZXR3b3JrVXRpbCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiB0aGUgbmV0d29yayBjb25zaWRlcmluZyB0aGUgYm91bmRpbmcgYm94ZXNcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IGFsbE5vZGVzXG4gICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBbc3BlY2lmaWNOb2Rlcz1bXV1cbiAgICogQHJldHVybnMge3ttaW5YOiBudW1iZXIsIG1heFg6IG51bWJlciwgbWluWTogbnVtYmVyLCBtYXhZOiBudW1iZXJ9fVxuICAgKiBAc3RhdGljXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE5ldHdvcmtVdGlsLCBudWxsLCBbe1xuICAgIGtleTogXCJnZXRSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5nZShhbGxOb2Rlcykge1xuICAgICAgdmFyIHNwZWNpZmljTm9kZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgICAgdmFyIG1pblkgPSAxZTksXG4gICAgICAgICAgbWF4WSA9IC0xZTksXG4gICAgICAgICAgbWluWCA9IDFlOSxcbiAgICAgICAgICBtYXhYID0gLTFlOSxcbiAgICAgICAgICBub2RlO1xuXG4gICAgICBpZiAoc3BlY2lmaWNOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlY2lmaWNOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBhbGxOb2Rlc1tzcGVjaWZpY05vZGVzW2ldXTtcblxuICAgICAgICAgIGlmIChtaW5YID4gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5sZWZ0KSB7XG4gICAgICAgICAgICBtaW5YID0gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5sZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXhYIDwgbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5yaWdodCkge1xuICAgICAgICAgICAgbWF4WCA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1pblkgPiBub2RlLnNoYXBlLmJvdW5kaW5nQm94LnRvcCkge1xuICAgICAgICAgICAgbWluWSA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gudG9wO1xuICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcblxuXG4gICAgICAgICAgaWYgKG1heFkgPCBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmJvdHRvbSkge1xuICAgICAgICAgICAgbWF4WSA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tO1xuICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW5YID09PSAxZTkgJiYgbWF4WCA9PT0gLTFlOSAmJiBtaW5ZID09PSAxZTkgJiYgbWF4WSA9PT0gLTFlOSkge1xuICAgICAgICBtaW5ZID0gMCwgbWF4WSA9IDAsIG1pblggPSAwLCBtYXhYID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluWDogbWluWCxcbiAgICAgICAgbWF4WDogbWF4WCxcbiAgICAgICAgbWluWTogbWluWSxcbiAgICAgICAgbWF4WTogbWF4WVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIHRoZSBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gYWxsTm9kZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gW3NwZWNpZmljTm9kZXM9W11dXG4gICAgICogQHJldHVybnMge3ttaW5YOiBudW1iZXIsIG1heFg6IG51bWJlciwgbWluWTogbnVtYmVyLCBtYXhZOiBudW1iZXJ9fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFJhbmdlQ29yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5nZUNvcmUoYWxsTm9kZXMpIHtcbiAgICAgIHZhciBzcGVjaWZpY05vZGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICAgIHZhciBtaW5ZID0gMWU5LFxuICAgICAgICAgIG1heFkgPSAtMWU5LFxuICAgICAgICAgIG1pblggPSAxZTksXG4gICAgICAgICAgbWF4WCA9IC0xZTksXG4gICAgICAgICAgbm9kZTtcblxuICAgICAgaWYgKHNwZWNpZmljTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNpZmljTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gYWxsTm9kZXNbc3BlY2lmaWNOb2Rlc1tpXV07XG5cbiAgICAgICAgICBpZiAobWluWCA+IG5vZGUueCkge1xuICAgICAgICAgICAgbWluWCA9IG5vZGUueDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF4WCA8IG5vZGUueCkge1xuICAgICAgICAgICAgbWF4WCA9IG5vZGUueDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWluWSA+IG5vZGUueSkge1xuICAgICAgICAgICAgbWluWSA9IG5vZGUueTtcbiAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG5cblxuICAgICAgICAgIGlmIChtYXhZIDwgbm9kZS55KSB7XG4gICAgICAgICAgICBtYXhZID0gbm9kZS55O1xuICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW5YID09PSAxZTkgJiYgbWF4WCA9PT0gLTFlOSAmJiBtaW5ZID09PSAxZTkgJiYgbWF4WSA9PT0gLTFlOSkge1xuICAgICAgICBtaW5ZID0gMCwgbWF4WSA9IDAsIG1pblggPSAwLCBtYXhYID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluWDogbWluWCxcbiAgICAgICAgbWF4WDogbWF4WCxcbiAgICAgICAgbWluWTogbWluWSxcbiAgICAgICAgbWF4WTogbWF4WVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJhbmdlID0ge21pblg6IG1pblgsIG1heFg6IG1heFgsIG1pblk6IG1pblksIG1heFk6IG1heFl9O1xuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpbmRDZW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZENlbnRlcihyYW5nZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMC41ICogKHJhbmdlLm1heFggKyByYW5nZS5taW5YKSxcbiAgICAgICAgeTogMC41ICogKHJhbmdlLm1heFkgKyByYW5nZS5taW5ZKVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyByZXR1cm5zIGEgY2xvbmUgb2YgdGhlIG9wdGlvbnMgb3Igb3B0aW9ucyBvZiB0aGUgZWRnZSBvciBub2RlIHRvIGJlIHVzZWQgZm9yIGNvbnN0cnVjdGlvbiBvZiBuZXcgZWRnZXMgb3IgY2hlY2sgZnVuY3Rpb25zIGZvciBuZXcgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5JdGVtfSBpdGVtXG4gICAgICogQHBhcmFtIHsnbm9kZSd8dW5kZWZpbmVkfSB0eXBlXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb25lT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZU9wdGlvbnMoaXRlbSwgdHlwZSkge1xuICAgICAgdmFyIGNsb25lZE9wdGlvbnMgPSB7fTtcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcIm5vZGVcIikge1xuICAgICAgICBkZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGl0ZW0ub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGNsb25lZE9wdGlvbnMueCA9IGl0ZW0ueDtcbiAgICAgICAgY2xvbmVkT3B0aW9ucy55ID0gaXRlbS55O1xuICAgICAgICBjbG9uZWRPcHRpb25zLmFtb3VudE9mQ29ubmVjdGlvbnMgPSBpdGVtLmVkZ2VzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgaXRlbS5vcHRpb25zLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lZE9wdGlvbnM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5ldHdvcmtVdGlsO1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkMShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgQ2x1c3RlciBpcyBhIHNwZWNpYWwgTm9kZSB0aGF0IGFsbG93cyBhIGdyb3VwIG9mIE5vZGVzIHBvc2l0aW9uZWQgY2xvc2VseSB0b2dldGhlclxuICogdG8gYmUgcmVwcmVzZW50ZWQgYnkgYSBzaW5nbGUgQ2x1c3RlciBOb2RlLlxuICpcbiAqIEBhdWdtZW50cyBOb2RlXG4gKi9cblxudmFyIENsdXN0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0cyhDbHVzdGVyLCBfTm9kZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQxKENsdXN0ZXIpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0FycmF5LjxIVE1MSW1hZ2VFbGVtZW50Pn1pbWFnZWxpc3RcbiAgICogQHBhcmFtIHtBcnJheX0gZ3JvdXBsaXN0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxPcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkZWZhdWx0T3B0aW9ucyAgICAgR2xvYmFsIGRlZmF1bHQgb3B0aW9ucyBmb3Igbm9kZXNcbiAgICovXG4gIGZ1bmN0aW9uIENsdXN0ZXIob3B0aW9ucywgYm9keSwgaW1hZ2VsaXN0LCBncm91cGxpc3QsIGdsb2JhbE9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsdXN0ZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBpbWFnZWxpc3QsIGdyb3VwbGlzdCwgZ2xvYmFsT3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpO1xuICAgIF90aGlzLmlzQ2x1c3RlciA9IHRydWU7XG4gICAgX3RoaXMuY29udGFpbmVkTm9kZXMgPSB7fTtcbiAgICBfdGhpcy5jb250YWluZWRFZGdlcyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogVHJhbnNmZXIgY2hpbGQgY2x1c3RlciBkYXRhIHRvIGN1cnJlbnQgYW5kIGRpc2Nvbm5lY3QgdGhlIGNoaWxkIGNsdXN0ZXIuXG4gICAqXG4gICAqIFBsZWFzZSBjb25zdWx0IHRoZSBoZWFkZXIgY29tbWVudCBpbiAnQ2x1c3RlcmluZy5qcycgZm9yIHRoZSBmaWVsZHMgc2V0IGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY2hpbGRDbHVzdGVySWQgIGlkIG9mIGNoaWxkIGNsdXN0ZXIgdG8gb3BlblxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDbHVzdGVyLCBbe1xuICAgIGtleTogXCJfb3BlbkNoaWxkQ2x1c3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlbkNoaWxkQ2x1c3RlcihjaGlsZENsdXN0ZXJJZCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGlsZENsdXN0ZXIgPSB0aGlzLmJvZHkubm9kZXNbY2hpbGRDbHVzdGVySWRdO1xuXG4gICAgICBpZiAodGhpcy5jb250YWluZWROb2Rlc1tjaGlsZENsdXN0ZXJJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub2RlIHdpdGggaWQ6IFwiICsgY2hpbGRDbHVzdGVySWQgKyBcIiBub3QgaW4gY3VycmVudCBjbHVzdGVyXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNoaWxkQ2x1c3Rlci5pc0NsdXN0ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9kZSB3aXRoIGlkOiBcIiArIGNoaWxkQ2x1c3RlcklkICsgXCIgaXMgbm90IGEgY2x1c3RlclwiKTtcbiAgICAgIH0gLy8gRGlzY29ubmVjdCBjaGlsZCBjbHVzdGVyIGZyb20gY3VycmVudCBjbHVzdGVyXG5cblxuICAgICAgZGVsZXRlIHRoaXMuY29udGFpbmVkTm9kZXNbY2hpbGRDbHVzdGVySWRdO1xuICAgICAgZm9yRWFjaCQxKGNoaWxkQ2x1c3Rlci5lZGdlcywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5jb250YWluZWRFZGdlc1tlZGdlLmlkXTtcbiAgICAgIH0pOyAvLyBUcmFuc2ZlciBub2RlcyBhbmQgZWRnZXNcblxuICAgICAgZm9yRWFjaCQxKGNoaWxkQ2x1c3Rlci5jb250YWluZWROb2RlcywgZnVuY3Rpb24gKG5vZGUsIG5vZGVJZCkge1xuICAgICAgICBfdGhpczIuY29udGFpbmVkTm9kZXNbbm9kZUlkXSA9IG5vZGU7XG4gICAgICB9KTtcbiAgICAgIGNoaWxkQ2x1c3Rlci5jb250YWluZWROb2RlcyA9IHt9O1xuICAgICAgZm9yRWFjaCQxKGNoaWxkQ2x1c3Rlci5jb250YWluZWRFZGdlcywgZnVuY3Rpb24gKGVkZ2UsIGVkZ2VJZCkge1xuICAgICAgICBfdGhpczIuY29udGFpbmVkRWRnZXNbZWRnZUlkXSA9IGVkZ2U7XG4gICAgICB9KTtcbiAgICAgIGNoaWxkQ2x1c3Rlci5jb250YWluZWRFZGdlcyA9IHt9OyAvLyBUcmFuc2ZlciBlZGdlcyB3aXRoaW4gY2x1c3RlciBlZGdlcyB3aGljaCBhcmUgY2x1c3RlcmVkXG5cbiAgICAgIGZvckVhY2gkMShjaGlsZENsdXN0ZXIuZWRnZXMsIGZ1bmN0aW9uIChjbHVzdGVyRWRnZSkge1xuICAgICAgICBmb3JFYWNoJDEoX3RoaXMyLmVkZ2VzLCBmdW5jdGlvbiAocGFyZW50Q2x1c3RlckVkZ2UpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQsIF9jb250ZXh0MjtcblxuICAgICAgICAgIC8vIEFzc3VtcHRpb246IGEgY2x1c3RlcmVkIGVkZ2UgY2FuIG9ubHkgYmUgcHJlc2VudCBpbiBhIHNpbmdsZSBjbHVzdGVyaW5nIGVkZ2VcbiAgICAgICAgICAvLyBOb3QgdGVzdGVkIGhlcmVcbiAgICAgICAgICB2YXIgaW5kZXggPSBpbmRleE9mKF9jb250ZXh0ID0gcGFyZW50Q2x1c3RlckVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMpLmNhbGwoX2NvbnRleHQsIGNsdXN0ZXJFZGdlLmlkKTtcblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybjtcbiAgICAgICAgICBmb3JFYWNoJDEoY2x1c3RlckVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMsIGZ1bmN0aW9uIChzcmNJZCkge1xuICAgICAgICAgICAgcGFyZW50Q2x1c3RlckVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMucHVzaChzcmNJZCk7IC8vIE1haW50YWluIGNvcnJlY3QgYm9va2tlZXBpbmcgZm9yIHRyYW5zZmVycmVkIGVkZ2VcblxuICAgICAgICAgICAgX3RoaXMyLmJvZHkuZWRnZXNbc3JjSWRdLmVkZ2VSZXBsYWNlZEJ5SWQgPSBwYXJlbnRDbHVzdGVyRWRnZS5pZDtcbiAgICAgICAgICB9KTsgLy8gUmVtb3ZlIGNsdXN0ZXIgZWRnZSBmcm9tIHBhcmVudCBjbHVzdGVyIGVkZ2VcblxuICAgICAgICAgIHNwbGljZSQxKF9jb250ZXh0MiA9IHBhcmVudENsdXN0ZXJFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzKS5jYWxsKF9jb250ZXh0MiwgaW5kZXgsIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY2hpbGRDbHVzdGVyLmVkZ2VzID0gW107XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENsdXN0ZXI7XG59KE5vZGUpO1xuXG4vKipcbiAqIFRoZSBjbHVzdGVyaW5nIGVuZ2luZVxuICovXG5cbnZhciBDbHVzdGVyRW5naW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqL1xuICBmdW5jdGlvbiBDbHVzdGVyRW5naW5lKGJvZHkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsdXN0ZXJFbmdpbmUpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNsdXN0ZXJlZE5vZGVzID0ge307IC8vIGtleTogbm9kZSBpZCwgdmFsdWU6IHsgY2x1c3RlcklkOiA8aWQgb2YgY2x1c3Rlcj4sIG5vZGU6IDxub2RlIGluc3RhbmNlPn1cblxuICAgIHRoaXMuY2x1c3RlcmVkRWRnZXMgPSB7fTsgLy8ga2V5OiBlZGdlIGlkLCB2YWx1ZTogcmVzdG9yZSBpbmZvcm1hdGlvbiBmb3IgZ2l2ZW4gZWRnZVxuXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4gICAgYXNzaWduJDIodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3Jlc2V0RGF0YVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jbHVzdGVyZWROb2RlcyA9IHt9O1xuICAgICAgX3RoaXMuY2x1c3RlcmVkRWRnZXMgPSB7fTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGh1YnNpemVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ2x1c3RlckVuZ2luZSwgW3tcbiAgICBrZXk6IFwiY2x1c3RlckJ5SHVic2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnlIdWJzaXplKGh1YnNpemUsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChodWJzaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaHVic2l6ZSA9IHRoaXMuX2dldEh1YlNpemUoKTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihodWJzaXplKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKGh1YnNpemUpO1xuICAgICAgICBodWJzaXplID0gdGhpcy5fZ2V0SHViU2l6ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZXNUb0NsdXN0ZXIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXTtcblxuICAgICAgICBpZiAobm9kZS5lZGdlcy5sZW5ndGggPj0gaHVic2l6ZSkge1xuICAgICAgICAgIG5vZGVzVG9DbHVzdGVyLnB1c2gobm9kZS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVzVG9DbHVzdGVyLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0aGlzLmNsdXN0ZXJCeUNvbm5lY3Rpb24obm9kZXNUb0NsdXN0ZXJbX2ldLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbG9vcCBvdmVyIGFsbCBub2RlcywgY2hlY2sgaWYgdGhleSBhZGhlcmUgdG8gdGhlIGNvbmRpdGlvbiBhbmQgY2x1c3RlciBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZnJlc2hEYXRhPXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbHVzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgY2x1c3RlckJ5Tm9kZURhdGEgd2l0aG91dCBhIGpvaW5Db25kaXRpb24gZnVuY3Rpb24gaW4gdGhlIG9wdGlvbnMuXCIpO1xuICAgICAgfSAvLyBjaGVjayBpZiB0aGUgb3B0aW9ucyBvYmplY3QgaXMgZmluZSwgYXBwZW5kIGlmIG5lZWRlZFxuXG5cbiAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMob3B0aW9ucyk7XG4gICAgICB2YXIgY2hpbGROb2Rlc09iaiA9IHt9O1xuICAgICAgdmFyIGNoaWxkRWRnZXNPYmogPSB7fTsgLy8gY29sbGVjdCB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG5cbiAgICAgIGZvckVhY2gkMSh0aGlzLmJvZHkubm9kZXMsIGZ1bmN0aW9uIChub2RlLCBub2RlSWQpIHtcbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucyAmJiBvcHRpb25zLmpvaW5Db25kaXRpb24obm9kZS5vcHRpb25zKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNoaWxkTm9kZXNPYmpbbm9kZUlkXSA9IG5vZGU7IC8vIGNvbGxlY3QgdGhlIGVkZ2VzIHRoYXQgd2lsbCBiZSBpbiB0aGUgY2x1c3RlclxuXG4gICAgICAgICAgZm9yRWFjaCQxKG5vZGUuZWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9jbHVzdGVyKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIG9wdGlvbnMsIHJlZnJlc2hEYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2x1c3RlciBhbGwgbm9kZXMgaW4gdGhlIG5ldHdvcmsgdGhhdCBoYXZlIG9ubHkgWCBlZGdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VDb3VudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsdXN0ZXJCeUVkZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnlFZGdlQ291bnQoZWRnZUNvdW50LCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgICAgb3B0aW9ucyA9IHRoaXMuX2NoZWNrT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHZhciBjbHVzdGVycyA9IFtdO1xuICAgICAgdmFyIHVzZWROb2RlcyA9IHt9O1xuICAgICAgdmFyIGVkZ2UsIGVkZ2VzLCByZWxldmFudEVkZ2VDb3VudDsgLy8gY29sbGVjdCB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZXNPYmogPSB7fTtcbiAgICAgICAgdmFyIGNoaWxkRWRnZXNPYmogPSB7fTtcbiAgICAgICAgdmFyIG5vZGVJZCA9IF90aGlzMy5ib2R5Lm5vZGVJbmRpY2VzW2ldO1xuICAgICAgICB2YXIgbm9kZSA9IF90aGlzMy5ib2R5Lm5vZGVzW25vZGVJZF07IC8vIGlmIHRoaXMgbm9kZSBpcyBhbHJlYWR5IHVzZWQgaW4gYW5vdGhlciBjbHVzdGVyIHRoaXMgc2Vzc2lvbiwgd2UgZG8gbm90IGhhdmUgdG8gcmUtZXZhbHVhdGUgaXQuXG5cbiAgICAgICAgaWYgKHVzZWROb2Rlc1tub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZWxldmFudEVkZ2VDb3VudCA9IDA7XG4gICAgICAgICAgZWRnZXMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZWRnZSA9IG5vZGUuZWRnZXNbal07XG5cbiAgICAgICAgICAgIGlmIChfdGhpczMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoZWRnZS50b0lkICE9PSBlZGdlLmZyb21JZCkge1xuICAgICAgICAgICAgICAgIHJlbGV2YW50RWRnZUNvdW50Kys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBlZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gdGhpcyBub2RlIHF1YWxpZmllcywgd2UgY29sbGVjdCBpdHMgbmVpZ2hib3VycyB0byBzdGFydCB0aGUgY2x1c3RlcmluZyBwcm9jZXNzLlxuXG5cbiAgICAgICAgICBpZiAocmVsZXZhbnRFZGdlQ291bnQgPT09IGVkZ2VDb3VudCkge1xuICAgICAgICAgICAgdmFyIGNoZWNrSm9pbkNvbmRpdGlvbiA9IGZ1bmN0aW9uIGNoZWNrSm9pbkNvbmRpdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKG5vZGUpO1xuICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5qb2luQ29uZGl0aW9uKGNsb25lZE9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdhdGhlcmluZ1N1Y2Nlc3NmdWwgPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgZWRnZXMubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICAgIGVkZ2UgPSBlZGdlc1tfal07XG5cbiAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZUlkID0gX3RoaXMzLl9nZXRDb25uZWN0ZWRJZChlZGdlLCBub2RlSWQpOyAvLyBhZGQgdGhlIG5vZGVzIHRvIHRoZSBsaXN0IGJ5IHRoZSBqb2luIGNvbmRpdGlvbi5cblxuXG4gICAgICAgICAgICAgIGlmIChjaGVja0pvaW5Db25kaXRpb24obm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzT2JqW25vZGVJZF0gPSBub2RlO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdID0gX3RoaXMzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICAgICAgICAgIHVzZWROb2Rlc1tub2RlSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIG5vZGUgZG9lcyBub3QgcXVhbGlmeSBhZnRlciBhbGwuXG4gICAgICAgICAgICAgICAgZ2F0aGVyaW5nU3VjY2Vzc2Z1bCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIGFkZCB0byB0aGUgY2x1c3RlciBxdWV1ZVxuXG5cbiAgICAgICAgICAgIGlmIChrZXlzJDQoY2hpbGROb2Rlc09iaikubGVuZ3RoID4gMCAmJiBrZXlzJDQoY2hpbGRFZGdlc09iaikubGVuZ3RoID4gMCAmJiBnYXRoZXJpbmdTdWNjZXNzZnVsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZWFyY2ggZm9yIGNsdXN0ZXIgZGF0YSB0aGF0IGNvbnRhaW5zIGFueSBvZiB0aGUgbm9kZSBpZCdzXG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIG5vIGpvaW5Db25kaXRpb24sIG90aGVyd2lzZSByZXR1cm4gdmFsdWUgb2Ygam9pbkNvbmRpdGlvblxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgdmFyIGZpbmRDbHVzdGVyRGF0YSA9IGZ1bmN0aW9uIGZpbmRDbHVzdGVyRGF0YSgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGNsdXN0ZXJzLmxlbmd0aDsgKytuKSB7XG4gICAgICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIGEgY2x1c3RlciBjb250YWluaW5nIGFueSBvZiB0aGUgbm9kZSBpZCdzXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBtIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsdXN0ZXJzW25dLm5vZGVzW21dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2x1c3RlcnNbbl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9OyAvLyBJZiBhbnkgb2YgdGhlIGZvdW5kIG5vZGVzIGlzIHBhcnQgb2YgYSBjbHVzdGVyIGZvdW5kIGluIHRoaXMgbWV0aG9kLFxuICAgICAgICAgICAgICAvLyBhZGQgdGhlIGN1cnJlbnQgdmFsdWVzIHRvIHRoYXQgY2x1c3RlclxuXG5cbiAgICAgICAgICAgICAgdmFyIGZvdW5kQ2x1c3RlciA9IGZpbmRDbHVzdGVyRGF0YSgpO1xuXG4gICAgICAgICAgICAgIGlmIChmb3VuZENsdXN0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBub2RlcyB0byBmb3VuZCBjbHVzdGVyIGlmIG5vdCBwcmVzZW50XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZm91bmRDbHVzdGVyLm5vZGVzW21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRDbHVzdGVyLm5vZGVzW21dID0gY2hpbGROb2Rlc09ialttXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIEFkZCBlZGdlcyB0byBmb3VuZCBjbHVzdGVyLCBpZiBub3QgcHJlc2VudFxuXG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbSBpbiBjaGlsZEVkZ2VzT2JqKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZm91bmRDbHVzdGVyLmVkZ2VzW19tXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kQ2x1c3Rlci5lZGdlc1tfbV0gPSBjaGlsZEVkZ2VzT2JqW19tXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNsdXN0ZXIgZ3JvdXBcbiAgICAgICAgICAgICAgICBjbHVzdGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG5vZGVzOiBjaGlsZE5vZGVzT2JqLFxuICAgICAgICAgICAgICAgICAgZWRnZXM6IGNoaWxkRWRnZXNPYmpcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX2xvb3AoaSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNsdXN0ZXJzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdGhpcy5fY2x1c3RlcihjbHVzdGVyc1tfaTJdLm5vZGVzLCBjbHVzdGVyc1tfaTJdLmVkZ2VzLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWZyZXNoRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbHVzdGVyIGFsbCBub2RlcyBpbiB0aGUgbmV0d29yayB0aGF0IGhhdmUgb25seSAxIGVkZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsdXN0ZXJPdXRsaWVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyT3V0bGllcnMob3B0aW9ucykge1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdGhpcy5jbHVzdGVyQnlFZGdlQ291bnQoMSwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbHVzdGVyIGFsbCBub2RlcyBpbiB0aGUgbmV0d29yayB0aGF0IGhhdmUgb25seSAyIGVkZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsdXN0ZXJCcmlkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXJCcmlkZ2VzKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHRoaXMuY2x1c3RlckJ5RWRnZUNvdW50KDIsIG9wdGlvbnMsIHJlZnJlc2hEYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc3VjayBhbGwgY29ubmVjdGVkIG5vZGVzIG9mIGEgbm9kZSBpbnRvIHRoZSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZnJlc2hEYXRhPXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbHVzdGVyQnlDb25uZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXJCeUNvbm5lY3Rpb24obm9kZUlkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcblxuICAgICAgLy8ga2lsbCBjb25kaXRpb25zXG4gICAgICBpZiAobm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbm9kZUlkIHN1cHBsaWVkIHRvIGNsdXN0ZXJCeUNvbm5lY3Rpb24hXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbm9kZUlkIGdpdmVuIHRvIGNsdXN0ZXJCeUNvbm5lY3Rpb24gZG9lcyBub3QgZXhpc3QhXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgb3B0aW9ucyA9IHRoaXMuX2NoZWNrT3B0aW9ucyhvcHRpb25zLCBub2RlKTtcblxuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID0gbm9kZS54O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPSBub2RlLnk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkID0ge307XG4gICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkLnggPSBub2RlLm9wdGlvbnMuZml4ZWQueDtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQueSA9IG5vZGUub3B0aW9ucy5maXhlZC55O1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGROb2Rlc09iaiA9IHt9O1xuICAgICAgdmFyIGNoaWxkRWRnZXNPYmogPSB7fTtcbiAgICAgIHZhciBwYXJlbnROb2RlSWQgPSBub2RlLmlkO1xuICAgICAgdmFyIHBhcmVudENsb25lZE9wdGlvbnMgPSBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMobm9kZSk7XG4gICAgICBjaGlsZE5vZGVzT2JqW3BhcmVudE5vZGVJZF0gPSBub2RlOyAvLyBjb2xsZWN0IHRoZSBub2RlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcblxuICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZUlkID0gdGhpcy5fZ2V0Q29ubmVjdGVkSWQoZWRnZSwgcGFyZW50Tm9kZUlkKTsgLy8gaWYgdGhlIGNoaWxkIG5vZGUgaXMgbm90IGluIGEgY2x1c3RlclxuXG5cbiAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWROb2Rlc1tjaGlsZE5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZUlkICE9PSBwYXJlbnROb2RlSWQpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF0gPSB0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNsb25lIHRoZSBvcHRpb25zIGFuZCBpbnNlcnQgc29tZSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgdGhhdCBjb3VsZCBiZSBpbnRlcmVzdGluZy5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRDbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKHRoaXMuYm9keS5ub2Rlc1tjaGlsZE5vZGVJZF0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbihwYXJlbnRDbG9uZWRPcHRpb25zLCBjaGlsZENsb25lZE9wdGlvbnMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHN3YWxsb3cgdGhlIGVkZ2UgaWYgaXQgaXMgc2VsZi1yZWZlcmVuY2luZy5cbiAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZE5vZGVJRHMgPSBtYXAkMyhfY29udGV4dCA9IGtleXMkNChjaGlsZE5vZGVzT2JqKSkuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICByZXR1cm4gY2hpbGROb2Rlc09ialtjaGlsZE5vZGVdLmlkO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGNoaWxkTm9kZUtleSBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoaWxkTm9kZXNPYmosIGNoaWxkTm9kZUtleSkpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gY2hpbGROb2Rlc09ialtjaGlsZE5vZGVLZXldO1xuXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2hpbGROb2RlLmVkZ2VzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkRWRnZSA9IGNoaWxkTm9kZS5lZGdlc1t5XTtcblxuICAgICAgICAgIGlmIChpbmRleE9mKGNoaWxkTm9kZUlEcykuY2FsbChjaGlsZE5vZGVJRHMsIHRoaXMuX2dldENvbm5lY3RlZElkKGNoaWxkRWRnZSwgY2hpbGROb2RlLmlkKSkgPiAtMSkge1xuICAgICAgICAgICAgY2hpbGRFZGdlc09ialtjaGlsZEVkZ2UuaWRdID0gY2hpbGRFZGdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9jbHVzdGVyKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIG9wdGlvbnMsIHJlZnJlc2hEYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIHRoZSBlZGdlcyB0aGF0IHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIGNsdXN0ZXJcbiAgICAgKiBJdCBsb29rcyBmb3IgZWRnZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoZSBub2RlcyBmcm9tIHRoZSBcIm91dHNpZGUnIG9mIHRoZSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7Tm9kZS5pZDogdmlzLk5vZGV9fSBjaGlsZE5vZGVzT2JqXG4gICAgICogQHBhcmFtIHt7dmlzLkVkZ2UuaWQ6IHZpcy5FZGdlfX0gY2hpbGRFZGdlc09ialxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjbHVzdGVyTm9kZVByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2x1c3RlckVkZ2VQcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVDbHVzdGVyRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUNsdXN0ZXJFZGdlcyhjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBjbHVzdGVyTm9kZVByb3BlcnRpZXMsIGNsdXN0ZXJFZGdlUHJvcGVydGllcykge1xuICAgICAgdmFyIGVkZ2UsIGNoaWxkTm9kZUlkLCBjaGlsZE5vZGUsIHRvSWQsIGZyb21JZCwgb3RoZXJOb2RlSWQ7IC8vIGxvb3Agb3ZlciBhbGwgY2hpbGQgbm9kZXMgYW5kIHRoZWlyIGVkZ2VzIHRvIGZpbmQgZWRnZXMgZ29pbmcgb3V0IG9mIHRoZSBjbHVzdGVyXG4gICAgICAvLyB0aGVzZSBlZGdlcyB3aWxsIGJlIHJlcGxhY2VkIGJ5IGNsdXN0ZXJFZGdlcy5cblxuICAgICAgdmFyIGNoaWxkS2V5cyA9IGtleXMkNChjaGlsZE5vZGVzT2JqKTtcblxuICAgICAgdmFyIGNyZWF0ZUVkZ2VzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZUlkID0gY2hpbGRLZXlzW2ldO1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZUlkXTsgLy8gY29uc3RydWN0IG5ldyBlZGdlcyBmcm9tIHRoZSBjbHVzdGVyIHRvIG90aGVyc1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGROb2RlLmVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZWRnZSA9IGNoaWxkTm9kZS5lZGdlc1tqXTsgLy8gd2Ugb25seSBoYW5kbGUgZWRnZXMgdGhhdCBhcmUgdmlzaWJsZSB0byB0aGUgc3lzdGVtLCBub3QgdGhlIGRpc2FibGVkIG9uZXMgZnJvbSB0aGUgY2x1c3RlcmluZyBwcm9jZXNzLlxuXG4gICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2VsZi1yZWZlcmVuY2luZyBlZGdlcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBcImhpZGRlblwiIGxpc3RcbiAgICAgICAgICAgIGlmIChlZGdlLnRvSWQgPT0gZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBzZXQgdXAgdGhlIGZyb20gYW5kIHRvLlxuICAgICAgICAgICAgICBpZiAoZWRnZS50b0lkID09IGNoaWxkTm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGRvdWJsZSBlcXVhbHMgYmVjYXVzZSBpbnRzIGFuZCBzdHJpbmdzIGNhbiBiZSBpbnRlcmNoYW5nZWQgaGVyZS5cbiAgICAgICAgICAgICAgICB0b0lkID0gY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkO1xuICAgICAgICAgICAgICAgIGZyb21JZCA9IGVkZ2UuZnJvbUlkO1xuICAgICAgICAgICAgICAgIG90aGVyTm9kZUlkID0gZnJvbUlkO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvSWQgPSBlZGdlLnRvSWQ7XG4gICAgICAgICAgICAgICAgZnJvbUlkID0gY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkO1xuICAgICAgICAgICAgICAgIG90aGVyTm9kZUlkID0gdG9JZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBPbmx5IGVkZ2VzIGZyb20gdGhlIGNsdXN0ZXIgb3V0d2FyZHMgYXJlIGJlaW5nIHJlcGxhY2VkLlxuXG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzT2JqW290aGVyTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNyZWF0ZUVkZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGVkZ2U6IGVkZ2UsXG4gICAgICAgICAgICAgICAgZnJvbUlkOiBmcm9tSWQsXG4gICAgICAgICAgICAgICAgdG9JZDogdG9JZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy9cbiAgICAgIC8vIEhlcmUgd2UgYWN0dWFsbHkgY3JlYXRlIHRoZSByZXBsYWNlbWVudCBlZGdlcy5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBjb3VsZCBub3QgZG8gdGhpcyBpbiB0aGUgbG9vcCBhYm92ZSBhcyB0aGUgY3JlYXRpb24gcHJvY2Vzc1xuICAgICAgLy8gd291bGQgYWRkIGFuIGVkZ2UgdG8gdGhlIGVkZ2VzIGFycmF5IHdlIGFyZSBpdGVyYXRpbmcgb3Zlci5cbiAgICAgIC8vXG4gICAgICAvLyBOT1RFOiBhIGNsdXN0ZXJlZCBlZGdlIGNhbiBoYXZlIG11bHRpcGxlIGJhc2UgZWRnZXMhXG4gICAgICAvL1xuXG5cbiAgICAgIHZhciBuZXdFZGdlcyA9IFtdO1xuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIGEgY2x1c3RlciBlZGdlIHdoaWNoIG1hdGNoZXMgdGhlIGdpdmVuIGNyZWF0ZWQgZWRnZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlfSBjcmVhdGVkRWRnZVxuICAgICAgICogQHJldHVybnMge3Zpcy5FZGdlfVxuICAgICAgICovXG5cbiAgICAgIHZhciBnZXROZXdFZGdlID0gZnVuY3Rpb24gZ2V0TmV3RWRnZShjcmVhdGVkRWRnZSkge1xuICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBuZXdFZGdlcy5sZW5ndGg7IF9qMisrKSB7XG4gICAgICAgICAgdmFyIG5ld0VkZ2UgPSBuZXdFZGdlc1tfajJdOyAvLyBXZSByZXBsYWNlIGJvdGggdG8gYW5kIGZyb20gZWRnZXMgd2l0aCBhIHNpbmdsZSBjbHVzdGVyIGVkZ2VcblxuICAgICAgICAgIHZhciBtYXRjaFRvRGlyZWN0aW9uID0gY3JlYXRlZEVkZ2UuZnJvbUlkID09PSBuZXdFZGdlLmZyb21JZCAmJiBjcmVhdGVkRWRnZS50b0lkID09PSBuZXdFZGdlLnRvSWQ7XG4gICAgICAgICAgdmFyIG1hdGNoRnJvbURpcmVjdGlvbiA9IGNyZWF0ZWRFZGdlLmZyb21JZCA9PT0gbmV3RWRnZS50b0lkICYmIGNyZWF0ZWRFZGdlLnRvSWQgPT09IG5ld0VkZ2UuZnJvbUlkO1xuXG4gICAgICAgICAgaWYgKG1hdGNoVG9EaXJlY3Rpb24gfHwgbWF0Y2hGcm9tRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3RWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IGNyZWF0ZUVkZ2VzLmxlbmd0aDsgX2ozKyspIHtcbiAgICAgICAgdmFyIGNyZWF0ZWRFZGdlID0gY3JlYXRlRWRnZXNbX2ozXTtcbiAgICAgICAgdmFyIF9lZGdlID0gY3JlYXRlZEVkZ2UuZWRnZTtcbiAgICAgICAgdmFyIG5ld0VkZ2UgPSBnZXROZXdFZGdlKGNyZWF0ZWRFZGdlKTtcblxuICAgICAgICBpZiAobmV3RWRnZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIGNsdXN0ZXJlZCBlZGdlIGZvciB0aGlzIGNvbm5lY3Rpb25cbiAgICAgICAgICBuZXdFZGdlID0gdGhpcy5fY3JlYXRlQ2x1c3RlcmVkRWRnZShjcmVhdGVkRWRnZS5mcm9tSWQsIGNyZWF0ZWRFZGdlLnRvSWQsIF9lZGdlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMpO1xuICAgICAgICAgIG5ld0VkZ2VzLnB1c2gobmV3RWRnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3RWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcy5wdXNoKF9lZGdlLmlkKTtcbiAgICAgICAgfSAvLyBhbHNvIHJlZmVyZW5jZSB0aGUgbmV3IGVkZ2UgaW4gdGhlIG9sZCBlZGdlXG5cblxuICAgICAgICB0aGlzLmJvZHkuZWRnZXNbX2VkZ2UuaWRdLmVkZ2VSZXBsYWNlZEJ5SWQgPSBuZXdFZGdlLmlkOyAvLyBoaWRlIHRoZSByZXBsYWNlZCBlZGdlXG5cbiAgICAgICAgdGhpcy5fYmFja3VwRWRnZU9wdGlvbnMoX2VkZ2UpO1xuXG4gICAgICAgIF9lZGdlLnNldE9wdGlvbnMoe1xuICAgICAgICAgIHBoeXNpY3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyB0aGUgb3B0aW9ucyB0aGF0IGNhbiBiZSBzdXBwbGllZCB0byB0aGUgZGlmZmVyZW50IGNsdXN0ZXIgZnVuY3Rpb25zXG4gICAgICogZm9yIGNlcnRhaW4gZmllbGRzIGFuZCBpbnNlcnRzIGRlZmF1bHRzIGlmIG5lZWRlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tPcHRpb25zKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICBpZiAob3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJFZGdlUHJvcGVydGllcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICAgY2hpbGROb2Rlc09iaiAgICAgICAgIHwgb2JqZWN0IHdpdGggbm9kZSBvYmplY3RzLCBpZCBhcyBrZXlzLCBzYW1lIGFzIGNoaWxkTm9kZXMgZXhjZXB0IGl0IGFsc28gY29udGFpbnMgYSBzb3VyY2Ugbm9kZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICBjaGlsZEVkZ2VzT2JqICAgICAgICAgfCBvYmplY3Qgd2l0aCBlZGdlIG9iamVjdHMsIGlkIGFzIGtleXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgICAgb3B0aW9ucyAgICAgICAgICAgICAgIHwgb2JqZWN0IHdpdGgge2NsdXN0ZXJOb2RlUHJvcGVydGllcywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzLCBwcm9jZXNzUHJvcGVydGllc31cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgcmVmcmVzaERhdGEgfCB3aGVuIHRydWUsIGRvIG5vdCB3cmFwIHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jbHVzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbHVzdGVyKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgICAgIC8vIFJlbW92ZSBub2RlcyB3aGljaCBhcmUgYWxyZWFkeSBjbHVzdGVyZWRcbiAgICAgIHZhciB0bXBOb2Rlc1RvUmVtb3ZlID0gW107XG5cbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hpbGROb2Rlc09iaiwgbm9kZUlkKSkge1xuICAgICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZE5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG1wTm9kZXNUb1JlbW92ZS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdG1wTm9kZXNUb1JlbW92ZS5sZW5ndGg7ICsrbikge1xuICAgICAgICBkZWxldGUgY2hpbGROb2Rlc09ialt0bXBOb2Rlc1RvUmVtb3ZlW25dXTtcbiAgICAgIH0gLy8ga2lsbCBjb25kaXRpb246IG5vIG5vZGVzIGRvbid0IGJvdGhlclxuXG5cbiAgICAgIGlmIChrZXlzJDQoY2hpbGROb2Rlc09iaikubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBhbGxvdyBjbHVzdGVycyBvZiAxIGlmIG9wdGlvbnMgYWxsb3dcblxuXG4gICAgICBpZiAoa2V5cyQ0KGNoaWxkTm9kZXNPYmopLmxlbmd0aCA9PSAxICYmIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmFsbG93U2luZ2xlTm9kZUNsdXN0ZXIgIT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjbHVzdGVyTm9kZVByb3BlcnRpZXMgPSBkZWVwRXh0ZW5kKHt9LCBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcyk7IC8vIGNvbnN0cnVjdCB0aGUgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzXG5cbiAgICAgIGlmIChvcHRpb25zLnByb2Nlc3NQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBjaGlsZE5vZGUgb3B0aW9uc1xuICAgICAgICB2YXIgY2hpbGROb2Rlc09wdGlvbnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfbm9kZUlkIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoaWxkTm9kZXNPYmosIF9ub2RlSWQpKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhjaGlsZE5vZGVzT2JqW19ub2RlSWRdKTtcbiAgICAgICAgICAgIGNoaWxkTm9kZXNPcHRpb25zLnB1c2goY2xvbmVkT3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGdldCBjbHVzdGVyIHByb3BlcnRpZXMgYmFzZWQgb24gY2hpbGROb2Rlc1xuXG5cbiAgICAgICAgdmFyIGNoaWxkRWRnZXNPcHRpb25zID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGNoaWxkRWRnZXNPYmopIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoaWxkRWRnZXNPYmosIGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIC8vIHRoZXNlIGNsdXN0ZXIgZWRnZXMgd2lsbCBiZSByZW1vdmVkIG9uIGNyZWF0aW9uIG9mIHRoZSBjbHVzdGVyLlxuICAgICAgICAgICAgaWYgKGVkZ2VJZC5zdWJzdHIoMCwgMTIpICE9PSBcImNsdXN0ZXJFZGdlOlwiKSB7XG4gICAgICAgICAgICAgIHZhciBfY2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhjaGlsZEVkZ2VzT2JqW2VkZ2VJZF0sIFwiZWRnZVwiKTtcblxuICAgICAgICAgICAgICBjaGlsZEVkZ2VzT3B0aW9ucy5wdXNoKF9jbG9uZWRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMgPSBvcHRpb25zLnByb2Nlc3NQcm9wZXJ0aWVzKGNsdXN0ZXJOb2RlUHJvcGVydGllcywgY2hpbGROb2Rlc09wdGlvbnMsIGNoaWxkRWRnZXNPcHRpb25zKTtcblxuICAgICAgICBpZiAoIWNsdXN0ZXJOb2RlUHJvcGVydGllcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwcm9jZXNzUHJvcGVydGllcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gcHJvcGVydGllcyFcIik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY2hlY2sgaWYgd2UgaGF2ZSBhbiB1bmlxdWUgaWQ7XG5cblxuICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9IFwiY2x1c3RlcjpcIiArIHY0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjbHVzdGVySWQgPSBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQ7XG5cbiAgICAgIGlmIChjbHVzdGVyTm9kZVByb3BlcnRpZXMubGFiZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMubGFiZWwgPSBcImNsdXN0ZXJcIjtcbiAgICAgIH0gLy8gZ2l2ZSB0aGUgY2x1c3Rlck5vZGUgYSBwb3NpdGlvbiBpZiBpdCBkb2VzIG5vdCBoYXZlIG9uZS5cblxuXG4gICAgICB2YXIgcG9zID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3MgPSB0aGlzLl9nZXRDbHVzdGVyUG9zaXRpb24oY2hpbGROb2Rlc09iaik7XG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID0gcG9zLng7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbHVzdGVyTm9kZVByb3BlcnRpZXMueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvcyA9IHRoaXMuX2dldENsdXN0ZXJQb3NpdGlvbihjaGlsZE5vZGVzT2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID0gcG9zLnk7XG4gICAgICB9IC8vIGZvcmNlIHRoZSBJRCB0byByZW1haW4gdGhlIHNhbWVcblxuXG4gICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQgPSBjbHVzdGVySWQ7IC8vIGNyZWF0ZSB0aGUgY2x1c3RlciBOb2RlXG4gICAgICAvLyBOb3RlIHRoYXQgYWxsb3dTaW5nbGVOb2RlQ2x1c3RlciwgaWYgcHJlc2VudCwgaXMgc3RvcmVkIGluIHRoZSBvcHRpb25zIGFzIHdlbGxcblxuICAgICAgdmFyIGNsdXN0ZXJOb2RlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKGNsdXN0ZXJOb2RlUHJvcGVydGllcywgQ2x1c3Rlcik7XG4gICAgICBjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcyA9IGNoaWxkTm9kZXNPYmo7XG4gICAgICBjbHVzdGVyTm9kZS5jb250YWluZWRFZGdlcyA9IGNoaWxkRWRnZXNPYmo7IC8vIGNhY2hlIGEgY29weSBmcm9tIHRoZSBjbHVzdGVyIGVkZ2UgcHJvcGVydGllcyBpZiB3ZSBoYXZlIHRvIHJlY29ubmVjdCBvdGhlcnMgbGF0ZXIgb25cblxuICAgICAgY2x1c3Rlck5vZGUuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID0gb3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXM7IC8vIGZpbmFsbHkgcHV0IHRoZSBjbHVzdGVyIG5vZGUgaW50byBnbG9iYWxcblxuICAgICAgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlUHJvcGVydGllcy5pZF0gPSBjbHVzdGVyTm9kZTtcblxuICAgICAgdGhpcy5fY2x1c3RlckVkZ2VzKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIGNsdXN0ZXJOb2RlUHJvcGVydGllcywgb3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXMpOyAvLyBzZXQgSUQgdG8gdW5kZWZpbmVkIHNvIG5vIGR1cGxpY2F0ZXMgYXJpc2VcblxuXG4gICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQgPSB1bmRlZmluZWQ7IC8vIHdyYXAgdXBcblxuICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFZGdlfSBlZGdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9iYWNrdXBFZGdlT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmFja3VwRWRnZU9wdGlvbnMoZWRnZSkge1xuICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID0ge1xuICAgICAgICAgIHBoeXNpY3M6IGVkZ2Uub3B0aW9ucy5waHlzaWNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFZGdlfSBlZGdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXN0b3JlRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzdG9yZUVkZ2UoZWRnZSkge1xuICAgICAgdmFyIG9yaWdpbmFsT3B0aW9ucyA9IHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF07XG5cbiAgICAgIGlmIChvcmlnaW5hbE9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlZGdlLnNldE9wdGlvbnMoe1xuICAgICAgICAgIHBoeXNpY3M6IG9yaWdpbmFsT3B0aW9ucy5waHlzaWNzXG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBub2RlIGlzIGEgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0NsdXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNDbHVzdGVyKG5vZGVJZCkge1xuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLmlzQ2x1c3RlciA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOb2RlIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjbHVzdGVyIG5vZGUgYmFzZWQgb24gd2hhdCdzIGluc2lkZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNoaWxkTm9kZXNPYmogICAgfCBvYmplY3Qgd2l0aCBub2RlIG9iamVjdHMsIGlkIGFzIGtleXNcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENsdXN0ZXJQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2x1c3RlclBvc2l0aW9uKGNoaWxkTm9kZXNPYmopIHtcbiAgICAgIHZhciBjaGlsZEtleXMgPSBrZXlzJDQoY2hpbGROb2Rlc09iaik7XG5cbiAgICAgIHZhciBtaW5YID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbMF1dLng7XG4gICAgICB2YXIgbWF4WCA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS54O1xuICAgICAgdmFyIG1pblkgPSBjaGlsZE5vZGVzT2JqW2NoaWxkS2V5c1swXV0ueTtcbiAgICAgIHZhciBtYXhZID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbMF1dLnk7XG4gICAgICB2YXIgbm9kZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjaGlsZEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzW2ldXTtcbiAgICAgICAgbWluWCA9IG5vZGUueCA8IG1pblggPyBub2RlLnggOiBtaW5YO1xuICAgICAgICBtYXhYID0gbm9kZS54ID4gbWF4WCA/IG5vZGUueCA6IG1heFg7XG4gICAgICAgIG1pblkgPSBub2RlLnkgPCBtaW5ZID8gbm9kZS55IDogbWluWTtcbiAgICAgICAgbWF4WSA9IG5vZGUueSA+IG1heFkgPyBub2RlLnkgOiBtYXhZO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAwLjUgKiAobWluWCArIG1heFgpLFxuICAgICAgICB5OiAwLjUgKiAobWluWSArIG1heFkpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVuIGEgY2x1c3RlciBieSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSAgY2x1c3Rlck5vZGVJZCB8IHRoZSBJRCBvZiB0aGUgY2x1c3RlciBub2RlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlZnJlc2hEYXRhIHwgd3JhcCB1cCBhZnRlcndhcmRzIGlmIG5vdCB0cnVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvcGVuQ2x1c3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuQ2x1c3RlcihjbHVzdGVyTm9kZUlkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG5cbiAgICAgIC8vIGtpbGwgY29uZGl0aW9uc1xuICAgICAgaWYgKGNsdXN0ZXJOb2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjbHVzdGVyTm9kZUlkIHN1cHBsaWVkIHRvIG9wZW5DbHVzdGVyLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsdXN0ZXJOb2RlID0gdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdO1xuXG4gICAgICBpZiAoY2x1c3Rlck5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY2x1c3Rlck5vZGVJZCBzdXBwbGllZCB0byBvcGVuQ2x1c3RlciBkb2VzIG5vdCBleGlzdC5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbHVzdGVyTm9kZS5pc0NsdXN0ZXIgIT09IHRydWUgfHwgY2x1c3Rlck5vZGUuY29udGFpbmVkTm9kZXMgPT09IHVuZGVmaW5lZCB8fCBjbHVzdGVyTm9kZS5jb250YWluZWRFZGdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBub2RlOlwiICsgY2x1c3Rlck5vZGVJZCArIFwiIGlzIG5vdCBhIHZhbGlkIGNsdXN0ZXIuXCIpO1xuICAgICAgfSAvLyBDaGVjayBpZiBjdXJyZW50IGNsdXN0ZXIgaXMgY2x1c3RlcmVkIGl0c2VsZlxuXG5cbiAgICAgIHZhciBzdGFjayA9IHRoaXMuZmluZE5vZGUoY2x1c3Rlck5vZGVJZCk7XG4gICAgICB2YXIgcGFyZW50SW5kZXggPSBpbmRleE9mKHN0YWNrKS5jYWxsKHN0YWNrLCBjbHVzdGVyTm9kZUlkKSAtIDE7XG5cbiAgICAgIGlmIChwYXJlbnRJbmRleCA+PSAwKSB7XG4gICAgICAgIC8vIEN1cnJlbnQgY2x1c3RlciBpcyBjbHVzdGVyZWQ7IHRyYW5zZmVyIGNvbnRhaW5lZCBub2RlcyBhbmQgZWRnZXMgdG8gcGFyZW50XG4gICAgICAgIHZhciBwYXJlbnRDbHVzdGVyTm9kZUlkID0gc3RhY2tbcGFyZW50SW5kZXhdO1xuICAgICAgICB2YXIgcGFyZW50Q2x1c3Rlck5vZGUgPSB0aGlzLmJvZHkubm9kZXNbcGFyZW50Q2x1c3Rlck5vZGVJZF07IC8vIGNsdXN0ZXJpbmcuY2x1c3RlcmVkTm9kZXMgYW5kIGNsdXN0ZXJpbmcuY2x1c3RlcmVkRWRnZXMgcmVtYWluIHVuY2hhbmdlZFxuXG4gICAgICAgIHBhcmVudENsdXN0ZXJOb2RlLl9vcGVuQ2hpbGRDbHVzdGVyKGNsdXN0ZXJOb2RlSWQpOyAvLyBBbGwgY29tcG9uZW50cyBvZiBjaGlsZCBjbHVzdGVyIG5vZGUgaGF2ZSBiZWVuIHRyYW5zZmVycmVkLiBJdCBjYW4gZGllIG5vdy5cblxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVJZF07XG5cbiAgICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbWFpbiBib2R5XG5cblxuICAgICAgdmFyIGNvbnRhaW5lZE5vZGVzID0gY2x1c3Rlck5vZGUuY29udGFpbmVkTm9kZXM7XG4gICAgICB2YXIgY29udGFpbmVkRWRnZXMgPSBjbHVzdGVyTm9kZS5jb250YWluZWRFZGdlczsgLy8gYWxsb3cgdGhlIHVzZXIgdG8gcG9zaXRpb24gdGhlIG5vZGVzIGFmdGVyIHJlbGVhc2UuXG5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZWxlYXNlRnVuY3Rpb24gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5yZWxlYXNlRnVuY3Rpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgcG9zaXRpb25zID0ge307XG4gICAgICAgIHZhciBjbHVzdGVyUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogY2x1c3Rlck5vZGUueCxcbiAgICAgICAgICB5OiBjbHVzdGVyTm9kZS55XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb250YWluZWROb2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lZE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIHBvc2l0aW9uc1tub2RlSWRdID0ge1xuICAgICAgICAgICAgICB4OiBjb250YWluZWROb2RlLngsXG4gICAgICAgICAgICAgIHk6IGNvbnRhaW5lZE5vZGUueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3UG9zaXRpb25zID0gb3B0aW9ucy5yZWxlYXNlRnVuY3Rpb24oY2x1c3RlclBvc2l0aW9uLCBwb3NpdGlvbnMpO1xuXG4gICAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb250YWluZWROb2RlcywgX25vZGVJZDIpKSB7XG4gICAgICAgICAgICB2YXIgX2NvbnRhaW5lZE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbX25vZGVJZDJdO1xuXG4gICAgICAgICAgICBpZiAobmV3UG9zaXRpb25zW19ub2RlSWQyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIF9jb250YWluZWROb2RlLnggPSBuZXdQb3NpdGlvbnNbX25vZGVJZDJdLnggPT09IHVuZGVmaW5lZCA/IGNsdXN0ZXJOb2RlLnggOiBuZXdQb3NpdGlvbnNbX25vZGVJZDJdLng7XG4gICAgICAgICAgICAgIF9jb250YWluZWROb2RlLnkgPSBuZXdQb3NpdGlvbnNbX25vZGVJZDJdLnkgPT09IHVuZGVmaW5lZCA/IGNsdXN0ZXJOb2RlLnkgOiBuZXdQb3NpdGlvbnNbX25vZGVJZDJdLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb3B5IHRoZSBwb3NpdGlvbiBmcm9tIHRoZSBjbHVzdGVyXG4gICAgICAgIGZvckVhY2gkMShjb250YWluZWROb2RlcywgZnVuY3Rpb24gKGNvbnRhaW5lZE5vZGUpIHtcbiAgICAgICAgICAvLyBpbmhlcml0IHBvc2l0aW9uXG4gICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGUub3B0aW9ucy5maXhlZC54ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGFpbmVkTm9kZS54ID0gY2x1c3Rlck5vZGUueDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGFpbmVkTm9kZS5vcHRpb25zLmZpeGVkLnkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250YWluZWROb2RlLnkgPSBjbHVzdGVyTm9kZS55O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vIHJlbGVhc2Ugbm9kZXNcblxuXG4gICAgICBmb3IgKHZhciBfbm9kZUlkMyBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRhaW5lZE5vZGVzLCBfbm9kZUlkMykpIHtcbiAgICAgICAgICB2YXIgX2NvbnRhaW5lZE5vZGUyID0gdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQzXTsgLy8gaW5oZXJpdCBzcGVlZFxuXG4gICAgICAgICAgX2NvbnRhaW5lZE5vZGUyLnZ4ID0gY2x1c3Rlck5vZGUudng7XG4gICAgICAgICAgX2NvbnRhaW5lZE5vZGUyLnZ5ID0gY2x1c3Rlck5vZGUudnk7XG5cbiAgICAgICAgICBfY29udGFpbmVkTm9kZTIuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBwaHlzaWNzOiB0cnVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBkZWxldGUgdGhpcy5jbHVzdGVyZWROb2Rlc1tfbm9kZUlkM107XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY29weSB0aGUgY2x1c3Rlck5vZGUgZWRnZXMgYmVjYXVzZSB3ZSBjYW5ub3QgaXRlcmF0ZSBvdmVyIGFuIG9iamVjdCB0aGF0IHdlIGFkZCBvciByZW1vdmUgZnJvbS5cblxuXG4gICAgICB2YXIgZWRnZXNUb0JlRGVsZXRlZCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJOb2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVkZ2VzVG9CZURlbGV0ZWQucHVzaChjbHVzdGVyTm9kZS5lZGdlc1tpXSk7XG4gICAgICB9IC8vIGFjdHVhbGx5IGhhbmRsaW5nIHRoZSBkZWxldGluZy5cblxuXG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBlZGdlc1RvQmVEZWxldGVkLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1RvQmVEZWxldGVkW19pM107XG5cbiAgICAgICAgdmFyIG90aGVyTm9kZUlkID0gdGhpcy5fZ2V0Q29ubmVjdGVkSWQoZWRnZSwgY2x1c3Rlck5vZGVJZCk7XG5cbiAgICAgICAgdmFyIG90aGVyTm9kZSA9IHRoaXMuY2x1c3RlcmVkTm9kZXNbb3RoZXJOb2RlSWRdO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciB0cmFuc2ZlcklkID0gZWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkc1tqXTtcbiAgICAgICAgICB2YXIgdHJhbnNmZXJFZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RyYW5zZmVySWRdO1xuICAgICAgICAgIGlmICh0cmFuc2ZlckVkZ2UgPT09IHVuZGVmaW5lZCkgY29udGludWU7IC8vIGlmIHRoZSBvdGhlciBub2RlIGlzIGluIGFub3RoZXIgY2x1c3Rlciwgd2UgdHJhbnNmZXIgb3duZXJzaGlwIG9mIHRoaXMgZWRnZSB0byB0aGUgb3RoZXIgY2x1c3RlclxuXG4gICAgICAgICAgaWYgKG90aGVyTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0cmFuc2ZlciBvd25lcnNoaXA6XG4gICAgICAgICAgICB2YXIgb3RoZXJDbHVzdGVyID0gdGhpcy5ib2R5Lm5vZGVzW290aGVyTm9kZS5jbHVzdGVySWRdO1xuICAgICAgICAgICAgb3RoZXJDbHVzdGVyLmNvbnRhaW5lZEVkZ2VzW3RyYW5zZmVyRWRnZS5pZF0gPSB0cmFuc2ZlckVkZ2U7IC8vIGRlbGV0ZSBsb2NhbCByZWZlcmVuY2VcblxuICAgICAgICAgICAgZGVsZXRlIGNvbnRhaW5lZEVkZ2VzW3RyYW5zZmVyRWRnZS5pZF07IC8vIGdldCB0byBhbmQgZnJvbVxuXG4gICAgICAgICAgICB2YXIgZnJvbUlkID0gdHJhbnNmZXJFZGdlLmZyb21JZDtcbiAgICAgICAgICAgIHZhciB0b0lkID0gdHJhbnNmZXJFZGdlLnRvSWQ7XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2ZlckVkZ2UudG9JZCA9PSBvdGhlck5vZGVJZCkge1xuICAgICAgICAgICAgICB0b0lkID0gb3RoZXJOb2RlLmNsdXN0ZXJJZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZyb21JZCA9IG90aGVyTm9kZS5jbHVzdGVySWQ7XG4gICAgICAgICAgICB9IC8vIGNyZWF0ZSBuZXcgY2x1c3RlciBlZGdlIGZyb20gdGhlIG90aGVyQ2x1c3RlclxuXG5cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNsdXN0ZXJlZEVkZ2UoZnJvbUlkLCB0b0lkLCB0cmFuc2ZlckVkZ2UsIG90aGVyQ2x1c3Rlci5jbHVzdGVyRWRnZVByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgcGh5c2ljczogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVFZGdlKHRyYW5zZmVyRWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWRnZS5yZW1vdmUoKTtcbiAgICAgIH0gLy8gaGFuZGxlIHRoZSByZWxlYXNpbmcgb2YgdGhlIGVkZ2VzXG5cblxuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGNvbnRhaW5lZEVkZ2VzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGFpbmVkRWRnZXMsIGVkZ2VJZCkpIHtcbiAgICAgICAgICB0aGlzLl9yZXN0b3JlRWRnZShjb250YWluZWRFZGdlc1tlZGdlSWRdKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyByZW1vdmUgY2x1c3Rlck5vZGVcblxuXG4gICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdO1xuXG4gICAgICBpZiAocmVmcmVzaERhdGEgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NsdXN0ZXIuaWR9IGNsdXN0ZXJJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48Tm9kZS5pZD59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXROb2Rlc0luQ2x1c3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2Rlc0luQ2x1c3RlcihjbHVzdGVySWQpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gW107XG5cbiAgICAgIGlmICh0aGlzLmlzQ2x1c3RlcihjbHVzdGVySWQpID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBjb250YWluZWROb2RlcyA9IHRoaXMuYm9keS5ub2Rlc1tjbHVzdGVySWRdLmNvbnRhaW5lZE5vZGVzO1xuXG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGFpbmVkTm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICAgIG5vZGVzQXJyYXkucHVzaCh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2Rlc0FycmF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0YWNrIGNsdXN0ZXJJZCdzIHRoYXQgYSBjZXJ0YWluIG5vZGUgcmVzaWRlcyBpbi4gY2x1c3RlciBBIC0+IGNsdXN0ZXIgQiAtPiBjbHVzdGVyIEMgLT4gbm9kZVxuICAgICAqXG4gICAgICogSWYgYSBub2RlIGNhbid0IGJlIGZvdW5kIGluIHRoZSBjaGFpbiwgcmV0dXJuIGFuIGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaW5kTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kTm9kZShub2RlSWQpIHtcbiAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgdmFyIG1heCA9IDEwMDtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciBub2RlO1xuXG4gICAgICB3aGlsZSAodGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQgJiYgY291bnRlciA8IG1heCkge1xuICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHJldHVybiBbXTtcbiAgICAgICAgc3RhY2sucHVzaChub2RlLmlkKTtcbiAgICAgICAgbm9kZUlkID0gdGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdLmNsdXN0ZXJJZDtcbiAgICAgICAgY291bnRlcisrO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gICAgICBzdGFjay5wdXNoKG5vZGUuaWQpO1xuXG4gICAgICByZXZlcnNlKHN0YWNrKS5jYWxsKHN0YWNrKTtcblxuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2luZyBhIGNsdXN0ZXJlZCBub2RlSWQsIHVwZGF0ZSB3aXRoIHRoZSBuZXcgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBjbHVzdGVyZWROb2RlSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQ2x1c3RlcmVkTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDbHVzdGVyZWROb2RlKGNsdXN0ZXJlZE5vZGVJZCwgbmV3T3B0aW9ucykge1xuICAgICAgaWYgKGNsdXN0ZXJlZE5vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNsdXN0ZXJlZE5vZGVJZCBzdXBwbGllZCB0byB1cGRhdGVDbHVzdGVyZWROb2RlLlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld09wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBuZXdPcHRpb25zIHN1cHBsaWVkIHRvIHVwZGF0ZUNsdXN0ZXJlZE5vZGUuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJlZE5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY2x1c3RlcmVkTm9kZUlkIHN1cHBsaWVkIHRvIHVwZGF0ZUNsdXN0ZXJlZE5vZGUgZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkubm9kZXNbY2x1c3RlcmVkTm9kZUlkXS5zZXRPcHRpb25zKG5ld09wdGlvbnMpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgYSBiYXNlIGVkZ2VJZCwgdXBkYXRlIGFsbCByZWxhdGVkIGNsdXN0ZXJlZCBlZGdlcyB3aXRoIHRoZSBuZXcgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gc3RhcnRFZGdlSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVFZGdlKHN0YXJ0RWRnZUlkLCBuZXdPcHRpb25zKSB7XG4gICAgICBpZiAoc3RhcnRFZGdlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdGFydEVkZ2VJZCBzdXBwbGllZCB0byB1cGRhdGVFZGdlLlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld09wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBuZXdPcHRpb25zIHN1cHBsaWVkIHRvIHVwZGF0ZUVkZ2UuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW3N0YXJ0RWRnZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdGFydEVkZ2VJZCBzdXBwbGllZCB0byB1cGRhdGVFZGdlIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFsbEVkZ2VJZHMgPSB0aGlzLmdldENsdXN0ZXJlZEVkZ2VzKHN0YXJ0RWRnZUlkKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxFZGdlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW2FsbEVkZ2VJZHNbaV1dO1xuICAgICAgICBlZGdlLnNldE9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHN0YWNrIG9mIGNsdXN0ZXJFZGdlSWQncyAoK2Jhc2UgZWRnZWlkKSB0aGF0IGEgYmFzZSBlZGdlIGlzIHRoZSBzYW1lIGFzLiBjbHVzdGVyIGVkZ2UgQyAtPiBjbHVzdGVyIGVkZ2UgQiAtPiBjbHVzdGVyIGVkZ2UgQSAtPiBiYXNlIGVkZ2UoZWRnZUlkKVxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gZWRnZUlkXG4gICAgICogQHJldHVybnMge0FycmF5Ljx2aXMuRWRnZS5pZD59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDbHVzdGVyZWRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbHVzdGVyZWRFZGdlcyhlZGdlSWQpIHtcbiAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgdmFyIG1heCA9IDEwMDtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcblxuICAgICAgd2hpbGUgKGVkZ2VJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQgJiYgY291bnRlciA8IG1heCkge1xuICAgICAgICBzdGFjay5wdXNoKHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdLmlkKTtcbiAgICAgICAgZWRnZUlkID0gdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0uZWRnZVJlcGxhY2VkQnlJZDtcbiAgICAgICAgY291bnRlcisrO1xuICAgICAgfVxuXG4gICAgICByZXZlcnNlKHN0YWNrKS5jYWxsKHN0YWNrKTtcblxuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJhc2UgZWRnZSBpZCBvZiBjbHVzdGVyRWRnZUlkLiBjbHVzdGVyIGVkZ2UgKGNsdXN0ZXJlZEVkZ2VJZCkgLT4gY2x1c3RlciBlZGdlIEIgLT4gY2x1c3RlciBlZGdlIEMgLT4gYmFzZSBlZGdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSBjbHVzdGVyZWRFZGdlSWRcbiAgICAgKiBAcmV0dXJucyB7dmlzLkVkZ2UuaWR9IGJhc2VFZGdlSWRcbiAgICAgKlxuICAgICAqIFRPRE86IGRlcHJlY2F0ZSBpbiA1LjAuMC4gTWV0aG9kIGdldEJhc2VFZGdlcygpIGlzIHRoZSBjb3JyZWN0IG9uZSB0byB1c2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRCYXNlRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXNlRWRnZShjbHVzdGVyZWRFZGdlSWQpIHtcbiAgICAgIC8vIEp1c3Qga2x1ZGdlIHRoaXMgYnkgcmV0dXJuaW5nIHRoZSBmaXJzdCBiYXNlIGVkZ2UgaWQgZm91bmRcbiAgICAgIHJldHVybiB0aGlzLmdldEJhc2VFZGdlcyhjbHVzdGVyZWRFZGdlSWQpWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHJlZ3VsYXIgZWRnZXMgZm9yIHRoaXMgY2x1c3RlcmVkIGVkZ2UgaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSBjbHVzdGVyZWRFZGdlSWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHZpcy5FZGdlLmlkPn0gYWxsIGJhc2VFZGdlSWQncyB1bmRlciB0aGlzIGNsdXN0ZXJlZCBlZGdlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRCYXNlRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFzZUVkZ2VzKGNsdXN0ZXJlZEVkZ2VJZCkge1xuICAgICAgdmFyIElkc1RvSGFuZGxlID0gW2NsdXN0ZXJlZEVkZ2VJZF07XG4gICAgICB2YXIgZG9uZUlkcyA9IFtdO1xuICAgICAgdmFyIGZvdW5kSWRzID0gW107XG4gICAgICB2YXIgbWF4ID0gMTAwO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgICB3aGlsZSAoSWRzVG9IYW5kbGUubGVuZ3RoID4gMCAmJiBjb3VudGVyIDwgbWF4KSB7XG4gICAgICAgIHZhciBuZXh0SWQgPSBJZHNUb0hhbmRsZS5wb3AoKTtcbiAgICAgICAgaWYgKG5leHRJZCA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTsgLy8gUGFyYW5vaWEgaGVyZSBhbmQgb253YXJkc1xuXG4gICAgICAgIHZhciBuZXh0RWRnZSA9IHRoaXMuYm9keS5lZGdlc1tuZXh0SWRdO1xuICAgICAgICBpZiAobmV4dEVkZ2UgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgdmFyIHJlcGxhY2luZ0lkcyA9IG5leHRFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzO1xuXG4gICAgICAgIGlmIChyZXBsYWNpbmdJZHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIG5leHRJZCBpcyBhIGJhc2UgaWRcbiAgICAgICAgICBmb3VuZElkcy5wdXNoKG5leHRJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQW5vdGhlciBjbHVzdGVyIGVkZ2UsIHVucmF2ZWwgdGhpcyBvbmUgYXMgd2VsbFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwbGFjaW5nSWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcmVwbGFjaW5nSWQgPSByZXBsYWNpbmdJZHNbaV07IC8vIERvbid0IGFkZCBpZiBhbHJlYWR5IGhhbmRsZWRcbiAgICAgICAgICAgIC8vIFRPRE86IG5ldmVyIHRyaWdnZXJzOyBmaW5kIGEgdGVzdC1jYXNlIHdoaWNoIGRvZXNcblxuICAgICAgICAgICAgaWYgKGluZGV4T2YoSWRzVG9IYW5kbGUpLmNhbGwoSWRzVG9IYW5kbGUsIHJlcGxhY2luZ0lkcykgIT09IC0xIHx8IGluZGV4T2YoZG9uZUlkcykuY2FsbChkb25lSWRzLCByZXBsYWNpbmdJZHMpICE9PSAtMSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgSWRzVG9IYW5kbGUucHVzaChyZXBsYWNpbmdJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZG9uZUlkcy5wdXNoKG5leHRJZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb3VuZElkcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBJZCB0aGUgbm9kZSBpcyBjb25uZWN0ZWQgdG9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2V9IGVkZ2VcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q29ubmVjdGVkSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENvbm5lY3RlZElkKGVkZ2UsIG5vZGVJZCkge1xuICAgICAgaWYgKGVkZ2UudG9JZCAhPSBub2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UudG9JZDtcbiAgICAgIH0gZWxzZSBpZiAoZWRnZS5mcm9tSWQgIT0gbm9kZUlkKSB7XG4gICAgICAgIHJldHVybiBlZGdlLmZyb21JZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlZGdlLmZyb21JZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2UgZGV0ZXJtaW5lIGhvdyBtYW55IGNvbm5lY3Rpb25zIGRlbm90ZSBhbiBpbXBvcnRhbnQgaHViLlxuICAgICAqIFdlIHRha2UgdGhlIG1lYW4gKyAyKnN0ZCBhcyB0aGUgaW1wb3J0YW50IGh1YiBzaXplLiAoQXNzdW1pbmcgYSBub3JtYWwgZGlzdHJpYnV0aW9uIG9mIGRhdGEsIH4yLjIlKVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEh1YlNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEh1YlNpemUoKSB7XG4gICAgICB2YXIgYXZlcmFnZSA9IDA7XG4gICAgICB2YXIgYXZlcmFnZVNxdWFyZWQgPSAwO1xuICAgICAgdmFyIGh1YkNvdW50ZXIgPSAwO1xuICAgICAgdmFyIGxhcmdlc3RIdWIgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO1xuXG4gICAgICAgIGlmIChub2RlLmVkZ2VzLmxlbmd0aCA+IGxhcmdlc3RIdWIpIHtcbiAgICAgICAgICBsYXJnZXN0SHViID0gbm9kZS5lZGdlcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBhdmVyYWdlICs9IG5vZGUuZWRnZXMubGVuZ3RoO1xuICAgICAgICBhdmVyYWdlU3F1YXJlZCArPSBNYXRoLnBvdyhub2RlLmVkZ2VzLmxlbmd0aCwgMik7XG4gICAgICAgIGh1YkNvdW50ZXIgKz0gMTtcbiAgICAgIH1cblxuICAgICAgYXZlcmFnZSA9IGF2ZXJhZ2UgLyBodWJDb3VudGVyO1xuICAgICAgYXZlcmFnZVNxdWFyZWQgPSBhdmVyYWdlU3F1YXJlZCAvIGh1YkNvdW50ZXI7XG4gICAgICB2YXIgdmFyaWFuY2UgPSBhdmVyYWdlU3F1YXJlZCAtIE1hdGgucG93KGF2ZXJhZ2UsIDIpO1xuICAgICAgdmFyIHN0YW5kYXJkRGV2aWF0aW9uID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcbiAgICAgIHZhciBodWJUaHJlc2hvbGQgPSBNYXRoLmZsb29yKGF2ZXJhZ2UgKyAyICogc3RhbmRhcmREZXZpYXRpb24pOyAvLyBhbHdheXMgaGF2ZSBhdCBsZWFzdCBvbmUgdG8gY2x1c3RlclxuXG4gICAgICBpZiAoaHViVGhyZXNob2xkID4gbGFyZ2VzdEh1Yikge1xuICAgICAgICBodWJUaHJlc2hvbGQgPSBsYXJnZXN0SHViO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaHViVGhyZXNob2xkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gZWRnZSBmb3IgdGhlIGNsdXN0ZXIgcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IGZyb21JZFxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gdG9JZFxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2V9IGJhc2VFZGdlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNsdXN0ZXJFZGdlUHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBleHRyYU9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7RWRnZX0gbmV3bHkgY3JlYXRlZCBjbHVzdGVyZWQgZWRnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQ2x1c3RlcmVkRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ2x1c3RlcmVkRWRnZShmcm9tSWQsIHRvSWQsIGJhc2VFZGdlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMsIGV4dHJhT3B0aW9ucykge1xuICAgICAgLy8gY29weSB0aGUgb3B0aW9ucyBvZiB0aGUgZWRnZSB3ZSB3aWxsIHJlcGxhY2VcbiAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKGJhc2VFZGdlLCBcImVkZ2VcIik7IC8vIG1ha2Ugc3VyZSB0aGUgcHJvcGVydGllcyBvZiBjbHVzdGVyRWRnZXMgYXJlIHN1cGVyaW1wb3NlZCBvbiBpdFxuXG4gICAgICBkZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGNsdXN0ZXJFZGdlUHJvcGVydGllcyk7IC8vIHNldCB1cCB0aGUgZWRnZVxuXG4gICAgICBjbG9uZWRPcHRpb25zLmZyb20gPSBmcm9tSWQ7XG4gICAgICBjbG9uZWRPcHRpb25zLnRvID0gdG9JZDtcbiAgICAgIGNsb25lZE9wdGlvbnMuaWQgPSBcImNsdXN0ZXJFZGdlOlwiICsgdjQoKTsgLy8gYXBwbHkgdGhlIGVkZ2Ugc3BlY2lmaWMgb3B0aW9ucyB0byBpdCBpZiBzcGVjaWZpZWRcblxuICAgICAgaWYgKGV4dHJhT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgZXh0cmFPcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0VkZ2UgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2UoY2xvbmVkT3B0aW9ucyk7XG4gICAgICBuZXdFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzID0gW2Jhc2VFZGdlLmlkXTtcbiAgICAgIG5ld0VkZ2UuY29ubmVjdCgpOyAvLyBSZWdpc3RlciB0aGUgbmV3IGVkZ2VcblxuICAgICAgdGhpcy5ib2R5LmVkZ2VzW25ld0VkZ2UuaWRdID0gbmV3RWRnZTtcbiAgICAgIHJldHVybiBuZXdFZGdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHBhc3NlZCBjaGlsZCBub2RlcyBhbmQgZWRnZXMgdG8gdGhlIGdpdmVuIGNsdXN0ZXIgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0IHwgTm9kZX0gY2hpbGROb2RlcyAgaGFzaCBvZiBub2RlcyBvciBzaW5nbGUgbm9kZSB0byBhZGQgaW4gY2x1c3RlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0IHwgRWRnZX0gY2hpbGRFZGdlcyAgaGFzaCBvZiBlZGdlcyBvciBzaW5nbGUgZWRnZSB0byB0YWtlIGludG8gYWNjb3VudCB3aGVuIGNsdXN0ZXJpbmdcbiAgICAgKiBAcGFyYW0ge05vZGV9IGNsdXN0ZXJOb2RlICBjbHVzdGVyIG5vZGUgdG8gYWRkIG5vZGVzIGFuZCBlZGdlcyB0b1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY2x1c3RlckVkZ2VQcm9wZXJ0aWVzXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2x1c3RlckVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbHVzdGVyRWRnZXMoY2hpbGROb2RlcywgY2hpbGRFZGdlcywgY2x1c3Rlck5vZGUsIGNsdXN0ZXJFZGdlUHJvcGVydGllcykge1xuICAgICAgaWYgKGNoaWxkRWRnZXMgaW5zdGFuY2VvZiBFZGdlKSB7XG4gICAgICAgIHZhciBlZGdlID0gY2hpbGRFZGdlcztcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBvYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICBjaGlsZEVkZ2VzID0gb2JqO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGROb2RlcyBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjaGlsZE5vZGVzO1xuICAgICAgICB2YXIgX29iaiA9IHt9O1xuICAgICAgICBfb2JqW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgY2hpbGROb2RlcyA9IF9vYmo7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbHVzdGVyTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGNsdXN0ZXJOb2RlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIl9jbHVzdGVyRWRnZXM6IHBhcmFtZXRlciBjbHVzdGVyTm9kZSByZXF1aXJlZFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsdXN0ZXJFZGdlUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRha2UgdGhlIHJlcXVpcmVkIHByb3BlcnRpZXMgZnJvbSB0aGUgY2x1c3RlciBub2RlXG4gICAgICAgIGNsdXN0ZXJFZGdlUHJvcGVydGllcyA9IGNsdXN0ZXJOb2RlLmNsdXN0ZXJFZGdlUHJvcGVydGllcztcbiAgICAgIH0gLy8gY3JlYXRlIHRoZSBuZXcgZWRnZXMgdGhhdCB3aWxsIGNvbm5lY3QgdG8gdGhlIGNsdXN0ZXIuXG4gICAgICAvLyBBbGwgc2VsZi1yZWZlcmVuY2luZyBlZGdlcyB3aWxsIGJlIGFkZGVkIHRvIGNoaWxkRWRnZXMgaGVyZS5cblxuXG4gICAgICB0aGlzLl9jcmVhdGVDbHVzdGVyRWRnZXMoY2hpbGROb2RlcywgY2hpbGRFZGdlcywgY2x1c3Rlck5vZGUsIGNsdXN0ZXJFZGdlUHJvcGVydGllcyk7IC8vIGRpc2FibGUgdGhlIGNoaWxkRWRnZXNcblxuXG4gICAgICBmb3IgKHZhciBlZGdlSWQgaW4gY2hpbGRFZGdlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoaWxkRWRnZXMsIGVkZ2VJZCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIF9lZGdlMiA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdOyAvLyBjYWNoZSB0aGUgb3B0aW9ucyBiZWZvcmUgY2hhbmdpbmdcblxuICAgICAgICAgICAgdGhpcy5fYmFja3VwRWRnZU9wdGlvbnMoX2VkZ2UyKTsgLy8gZGlzYWJsZSBwaHlzaWNzIGFuZCBoaWRlIHRoZSBlZGdlXG5cblxuICAgICAgICAgICAgX2VkZ2UyLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICBwaHlzaWNzOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIGRpc2FibGUgdGhlIGNoaWxkTm9kZXNcblxuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gY2hpbGROb2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoaWxkTm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICB0aGlzLmNsdXN0ZXJlZE5vZGVzW25vZGVJZF0gPSB7XG4gICAgICAgICAgICBjbHVzdGVySWQ6IGNsdXN0ZXJOb2RlLmlkLFxuICAgICAgICAgICAgbm9kZTogdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgcGh5c2ljczogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaW4gd2hpY2ggY2x1c3RlciBnaXZlbiBub2RlSWQgcmVzaWRlcy5cbiAgICAgKlxuICAgICAqIElmIG5vdCBpbiBjbHVzdGVyLCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogTk9URTogSWYgeW91IGtub3cgYSBjbGVhbmVyIHdheSB0byBkbyB0aGlzLCBwbGVhc2UgZW5saWdodGVuIG1lICh3aW1yaWpuZGVycykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtOb2RlfHVuZGVmaW5lZH0gTm9kZSBpbnN0YW5jZSBmb3IgY2x1c3RlciwgaWYgcHJlc2VudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q2x1c3Rlck5vZGVGb3JOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDbHVzdGVyTm9kZUZvck5vZGUobm9kZUlkKSB7XG4gICAgICBpZiAobm9kZUlkID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgY2x1c3RlcmVkTm9kZSA9IHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXTsgLy8gTk9URTogSWYgbm8gY2x1c3RlciBpbmZvIGZvdW5kLCBpdCBzaG91bGQgYWN0dWFsbHkgYmUgYW4gZXJyb3JcblxuICAgICAgaWYgKGNsdXN0ZXJlZE5vZGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBjbHVzdGVySWQgPSBjbHVzdGVyZWROb2RlLmNsdXN0ZXJJZDtcbiAgICAgIGlmIChjbHVzdGVySWQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbY2x1c3RlcklkXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIGZvciBjb25kaXRpb25hbGx5IHJlbW92aW5nIGl0ZW1zIGluIGFycmF5XG4gICAgICpcbiAgICAgKiBEb25lIGxpa2UgdGhpcyBiZWNhdXNlIEFycmF5LmZpbHRlcigpIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgYnkgYWxsIElFJ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmlsdGVyKGFyciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgIGZvckVhY2gkMShhcnIsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhpdGVtKSkge1xuICAgICAgICAgIHJldC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYW4gYWxsIGVkZ2VzIGZvciBjaGFuZ2VzIGluIGNsdXN0ZXJpbmcgYW5kIGFkanVzdCB0aGlzIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIENhbGwgdGhpcyAoaW50ZXJuYWxseSkgYWZ0ZXIgdGhlcmUgaGFzIGJlZW4gYSBjaGFuZ2UgaW4gbm9kZSBvciBlZGdlIGRhdGEuXG4gICAgICpcbiAgICAgKiBQcmU6IFN0YXRlcyBvZiB0aGlzLmJvZHkubm9kZXMgYW5kIHRoaXMuYm9keS5lZGdlcyBjb25zaXN0ZW50XG4gICAgICogUHJlOiB0aGlzLmNsdXN0ZXJlZE5vZGVzIGFuZCB0aGlzLmNsdXN0ZXJlZEVkZ2UgY29uc2lzdGVudCB3aXRoIGNvbnRhaW5lZE5vZGVzIGFuZCBjb250YWluZWRFZGdlc1xuICAgICAqICAgICAgb2YgY2x1c3RlciBub2Rlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlU3RhdGUoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIG5vZGVJZDtcbiAgICAgIHZhciBkZWxldGVkTm9kZUlkcyA9IFtdO1xuICAgICAgdmFyIGRlbGV0ZWRFZGdlSWRzID0ge307XG4gICAgICAvKipcbiAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGNsdXN0ZXJpbmcgbm9kZXMgb25seVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGNsdXN0ZXIgbm9kZVxuICAgICAgICovXG5cbiAgICAgIHZhciBlYWNoQ2x1c3Rlck5vZGUgPSBmdW5jdGlvbiBlYWNoQ2x1c3Rlck5vZGUoY2FsbGJhY2spIHtcbiAgICAgICAgZm9yRWFjaCQxKF90aGlzNC5ib2R5Lm5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07IC8vXG4gICAgICAvLyBSZW1vdmUgZGVsZXRlZCByZWd1bGFyIG5vZGVzIGZyb20gY2x1c3RlcmluZ1xuICAgICAgLy9cbiAgICAgIC8vIERldGVybWluZSB0aGUgZGVsZXRlZCBub2Rlc1xuXG5cbiAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuY2x1c3RlcmVkTm9kZXMpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jbHVzdGVyZWROb2Rlcywgbm9kZUlkKSkgY29udGludWU7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZWROb2RlSWRzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZW1vdmUgbm9kZXMgZnJvbSBjbHVzdGVyIG5vZGVzXG5cblxuICAgICAgZWFjaENsdXN0ZXJOb2RlKGZ1bmN0aW9uIChjbHVzdGVyTm9kZSkge1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGRlbGV0ZWROb2RlSWRzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgZGVsZXRlIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzW2RlbGV0ZWROb2RlSWRzW25dXTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIFJlbW92ZSBub2RlcyBmcm9tIGNsdXN0ZXIgbGlzdFxuXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGRlbGV0ZWROb2RlSWRzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNsdXN0ZXJlZE5vZGVzW2RlbGV0ZWROb2RlSWRzW25dXTtcbiAgICAgIH0gLy9cbiAgICAgIC8vIFJlbW92ZSBkZWxldGVkIGVkZ2VzIGZyb20gY2x1c3RlcmluZ1xuICAgICAgLy9cbiAgICAgIC8vIEFkZCB0aGUgZGVsZXRlZCBjbHVzdGVyZWQgZWRnZXMgdG8gdGhlIGxpc3RcblxuXG4gICAgICBmb3JFYWNoJDEodGhpcy5jbHVzdGVyZWRFZGdlcywgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICB2YXIgZWRnZSA9IF90aGlzNC5ib2R5LmVkZ2VzW2VkZ2VJZF07XG5cbiAgICAgICAgaWYgKGVkZ2UgPT09IHVuZGVmaW5lZCB8fCAhZWRnZS5lbmRQb2ludHNWYWxpZCgpKSB7XG4gICAgICAgICAgZGVsZXRlZEVkZ2VJZHNbZWRnZUlkXSA9IGVkZ2VJZDtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIENsdXN0ZXIgbm9kZXMgY2FuIGFsc28gY29udGFpbiBlZGdlcyB3aGljaCBhcmUgbm90IGNsdXN0ZXJlZCxcbiAgICAgIC8vIGkuZS4gbm9kZXMgMS0yIHdpdGhpbiBjbHVzdGVyIHdpdGggYW4gZWRnZSBpbiBiZXR3ZWVuLlxuICAgICAgLy8gU28gdGhlIGNsdXN0ZXIgbm9kZXMgYWxzbyBuZWVkIHRvIGJlIHNjYW5uZWQgZm9yIGludmFsaWQgZWRnZXNcblxuICAgICAgZWFjaENsdXN0ZXJOb2RlKGZ1bmN0aW9uIChjbHVzdGVyTm9kZSkge1xuICAgICAgICBmb3JFYWNoJDEoY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBlZGdlSWQpIHtcbiAgICAgICAgICBpZiAoIWVkZ2UuZW5kUG9pbnRzVmFsaWQoKSAmJiAhZGVsZXRlZEVkZ2VJZHNbZWRnZUlkXSkge1xuICAgICAgICAgICAgZGVsZXRlZEVkZ2VJZHNbZWRnZUlkXSA9IGVkZ2VJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7IC8vIEFsc28gc2NhbiBmb3IgY2x1c3RlciBlZGdlcyB3aGljaCBuZWVkIHRvIGJlIHJlbW92ZWQgaW4gdGhlIGFjdGl2ZSBsaXN0LlxuICAgICAgLy8gUmVndWxhciBlZGdlcyBoYXZlIGJlZW4gcmVtb3ZlZCBiZWZvcmVoYW5kLCBzbyB0aGlzIG9ubHkgcGlja3MgdXAgdGhlIGNsdXN0ZXIgZWRnZXMuXG5cbiAgICAgIGZvckVhY2gkMSh0aGlzLmJvZHkuZWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBlZGdlSWQpIHtcbiAgICAgICAgLy8gRXhwbGljaXRseSBzY2FuIHRoZSBjb250YWluZWQgZWRnZXMgZm9yIHZhbGlkaXR5XG4gICAgICAgIHZhciBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJlcGxhY2VkSWRzID0gZWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcztcblxuICAgICAgICBpZiAocmVwbGFjZWRJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBudW1WYWxpZCA9IDA7XG4gICAgICAgICAgZm9yRWFjaCQxKHJlcGxhY2VkSWRzLCBmdW5jdGlvbiAoY29udGFpbmVkRWRnZUlkKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVkRWRnZSA9IF90aGlzNC5ib2R5LmVkZ2VzW2NvbnRhaW5lZEVkZ2VJZF07XG5cbiAgICAgICAgICAgIGlmIChjb250YWluZWRFZGdlICE9PSB1bmRlZmluZWQgJiYgY29udGFpbmVkRWRnZS5lbmRQb2ludHNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgIG51bVZhbGlkICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaXNWYWxpZCA9IG51bVZhbGlkID4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZWRnZS5lbmRQb2ludHNWYWxpZCgpIHx8ICFpc1ZhbGlkKSB7XG4gICAgICAgICAgZGVsZXRlZEVkZ2VJZHNbZWRnZUlkXSA9IGVkZ2VJZDtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIFJlbW92ZSBlZGdlcyBmcm9tIGNsdXN0ZXIgbm9kZXNcblxuICAgICAgZWFjaENsdXN0ZXJOb2RlKGZ1bmN0aW9uIChjbHVzdGVyTm9kZSkge1xuICAgICAgICBmb3JFYWNoJDEoZGVsZXRlZEVkZ2VJZHMsIGZ1bmN0aW9uIChkZWxldGVkRWRnZUlkKSB7XG4gICAgICAgICAgZGVsZXRlIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzW2RlbGV0ZWRFZGdlSWRdO1xuICAgICAgICAgIGZvckVhY2gkMShjbHVzdGVyTm9kZS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UsIG0pIHtcbiAgICAgICAgICAgIGlmIChlZGdlLmlkID09PSBkZWxldGVkRWRnZUlkKSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXJOb2RlLmVkZ2VzW21dID0gbnVsbDsgLy8gRG9uJ3Qgd2FudCB0byBkaXJlY3RseSBkZWxldGUgaGVyZSwgYmVjYXVzZSBpbiB0aGUgbG9vcFxuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcyA9IF90aGlzNC5fZmlsdGVyKGVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gIWRlbGV0ZWRFZGdlSWRzW2lkXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pOyAvLyBDbGVhbiB1cCB0aGUgbnVsbHNcblxuICAgICAgICAgIGNsdXN0ZXJOb2RlLmVkZ2VzID0gX3RoaXM0Ll9maWx0ZXIoY2x1c3Rlck5vZGUuZWRnZXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbSAhPT0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gUmVtb3ZlIGZyb20gY2x1c3RlciBsaXN0XG5cbiAgICAgIGZvckVhY2gkMShkZWxldGVkRWRnZUlkcywgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICBkZWxldGUgX3RoaXM0LmNsdXN0ZXJlZEVkZ2VzW2VkZ2VJZF07XG4gICAgICB9KTsgLy8gUmVtb3ZlIGNsdXN0ZXIgZWRnZXMgZnJvbSBhY3RpdmUgbGlzdCAodGhpcy5ib2R5LmVkZ2VzKS5cbiAgICAgIC8vIGRlbGV0ZWRFZGdlSWRzIHN0aWxsIGNvbnRhaW5zIGlkIG9mIHJlZ3VsYXIgZWRnZXMsIGJ1dCB0aGVzZSBzaG91bGQgYWxsXG4gICAgICAvLyBiZSBnb25lIHdoZW4geW91IHJlYWNoIGhlcmUuXG5cbiAgICAgIGZvckVhY2gkMShkZWxldGVkRWRnZUlkcywgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICBkZWxldGUgX3RoaXM0LmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgIH0pOyAvL1xuICAgICAgLy8gQ2hlY2sgY2hhbmdlZCBjbHVzdGVyIHN0YXRlIG9mIGVkZ2VzXG4gICAgICAvL1xuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIga2V5cyBoZXJlLCBiZWNhdXNlIGVkZ2VzIG1heSBiZSByZW1vdmVkIGluIHRoZSBsb29wXG5cbiAgICAgIHZhciBpZHMgPSBrZXlzJDQodGhpcy5ib2R5LmVkZ2VzKTtcblxuICAgICAgZm9yRWFjaCQxKGlkcywgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICB2YXIgZWRnZSA9IF90aGlzNC5ib2R5LmVkZ2VzW2VkZ2VJZF07XG5cbiAgICAgICAgdmFyIHNob3VsZEJlQ2x1c3RlcmVkID0gX3RoaXM0Ll9pc0NsdXN0ZXJlZE5vZGUoZWRnZS5mcm9tSWQpIHx8IF90aGlzNC5faXNDbHVzdGVyZWROb2RlKGVkZ2UudG9JZCk7XG5cbiAgICAgICAgaWYgKHNob3VsZEJlQ2x1c3RlcmVkID09PSBfdGhpczQuX2lzQ2x1c3RlcmVkRWRnZShlZGdlLmlkKSkge1xuICAgICAgICAgIHJldHVybjsgLy8gYWxsIGlzIHdlbGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRCZUNsdXN0ZXJlZCkge1xuICAgICAgICAgIC8vIGFkZCBlZGdlIHRvIGNsdXN0ZXJpbmdcbiAgICAgICAgICB2YXIgY2x1c3RlckZyb20gPSBfdGhpczQuX2dldENsdXN0ZXJOb2RlRm9yTm9kZShlZGdlLmZyb21JZCk7XG5cbiAgICAgICAgICBpZiAoY2x1c3RlckZyb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXM0Ll9jbHVzdGVyRWRnZXMoX3RoaXM0LmJvZHkubm9kZXNbZWRnZS5mcm9tSWRdLCBlZGdlLCBjbHVzdGVyRnJvbSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNsdXN0ZXJUbyA9IF90aGlzNC5fZ2V0Q2x1c3Rlck5vZGVGb3JOb2RlKGVkZ2UudG9JZCk7XG5cbiAgICAgICAgICBpZiAoY2x1c3RlclRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzNC5fY2x1c3RlckVkZ2VzKF90aGlzNC5ib2R5Lm5vZGVzW2VkZ2UudG9JZF0sIGVkZ2UsIGNsdXN0ZXJUbyk7XG4gICAgICAgICAgfSAvLyBUT0RPOiBjaGVjayB0aGF0IGl0IHdvcmtzIGZvciBib3RoIGVkZ2VzIGNsdXN0ZXJlZFxuICAgICAgICAgIC8vICAgICAgIChUaGlzIG1pZ2h0IGJlIHBhcmFub2lhKVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIF90aGlzNC5fY2x1c3RlckVkZ2VzW2VkZ2VJZF07XG5cbiAgICAgICAgICBfdGhpczQuX3Jlc3RvcmVFZGdlKGVkZ2UpOyAvLyBUaGlzIHNob3VsZCBub3QgYmUgaGFwcGVuaW5nLCB0aGUgc3RhdGUgc2hvdWxkXG4gICAgICAgICAgLy8gYmUgcHJvcGVybHkgdXBkYXRlZCBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSWYgaXQgKmlzKiByZWFjaGVkIGR1cmluZyBub3JtYWwgb3BlcmF0aW9uLCB0aGVuIHdlIGhhdmUgdG8gaW1wbGVtZW50XG4gICAgICAgICAgLy8gdW5kbyBjbHVzdGVyaW5nIGZvciB0aGlzIGVkZ2UgaGVyZS5cbiAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZSBlZGdlIGZyb20gY2x1c3RlcmluZyBub3QgaW1wbGVtZW50ZWQhJylcblxuICAgICAgICB9XG4gICAgICB9KTsgLy8gQ2x1c3RlcnMgbWF5IGJlIG5lc3RlZCB0byBhbnkgbGV2ZWwuIEtlZXAgb24gb3BlbmluZyB1bnRpbCBub3RoaW5nIHRvIG9wZW5cblxuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBjb250aW51ZUxvb3AgPSB0cnVlO1xuXG4gICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKCkge1xuICAgICAgICB2YXIgY2x1c3RlcnNUb09wZW4gPSBbXTsgLy8gRGV0ZXJtaW5lIHRoZSBpZCdzIG9mIGNsdXN0ZXJzIHRoYXQgbmVlZCBvcGVuaW5nXG5cbiAgICAgICAgZWFjaENsdXN0ZXJOb2RlKGZ1bmN0aW9uIChjbHVzdGVyTm9kZSkge1xuICAgICAgICAgIHZhciBudW1Ob2RlcyA9IGtleXMkNChjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcykubGVuZ3RoO1xuXG4gICAgICAgICAgdmFyIGFsbG93U2luZ2xlID0gY2x1c3Rlck5vZGUub3B0aW9ucy5hbGxvd1NpbmdsZU5vZGVDbHVzdGVyID09PSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGFsbG93U2luZ2xlICYmIG51bU5vZGVzIDwgMSB8fCAhYWxsb3dTaW5nbGUgJiYgbnVtTm9kZXMgPCAyKSB7XG4gICAgICAgICAgICBjbHVzdGVyc1RvT3Blbi5wdXNoKGNsdXN0ZXJOb2RlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBPcGVuIHRoZW1cblxuICAgICAgICBmb3IgKHZhciBfbiA9IDA7IF9uIDwgY2x1c3RlcnNUb09wZW4ubGVuZ3RoOyArK19uKSB7XG4gICAgICAgICAgX3RoaXM0Lm9wZW5DbHVzdGVyKGNsdXN0ZXJzVG9PcGVuW19uXSwge30sIGZhbHNlXG4gICAgICAgICAgLyogRG9uJ3QgcmVmcmVzaCwgd2UncmUgaW4gYW4gcmVmcmVzaC91cGRhdGUgYWxyZWFkeSAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZUxvb3AgPSBjbHVzdGVyc1RvT3Blbi5sZW5ndGggPiAwO1xuICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBjb250aW51ZUxvb3A7XG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAoY29udGludWVMb29wKSB7XG4gICAgICAgIF9sb29wMigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZSgpOyAvLyBSZWRvIHRoaXMgbWV0aG9kIChyZWN1cnNpb24gcG9zc2libGUhIHNob3VsZCBiZSBzYWZlKVxuXG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBub2RlIHdpdGggZ2l2ZW4gaWQgaXMgcGFydCBvZiBhIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHBhcnQgb2YgYSBjbHVzdGVyLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzQ2x1c3RlcmVkTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNDbHVzdGVyZWROb2RlKG5vZGVJZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgZWRnZSB3aXRoIGdpdmVuIGlkIGlzIG5vdCB2aXNpYmxlIGR1ZSB0byBjbHVzdGVyaW5nLlxuICAgICAqXG4gICAgICogQW4gZWRnZSBpcyBjb25zaWRlcmVkIGNsdXN0ZXJlZCBpZjpcbiAgICAgKiAtIGl0IGlzIGRpcmVjdGx5IHJlcGxhY2VkIGJ5IGEgY2x1c3RlcmluZyBlZGdlXG4gICAgICogLSBhbnkgb2YgaXRzIGNvbm5lY3Rpbmcgbm9kZXMgaXMgaW4gYSBjbHVzdGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSBlZGdlSWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBwYXJ0IG9mIGEgY2x1c3Rlci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pc0NsdXN0ZXJlZEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzQ2x1c3RlcmVkRWRnZShlZGdlSWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2VJZF0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2x1c3RlckVuZ2luZTtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2Ygc3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGdldEl0ZXJhdG9yTWV0aG9kJDEobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKGlzQXJyYXkkMihvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ1KG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQ0OyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNShvLCBtaW5MZW4pOyB2YXIgbiA9IHNsaWNlKF9jb250ZXh0NCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDQsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb20kMyhvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ1KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbi8qKlxuICogSW5pdGlhbGl6ZXMgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgpIHRvIGEgdXNhYmxlIGZvcm0uXG4gKlxuICogU3BlY2lmaWNhbGx5LCBzZXQgdXAgdGhpcyBtZXRob2QgZm9yIHRoZSBjYXNlIG9mIHJ1bm5pbmcgb24gbm9kZS5qcyB3aXRoIGpzZG9tIGVuYWJsZWQuXG4gKlxuICogTk9URVM6XG4gKlxuICogT24gbm9kZS5qcywgd2hlbiBjYWxsaW5nIHRoaXMgZGlyZWN0bHkgb3V0c2lkZSBvZiB0aGlzIGNsYXNzLCBgd2luZG93YCBpcyBub3QgZGVmaW5lZC5cbiAqICAgVGhpcyBoYXBwZW5zIGV2ZW4gaWYganNkb20gaXMgdXNlZC5cbiAqIEZvciBub2RlLmpzICsganNkb20sIGB3aW5kb3dgIGlzIGF2YWlsYWJsZSBhdCB0aGUgbW9tZW50IHRoZSBjb25zdHJ1Y3RvciBpcyBjYWxsZWQuXG4gKiAgIEZvciB0aGlzIHJlYXNvbiwgdGhlIGNhbGxlZCBpcyBwbGFjZWQgd2l0aGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEV2ZW4gdGhlbiwgYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKWAgaXMgbm90IGRlZmluZWQsIHNvIGl0IHN0aWxsIG5lZWRzIHRvIGJlIGFkZGVkLlxuICogRHVyaW5nIHVuaXQgdGVzdGluZywgaXQgaGFwcGVucyB0aGF0IHRoZSB3aW5kb3cgb2JqZWN0IGlzIHJlc2V0IGR1cmluZyBleGVjdXRpb24sIGNhdXNpbmdcbiAqICAgYSBydW50aW1lIGVycm9yIGR1ZSB0byBtaXNzaW5nIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKWAuIFRoaXMgbmVlZHMgdG8gYmUgY29tcGVuc2F0ZWQgZm9yLFxuICogICBzZWUgYF9yZXF1ZXN0TmV4dEZyYW1lKClgLlxuICogU2luY2UgdGhpcyBpcyBhIGdsb2JhbCBvYmplY3QsIGl0IG1heSBhZmZlY3Qgb3RoZXIgbW9kdWxlcyBiZXNpZGVzIGBOZXR3b3JrYC4gV2l0aCBub3JtYWxcbiAqICAgdXNhZ2UsIHRoaXMgZG9lcyBub3QgY2F1c2UgYW55IHByb2JsZW1zLiBEdXJpbmcgdW5pdCB0ZXN0aW5nLCBlcnJvcnMgbWF5IG9jY3VyLiBUaGVzZSBoYXZlXG4gKiAgIGJlZW4gY29tcGVuc2F0ZWQgZm9yLCBzZWUgY29tbWVudCBibG9jayBpbiBfcmVxdWVzdE5leHRGcmFtZSgpLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX2luaXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSB7XG4gIHZhciBmdW5jO1xuXG4gIGlmICh3aW5kb3cgIT09IHVuZGVmaW5lZCkge1xuICAgIGZ1bmMgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gIH1cblxuICBpZiAoZnVuYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gd2luZG93IG9yIG1ldGhvZCBub3QgcHJlc2VudCwgc2V0dGluZyBtb2NrIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJDYWxsZWQgbW9jayByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIik7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmM7XG4gIH1cbn1cbi8qKlxuICogVGhlIGNhbnZhcyByZW5kZXJlclxuICovXG5cblxudmFyIENhbnZhc1JlbmRlcmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKGJvZHksIGNhbnZhcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW52YXNSZW5kZXJlcik7XG5cbiAgICBfaW5pdFJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnJlZHJhd1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJSZXF1ZXN0cyA9IDA7XG4gICAgdGhpcy5hbGxvd1JlZHJhdyA9IHRydWU7XG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBoaWRlRWRnZXNPbkRyYWc6IGZhbHNlLFxuICAgICAgaGlkZUVkZ2VzT25ab29tOiBmYWxzZSxcbiAgICAgIGhpZGVOb2Rlc09uRHJhZzogZmFsc2VcbiAgICB9O1xuXG4gICAgYXNzaWduJDIodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuX2RldGVybWluZUJyb3dzZXJNZXRob2QoKTtcblxuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmRzIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDYW52YXNSZW5kZXJlciwgW3tcbiAgICBrZXk6IFwiYmluZEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgX2NvbnRleHQyO1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRyYWdTdGFydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkcmFnRW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJ6b29tXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuem9vbWluZyA9IHRydWU7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoX3RoaXMuem9vbVRpbWVvdXRJZCk7XG4gICAgICAgIF90aGlzLnpvb21UaW1lb3V0SWQgPSBzZXRUaW1lb3V0JDEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgICAgIF90aGlzLnpvb21pbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dCA9IF90aGlzLl9yZXF1ZXN0UmVkcmF3KS5jYWxsKF9jb250ZXh0LCBfdGhpcykoKTtcbiAgICAgICAgfSwgMjUwKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVzaXplTm9kZXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fcmVzaXplTm9kZXMoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVkcmF3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBfdGhpcy5fcmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfYmxvY2tSZWRyYXdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5hbGxvd1JlZHJhdyA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9hbGxvd1JlZHJhd1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmFsbG93UmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMucmVkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3JlcXVlc3RSZWRyYXdcIiwgYmluZCQ2KF9jb250ZXh0MiA9IHRoaXMuX3JlcXVlc3RSZWRyYXcpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9zdGFydFJlbmRlcmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnJlbmRlclJlcXVlc3RzICs9IDE7XG4gICAgICAgIF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgX3RoaXMuX3N0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3N0b3BSZW5kZXJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW5kZXJSZXF1ZXN0cyAtPSAxO1xuICAgICAgICBfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSBfdGhpcy5yZW5kZXJSZXF1ZXN0cyA+IDA7XG4gICAgICAgIF90aGlzLnJlbmRlclRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW5kZXJSZXF1ZXN0cyA9IDA7XG4gICAgICAgIF90aGlzLmFsbG93UmVkcmF3ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChfdGhpcy5yZXF1aXJlc1RpbWVvdXQgPT09IHRydWUpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMucmVuZGVyVGltZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShfdGhpcy5yZW5kZXJUaW1lcik7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtcImhpZGVFZGdlc09uRHJhZ1wiLCBcImhpZGVFZGdlc09uWm9vbVwiLCBcImhpZGVOb2Rlc09uRHJhZ1wiXTtcbiAgICAgICAgc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGRyYXdpbmcgb2YgdGhlIG5leHQgZnJhbWUuXG4gICAgICpcbiAgICAgKiBDYWxscyB0aGUgY2FsbGJhY2sgd2hlbiB0aGUgbmV4dCBmcmFtZSBjYW4gb3Igd2lsbCBiZSBkcmF3bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gdGltZW91dCBjYXNlIG9ubHksIHdhaXQgdGhpcyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9uIHwgdW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVxdWVzdE5leHRGcmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVxdWVzdE5leHRGcmFtZShjYWxsYmFjaywgZGVsYXkpIHtcbiAgICAgIC8vIER1cmluZyB1bml0IHRlc3RpbmcsIGl0IGhhcHBlbnMgdGhhdCB0aGUgbW9jayB3aW5kb3cgb2JqZWN0IGlzIHJlc2V0IHdoaWxlXG4gICAgICAvLyB0aGUgbmV4dCBmcmFtZSBpcyBzdGlsbCBwZW5kaW5nLiBUaGVuLCBlaXRoZXIgJ3dpbmRvdycgaXMgbm90IHByZXNlbnQsIG9yXG4gICAgICAvLyAncmVxdWVzdEFuaW1hdGlvbkZyYW1lKCknIGlzIG5vdCBwcmVzZW50IGJlY2F1c2UgaXQgaXMgbm90IGRlZmluZWQgb24gdGhlXG4gICAgICAvLyBtb2NrIHdpbmRvdyBvYmplY3QuXG4gICAgICAvL1xuICAgICAgLy8gQXMgYSBjb25zZXF1ZW5jZSwgdW5yZWxhdGVkIHVuaXQgdGVzdHMgbWF5IGFwcGVhciB0byBmYWlsLCBldmVuIGlmIHRoZSBwcm9ibGVtXG4gICAgICAvLyBkZXNjcmliZWQgaGFwcGVucyBpbiB0aGUgY3VycmVudCB1bml0IHRlc3QuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBpcyBub3Qgc29tZXRoaW5nIHRoYXQgd2lsbCBoYXBwZW4gaW4gbm9ybWFsIG9wZXJhdGlvbiwgYnV0IHdlIHN0aWxsIG5lZWRcbiAgICAgIC8vIHRvIHRha2UgaXQgaW50byBhY2NvdW50LlxuICAgICAgLy9cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47IC8vIERvaW5nIGBpZiAod2luZG93ID09PSB1bmRlZmluZWQpYCBkb2VzIG5vdCB3b3JrIGhlcmUhXG5cbiAgICAgIHZhciB0aW1lcjtcbiAgICAgIHZhciBteVdpbmRvdyA9IHdpbmRvdzsgLy8gR3JhYiBhIHJlZmVyZW5jZSB0byByZWR1Y2UgdGhlIHBvc3NpYmlsaXR5IHRoYXQgJ3dpbmRvdycgaXMgcmVzZXRcbiAgICAgIC8vIHdoaWxlIHJ1bm5pbmcgdGhpcyBtZXRob2QuXG5cbiAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyB3YWl0IGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYW5kIHBlcmZvcm0gdGhlIGFuaW1hdGlvbiBzdGVwIGZ1bmN0aW9uXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCQxKGNhbGxiYWNrLCBkZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobXlXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgdGltZXIgPSBteVdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aW1lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0UmVuZGVyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFJlbmRlcmluZygpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJUaW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0MztcblxuICAgICAgICAgIHRoaXMucmVuZGVyVGltZXIgPSB0aGlzLl9yZXF1ZXN0TmV4dEZyYW1lKGJpbmQkNihfY29udGV4dDMgPSB0aGlzLl9yZW5kZXJTdGVwKS5jYWxsKF9jb250ZXh0MywgdGhpcyksIHRoaXMuc2ltdWxhdGlvbkludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVuZGVyU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyU3RlcCgpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyByZXNldCB0aGUgcmVuZGVyVGltZXIgc28gYSBuZXcgc2NoZWR1bGVkIGFuaW1hdGlvbiBzdGVwIGNhbiBiZSBzZXRcbiAgICAgICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAodGhpcy5yZXF1aXJlc1RpbWVvdXQgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyB0aGlzIHNjaGVkdWxlcyBhIG5ldyBzaW11bGF0aW9uIHN0ZXBcbiAgICAgICAgICB0aGlzLl9zdGFydFJlbmRlcmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVkcmF3KCk7XG5cbiAgICAgICAgaWYgKHRoaXMucmVxdWlyZXNUaW1lb3V0ID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIHRoaXMgc2NoZWR1bGVzIGEgbmV3IHNpbXVsYXRpb24gc3RlcFxuICAgICAgICAgIHRoaXMuX3N0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IHRoZSBuZXR3b3JrIHdpdGggdGhlIGN1cnJlbnQgZGF0YVxuICAgICAqIGNoYXJ0IHdpbGwgYmUgcmVzaXplZCB0b28uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInNldFNpemVcIik7XG5cbiAgICAgIHRoaXMuX3JlZHJhdygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgdGhlIG5ldHdvcmsgd2l0aCB0aGUgY3VycmVudCBkYXRhXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlcXVlc3RSZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcXVlc3RSZWRyYXcoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucmVkcmF3UmVxdWVzdGVkICE9PSB0cnVlICYmIHRoaXMucmVuZGVyaW5nQWN0aXZlID09PSBmYWxzZSAmJiB0aGlzLmFsbG93UmVkcmF3ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVkcmF3UmVxdWVzdGVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9yZXF1ZXN0TmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuX3JlZHJhdyhmYWxzZSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgdGhlIG5ldHdvcmsgd2l0aCB0aGUgY3VycmVudCBkYXRhXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoaWRkZW49ZmFsc2VdIHwgVXNlZCB0byBnZXQgdGhlIGZpcnN0IGVzdGltYXRlIG9mIHRoZSBub2RlIHNpemVzLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHRoZSBub2RlcyBhcmUgZHJhd24gYWZ0ZXIgd2hpY2ggdGhleSBhcmUgcXVpY2tseSBkcmF3biBvdmVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWRyYXcoKSB7XG4gICAgICB2YXIgaGlkZGVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuYWxsb3dSZWRyYXcgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImluaXRSZWRyYXdcIik7XG4gICAgICAgIHRoaXMucmVkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBkcmF3TGF0ZXIgPSB7XG4gICAgICAgICAgZHJhd0V4dGVybmFsTGFiZWxzOiBudWxsXG4gICAgICAgIH07IC8vIHdoZW4gdGhlIGNvbnRhaW5lciBkaXYgd2FzIGhpZGRlbiwgdGhpcyBmaXhlcyBpdCBiYWNrIHVwIVxuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMud2lkdGggPT09IDAgfHwgdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuY2FudmFzLnNldFNpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FudmFzLnNldFRyYW5zZm9ybSgpO1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgpOyAvLyBjbGVhciB0aGUgY2FudmFzXG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBoID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTsgLy8gaWYgdGhlIGRpdiBpcyBoaWRkZW4sIHdlIHN0b3AgdGhlIHJlZHJhdyBoZXJlIGZvciBwZXJmb3JtYW5jZS5cblxuICAgICAgICBpZiAodGhpcy5jYW52YXMuZnJhbWUuY2xpZW50V2lkdGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gc2V0IHNjYWxpbmcgYW5kIHRyYW5zbGF0aW9uXG5cblxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLngsIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkpO1xuICAgICAgICBjdHguc2NhbGUodGhpcy5ib2R5LnZpZXcuc2NhbGUsIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYmVmb3JlRHJhd2luZ1wiLCBjdHgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgaWYgKGhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlIHx8IHRoaXMuZHJhZ2dpbmcgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmhpZGVFZGdlc09uRHJhZyA9PT0gZmFsc2UpICYmICh0aGlzLnpvb21pbmcgPT09IGZhbHNlIHx8IHRoaXMuem9vbWluZyA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaGlkZUVkZ2VzT25ab29tID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdFZGdlcyhjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSB8fCB0aGlzLmRyYWdnaW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlTm9kZXNPbkRyYWcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIF90aGlzJF9kcmF3Tm9kZXMgPSB0aGlzLl9kcmF3Tm9kZXMoY3R4LCBoaWRkZW4pLFxuICAgICAgICAgICAgICBkcmF3RXh0ZXJuYWxMYWJlbHMgPSBfdGhpcyRfZHJhd05vZGVzLmRyYXdFeHRlcm5hbExhYmVscztcblxuICAgICAgICAgIGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbHMgPSBkcmF3RXh0ZXJuYWxMYWJlbHM7XG4gICAgICAgIH0gLy8gZHJhdyB0aGUgYXJyb3dzIGxhc3Qgc28gdGhleSB3aWxsIGJlIGF0IHRoZSB0b3BcblxuXG4gICAgICAgIGlmIChoaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSB8fCB0aGlzLmRyYWdnaW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlRWRnZXNPbkRyYWcgPT09IGZhbHNlKSAmJiAodGhpcy56b29taW5nID09PSBmYWxzZSB8fCB0aGlzLnpvb21pbmcgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmhpZGVFZGdlc09uWm9vbSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3QXJyb3dzKGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICAgIGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fZHJhd1NlbGVjdGlvbkJveChjdHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYWZ0ZXJEcmF3aW5nXCIsIGN0eCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTsgLy8gcmVzdG9yZSBvcmlnaW5hbCBzY2FsaW5nIGFuZCB0cmFuc2xhdGlvblxuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgaWYgKGhpZGRlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IGFsbCBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWx3YXlzU2hvd11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2l6ZU5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemVOb2RlcygpIHtcbiAgICAgIHRoaXMuY2FudmFzLnNldFRyYW5zZm9ybSgpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLngsIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkpO1xuICAgICAgY3R4LnNjYWxlKHRoaXMuYm9keS52aWV3LnNjYWxlLCB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZTsgLy8gcmVzaXplIGFsbCBub2Rlc1xuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIG5vZGUucmVzaXplKGN0eCk7XG4gICAgICAgICAgbm9kZS51cGRhdGVCb3VuZGluZ0JveChjdHgsIG5vZGUuc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHJlc3RvcmUgb3JpZ2luYWwgc2NhbGluZyBhbmQgdHJhbnNsYXRpb25cblxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYWxsIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4ICAyRCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbHdheXNTaG93XVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3Tm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdOb2RlcyhjdHgpIHtcbiAgICAgIHZhciBhbHdheXNTaG93ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlO1xuICAgICAgdmFyIHNlbGVjdGVkID0gW107XG4gICAgICB2YXIgaG92ZXJlZCA9IFtdO1xuICAgICAgdmFyIG1hcmdpbiA9IDIwO1xuICAgICAgdmFyIHRvcExlZnQgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IC1tYXJnaW4sXG4gICAgICAgIHk6IC1tYXJnaW5cbiAgICAgIH0pO1xuICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICB4OiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggKyBtYXJnaW4sXG4gICAgICAgIHk6IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKyBtYXJnaW5cbiAgICAgIH0pO1xuICAgICAgdmFyIHZpZXdhYmxlQXJlYSA9IHtcbiAgICAgICAgdG9wOiB0b3BMZWZ0LnksXG4gICAgICAgIGxlZnQ6IHRvcExlZnQueCxcbiAgICAgICAgYm90dG9tOiBib3R0b21SaWdodC55LFxuICAgICAgICByaWdodDogYm90dG9tUmlnaHQueFxuICAgICAgfTtcbiAgICAgIHZhciBfZHJhd0V4dGVybmFsTGFiZWxzID0gW107IC8vIGRyYXcgdW5zZWxlY3RlZCBub2RlcztcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbX2ldXTsgLy8gc2V0IHNlbGVjdGVkIGFuZCBob3ZlcmVkIG5vZGVzIGFzaWRlXG5cbiAgICAgICAgaWYgKG5vZGUuaG92ZXIpIHtcbiAgICAgICAgICBob3ZlcmVkLnB1c2gobm9kZUluZGljZXNbX2ldKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgIHNlbGVjdGVkLnB1c2gobm9kZUluZGljZXNbX2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYWx3YXlzU2hvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGRyYXdMYXRlciA9IG5vZGUuZHJhdyhjdHgpO1xuXG4gICAgICAgICAgICBpZiAoZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgX2RyYXdFeHRlcm5hbExhYmVscy5wdXNoKGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmlzQm91bmRpbmdCb3hPdmVybGFwcGluZ1dpdGgodmlld2FibGVBcmVhKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9kcmF3TGF0ZXIgPSBub2RlLmRyYXcoY3R4KTtcblxuICAgICAgICAgICAgaWYgKF9kcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBfZHJhd0V4dGVybmFsTGFiZWxzLnB1c2goX2RyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUudXBkYXRlQm91bmRpbmdCb3goY3R4LCBub2RlLnNlbGVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgc2VsZWN0ZWRMZW5ndGggPSBzZWxlY3RlZC5sZW5ndGg7XG4gICAgICB2YXIgaG92ZXJlZExlbmd0aCA9IGhvdmVyZWQubGVuZ3RoOyAvLyBkcmF3IHRoZSBzZWxlY3RlZCBub2RlcyBvbiB0b3BcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdGVkTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW3NlbGVjdGVkW2ldXTtcblxuICAgICAgICB2YXIgX2RyYXdMYXRlcjIgPSBub2RlLmRyYXcoY3R4KTtcblxuICAgICAgICBpZiAoX2RyYXdMYXRlcjIuZHJhd0V4dGVybmFsTGFiZWwgIT0gbnVsbCkge1xuICAgICAgICAgIF9kcmF3RXh0ZXJuYWxMYWJlbHMucHVzaChfZHJhd0xhdGVyMi5kcmF3RXh0ZXJuYWxMYWJlbCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZHJhdyBob3ZlcmVkIG5vZGVzIGFib3ZlIGV2ZXJ5dGhpbmcgZWxzZTogZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3Zpc2pzL3Zpcy1uZXR3b3JrL2lzc3Vlcy8yMjZcblxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaG92ZXJlZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tob3ZlcmVkW2ldXTtcblxuICAgICAgICB2YXIgX2RyYXdMYXRlcjMgPSBub2RlLmRyYXcoY3R4KTtcblxuICAgICAgICBpZiAoX2RyYXdMYXRlcjMuZHJhd0V4dGVybmFsTGFiZWwgIT0gbnVsbCkge1xuICAgICAgICAgIF9kcmF3RXh0ZXJuYWxMYWJlbHMucHVzaChfZHJhd0xhdGVyMy5kcmF3RXh0ZXJuYWxMYWJlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHJhd0V4dGVybmFsTGFiZWxzOiBmdW5jdGlvbiBkcmF3RXh0ZXJuYWxMYWJlbHMoKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoX2RyYXdFeHRlcm5hbExhYmVscyksXG4gICAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBkcmF3ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYWxsIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4ICAyRCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0VkZ2VzKGN0eCkge1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbaV1dO1xuXG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGVkZ2UuZHJhdyhjdHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhbGwgYXJyb3dzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4ICAyRCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdBcnJvd3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdBcnJvd3MoY3R4KSB7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLmJvZHkuZWRnZUluZGljZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tpXV07XG5cbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgZWRnZS5kcmF3QXJyb3dzKGN0eCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBicm93c2VyIHJlcXVpcmVzIGEgc2V0VGltZW91dCBvciBhIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gVGhpcyB3YXMgcmVxdWlyZWQgYmVjYXVzZVxuICAgICAqIHNvbWUgaW1wbGVtZW50YXRpb25zIChzYWZhcmkgYW5kIElFOSkgZGlkIG5vdCBzdXBwb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXRlcm1pbmVCcm93c2VyTWV0aG9kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVCcm93c2VyTWV0aG9kKCkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIGJyb3dzZXJUeXBlID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChpbmRleE9mKGJyb3dzZXJUeXBlKS5jYWxsKGJyb3dzZXJUeXBlLCBcIm1zaWUgOS4wXCIpICE9IC0xKSB7XG4gICAgICAgICAgLy8gSUUgOVxuICAgICAgICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleE9mKGJyb3dzZXJUeXBlKS5jYWxsKGJyb3dzZXJUeXBlLCBcInNhZmFyaVwiKSAhPSAtMSkge1xuICAgICAgICAgIC8vIHNhZmFyaVxuICAgICAgICAgIGlmIChpbmRleE9mKGJyb3dzZXJUeXBlKS5jYWxsKGJyb3dzZXJUeXBlLCBcImNocm9tZVwiKSA8PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgc2VsZWN0aW9uIGJveFxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgMkQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3U2VsZWN0aW9uQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3U2VsZWN0aW9uQm94KGN0eCkge1xuICAgICAgaWYgKHRoaXMuYm9keS5zZWxlY3Rpb25Cb3guc2hvdykge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uZW5kLnggLSB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0Lng7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLmVuZC55IC0gdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC55O1xuICAgICAgICBjdHgucmVjdCh0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0LngsIHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQueSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMTUxLCAxOTQsIDI1MiwgMC4yKVwiO1xuICAgICAgICBjdHguZmlsbFJlY3QodGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC54LCB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0LnksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMTUxLCAxOTQsIDI1MiwgMSlcIjtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYW52YXNSZW5kZXJlcjtcbn0oKTtcblxudmFyIHBhdGgkMSA9IHBhdGgkeTtcbnZhciBzZXRJbnRlcnZhbCQxID0gcGF0aCQxLnNldEludGVydmFsO1xuXG52YXIgc2V0SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCQxO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgdG91Y2ggZXZlbnQsIHRha2luZyBwbGFjZSBiZWZvcmUgYSBnZXN0dXJlXG4gKlxuICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICovXG5mdW5jdGlvbiBvblRvdWNoKGhhbW1lciwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2suaW5wdXRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlzRmlyc3QpIHtcbiAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgaGFtbWVyLm9uKFwiaGFtbWVyLmlucHV0XCIsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG59XG4vKipcbiAqIFJlZ2lzdGVyIGEgcmVsZWFzZSBldmVudCwgdGFraW5nIHBsYWNlIGFmdGVyIGEgZ2VzdHVyZVxuICpcbiAqIEBwYXJhbSB7SGFtbWVyfSBoYW1tZXIgICAgICAgQSBoYW1tZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2ssIGNhbGxlZCBhcyBjYWxsYmFjayhldmVudClcbiAqIEByZXR1cm5zIHsqfVxuICovXG5cbmZ1bmN0aW9uIG9uUmVsZWFzZShoYW1tZXIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrLmlucHV0SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5pc0ZpbmFsKSB7XG4gICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBoYW1tZXIub24oXCJoYW1tZXIuaW5wdXRcIiwgY2FsbGJhY2suaW5wdXRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIG1haW4gZnJhbWUgZm9yIHRoZSBOZXR3b3JrLlxuICogVGhpcyBmdW5jdGlvbiBpcyBleGVjdXRlZCBvbmNlIHdoZW4gYSBOZXR3b3JrIG9iamVjdCBpcyBjcmVhdGVkLiBUaGUgZnJhbWVcbiAqIGNvbnRhaW5zIGEgY2FudmFzLCBhbmQgdGhpcyBjYW52YXMgY29udGFpbnMgYWxsIG9iamVjdHMgbGlrZSB0aGUgYXhpcyBhbmRcbiAqIG5vZGVzLlxuICovXG5cbnZhciBDYW52YXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICovXG4gIGZ1bmN0aW9uIENhbnZhcyhib2R5KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhcyk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IDE7XG4gICAgdGhpcy5jYW1lcmFTdGF0ZSA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbnZhc1ZpZXdDZW50ZXIgPSB7fTtcbiAgICB0aGlzLl9jbGVhbnVwQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGF1dG9SZXNpemU6IHRydWUsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgd2lkdGg6IFwiMTAwJVwiXG4gICAgfTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ2FudmFzLCBbe1xuICAgIGtleTogXCJiaW5kRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBfY29udGV4dDtcblxuICAgICAgLy8gYmluZCB0aGUgZXZlbnRzXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbmNlKFwicmVzaXplXCIsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKG9iai53aWR0aCAhPT0gMCkge1xuICAgICAgICAgIF90aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54ID0gb2JqLndpZHRoICogMC41O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iai5oZWlnaHQgIT09IDApIHtcbiAgICAgICAgICBfdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSA9IG9iai5oZWlnaHQgKiAwLjU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJzZXRTaXplXCIsIGJpbmQkNihfY29udGV4dCA9IHRoaXMuc2V0U2l6ZSkuY2FsbChfY29udGV4dCwgdGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuaGFtbWVyRnJhbWUuZGVzdHJveSgpO1xuXG4gICAgICAgIF90aGlzLmhhbW1lci5kZXN0cm95KCk7XG5cbiAgICAgICAgX3RoaXMuX2NsZWFuVXAoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImF1dG9SZXNpemVcIl07XG4gICAgICAgIHNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgfSAvLyBBdXRvbWF0aWNhbGx5IGFkYXB0IHRvIGNoYW5naW5nIHNpemUgb2YgdGhlIGNvbnRhaW5lciBlbGVtZW50LlxuXG5cbiAgICAgIHRoaXMuX2NsZWFuVXAoKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUmVzaXplID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDI7XG5cbiAgICAgICAgaWYgKHdpbmRvdy5SZXNpemVPYnNlcnZlcikge1xuICAgICAgICAgIC8vIGRlY2VudCBicm93c2VycywgaW1tZWRpYXRlIHJlYWN0aW9uc1xuICAgICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IF90aGlzMi5zZXRTaXplKCk7XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWU7XG4gICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShmcmFtZSk7XG5cbiAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGZyYW1lKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJRTExLCBjb250aW5vdXMgcG9sbGluZ1xuICAgICAgICAgIHZhciByZXNpemVUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gX3RoaXMyLnNldFNpemUoKTtcblxuICAgICAgICAgICAgaWYgKGNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMTAwMCk7XG5cbiAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChyZXNpemVUaW1lcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gQXV0b21hdGljYWxseSBhZGFwdCB0byBjaGFuZ2luZyBzaXplIG9mIHRoZSBicm93c2VyLlxuXG5cbiAgICAgICAgdmFyIHJlc2l6ZUZ1bmN0aW9uID0gYmluZCQ2KF9jb250ZXh0MiA9IHRoaXMuX29uUmVzaXplKS5jYWxsKF9jb250ZXh0MiwgdGhpcyk7XG5cbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwicmVzaXplXCIsIHJlc2l6ZUZ1bmN0aW9uKTtcblxuICAgICAgICB0aGlzLl9jbGVhbnVwQ2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBcInJlc2l6ZVwiLCByZXNpemVGdW5jdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsZWFuVXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFuVXAoKSB7XG4gICAgICB2YXIgX2NvbnRleHQzLCBfY29udGV4dDQsIF9jb250ZXh0NTtcblxuICAgICAgZm9yRWFjaCQyKF9jb250ZXh0MyA9IHJldmVyc2UoX2NvbnRleHQ0ID0gc3BsaWNlJDEoX2NvbnRleHQ1ID0gdGhpcy5fY2xlYW51cENhbGxiYWNrcykuY2FsbChfY29udGV4dDUsIDApKS5jYWxsKF9jb250ZXh0NCkpLmNhbGwoX2NvbnRleHQzLCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9vblJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25SZXNpemUoKSB7XG4gICAgICB0aGlzLnNldFNpemUoKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYW5kIHN0b3JlIHRoZSBjYW1lcmFTdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwaXhlbFJhdGlvPXRoaXMucGl4ZWxSYXRpb11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENhbWVyYVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDYW1lcmFTdGF0ZSgpIHtcbiAgICAgIHZhciBwaXhlbFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnBpeGVsUmF0aW87XG5cbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNXaWR0aCA9IHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c0hlaWdodCA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW87XG4gICAgICAgIHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbiA9IHRoaXMuRE9NdG9DYW52YXMoe1xuICAgICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbyxcbiAgICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyBwaXhlbFJhdGlvXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNhbWVyYVN0YXRlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldENhbWVyYVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDYW1lcmFTdGF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggIT09IDAgJiYgdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICE9PSAwICYmIHRoaXMucGl4ZWxSYXRpbyAhPT0gMCAmJiB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzV2lkdGggPiAwICYmIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNIZWlnaHQgPiAwKSB7XG4gICAgICAgIHZhciB3aWR0aFJhdGlvID0gdGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyB0aGlzLnBpeGVsUmF0aW8gLyB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzV2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHRSYXRpbyA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHRoaXMucGl4ZWxSYXRpbyAvIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNIZWlnaHQ7XG4gICAgICAgIHZhciBuZXdTY2FsZSA9IHRoaXMuY2FtZXJhU3RhdGUuc2NhbGU7XG5cbiAgICAgICAgaWYgKHdpZHRoUmF0aW8gIT0gMSAmJiBoZWlnaHRSYXRpbyAhPSAxKSB7XG4gICAgICAgICAgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICogMC41ICogKHdpZHRoUmF0aW8gKyBoZWlnaHRSYXRpbyk7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGhSYXRpbyAhPSAxKSB7XG4gICAgICAgICAgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICogd2lkdGhSYXRpbztcbiAgICAgICAgfSBlbHNlIGlmIChoZWlnaHRSYXRpbyAhPSAxKSB7XG4gICAgICAgICAgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICogaGVpZ2h0UmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IG5ld1NjYWxlOyAvLyB0aGlzIGNvbWVzIGZyb20gdGhlIHZpZXcgbW9kdWxlLlxuXG4gICAgICAgIHZhciBjdXJyZW50Vmlld0NlbnRlciA9IHRoaXMuRE9NdG9DYW52YXMoe1xuICAgICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLFxuICAgICAgICAgIHk6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRpc3RhbmNlRnJvbUNlbnRlciA9IHtcbiAgICAgICAgICAvLyBvZmZzZXQgZnJvbSB2aWV3LCBkaXN0YW5jZSB2aWV3IGhhcyB0byBjaGFuZ2UgYnkgdGhlc2UgeCBhbmQgeSB0byBjZW50ZXIgdGhlIG5vZGVcbiAgICAgICAgICB4OiBjdXJyZW50Vmlld0NlbnRlci54IC0gdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbi54LFxuICAgICAgICAgIHk6IGN1cnJlbnRWaWV3Q2VudGVyLnkgLSB0aGlzLmNhbWVyYVN0YXRlLnBvc2l0aW9uLnlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCArPSBkaXN0YW5jZUZyb21DZW50ZXIueCAqIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55ICs9IGRpc3RhbmNlRnJvbUNlbnRlci55ICogdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wcmVwYXJlVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVWYWx1ZSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUgKyBcInB4XCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoaW5kZXhPZih2YWx1ZSkuY2FsbCh2YWx1ZSwgXCIlXCIpICE9PSAtMSB8fCBpbmRleE9mKHZhbHVlKS5jYWxsKHZhbHVlLCBcInB4XCIpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleE9mKHZhbHVlKS5jYWxsKHZhbHVlLCBcIiVcIikgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCB1c2UgdGhlIHZhbHVlIHN1cHBsaWVkIGZvciB3aWR0aCBvciBoZWlnaHQ6XCIgKyB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgSFRNTFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xuICAgICAgLy8gcmVtb3ZlIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBjb250YWluZXIgZWxlbWVudC5cbiAgICAgIHdoaWxlICh0aGlzLmJvZHkuY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICB0aGlzLmJvZHkuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuYm9keS5jb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5mcmFtZS5jbGFzc05hbWUgPSBcInZpcy1uZXR3b3JrXCI7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICB0aGlzLmZyYW1lLnRhYkluZGV4ID0gMDsgLy8gdGFiIGluZGV4IGlzIHJlcXVpcmVkIGZvciBrZXljaGFybSB0byBiaW5kIGtleXN0cm9rZXMgdG8gdGhlIGRpdiBpbnN0ZWFkIG9mIHRoZSB3aW5kb3dcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZS5jYW52YXMpO1xuXG4gICAgICBpZiAoIXRoaXMuZnJhbWUuY2FudmFzLmdldENvbnRleHQpIHtcbiAgICAgICAgdmFyIG5vQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgICAgICAgbm9DYW52YXMuc3R5bGUuY29sb3IgPSBcInJlZFwiO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5mb250V2VpZ2h0ID0gXCJib2xkXCI7XG4gICAgICAgIG5vQ2FudmFzLnN0eWxlLnBhZGRpbmcgPSBcIjEwcHhcIjtcbiAgICAgICAgbm9DYW52YXMuaW5uZXJUZXh0ID0gXCJFcnJvcjogeW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgSFRNTCBjYW52YXNcIjtcbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYXBwZW5kQ2hpbGQobm9DYW52YXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKCk7XG4gICAgICB9IC8vIGFkZCB0aGUgZnJhbWUgdG8gdGhlIGNvbnRhaW5lciBlbGVtZW50XG5cblxuICAgICAgdGhpcy5ib2R5LmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcbiAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gMTtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCxcbiAgICAgICAgeTogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9iaW5kSGFtbWVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYmluZHMgaGFtbWVyLCBpdCBjYW4gYmUgcmVwZWF0ZWQgb3ZlciBhbmQgb3ZlciBkdWUgdG8gdGhlIHVuaXF1ZW5lc3MgY2hlY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JpbmRIYW1tZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRIYW1tZXIoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuaGFtbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRyYWcgPSB7fTtcbiAgICAgIHRoaXMucGluY2ggPSB7fTsgLy8gaW5pdCBoYW1tZXJcblxuICAgICAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuZnJhbWUuY2FudmFzKTtcbiAgICAgIHRoaXMuaGFtbWVyLmdldChcInBpbmNoXCIpLnNldCh7XG4gICAgICAgIGVuYWJsZTogdHJ1ZVxuICAgICAgfSk7IC8vIGVuYWJsZSB0byBnZXQgYmV0dGVyIHJlc3BvbnNlLCB0b2RvOiB0ZXN0IG9uIG1vYmlsZS5cblxuICAgICAgdGhpcy5oYW1tZXIuZ2V0KFwicGFuXCIpLnNldCh7XG4gICAgICAgIHRocmVzaG9sZDogNSxcbiAgICAgICAgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0FMTFxuICAgICAgfSk7XG4gICAgICBvblRvdWNoKHRoaXMuaGFtbWVyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ub3VjaChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwidGFwXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vblRhcChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwiZG91YmxldGFwXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkRvdWJsZVRhcChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicHJlc3NcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uSG9sZChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGFuc3RhcnRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ1N0YXJ0KGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJwYW5tb3ZlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWcoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBhbmVuZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnRW5kKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJwaW5jaFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25QaW5jaChldmVudCk7XG4gICAgICB9KTsgLy8gVE9ETzogbmVhdGx5IGNsZWFudXAgdGhlc2UgaGFuZGxlcnMgd2hlbiByZS1jcmVhdGluZyB0aGUgQ2FudmFzLCBJRiB0aGVzZSBhcmUgZG9uZSB3aXRoIGhhbW1lciwgZXZlbnQuc3RvcFByb3BhZ2F0aW9uIHdpbGwgbm90IHdvcms/XG5cbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZVdoZWVsKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZU1vdmUoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uQ29udGV4dChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyRnJhbWUgPSBuZXcgSGFtbWVyKHRoaXMuZnJhbWUpO1xuICAgICAgb25SZWxlYXNlKHRoaXMuaGFtbWVyRnJhbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vblJlbGVhc2UoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIG5ldyBzaXplIGZvciB0aGUgbmV0d29ya1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdpZHRoICAgV2lkdGggaW4gcGl4ZWxzIG9yIHBlcmNlbnRhZ2UgKGZvciBleGFtcGxlICc4MDBweCdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBvciAnNTAlJylcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGVpZ2h0ICBIZWlnaHQgaW4gcGl4ZWxzIG9yIHBlcmNlbnRhZ2UgIChmb3IgZXhhbXBsZSAnNDAwcHgnXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgb3IgJzMwJScpXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNpemUoKSB7XG4gICAgICB2YXIgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMub3B0aW9ucy5oZWlnaHQ7XG4gICAgICB3aWR0aCA9IHRoaXMuX3ByZXBhcmVWYWx1ZSh3aWR0aCk7XG4gICAgICBoZWlnaHQgPSB0aGlzLl9wcmVwYXJlVmFsdWUoaGVpZ2h0KTtcbiAgICAgIHZhciBlbWl0RXZlbnQgPSBmYWxzZTtcbiAgICAgIHZhciBvbGRXaWR0aCA9IHRoaXMuZnJhbWUuY2FudmFzLndpZHRoO1xuICAgICAgdmFyIG9sZEhlaWdodCA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodDsgLy8gdXBkYXRlIHRoZSBwaXhlbCByYXRpb1xuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IENvbW1lbnQgaW4gZm9sbG93aW5nIGlzIHJhdGhlciBpbmNvbnNpc3RlbnQ7IHRoaXMgaXMgdGhlIE9OTFkgcGxhY2UgaW4gdGhlIGNvZGVcbiAgICAgIC8vICAgICAgIHdoZXJlIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgcGl4ZWwgcmF0aW8gY291bGQgY2hhbmdlIGF0IHJ1bnRpbWUuXG4gICAgICAvLyAgICAgICBUaGUgb25seSB3YXkgSSBjYW4gdGhpbmsgb2YgdGhpcyBoYXBwZW5pbmcgaXMgYSByb3RhdGluZyBzY3JlZW4gb3IgdGFibGV0OyBidXQgdGhlblxuICAgICAgLy8gICAgICAgdGhlcmUgc2hvdWxkIGJlIGEgbWVjaGFuaXNtIGZvciByZWxvYWRpbmcgdGhlIGRhdGEgKFRPRE86IGNoZWNrIGlmIHRoaXMgaXMgcHJlc2VudCkuXG4gICAgICAvL1xuICAgICAgLy8gICAgICAgSWYgdGhlIGFzc3VtcHRpb24gaXMgdHJ1ZSAoaS5lLiBwaXhlbCByYXRpbyBjYW4gY2hhbmdlIGF0IHJ1bnRpbWUpLCB0aGVuICphbGwqIHVzYWdlXG4gICAgICAvLyAgICAgICBvZiBwaXhlbCByYXRpbyBtdXN0IGJlIG92ZXJoYXVsZWQgZm9yIHRoaXMuXG4gICAgICAvL1xuICAgICAgLy8gICAgICAgRm9yIHRoZSB0aW1lIGJlaW5nLCBJIHdpbGwgaHVtb3IgdGhlIGFzc3VtcHRpb24gaGVyZSwgYW5kIGluIHRoZSByZXN0IG9mIHRoZSBjb2RlIGFzc3VtZSBpdCBpc1xuICAgICAgLy8gICAgICAgY29uc3RhbnQuXG5cbiAgICAgIHZhciBwcmV2aW91c1JhdGlvID0gdGhpcy5waXhlbFJhdGlvOyAvLyB3ZSBjYWNoZSB0aGlzIGJlY2F1c2UgdGhlIGNhbWVyYSBzdGF0ZSBzdG9yYWdlIG5lZWRzIHRoZSBvbGQgdmFsdWVcblxuICAgICAgdGhpcy5fc2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgICBpZiAod2lkdGggIT0gdGhpcy5vcHRpb25zLndpZHRoIHx8IGhlaWdodCAhPSB0aGlzLm9wdGlvbnMuaGVpZ2h0IHx8IHRoaXMuZnJhbWUuc3R5bGUud2lkdGggIT0gd2lkdGggfHwgdGhpcy5mcmFtZS5zdHlsZS5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2dldENhbWVyYVN0YXRlKHByZXZpb3VzUmF0aW8pO1xuXG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCA9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLm9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhbnZhc1ZpZXdDZW50ZXIgPSB7XG4gICAgICAgICAgeDogMC41ICogdGhpcy5mcmFtZS5jbGllbnRXaWR0aCxcbiAgICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNsaWVudEhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyB3b3VsZCBhZGFwdCB0aGUgd2lkdGggb2YgdGhlIGNhbnZhcyB0byB0aGUgd2lkdGggZnJvbSAxMDAlIGlmIGFuZCBvbmx5IGlmXG4gICAgICAgIC8vIHRoZXJlIGlzIGEgY2hhbmdlLlxuICAgICAgICB2YXIgbmV3V2lkdGggPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICogdGhpcy5waXhlbFJhdGlvKTtcbiAgICAgICAgdmFyIG5ld0hlaWdodCA9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvKTsgLy8gc3RvcmUgdGhlIGNhbWVyYSBpZiB0aGVyZSBpcyBhIGNoYW5nZSBpbiBzaXplLlxuXG4gICAgICAgIGlmICh0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAhPT0gbmV3V2lkdGggfHwgdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0ICE9PSBuZXdIZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLl9nZXRDYW1lcmFTdGF0ZShwcmV2aW91c1JhdGlvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAhPT0gbmV3V2lkdGgpIHtcbiAgICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICAgIGVtaXRFdmVudCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0ICE9PSBuZXdIZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICAgICAgZW1pdEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW1pdEV2ZW50ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZXNpemVcIiwge1xuICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gdGhpcy5waXhlbFJhdGlvKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0IC8gdGhpcy5waXhlbFJhdGlvKSxcbiAgICAgICAgICBvbGRXaWR0aDogTWF0aC5yb3VuZChvbGRXaWR0aCAvIHRoaXMucGl4ZWxSYXRpbyksXG4gICAgICAgICAgb2xkSGVpZ2h0OiBNYXRoLnJvdW5kKG9sZEhlaWdodCAvIHRoaXMucGl4ZWxSYXRpbylcbiAgICAgICAgfSk7IC8vIHJlc3RvcmUgdGhlIGNhbWVyYSBvbiBjaGFuZ2UuXG5cbiAgICAgICAgdGhpcy5fc2V0Q2FtZXJhU3RhdGUoKTtcbiAgICAgIH0gLy8gc2V0IGluaXRpYWxpemVkIHNvIHRoZSBnZXQgYW5kIHNldCBjYW1lcmEgd2lsbCB3b3JrIGZyb20gbm93IG9uLlxuXG5cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGVtaXRFdmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJhbWUuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBwaXhlbCByYXRpbyBmb3IgdmFyaW91cyBicm93c2Vycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXRlcm1pbmVQaXhlbFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVQaXhlbFJhdGlvKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0Q29udGV4dCgpO1xuXG4gICAgICBpZiAoY3R4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGdldCBjYW52YXggY29udGV4dFwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG51bWVyYXRvciA9IDE7XG5cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vICh3aW5kb3cgIT09IHVuZGVmaW5lZCkgZG9lc24ndCB3b3JrIGhlcmUhXG4gICAgICAgIC8vIFByb3RlY3Rpb24gZHVyaW5nIHVuaXQgdGVzdHMsIHdoZXJlICd3aW5kb3cnIGNhbiBiZSBtaXNzaW5nXG4gICAgICAgIG51bWVyYXRvciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZW5vbWluYXRvciA9IGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG4gICAgICByZXR1cm4gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExhenkgZGV0ZXJtaW5hdGlvbiBvZiBwaXhlbCByYXRpby5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0UGl4ZWxSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0UGl4ZWxSYXRpbygpIHtcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHRoaXMuX2RldGVybWluZVBpeGVsUmF0aW8oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0cmFuc2Zvcm0gaW4gdGhlIGNvbnRhaW5lZCBjb250ZXh0LCBiYXNlZCBvbiBpdHMgcGl4ZWxSYXRpb1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRyYW5zZm9ybSgpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmdldENvbnRleHQoKTtcblxuICAgICAgaWYgKGN0eCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgY2FudmF4IGNvbnRleHRcIik7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBYIGNvb3JkaW5hdGUgaW4gRE9NLXNwYWNlIChjb29yZGluYXRlIHBvaW50IGluIGJyb3dzZXIgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBkaXYpIHRvXG4gICAgICogdGhlIFggY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX1hjb252ZXJ0RE9NdG9DYW52YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX1hjb252ZXJ0RE9NdG9DYW52YXMoeCkge1xuICAgICAgcmV0dXJuICh4IC0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgWCBjb29yZGluYXRlIGluIGNhbnZhcy1zcGFjZSAodGhlIHNpbXVsYXRpb24gc2FuZGJveCwgd2hpY2ggdGhlIGNhbWVyYSBsb29rcyB1cG9uKSB0b1xuICAgICAqIHRoZSBYIGNvb3JkaW5hdGUgaW4gRE9NLXNwYWNlIChjb29yZGluYXRlIHBvaW50IGluIGJyb3dzZXIgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBkaXYpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9YY29udmVydENhbnZhc1RvRE9NXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9YY29udmVydENhbnZhc1RvRE9NKHgpIHtcbiAgICAgIHJldHVybiB4ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBZIGNvb3JkaW5hdGUgaW4gRE9NLXNwYWNlIChjb29yZGluYXRlIHBvaW50IGluIGJyb3dzZXIgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBkaXYpIHRvXG4gICAgICogdGhlIFkgY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX1ljb252ZXJ0RE9NdG9DYW52YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX1ljb252ZXJ0RE9NdG9DYW52YXMoeSkge1xuICAgICAgcmV0dXJuICh5IC0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgWSBjb29yZGluYXRlIGluIGNhbnZhcy1zcGFjZSAodGhlIHNpbXVsYXRpb24gc2FuZGJveCwgd2hpY2ggdGhlIGNhbWVyYSBsb29rcyB1cG9uKSB0b1xuICAgICAqIHRoZSBZIGNvb3JkaW5hdGUgaW4gRE9NLXNwYWNlIChjb29yZGluYXRlIHBvaW50IGluIGJyb3dzZXIgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBkaXYpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ZY29udmVydENhbnZhc1RvRE9NXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ZY29udmVydENhbnZhc1RvRE9NKHkpIHtcbiAgICAgIHJldHVybiB5ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBwb3NcbiAgICAgKiBAcmV0dXJucyB7cG9pbnR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYW52YXNUb0RPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW52YXNUb0RPTShwb3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRoaXMuX1hjb252ZXJ0Q2FudmFzVG9ET00ocG9zLngpLFxuICAgICAgICB5OiB0aGlzLl9ZY29udmVydENhbnZhc1RvRE9NKHBvcy55KVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBwb3NcbiAgICAgKiBAcmV0dXJucyB7cG9pbnR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJET010b0NhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBET010b0NhbnZhcyhwb3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRoaXMuX1hjb252ZXJ0RE9NdG9DYW52YXMocG9zLngpLFxuICAgICAgICB5OiB0aGlzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvcy55KVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FudmFzO1xufSgpO1xuXG4vKipcclxuICogVmFsaWRhdGUgdGhlIGZpdCBvcHRpb25zLCByZXBsYWNlIG1pc3Npbmcgb3B0aW9uYWwgdmFsdWVzIGJ5IGRlZmF1bHRzIGV0Yy5cclxuICpcclxuICogQHBhcmFtIHJhd09wdGlvbnMgLSBUaGUgcmF3IG9wdGlvbnMuXHJcbiAqIEBwYXJhbSBhbGxOb2RlSWRzIC0gQWxsIG5vZGUgaWRzIHRoYXQgd2lsbCBiZSB1c2VkIGlmIG5vZGVzIGFyZSBvbWl0dGVkIGluXHJcbiAqIHRoZSByYXcgb3B0aW9ucy5cclxuICogQHJldHVybnMgT3B0aW9ucyB3aXRoIGV2ZXJ5dGhpbmcgZmlsbGVkIGluIGFuZCB2YWxpZGF0ZWQuXHJcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRml0T3B0aW9ucyhyYXdPcHRpb25zLCBhbGxOb2RlSWRzKSB7XG4gIHZhciBvcHRpb25zID0gYXNzaWduJDIoe1xuICAgIG5vZGVzOiBhbGxOb2RlSWRzLFxuICAgIG1pblpvb21MZXZlbDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICBtYXhab29tTGV2ZWw6IDFcbiAgfSwgcmF3T3B0aW9ucyAhPT0gbnVsbCAmJiByYXdPcHRpb25zICE9PSB2b2lkIDAgPyByYXdPcHRpb25zIDoge30pO1xuXG4gIGlmICghaXNBcnJheSQyKG9wdGlvbnMubm9kZXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vZGVzIGhhcyB0byBiZSBhbiBhcnJheSBvZiBpZHMuXCIpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgb3B0aW9ucy5ub2RlcyA9IGFsbE5vZGVJZHM7XG4gIH1cblxuICBpZiAoISh0eXBlb2Ygb3B0aW9ucy5taW5ab29tTGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgb3B0aW9ucy5taW5ab29tTGV2ZWwgPiAwKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNaW4gem9vbSBsZXZlbCBoYXMgdG8gYmUgYSBudW1iZXIgaGlnaGVyIHRoYW4gemVyby5cIik7XG4gIH1cblxuICBpZiAoISh0eXBlb2Ygb3B0aW9ucy5tYXhab29tTGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgb3B0aW9ucy5taW5ab29tTGV2ZWwgPD0gb3B0aW9ucy5tYXhab29tTGV2ZWwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1heCB6b29tIGxldmVsIGhhcyB0byBiZSBhIG51bWJlciBoaWdoZXIgdGhhbiBtaW4gem9vbSBsZXZlbC5cIik7XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBUaGUgdmlld1xuICovXG5cbnZhciBWaWV3ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIFZpZXcoYm9keSwgY2FudmFzKSB7XG4gICAgdmFyIF9jb250ZXh0LFxuICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgIF9jb250ZXh0MjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3KTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5hbmltYXRpb25TcGVlZCA9IDEgLyB0aGlzLnJlbmRlclJlZnJlc2hSYXRlO1xuICAgIHRoaXMuYW5pbWF0aW9uRWFzaW5nRnVuY3Rpb24gPSBcImVhc2VJbk91dFF1aW50XCI7XG4gICAgdGhpcy5lYXNpbmdUaW1lID0gMDtcbiAgICB0aGlzLnNvdXJjZVNjYWxlID0gMDtcbiAgICB0aGlzLnRhcmdldFNjYWxlID0gMDtcbiAgICB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uID0gMDtcbiAgICB0aGlzLnRhcmdldFRyYW5zbGF0aW9uID0gMDtcbiAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImZpdFwiLCBiaW5kJDYoX2NvbnRleHQgPSB0aGlzLmZpdCkuY2FsbChfY29udGV4dCwgdGhpcykpO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiYW5pbWF0aW9uRmluaXNoZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RvcFJlbmRlcmluZ1wiKTtcbiAgICB9KTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInVubG9ja05vZGVcIiwgYmluZCQ2KF9jb250ZXh0MiA9IHRoaXMucmVsZWFzZU5vZGUpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVmlldywgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB6b29tcyBvdXQgdG8gZml0IGFsbCBkYXRhIG9uIHNjcmVlbiBiYXNlZCBvbiBhbW91bnQgb2Ygbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17e25vZGVzPUFycmF5fX1dXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0aWFsWm9vbT1mYWxzZV0gIHwgem9vbSBiYXNlZCBvbiBmaXR0ZWQgZm9ybXVsYSBvciByYW5nZSwgdHJ1ZSA9IGZpdHRlZCwgZGVmYXVsdCA9IGZhbHNlO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpdChvcHRpb25zKSB7XG4gICAgICB2YXIgaW5pdGlhbFpvb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgb3B0aW9ucyA9IG5vcm1hbGl6ZUZpdE9wdGlvbnMob3B0aW9ucywgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKTtcbiAgICAgIHZhciBjYW52YXNXaWR0aCA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIHZhciBjYW52YXNIZWlnaHQgPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgdmFyIHJhbmdlO1xuICAgICAgdmFyIHpvb21MZXZlbDtcblxuICAgICAgaWYgKGNhbnZhc1dpZHRoID09PSAwIHx8IGNhbnZhc0hlaWdodCA9PT0gMCkge1xuICAgICAgICAvLyBUaGVyZSdzIG5vIHBvaW50IGluIHRyeWluZyB0byBmaXQgaW50byB6ZXJvIHNpemVkIGNhbnZhcy4gVGhpcyBjb3VsZFxuICAgICAgICAvLyBwb3RlbnRpYWxseSBldmVuIHJlc3VsdCBpbiBpbnZhbGlkIHZhbHVlcyBiZWluZyBjb21wdXRlZC4gRm9yIGV4YW1wbGVcbiAgICAgICAgLy8gZm9yIG5ldHdvcmsgd2l0aG91dCBub2RlcyBhbmQgemVybyBzaXplZCBjYW52YXMgdGhlIHpvb20gbGV2ZWwgd291bGRcbiAgICAgICAgLy8gZW5kIHVwIGJlaW5nIGNvbXB1dGVkIGFzIDAvMCB3aGljaCByZXN1bHRzIGluIE5hTi4gSW4gYW55IG90aGVyIGNhc2VcbiAgICAgICAgLy8gdGhpcyB3b3VsZCBiZSAwL3NvbWV0aGluZyB3aGljaCBpcyBhZ2FpbiBwb2ludGxlc3MgdG8gY29tcHV0ZS5cbiAgICAgICAgem9vbUxldmVsID0gMTtcbiAgICAgICAgcmFuZ2UgPSBOZXR3b3JrVXRpbC5nZXRSYW5nZSh0aGlzLmJvZHkubm9kZXMsIG9wdGlvbnMubm9kZXMpO1xuICAgICAgfSBlbHNlIGlmIChpbml0aWFsWm9vbSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBjaGVjayBpZiBtb3JlIHRoYW4gaGFsZiBvZiB0aGUgbm9kZXMgaGF2ZSBhIHByZWRlZmluZWQgcG9zaXRpb24uIElmIHNvLCB3ZSB1c2UgdGhlIHJhbmdlLCBub3QgdGhlIGFwcHJveGltYXRpb24uXG4gICAgICAgIHZhciBwb3NpdGlvbkRlZmluZWQgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcblxuICAgICAgICAgICAgaWYgKG5vZGUucHJlZGVmaW5lZFBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uRGVmaW5lZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbkRlZmluZWQgPiAwLjUgKiB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5maXQob3B0aW9ucywgZmFsc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJhbmdlID0gTmV0d29ya1V0aWwuZ2V0UmFuZ2UodGhpcy5ib2R5Lm5vZGVzLCBvcHRpb25zLm5vZGVzKTtcbiAgICAgICAgdmFyIG51bWJlck9mTm9kZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgICB6b29tTGV2ZWwgPSAxMi42NjIgLyAobnVtYmVyT2ZOb2RlcyArIDcuNDE0NykgKyAwLjA5NjQ4MjI7IC8vIHRoaXMgaXMgb2J0YWluZWQgZnJvbSBmaXR0aW5nIGEgZGF0YXNldCBmcm9tIDUgcG9pbnRzIHdpdGggc2NhbGUgbGV2ZWxzIHRoYXQgbG9va2VkIGdvb2QuXG4gICAgICAgIC8vIGNvcnJlY3QgZm9yIGxhcmdlciBjYW52YXNzZXMuXG5cbiAgICAgICAgdmFyIGZhY3RvciA9IE1hdGgubWluKGNhbnZhc1dpZHRoIC8gNjAwLCBjYW52YXNIZWlnaHQgLyA2MDApO1xuICAgICAgICB6b29tTGV2ZWwgKj0gZmFjdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNpemVOb2Rlc1wiKTtcbiAgICAgICAgcmFuZ2UgPSBOZXR3b3JrVXRpbC5nZXRSYW5nZSh0aGlzLmJvZHkubm9kZXMsIG9wdGlvbnMubm9kZXMpO1xuICAgICAgICB2YXIgeERpc3RhbmNlID0gTWF0aC5hYnMocmFuZ2UubWF4WCAtIHJhbmdlLm1pblgpICogMS4xO1xuICAgICAgICB2YXIgeURpc3RhbmNlID0gTWF0aC5hYnMocmFuZ2UubWF4WSAtIHJhbmdlLm1pblkpICogMS4xO1xuICAgICAgICB2YXIgeFpvb21MZXZlbCA9IGNhbnZhc1dpZHRoIC8geERpc3RhbmNlO1xuICAgICAgICB2YXIgeVpvb21MZXZlbCA9IGNhbnZhc0hlaWdodCAvIHlEaXN0YW5jZTtcbiAgICAgICAgem9vbUxldmVsID0geFpvb21MZXZlbCA8PSB5Wm9vbUxldmVsID8geFpvb21MZXZlbCA6IHlab29tTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh6b29tTGV2ZWwgPiBvcHRpb25zLm1heFpvb21MZXZlbCkge1xuICAgICAgICB6b29tTGV2ZWwgPSBvcHRpb25zLm1heFpvb21MZXZlbDtcbiAgICAgIH0gZWxzZSBpZiAoem9vbUxldmVsIDwgb3B0aW9ucy5taW5ab29tTGV2ZWwpIHtcbiAgICAgICAgem9vbUxldmVsID0gb3B0aW9ucy5taW5ab29tTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjZW50ZXIgPSBOZXR3b3JrVXRpbC5maW5kQ2VudGVyKHJhbmdlKTtcbiAgICAgIHZhciBhbmltYXRpb25PcHRpb25zID0ge1xuICAgICAgICBwb3NpdGlvbjogY2VudGVyLFxuICAgICAgICBzY2FsZTogem9vbUxldmVsLFxuICAgICAgICBhbmltYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAgICB9O1xuICAgICAgdGhpcy5tb3ZlVG8oYW5pbWF0aW9uT3B0aW9ucyk7XG4gICAgfSAvLyBhbmltYXRpb25cblxuICAgIC8qKlxuICAgICAqIENlbnRlciBhIG5vZGUgaW4gdmlldy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBub2RlSWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnNdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmb2N1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb2N1cyhub2RlSWQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS54LFxuICAgICAgICAgIHk6IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnlcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy5wb3NpdGlvbiA9IG5vZGVQb3NpdGlvbjtcbiAgICAgICAgb3B0aW9ucy5sb2NrZWRPbk5vZGUgPSBub2RlSWQ7XG4gICAgICAgIHRoaXMubW92ZVRvKG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vZGU6IFwiICsgbm9kZUlkICsgXCIgY2Fubm90IGJlIGZvdW5kLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgfCAgb3B0aW9ucy5vZmZzZXQgICA9IHt4Om51bWJlciwgeTpudW1iZXJ9ICAgLy8gb2Zmc2V0IGZyb20gdGhlIGNlbnRlciBpbiBET00gcGl4ZWxzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMuc2NhbGUgICAgPSBudW1iZXIgICAgICAgICAgICAgICAgIC8vIHNjYWxlIHRvIG1vdmUgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5wb3NpdGlvbiA9IHt4Om51bWJlciwgeTpudW1iZXJ9ICAgLy8gcG9zaXRpb24gdG8gbW92ZSB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLmFuaW1hdGlvbiA9IHtkdXJhdGlvbjpudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOlN0cmluZ30gfHwgQm9vbGVhbiAgIC8vIHBvc2l0aW9uIHRvIG1vdmUgdG9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlVG8ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0LnggIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvZXJjZSBhbmQgdmVyaWZ5IHRoYXQgeCBpcyB2YWxpZC5cbiAgICAgICAgICBvcHRpb25zLm9mZnNldC54ID0gK29wdGlvbnMub2Zmc2V0Lng7XG5cbiAgICAgICAgICBpZiAoIV9pc0Zpbml0ZShvcHRpb25zLm9mZnNldC54KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcIm9mZnNldC54XCIgaGFzIHRvIGJlIGEgZmluaXRlIG51bWJlci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5vZmZzZXQueCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5vZmZzZXQueSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29lcmNlIGFuZCB2ZXJpZnkgdGhhdCB5IGlzIHZhbGlkLlxuICAgICAgICAgIG9wdGlvbnMub2Zmc2V0LnkgPSArb3B0aW9ucy5vZmZzZXQueTtcblxuICAgICAgICAgIGlmICghX2lzRmluaXRlKG9wdGlvbnMub2Zmc2V0LnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgb3B0aW9uIFwib2Zmc2V0LnlcIiBoYXMgdG8gYmUgYSBmaW5pdGUgbnVtYmVyLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLm9mZnNldC54ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5vZmZzZXQgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24ueCAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29lcmNlIGFuZCB2ZXJpZnkgdGhhdCB4IGlzIHZhbGlkLlxuICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24ueCA9ICtvcHRpb25zLnBvc2l0aW9uLng7XG5cbiAgICAgICAgICBpZiAoIV9pc0Zpbml0ZShvcHRpb25zLnBvc2l0aW9uLngpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgb3B0aW9uIFwicG9zaXRpb24ueFwiIGhhcyB0byBiZSBhIGZpbml0ZSBudW1iZXIuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24ueCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbi55ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb2VyY2UgYW5kIHZlcmlmeSB0aGF0IHkgaXMgdmFsaWQuXG4gICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbi55ID0gK29wdGlvbnMucG9zaXRpb24ueTtcblxuICAgICAgICAgIGlmICghX2lzRmluaXRlKG9wdGlvbnMucG9zaXRpb24ueSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBvcHRpb24gXCJwb3NpdGlvbi55XCIgaGFzIHRvIGJlIGEgZmluaXRlIG51bWJlci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbi54ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5wb3NpdGlvbiA9IHRoaXMuZ2V0Vmlld1Bvc2l0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ29lcmNlIGFuZCB2ZXJpZnkgdGhhdCB0aGUgc2NhbGUgaXMgdmFsaWQuXG4gICAgICAgIG9wdGlvbnMuc2NhbGUgPSArb3B0aW9ucy5zY2FsZTtcblxuICAgICAgICBpZiAoIShvcHRpb25zLnNjYWxlID4gMCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgb3B0aW9uIFwic2NhbGVcIiBoYXMgdG8gYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIHplcm8uJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB7XG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uID09PSBmYWxzZSkge1xuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHtcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gPSAxMDAwO1xuICAgICAgfSAvLyBkZWZhdWx0IGR1cmF0aW9uXG5cblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb24gPSBcImVhc2VJbk91dFF1YWRcIjtcbiAgICAgIH0gLy8gZGVmYXVsdCBlYXNpbmcgZnVuY3Rpb25cblxuXG4gICAgICB0aGlzLmFuaW1hdGVWaWV3KG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICB8ICBvcHRpb25zLm9mZnNldCAgID0ge3g6bnVtYmVyLCB5Om51bWJlcn0gICAvLyBvZmZzZXQgZnJvbSB0aGUgY2VudGVyIGluIERPTSBwaXhlbHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy50aW1lICAgICA9IG51bWJlciAgICAgICAgICAgICAgICAgLy8gYW5pbWF0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMuc2NhbGUgICAgPSBudW1iZXIgICAgICAgICAgICAgICAgIC8vIHNjYWxlIHRvIGFuaW1hdGUgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5wb3NpdGlvbiA9IHt4Om51bWJlciwgeTpudW1iZXJ9ICAgLy8gcG9zaXRpb24gdG8gYW5pbWF0ZSB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLmVhc2luZ0Z1bmN0aW9uID0gU3RyaW5nICAgICAgICAgICAvLyBsaW5lYXIsIGVhc2VJblF1YWQsIGVhc2VPdXRRdWFkLCBlYXNlSW5PdXRRdWFkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXNlSW5DdWJpYywgZWFzZU91dEN1YmljLCBlYXNlSW5PdXRDdWJpYyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFzZUluUXVhcnQsIGVhc2VPdXRRdWFydCwgZWFzZUluT3V0UXVhcnQsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhc2VJblF1aW50LCBlYXNlT3V0UXVpbnQsIGVhc2VJbk91dFF1aW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlVmlld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlVmlldyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uOyAvLyByZWxlYXNlIGlmIHNvbWV0aGluZyBmb2N1c3NlZCBvbiB0aGUgbm9kZVxuXG4gICAgICB0aGlzLnJlbGVhc2VOb2RlKCk7XG5cbiAgICAgIGlmIChvcHRpb25zLmxvY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gb3B0aW9ucy5sb2NrZWRPbk5vZGU7XG4gICAgICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XG4gICAgICB9IC8vIGZvcmNlZnVsbHkgY29tcGxldGUgdGhlIG9sZCBhbmltYXRpb24gaWYgaXQgd2FzIHN0aWxsIHJ1bm5pbmdcblxuXG4gICAgICBpZiAodGhpcy5lYXNpbmdUaW1lICE9IDApIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvblJlZHJhdyh0cnVlKTsgLy8gYnkgc2V0dGluZyBlYXNpbmd0aW1lIHRvIDEsIHdlIGZpbmlzaCB0aGUgYW5pbWF0aW9uLlxuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc291cmNlU2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIHRoaXMuc291cmNlVHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgIHRoaXMudGFyZ2V0U2NhbGUgPSBvcHRpb25zLnNjYWxlOyAvLyBzZXQgdGhlIHNjYWxlIHNvIHRoZSB2aWV3Q2VudGVyIGlzIGJhc2VkIG9uIHRoZSBjb3JyZWN0IHpvb20gbGV2ZWwuIFRoaXMgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgdHJhbnNpdGlvblJlZHJhd1xuICAgICAgLy8gYnV0IGF0IGxlYXN0IHRoZW4gd2UnbGwgaGF2ZSB0aGUgdGFyZ2V0IHRyYW5zaXRpb25cblxuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSB0aGlzLnRhcmdldFNjYWxlO1xuICAgICAgdmFyIHZpZXdDZW50ZXIgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCxcbiAgICAgICAgeTogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgfSk7XG4gICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyID0ge1xuICAgICAgICAvLyBvZmZzZXQgZnJvbSB2aWV3LCBkaXN0YW5jZSB2aWV3IGhhcyB0byBjaGFuZ2UgYnkgdGhlc2UgeCBhbmQgeSB0byBjZW50ZXIgdGhlIG5vZGVcbiAgICAgICAgeDogdmlld0NlbnRlci54IC0gb3B0aW9ucy5wb3NpdGlvbi54LFxuICAgICAgICB5OiB2aWV3Q2VudGVyLnkgLSBvcHRpb25zLnBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgICB0aGlzLnRhcmdldFRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnggKyBkaXN0YW5jZUZyb21DZW50ZXIueCAqIHRoaXMudGFyZ2V0U2NhbGUgKyBvcHRpb25zLm9mZnNldC54LFxuICAgICAgICB5OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkgKyBkaXN0YW5jZUZyb21DZW50ZXIueSAqIHRoaXMudGFyZ2V0U2NhbGUgKyBvcHRpb25zLm9mZnNldC55XG4gICAgICB9OyAvLyBpZiB0aGUgdGltZSBpcyBzZXQgdG8gMCwgZG9uJ3QgZG8gYW4gYW5pbWF0aW9uXG5cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbi5kdXJhdGlvbiA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5sb2NrZWRPbk5vZGVJZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQzO1xuXG4gICAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSBiaW5kJDYoX2NvbnRleHQzID0gdGhpcy5fbG9ja2VkUmVkcmF3KS5jYWxsKF9jb250ZXh0MywgdGhpcyk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHRoaXMudGFyZ2V0U2NhbGU7XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB0aGlzLnRhcmdldFRyYW5zbGF0aW9uO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NDtcblxuICAgICAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gMSAvICg2MCAqIG9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uICogMC4wMDEpIHx8IDEgLyA2MDsgLy8gNjAgZm9yIDYwIHNlY29uZHMsIDAuMDAxIGZvciBtaWxsaSdzXG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uO1xuICAgICAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IGJpbmQkNihfY29udGV4dDQgPSB0aGlzLl90cmFuc2l0aW9uUmVkcmF3KS5jYWxsKF9jb250ZXh0NCwgdGhpcyk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RhcnRSZW5kZXJpbmdcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVzZWQgdG8gYW5pbWF0ZSBzbW9vdGhseSBieSBoaWphY2tpbmcgdGhlIHJlZHJhdyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbG9ja2VkUmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2NrZWRSZWRyYXcoKSB7XG4gICAgICB2YXIgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiB0aGlzLmJvZHkubm9kZXNbdGhpcy5sb2NrZWRPbk5vZGVJZF0ueCxcbiAgICAgICAgeTogdGhpcy5ib2R5Lm5vZGVzW3RoaXMubG9ja2VkT25Ob2RlSWRdLnlcbiAgICAgIH07XG4gICAgICB2YXIgdmlld0NlbnRlciA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHtcbiAgICAgICAgeDogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLFxuICAgICAgICB5OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIHZhciBkaXN0YW5jZUZyb21DZW50ZXIgPSB7XG4gICAgICAgIC8vIG9mZnNldCBmcm9tIHZpZXcsIGRpc3RhbmNlIHZpZXcgaGFzIHRvIGNoYW5nZSBieSB0aGVzZSB4IGFuZCB5IHRvIGNlbnRlciB0aGUgbm9kZVxuICAgICAgICB4OiB2aWV3Q2VudGVyLnggLSBub2RlUG9zaXRpb24ueCxcbiAgICAgICAgeTogdmlld0NlbnRlci55IC0gbm9kZVBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgICB2YXIgc291cmNlVHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgIHZhciB0YXJnZXRUcmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogc291cmNlVHJhbnNsYXRpb24ueCArIGRpc3RhbmNlRnJvbUNlbnRlci54ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldC54LFxuICAgICAgICB5OiBzb3VyY2VUcmFuc2xhdGlvbi55ICsgZGlzdGFuY2VGcm9tQ2VudGVyLnkgKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0LnlcbiAgICAgIH07XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHRhcmdldFRyYW5zbGF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgc3RhdGUgb2YgYSBsb2NrZWQgb24gTm9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVsZWFzZU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZU5vZGUoKSB7XG4gICAgICBpZiAodGhpcy5sb2NrZWRPbk5vZGVJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmlld0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIHRoaXMubG9ja2VkT25Ob2RlSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmaW5pc2hlZD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyYW5zaXRpb25SZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zaXRpb25SZWRyYXcoKSB7XG4gICAgICB2YXIgZmluaXNoZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICAgdGhpcy5lYXNpbmdUaW1lICs9IHRoaXMuYW5pbWF0aW9uU3BlZWQ7XG4gICAgICB0aGlzLmVhc2luZ1RpbWUgPSBmaW5pc2hlZCA9PT0gdHJ1ZSA/IDEuMCA6IHRoaXMuZWFzaW5nVGltZTtcbiAgICAgIHZhciBwcm9ncmVzcyA9IGVhc2luZ0Z1bmN0aW9uc1t0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uXSh0aGlzLmVhc2luZ1RpbWUpO1xuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSB0aGlzLnNvdXJjZVNjYWxlICsgKHRoaXMudGFyZ2V0U2NhbGUgLSB0aGlzLnNvdXJjZVNjYWxlKSAqIHByb2dyZXNzO1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueCArICh0aGlzLnRhcmdldFRyYW5zbGF0aW9uLnggLSB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLngpICogcHJvZ3Jlc3MsXG4gICAgICAgIHk6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueSArICh0aGlzLnRhcmdldFRyYW5zbGF0aW9uLnkgLSB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkpICogcHJvZ3Jlc3NcbiAgICAgIH07IC8vIGNsZWFudXBcblxuICAgICAgaWYgKHRoaXMuZWFzaW5nVGltZSA+PSAxLjApIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIHRoaXMuZWFzaW5nVGltZSA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMubG9ja2VkT25Ob2RlSWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0NTtcblxuICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gYmluZCQ2KF9jb250ZXh0NSA9IHRoaXMuX2xvY2tlZFJlZHJhdykuY2FsbChfY29udGV4dDUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYW5pbWF0aW9uRmluaXNoZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjYWxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Vmlld1Bvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdQb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCxcbiAgICAgICAgeTogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpZXc7XG59KCk7XG5cbnZhciBjc3NfMjQ4eiQxID0gXCJkaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1uYXZpZ2F0aW9uIGRpdi52aXMtYnV0dG9uIHtcXG4gIHdpZHRoOiAzNHB4O1xcbiAgaGVpZ2h0OiAzNHB4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAxN3B4O1xcbiAgYm9yZGVyLXJhZGl1czogMTdweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IDJweCAycHg7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbmF2aWdhdGlvbiBkaXYudmlzLWJ1dHRvbjpob3ZlciB7XFxuICBib3gtc2hhZG93OiAwIDAgM3B4IDNweCByZ2JhKDU2LCAyMDcsIDIxLCAwLjMpO1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1uYXZpZ2F0aW9uIGRpdi52aXMtYnV0dG9uOmFjdGl2ZSB7XFxuICBib3gtc2hhZG93OiAwIDAgMXB4IDNweCByZ2JhKDU2LCAyMDcsIDIxLCAwLjk1KTtcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbmF2aWdhdGlvbiBkaXYudmlzLWJ1dHRvbi52aXMtdXAge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUI0QUFBQWVDQVlBQUFBN01LNmlBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBQUFnWTBoU1RRQUFlaVVBQUlDREFBRDUvd0FBZ09rQUFIVXdBQURxWUFBQU9wZ0FBQmR2a2wvRlJnQUFCcGhKUkVGVWVOcWNWMnR3VTljUi9uYlBsVlRIeHBLUmJObkJMeUViUHlKaXNMRWNQd2d3VU1LUXRqTkpBek5KWmtnTk5KT21KYVpBYURLbHhhWERUSUJBY0p0T096U1lLU2tkaWltaEFkSU1qeVQ0YllnQll4QTJCZ2NVUVBMckNpR0RSNHF0MngreVhUQVNGdDEvOTU3ZDd6dDN6M2QzOXhEQ01RV1VmZ0F6L1JJL1Q0cFNUQUpwQUdMOHJFQ0FYWDdRRlFHcTl3T0hPeFlPMW9DZ2pBZEpqMXd0QjA5NUdpdjlURnVaQUlXSEF6aUFUTVBoVEF3aUhnVWtZUFhGSnU5MmxNUC8yTVRwQjFBS1VDVkVnTkFjbGVVbzFNKzJGOFRPNmNyU1RuY2IxUWxlQU9qMk9UU1gzR2UxcCtWYTQybTVKcm56Ym5zQ0U4T3YrRUhncGEwTFBMdkNKalovd2h1SWxOOHdBY1hHK2UxTFVuOWhtMjM4UVU4NHAxTGQ4M25zWHZ1TzdMcStMektZR0FUNi9kbjU4bS9ISlRZZjRPM0VTaGtUOElycHphYjFVejlzR2V2VDUrdFduK2o2TkI0QTVocC81TlNyNDN4amZkNXJXNXRUOWUzT0FoQ0JpQ3VhNS9Xc0RFbHMvaGR2WWtsWlN3RGVmbXJUOGVYbXR6dURrYjVZWjMzcDluZHlsSUNBVmpXeGYzOXh3LzVnNUx1di85SDg0WldOY3dORXlwWlQ4N3JYanF5SkI4NVVZRE1KWU4zVTdVZExKNi82SmxncVY1MTd0ZVJxZjl1VGx1ZzhlMXpFazI3SGdEMjJvOThXc1RCaDhmV3h2am02QXBkT05iR3ZzZThMTTVOVVBPbTFDZmFidXozbkFDQWd4WDBRRUZUSkFuak52TEorU2VwYjE0S1JIbk4rRXYrMVhKT2haczNRdTFtYkc5N0oyTlFnc1hyb2ExZHR4ckd1ZjhjSGkxbVV0UFRheTBsdjFETUpTQ1JWTHRvWCtGZ0dnRFFOeXNCQWNlejg5bDluYmJzUVNqaTdybFhrRWhqUHhiL1FhdEhPY0Z1ME05eno0MTlvRlNSaGovM1B1YUhpeXFhc3YxQ29uOU5HeEhBWVVzb0N4QXFJbWJZU2dDV21GYlpRd2RzdXI3TjBlQzRtNnRUNi9qVVo3NTBaZWI4MmMrT1pHTFdoLzJwL1crS2ZybXkwaElwL2FWS3BUU0lKRXF1MlFnRngyaUU4Q3dEcDBSYkg3TGpuZy80eVhyK1hUM1FkeWhZc29kUzBzbEdyMGcyT3JFVUs3ZUNyS1c4MlNxekNWejMveWZiNnZSd000eG45ck43SmtSa09RUkxtZkpuMkxCUHhRakRCcXA5bEQ3WGJYN1g4cEtUUDE2MHpSMmJkZWlYNWpZZVUvbkxTVHp0TmtlbTNYTDVlWGJsdFJVa29uQnhkZ1oySUlVbWFoVXhFUlFTQ1ZUK3JLNWh6UTg5eFE2UDhWYWFLMWY1Vm1SdnFRNEcrbGJhK25sbmxiNWJyTWh2bGs3RkJpYVB6dXdRRW1FUWhnNUJPeE1qV1RuY0hjMjUwMWNRTGtqRFRzTUNXcHl1UlF4RlAweFhJSmZwNUZ5Vlc0Wnk3S2FqQzA2SXRiaUlHZzZaSVRCeER4SWdicnIxalRTTTBmaWJHSUh6OE85c0tLMEdBaWJFdWE5c3BBTmg0YVkyVm1jRWcrREVraUJnUi9MMmhZRmdHdGNFcmtRUUFNVkpnQnh5eTloYm9aenYzMnYrS3ByN3FiRUVDVEFJTUFvYUphM3FQVG1OaWlBQWdKQWprNko1eGh1NkhEQUlnUVlHTG1JMjlQb2NtTWNJOE1OWXZUMWNrZnpEOUgvdWI1YnI0ZTRNZTlXZk9LcXR5WDZVZDJjd0M0NDlQUmFtaWZEbTZBdWMwclRYb2tjaStYbzFFQWdCY2tpRHVZR0xqcFR2bnRjR0lBK1NGY3A2dVVBYUFJODc5VmhXclJ0ZVlBcW4vZWRxNzU4YnJYSjEzMjdRTWhnSmNaakEzRUJqTnJnWmpPRzFQa0FqeVRHRU5NalpQcTVFQ1EwTURFOUVSQnFGWnJrME9KM2k0eC83dnlJakJ4R0VSdDN0YWtnVkpFQXA5eHEzZjc2OVdpUEROdlNzSmRUM0hET0VBU1BlbG1vQlJZVDNLenQ1dU10d2F1SkVnU09DcHdyazFESUpDb05VTXdqOXY3TXdlUDlYU1E4L2hKUHA0OTZmWlRBSUN2THFjeXYyQjduUmJyZ0NBMDNKTjVoOHViN0E4VnFwQjQzN3hIdnNPeTNsM2N5YUI0TDJ1cXhodGkxV0xNY1NnWlFDdzcrYk9vb08zUGs0SkJaSVlZWElTTVY1c0tINTlVZVBNMTBHRVNSR3BJZi9iRTkySFU0NTJIeXdTSklHSWxsY3RyaHA2WUFLNStmSGRzMGxMdEpGTVhOd2tWNmZGcUEyOW1ST2VmcWlNSmoxaDZ1bTRhNXZZLzkyZEtHYUJ4SWhVNXpKVFdXMmNKbUVnR09tZWIzYzhGeEFmYjltZGYyUnp5R0d2NU12VTdRd3VFeVN3S0hGcC9jL003MXpBLzJGN2IxUmFqbllkTEFxTXVrTVZ1MlljZm1EWUUyTUQ3SCs3L1hscTZjUklKcW00elhNK3FkM1RHalZCaXI0M0tTTGxYamlFTGU1VHNYKzMveVcvU1Q0NVBhQUhiS21jY1doMTJBUDkzSk5aeXdqMGtTQUJJb2JwaVhSSGp0WjZmYW91dDJ0eVpNYWRHTFhCQ3hCY3ZsNk5mYUF6K3RLZEZtT2JweldsMit0SUlCQUNZeTB0L3lqMzRNN0h2c0tVSytDR2Fzc3ZpY1g3YWxZRHd3cSt2eWtJRXFQVmErUTlnZFlrNStWK1VFN2xqMytGR2J1Qk0vWDVKVVQ4UXdJVlNTU1ppVGdtb0ZSMk1maXFZRkZQZmpwa3lyZldQb3B3eFA0N0FQMXBLMWc5L2RxZUFBQUFBRWxGVGtTdVFtQ0MnKTtcXG4gIGJvdHRvbTogNTBweDtcXG4gIGxlZnQ6IDU1cHg7XFxufVxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW5hdmlnYXRpb24gZGl2LnZpcy1idXR0b24udmlzLWRvd24ge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUI0QUFBQWVDQVlBQUFBN01LNmlBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBQUFnWTBoU1RRQUFlaVVBQUlDREFBRDUvd0FBZ09rQUFIVXdBQURxWUFBQU9wZ0FBQmR2a2wvRlJnQUFCcGRKUkVGVWVOcWNWMjFRbE5jVmZwNXpYOWlrb0F2TEVzQUlJZ3NvSHdwcVdBUVVOS0xOYU52OGlaMUpNa05HNi9Rai9kRFV5Q1NUdENIcG1Fa3dWazNUVG9aUk1qWGo1TU9HMktpZGpJa3hRWVNBUVVBdFg2SWdJTjhzdThLQ29PemJINHNrNHE1Zzc3LzMzdWVlNTU1ejdybm5lWW1aREIyTUtjSktseVlicU9zWlZJZ0dFT2dTSFFveTRBS2JGRmpxQW81ZFduL3JOQWg5T3BPODUyb2VKSFl4dHJtRXU0V0FMaE1ieEcyWkU5dUZBbEltRFJMWS90L3kwYjNJZyt1K2lXT0tzQWxnSVpTYjBPSWYxNWtXdEtvMU5YaDFkNXh4aVNQRU4yd1VBSHJHT2cxMWppcmpXVnRKeUZuYjZZZ3J6b1l3b2NDbHUwREk1Z3VQRGI0M1kyTExwL0lhcWY5SkNHU0VyR3ZJaWZ4ZDdhcVFuL1RPSkN2RnZaOEhmOWhhRUgrbS82c0ZRZ0hCdjFTdHMvMTVXbUpMa2V5bDZGdUZ3RlB6bnkxL1pkRTdOZmcveGh2MXVVbUgydzZrZ2dRcCt5cXplN2Q1SmJaOEltK0twdWNTd0k2RU43L2NZdGx4WmFyQkN0czNwdGZydHE5b2RqYUdLaWhFK3NWMHZSQzN1OFJxV21tYmlqMTQ5VytXZDVwMnJuRVQ2YnNxc250eWI2K3BPM0txa0U4RnZMeG83NGxOVVg5czl1VEpiOC85ZkcyTDgxS29vZ0pGWWZDbTNiOXVzTnEwTVh4encxUnNVa0RxUUlDUHFmL2IvcThzUWkzajRXZG10VjQ3T0ZnTkFPNnIrREVVRkF0RkFjOVl0cFhtUlA2aHhWc0kyNGN2aHlvcW5GdHJLNmpNN2lzZ0JhM0RsME85NFRlR2IyNTVNdnpYcFVJRmpWcmh4by9kemdvQVJCdXdGUUprQks5cmVDbnVyeGZ2WFg4Q1JXM3lXMUc3NDl2VDJCcjd5c1cwb05YMXBLRFRQRytybTFnSFJiaWJBSExtLzc1MjJzS25RQ1pxRmdDVWFCQ3FhUy9iRXc5dnF0V29RUk9mM2RCQmlUNktUQUNJbVozWXVlcWhEZE9XakRiRlE0SXpJbDRlbE5VWDViZWdVMUhENmxQUm1VTEtlZ2hoRGNwcW5VbVp1RDMrbmtnVEg2Z1pFRTljdGxaU29HbUc5VUl5blNDc1FWbmRNeVgrSVpHaUJvSE1qSGgyU3JlQ2dsQ2xhU0JpU0VHOGNZbkQyNGJ2N0NXbXMvM0ZvY08zaG53MTNwbFRnZ0FGYjE5Nk5kbFBNNDR0QzB6clNnNUl0WG15RXowNzBVRUtDTVJxUWdra0JROU52TDJlU0orcmV2b0pUT1JTcG9UNmRvNC83LzdVU2hCRkhRZXhNK0hkZnlVSFdPOGlOL3VhUnpYMy9RalVTTGxucU03MkY0Y0NSSVk1dTlaZitZK0JBdjRBdnpwa1E3V0FJQlJ1akEvN1ZnNmNpYTl4bElkNkluYWZWRUFBR25RTVVDU2tiNnpUTVBkQnk4aFUzSmpycGhJcStDckQrTXZ4ZXl1bXJyKzRJSDl5N28yR0Y1ZURnaHV1R3g0TDJ6YldaOURjMFJvUVJia2tGTlJkUDIvMEJIN0V0TEpMS0Nqcit6cWgybDV1OGhhWjg0N3ZUQlcyNGtSRlFYS0F0Y3NUNW9xejNpZ1FFTklvRUNrakJKVURaU0dld0JsQmovYW1takxyZFgxYy90NzBlcm8zNGdNdGU5SUJ5TExBalByVXdLd2VUNWphd1FzaGRJdUdNaUY1WEVCVTJrb2l2Qmw5TmVFZkplWUh3dXh0STgxelBybjJ6NmlwNjBjNkRrVjFqTFRPQ1RhRTJITmpkNVo0czlNd1dCT2hxRUhwL0k5Y1dEdFVySk5vSG00S085UDdoZG5UQm9NWVhJOEdiNmdWQ2c2M0ZTNTNqZzlPNXRBNTd0U09kSHl3bkNBeWdySnJmY1RnVWU1VTJjdk5IU1B0WVlvS0NXbHJUZ3NJbmVCMkFmRlIrNEY0YjZmOVpkVHpGNlA4WXR1ZDQwNy9keS9uTDdrOVg5aThKOWw1eStFZjZSZmJualB2V2E4TjVzdWV6K0tGQ2dxeVBZOTVMbmQzc3R2MkFjQloyK21GYnplK2x1aTF4YzNkWENVVWxQYWZYTng0L2FLeGNhaldXTnAvTWtsUnc4L21QRm50YmQraDFvTEU4NDdLaFFReGVqVmczNlFRcUQwTVBUekh2NDJVeCt1R2FzSk5CblBmd2xsSmQ3MWtrWDdSUTNXRE5mN2RveDNCTGNOTnM2dnQzNGJiYnZZSEpobFRHcDZPK0pWSGIwLzJISnRYMVBIK2FxRUNxRy81WU4xbmxYY29rR3Z2TzZ2Q2M0eCtRc2tvdHhWSEIvcWEreGJPV3V6dzhOQjNudW8rSHQwejJoSHN1R1UzR3JXQW9aZmkzanJ4Z0hwdzNCUHBvYmFDSDd2YnFPdzZtSEk4MzZ2WVczRXFjcTlBdGlvcWJKeTd1ZlEzbGhmdThzUitzOSszdkw4a2xBQ3NRU3U3QW54TVkxTXhIN1lYSnA3b1BwTHVscnJqKzk1NzVOaTJhZVZ0MXRlV2ZFV2ZIUUxDYXNwc2VIek9VN1ZXVSthTTVHMk5veUw0aSs2ajhYV0ROUXNtR3NLdS9jdituVHRqUWIvbW03aGZFTnl2cUVBSzV2OG9walBKYUwyNktHQnBkNVRmZ3V1QnZ1WlJnQmdZNnpPMGpseVpYWGU5SnFSKzhNSzhudEhPTUhmSElraHUyYi8weUlINy9vWEoweUZseFluUFVkUmJ2dUlMZ083K3krOTFsNkthNk0rY25DZjRmTVN5cFh2eW1IZi92ekJURDNDdU5HVUZLVDhsbUs1UnM1QVNxS2lCbEFHQlhGYWlTdW5pMGZrcDFwSjdFZDRlL3hzQXFMazQ2RVdzRzFFQUFBQUFTVVZPUks1Q1lJST0nKTtcXG4gIGJvdHRvbTogMTBweDtcXG4gIGxlZnQ6IDU1cHg7XFxufVxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW5hdmlnYXRpb24gZGl2LnZpcy1idXR0b24udmlzLWxlZnQge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUI0QUFBQWVDQVlBQUFBN01LNmlBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBQUFnWTBoU1RRQUFlaVVBQUlDREFBRDUvd0FBZ09rQUFIVXdBQURxWUFBQU9wZ0FBQmR2a2wvRlJnQUFCdDVKUkVGVWVOcXNsMmxVbE9jVngvLzNQaTlEWlJzR0JnWWlTMlJZQlFLSWpBaEVKVzRwTnJYTk1iWnBXdFRHTmt0dFltSk1HNXNvU1pja1JrKzBwK2RZUFlZMEdrMGlobGhSajYzR2hWVWdCaERENW9JT3k4QUFNd3pENGxDWXR4K0dxQ1FLdU55UDcvUGMrM3UyKzcvM0pVekVaRkJZTGg2MlM3eUlaRG1WQkVJQnFPd3NRNEROZHRCRkFTcTJBNGN1WkF3VmdDQ1BGNUxHSE0wQ2h6K0UxWGFtelV5QXpDTU83SWhNSSs1TURDSytIcENBTmQrVTJyWWdDL1k3Qm9mbFlnVkEyUkFPb05ZdHlqRFRlNDUraGs5NmU1UXl3YUpSK05zQXdEaG9jSzYxVkNqTFRZV2FjbE5CME9XK2VuOG1obDIyZzhDL3JuN1UrdUdFd2RvditDMGkrUTBtSUZXem9EN3p3VlUxY3pRLzZwaklyZVIzSFBYNVZMOWphbEhYaVFnbUJvSCtYTEhBdEg1Y3NEYVh0eERMTHpJQnY1anlmT21HMkg5VTRTN3NuYnBYNDNLYVBwZ0JJaER4MXJQek9sYmZQQzVHUVQvbmQxbVMxekFCYTZQZlBmNXk1Ri9yY0plV3BwN2ZQa2x5NmY3S1hCUkNvT1NBVEZmWGxsMTl4NzRIRHN2RkNnaHNKQUc4SHJ2bHZ5dENYbTdFUFZxYzV3eXpwNU5YMTVtdUUxb21LWFh5TW5kOXl5NXI1UTN3UGdodkp6ckxBbGltWFYzOCs3RDFEYmhQRnExTTZPNGI2clBWV0tzQ0JmSGk1RVdXdjlUa1FCWUFFUHBMdkVSTUM5TjhGdFJ2anQ5ZFBsNnd3bzVqUHZ1YXM3V1Y1ak5xRWp6OHdBK0NCc2Fhbit3OXgxaHJyWEp0dWFaWDk3b29MZnFQTENVRUdSUitpT3dBc0YyWDk4VWMzMFczZmIwMnU0MWZyVnFlVm1vNkZVa2t3Q0F3Q1d4SjJMcy8wVFBGTkJiOFROZHA5V3ZuVno0T0FLZG1YMlFPemNNc0FBanppREdNQmQzYXNDRjZTWEh5a25KVGZxUVRLK3pwdmhuVktUNXphd0NnekZUZ045NHBKWHZQN2d4eGpUQUlrcEIrTW5TV1JNUVpZRURuUFZ0L0s0ZWpiWi83NzcyNkxiNmg5NXRBQWlQRUxhSjFiY1RiUmZHZU04eHYxYXpXU2V5RWEwUDlpZ2srTnIxK29ORmZrcHd6SkNKS0lRQTY3OW50TjA4eURYWW8zcWgrTHVVcmMwRTRFY05MNGRQN1ZORHpwVThGUDN2cGVrb1FRNUNFdzRiUGRFZmE5K3NBZ0VaVW1rbUFBQVM1aExROXAxMVhHTytwTThWNUpMVWZNZVFBUkRNbEVNS0lHRk9WQ1pZYjBDN0Z6MG9lWG1JWjZuWnpZb1Y5b2QvalZTK0diYWhVT25uOWI3VDZzRU92aVVHeUE4Yk1EbFVhMFc3OXdCVy9iWmYrbHJZOThjREJVSThZQ3hHRGdIQ0ppVlZFRE44UjdRV0FFOFovKzFtR3V0MmkzZVAxcjBTK1hSenRrZEJ6cTZOYkY3V3BiRjNVcHJLeGp2Zkh4YnJmdHRsYS9RQkFyVkRiSkpJQVFDVVJNUmc4dWdyS0lBS0JTTnh6SHROM1ZkbXhZMGlRWVNabVRlZWd3VGxna25ZQUFCN1JaQmgyTm03dXJiZWVDMXIxOVJPVDUya1duM3NoZkgyRnUxQU8zUnhqWS8wZmRhYzcvaFBQSk1ERTExR0MrSHBCSm1JRXVBUzNPYTZ3MDFseWJNYk1ndmdDRTZPMjU1enkyNERlQ3IvQnZja245K3U4WmpYWUlZdmp4b01KeThvZVhaclQ5R0hJcU1XVHdBMm9JNmNGTWVESWNBaVNFT3lpYlhzbVpHMGhBRnp1cTFPeVk2eEJBbk1KZ2RQT21rczA4elUvYmJzQjl4MThQMzdQcVMvYjgrby9hOTZaY0xtM1BtQkg0Nlo1eDQwSFcxZUZ2bDRVcTB3ME13aUNCT2I3L3FUc2Q2R3ZWWTUzN0RYV2FzMUl3MUFpTkpuT2d3SmkrYlhoQWJFMDhPbnZhWFNJVzBUdll3ODhlYUYvdU0vV05kanUzbTVyOVRsaFBCelZOTkRvUEdDLzV0Um1hL0dKODB4cWpQUFVqVnV2UDJuYXJyTU9XZDFKbHYvRTFmTjc4MlVpTlBaZjlDL3FPS2ErbmRPejJqK2N6MDQ2c24rNktyVk9zT0RpcnBPeGxkMGxVeG1FQksva3R2R2dGZDJsNnRhQlpuOUJBdEV6NXhZSXZBbjQvOHJGS2tnc3RBeVo2WWYrUzY3ZXpsa2lTVTczWFhSVjZ4cWg5M1R5c3NSNEpGNzVlZkJ2eW1MZEUwM2pnVC9XYjV0dXRMV3BHYlRtN3dIWnhRUUFUK3lEdUtMeUhSSWs0Y25BWjRwZkNGOS9IdmZSOXVoM3hCeHR6MDBCQU5zVkR5bG5hYzZ3QUlDYUhNaUJtVzVOUkx5NHRyY3EwTXRaM1JucEhtZTVIOUF2alllQ2MxdDNwek1KZ09TVm55dzRlSFpVQjlLeXU2OGlNRlBweXNTcHBhYjhVSlZDM1JucC9wRGxYcUY3bW5Zc2RLUWJ2N2NyNmZER1cvWmN6YnQ2amdVdFY2a0lsRnh1eWcvdEgrNnpKWG1sR2U4RyttbHpkc3lCMWozcFRBd1o5cTMvU3NwYmM5dG1Ed0QwSDNVZmZYQ0ZseXVUbEZwblBSZFliNjEyYzVjOCtpZFBDdTZmQ0xES1V1YnpzZjZmU2FXbTB3bU85aGJ2WlU4ZkRSMnpvWjk3T3VwcEF1MFVKRURFbU9JU1pvaFQ2cTdHZWs1ckQzR042RkVwMURhQVlCN3NkTllQWFBhbzdhblMxRm1yZzQwMmc3K2pZaEdJYU9YT2FRYyt1T05mbUN3WlhKSWY4eEt4MktSZ3hZZ09TK0NST3V5b3lRS0N4SWhrT3I0VDZKV2d4R252WjFIV25mL0NmSGNCWHhjbnBSSHhZd1JLa1VqU0VyRktrQVFpTmpQNGttQlJUSGJLbTVLa0t4d0wrSzM5ZndEWDFYR0Y4Y3QrK1FBQUFBQkpSVTVFcmtKZ2dnPT0nKTtcXG4gIGJvdHRvbTogMTBweDtcXG4gIGxlZnQ6IDE1cHg7XFxufVxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW5hdmlnYXRpb24gZGl2LnZpcy1idXR0b24udmlzLXJpZ2h0IHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCNEFBQUFlQ0FZQUFBQTdNSzZpQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUFBZ1kwaFNUUUFBZWlVQUFJQ0RBQUQ1L3dBQWdPa0FBSFV3QUFEcVlBQUFPcGdBQUJkdmtsL0ZSZ0FBQnMxSlJFRlVlTnFzbDN0UWxPY1Z4cDl6M20rWHlnSzdDNHNMeGtXNW80Q0FrWXNzRlNrUmphYmpKRU9TSm0xSWJaeDJrcmFwaVpkZXByVzBOVlZKMHBxTU0wa1lKUWxxa29aSW1HaW9FMUl0aUNBZ0lzRndFNEVzOTl2Q3Nsd0NoZjM2eHk1RVcxQTBQbjkrNzNmTzc3MmU5M2tKQzVFTUNzekZkMjBTYnlGWk5wSkFBQUN0aldVSThLQU4xQ1JBSlRiZzlMWE5VK2RCa0crWGttN1ptZzRPV29VZE5xWlhtUUNaSFFGc3oweU9jQ1lHRWM4bUpHRG5sMlVUaDVBTzJ4MkRBM094RGFBc0NEdlEzMlZGMTFxUDlhWll6NlNlRmVvb2kxN3BQUUVBdlpOZFRuV1dLbldGdVZoZllUN3YwenphNE0zRXNNazJFUGduTlp1c2J5OFk3UDh4LzVsSS9nTVRZTlNuTktRdC8wWHRldjFEZlF0WmxhSytNNTRmbURKWFhoZzRHOHpFSU5CZnFsTE1lMjhMOXMvbFE4VHlyNWlBSjMyZksvdGorT0ZxM0lVTzFPK0p5R2s3R2dzaUVQRnJsUS8wN2JpeFhkd0VQY2tIV1pKM01nRzdRdzkrL21MSVMvVzRTeVhvTnZRc2tweUhMZzFlOENOUTNOSTBsYW9qZTdUZy84Q0J1ZGdHZ1F3U3dPL0REMzIyemUvRkZueExSV2hpQnpVSzk0R0xBMmY5bVNUamZVKzdtanF5clZlK0FYOEk0YUdnU2hiQTAvNDdTbjRadUxjUjkwaWg2cWloMGFuUmlWcHJ0VUVRYjQzYll0bFhtd05aQUVEQWovQUNNVzFNOEV4cGVEWHlXTVZDRWw0eUY3dm50Ui96TGVvdjhKSmxXZlpSK1kzTjkyK2N4L3JlT211MXF1TnJrMjdFV1cweHZXc3BKY2lnb05Oa0E0QzNZazU5dkg3eGx0dnUza3REeGU3UFgzNGlsUUNRZmVjaTFqMnhmbjk0WnJHQ25lWTh1eGNIQ25XL3ZicjlFUUQ0ZDJJVGM4QXByQU9BUUxld3JvVkFBYUI4b01pTGlSSHZtVnk3em5OVGpXQ0ZyWEtvSk9TSEZRK2t2bkY5ZitqY28wN3M5MU1GZHdtU2tIUXVZQjBUOFdZd0ljWWowYlRRZFJ1ZkdsRktKTUZWYUNiL0d2Wlc2YUdJNHllWE93ZDJtci91MDV6c3lEWStXNVg2NE5tK2ZPODVOcHVKaUNGSlRwc2xJb29uQURFZWlUMnpJeklYdWgrbzI1UFFOdGJzTlZNT0JVbjJnMDhNaVNUSE4zdVpqTlRFRHI0ZG5YLzZIKzFIL1hQYXNtS3ZXK3NNR2ZXL01YemVuZGU0SzNoL2lidlNZeElBSXR5aWUvSzdjZ0NpdFF4Q0lCRmpwVHJLTWdNK1dQZnJoTGJ4Rmk5aU1RdGxZakFKU0NTQlNZQkFJUEJOSTNwODZUUFhqOGJrNTZSNFBWeWxGRTYyNnVGTFFjOWVmaVRWUERtZ0JJQUF0ekFMRVlOQlFSSVRhNGtZaXgyMUZ3QmF4NjU1Q1ZhZ1BMazc4MDZQajFxby83TXJhRi9GUTE0L2FNaHN6WWh2R3FuM0tUZWY4OXJrbFdyU0tYVVRrbjNtdEpLOUJ6ZjNYSkEwZS9QY3JkZ3hJd1NDRFBtYlpNUWdBQkprREJLenZuK3l5Mm5wSXY5eEFQQjFDZW8yalRaN0djOGFmaXBJZ0VoQWtBQ0R3Y1NRUVpCSUlHbng1aXQ3Z2crVTN3Z2NuYlpLUjFyK0ZuVyt2MkRWdER3dFhDWE5TS3o3OTdvQXdEelo3eVNSQUlCQkZzVFhtQmgxdzErb1o0SjNoK3d2OWxVRmRiTURPck8rNUlBcVdJR1p0aHVWMTNuQzc3bktSeDhyN1Bzc3lpYkxJa29UMS9oNjVIc2Z6V3l1NXRGNk5ZTkI0RVlKektVRVRxZ2NMTlZ2MEQvY0RRQnJOQW5tOStMT2ZUTGZOQjV1MmhmNXorNlRNZXhZamkrdFZkck01bGVNYldPdFN3UXgvRjFDMnJjdWViSXF3U081NjhhNFdtdU4zbUVZU2lVaStwUmwybDFwTHZZQnNLQXJVS1Z3blpSWWdkSHBNV1ZHNCsvV1hod29EQlhFN09ta0h6SjZKTmVtTGZ2NTFibmlHcXpWUG9Ja3lMYnBmSzdaTUZJa0U2RmxyTW43UWwrQmJpSGcrelhHYmdManlsRHB5b3NENThLWm1LTTBjZldISTkvL2FENW8xVkNacm5PODNWdVFRT2phNVBNQ2Z3SzhuM0syQ2hJYkxWT0Q5S0IzNmxlM0ErdS9zMlE4MUMyeVJhdlFtUU5kVm5hbUxubXE0bkhEOWpwQjByd203N2pwalRXOUU5MDZCdTE4ZldsV0NRSEFveDlDdEdvWFR3bVM4SVRoWnlYUEIrMjlpbnVvRTZiTXNETTl1ZkVBTU5IcUp1VThsak10QUtBMkI3SWh6YVdOaUxmV2pWUWIzSjEwL1NHdUVaWjdBZjFYNytsbHVaM0hrcGdFUVBMMjkxTStxYnpKZ1hRY0c2MHlwS2xWVEd3c014Y0ZhSlc2L2hEWFZaWnZDejNSbHJtUmlRSHd5OW5SbjJiTTZibmFzNGNMZkg2czFSSW9yc0pjRkRBMlBUb1I3WjdRZXpmUUQ5cXp3dkk2VHlUWkM0N3R0WGVpVCsyYzErd0JnT25kb1RQTHQ3bXJtQ1JqdmZVTFE0TzF4c1ZWY2h1N2I5R3lzWVVBcXkzbG5zZE5iMGFYbVF1ajdQWVdMMmV0dVJsNlMwT2ZYTGppR1FJZEVZNks1ZXNjMkJXaGp2a3FYTE82eDA4VlBLeFY2aVlBd3VCa3Y1TnB2Tm10YnJoYVgyK3RXZFk3MGVWTklOaHRMVzAvc2pydjZCMC9ZZEpsY0dsUjJBdkU0aFVsS3dIUTdCVTVjejhMUngwSGFQWTdnWGI1M0wvNjcrbVVmdWRQbVAvdHdPV1M2QVFpL2o2QjRpV1MvSWxZSyt5R1lKREIxd1dMRXJMUktkL29tT0piQVdmMDN3RUF5TzltKy9UdFMzQUFBQUFBU1VWT1JLNUNZSUk9Jyk7XFxuICBib3R0b206IDEwcHg7XFxuICBsZWZ0OiA5NXB4O1xcbn1cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1uYXZpZ2F0aW9uIGRpdi52aXMtYnV0dG9uLnZpcy16b29tSW4ge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUI0QUFBQWVDQVlBQUFBN01LNmlBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBQUFnWTBoU1RRQUFlaVVBQUlDREFBRDUvd0FBZ09rQUFIVXdBQURxWUFBQU9wZ0FBQmR2a2wvRlJnQUFCaUJKUkVGVWVOcWtWMnRRbE9jVmZwN3p2Z3ZEUmU2Nnk4aHRYVUJSMUdvRkkrQnRGSnZSdGpQSkJHZWFIMmE4REdtYnR0Z1NUV2JTSkV3NlRXT3NyYmJwVEllSlpHcWFUaXBUYTZMSlpEVFZVVFlRZE5Bb2hvc282cUx1Y25FUk4wQXhjYi84K0hhSlVIRFg5UHo2dm5uUGU1N3ZYSjV6emtlRUl3YVljd0JML1ZyVzBUQ0txWkFOSU5FdkJoU2szdzllVW1DOUh6amNzZmFyT2hCR0tKTjg0R2tWSkhjZXR2cUZ1NFNBSVlFTFlscG00THBRUU1xb1FRS1ZuemVPN0VZVi9BOE5uSE1BR3dIV1FKbUFqdGc4OTVMa0ZhN0ZVMWQyNThVdkdMQkdwSTRBUU05ZGQyVHJ3Tm40MDE2bjliUzNMcU56c0QxVktQQWJmaEN5cWZsUjMxdGhBenYrTGErUXhvdENvTmk2cG4xRDFzOWFWbGkvM3h0T1ZrNzJmalQxWFZmMTdFOXVIWnNwRkJEOHpkazEzcGRDQWpzT3lHNktVU0VFbnJUL3RQSGx1VytjdzdlUTE5cTJ6Ni90MnJzWUpFalowN1M2ZCt1a3dJNS95UTdSeG5ZQzJEWm54OGRiSE5zNnh4czg1VDJSOUdwclpjbVZ3WXMyQllXc21CelA4M203bklWSlM3M2pkZmRkKzdQampVdS9YV1VDR1R0UHJlN1pIanhUWTNLcThEb1Y4T3U1dTQ5c25QR3JLeE41OHN5WjlhVlhCenRzaWdvVUJkK1h0Mk5iZlo4bGxhVnZhaCt2T3o5aGNYK0NKZW5XcDdlT09ZUzZlUHBUVTF3Mzl2aytBd0N6RlBkRFFiRkdGUENVWTJ2OWhxeGZYSjBzaE5lSEx0c1VGYzZVZXF1YlZ2ZFZrd0xYMEdYYlpQcGw2WnV1L2lqOXgvVkNCVTFkVTdiZmRGWUFJRHNTRlJDZ2VPcWE5aGZ5L25EaHdmd1RLT3JSZDBVOTVuMGlxY2g5K2NLUzVKVnRwTUNka2xsaEFodWdDSGNSd0FiN3oxdENFcDhDQ1hBV0FKUm9DRlhJWW50aStzWVdUUTB0bGwwd1FNaytoR1VBa0JPWDcxNHhiVjFJeXVoeEhoSU1DL2lSNU9WOU0ySm11aFUxVmg3UFhpYWtySVVRaGNuTFhlSFF4UFQ0R3lBdEZxZ3dnQVBGNWlJRldrZXUxU1NMQ0tBd2VYbjMvWlI1clhWN1NkZFFweTNZRG9OZW1zOXFUSTVoR0NpdG0xTU9BQXgwYWFGQ2VyVGQ4NHpqQmVkM0VncTlBREEvcnFEN1EzY3RRQzRSRURta1lIYjhnb0dnc1IydHo1VjBEVit4VWRRb3FBUTgxUnliVTRJZ0ZXZ0FDZ3BhTExDSUJVbzBidjYzeS9hWHk2K1dCSFd6NC9JSFNJR0F1Vm9vaWFSZ1dxRDNBc0RWb1E2YkVndE9yZkpVaHdyZjBXVXRrK3I4c0w2d3ZIdms1aWpWVWlKU1JyUVp1VVJ0Zm9HTXVhQ29SeWZQL3lNeTBYeWtnQUEwRFBSVHhOcDMxeDJaRnVVWUJnQjdiSzdITmRocEt6NldYcTZvUUNvb0tnaE1LaGtnamk3N3ZCb0ExamtYbEF2VmZSUWpGTVVjbXhTa1JXZDZncGpldTMyUjJreFR2eWhLaDFEUWV1ZDhmRkJoMjZ6Zk9lMHh1UjRKZ0Fienl3Q29SU3pmZURVS2F0SktVUUsrQ2pLaUhaNm5aMnh6Qm5VN0I5dml4VHk3cUNIU1FFaEpVMytEdGRUNm1BY0FGaVdVZVAveHlQSDNKd3JmbzNYenlzZW1SY0VBOEY1Ulk4aDZhUEUxV3dNTFE0T1EvRUJBTkhtZEdXSGx6Wnl4azNheUIwbTc3MXlHb29ZeStLRTBsMzV4MGlCeFplaFM2aWU5UjFQQ01hRHZDeldEWEE0aFoyODNwdHdjdnA2cXFEQm55YW82QVdFUXJCUVEvN3krZDNZb0ErTkJUQWFFbG85NzNwOHRWRkNReWlwVytjM3BkTnU3QndCT2UrdG0vZW5pSy9rUEZXb3dwTWZ2dUtyenp3ODB6U0tJa1dzSmUwYkhZdTE2M0JOd013RHN2N0czNk9ETnR6TW5NNUlXWmZlUWdzY2Jpc3ZMUGwxYURoTFRvN0k4aytuL3ArZHc1cEdlZzBXS0dpUzMxSzZ2dlRkbUE3bng5dURaOUEzeE1VSXBidlNlekU2TVNPbWJOV1hld0hoRDZkSDIzbzdCbHFRdnZyd1RLNktRRnBYbDJXeXZjRTZMVEIyZUNQU2RydXJ2bWNVbk8vY1ZmUEQ2cE10ZXlmR3MzUUtwVUZRb1M5dFUveFBIOHhlK1RkZDY5M3BOL3BIdWcwWG1xbnR2ejF1TERvOVo5djVubnJuK2R2dWpySTFKTVVKZDNPWTduOTd1YTQ2ZG91T0dwa2RsRG9VRGVHN2cxTlMvdS81YTBPZzlzY0NzQit5c1dYU29NdXlGZnRXSnZNMEUzMVNCam1XUHpuSFBqeSs4TmpkaFlmZU1tSmwzRWlOU1JnQ2kvMjVmcEd1NE02NzF6amxybTY4NXMyZkVuVW9RNWxyTExXOHVQTGozb1g5aHFneEl3OG44WDFMVTd5TWtJdENIelJFWnJHUVY2T05teTVUZ2dIazI0N3NMLzFqRnFvZi9oUm4vQVdmcUMwcEkrUUhCSWszdElDWFJyRlRwRjhobEphcWVmaDZ5RnhRNkh3UVlsSzhIQUt5dDNXc1d4bDdmQUFBQUFFbEZUa1N1UW1DQycpO1xcbiAgYm90dG9tOiAxMHB4O1xcbiAgcmlnaHQ6IDE1cHg7XFxufVxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW5hdmlnYXRpb24gZGl2LnZpcy1idXR0b24udmlzLXpvb21PdXQge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUI0QUFBQWVDQVlBQUFBN01LNmlBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBQUFnWTBoU1RRQUFlaVVBQUlDREFBRDUvd0FBZ09rQUFIVXdBQURxWUFBQU9wZ0FBQmR2a2wvRlJnQUFCVjVKUkVGVWVOcTBsMnRRVlZVWWh0LzNXL3ZBQ01yMTZJRlJRRGlBZ0NocGdpaWtNcVkxV2puTjlLc2ZHT1hZVE9WZ2t2YkRVc1p1WHJLMHFabUdVU3ZOc3BqSThUWk9tbzZBR0JvWllseThZQjZRdzgwREJ3UTZqSjNkajMwT1pabWl3dnR2NzdYVzk2eTkxbDd2OXkxaU1OTEJ1Q0k4NHRaa0lYVTlnd3F4QUlMZG9rTkJPdHpnSlFXV3VZRURGeGZjTEFHaDN5MGs3OWlhRDRtZmpPVnU0V1lob0l0bmdCaVI2Umt1RkpBeUVKQkEzbS9scmkzSWgvdWV3WEZGeUFHNEE4b0FXa2NtMm1lRXpyRk5INTNWa2hnNHhXbnhDWGNCUUd1LzNiZkdlVGJ3aktQVWNzWlJFbG5mVXhjdUZMaDFOd2g1dnVyeDdzOEdEYlorTCt0SS9VMGhrR0daWDVjOS9wWHFPWlluMmdheks4VnRoMGZ2c1JVa25ieCtiSUpRUVBDdHMvTWRhKzRLdGhiSkZvcWVLd1Nlalg2cGZPMmtqeXR4SDFwZnV5cWxzR0g3ZEpBZ1pXdkZvMjNMLzltdWJvRitKeHRFMC9PRXdNcUpHNDZ1U0hpbkZ2ZXBUUE84bGhHYVgrZlBIU2RqQ0thUHkvYjN2N2F6NThoL3dIRkZ5SUhDUmlyZ2pVbGJmc2lKV1hFRkQ2aVVvT2tkUWFhUTZ6OWRQMllWYWhsakY0K3lYZHZaL2V2ZjRHK2hRazJzRUFVc3RpNHZXeGEzNWdLR1NCTURwM1QyM094eFZYZFhSaWpLb3ZTRnpyZXJDNkVMQU1UNkloY0NaSXllWDdjNjhZUHpHR0xseHE4OVB5TTBxNVlVMk0xUnVRQWcwRUVSYmlhQTdPaGwxUmdtUFRNMnAxcWpCazFNbTZHREVyc2Zzd0FnTGlEWlBtZk13cmJoQXFlSHptNlA4WjlnVjlTUWRUeDJscEN5QUVLa2hjNjJZWmlWRWpUZFJnbzB6WGVCUm5JbUFhU0Z6bTd4ZGpqdE9CR3l2bVpWWmtOdmZaalhEaFUxNCtCVG9GRURLUkFRcEFKMEhSVGpQNlhIcFlVS0VYN1J6UzliVjVjK0ZKVG1BSUNVZ05TV1EvWkNnSndoSU9KSVFWTGdGS2NYdktIbTljeUd2aXRoRkRVQUZRcUVDaG8xQ0JVSWdnWWFwQUoxUUVGQkV4Tk1Zb0lTRFUxL05JUjljdm5kVEcvYzJJQmtwMmZDOFpwUWdrbkJHSS8zQXNEdnZSZkRsSmh3ZW01endZTXM3Vk5sYVV0YlhFMWgzbWV6ajltbEdTc1hyQmt6a0ZzR0tHb0RtZWRCSkxmTGp4UVFnQVlkSFJTeHRQZmJmY2VOc1BZQlFQVEkrR1piVDMxWXhyR0lwWW9LcElLaWdrQWdGT2dnTkJyYlFCQkNCYUVNMkwraUdHbVRnbkYrVWMxZXBxTy8zVmVqQW9BT1VaU0xRa0ZOMTdsQWI0ZVZDZStWUnZ2SE40c0g2dDFmZXFBbU1VR29QSHZ2aGRMelRqemZLb2owc3phL0dMT3kxQnUzdnFjMjBQZ2w1WUlHa1ZPRVpGWjBuTExNc3p6ZERBRFRnaklkWDZVZjN6ZlV4Nm02dThyaUtSaE9DY21EQXFMQ1VSbzUzT2U0cnJzeVVsR0QwbmxJcXViZEtOWkpYT205Rkg2eTdZaDV1S0JuTzh2TlRYMk40WW9LRTJmTUxSRVFPc0U4QWZGTjQvYWs0UUlmYmQyWEpGUlFrTHg4NXJ1TjdOVHAyQW9BWnh3bENSOWRXSmM4MU5EZHRvTGtjODZLQklKd1hRM2FPcENQcXd1aFIyU1BiQ0JsVWMyTnlvZ1FYM043d3FnVTUxQkFmMnc5RUZYVXRDdExxQURxUzc2ZXY2L2lsZ3JrMnE2ZXN4SFpnZjVDeVNoM0ZNY0crNWpiRTBaTmRqNG9kSGREd1dQR2NaTk5PMU1QYnJ4dHpkVzRzK3RJNUhQQndRVFR6emlLWTN2LzdIR2xobVMyM2c5MFQrT081TDFOdTdNTXczRnYvVHgxZjk3L0Zuc0FZUHVpOC9ENG5CQi9vWlpSMjMwdW9xNjdhdVFvTGFCMzdJaW8zc0VBSzUyblIzOXArelMxM0hGaWlsSGVZdE9PYWJkQzcxalF6ejJSK0FMQmJjcmpXTkYrY2ZhVXdMU3JrNEttdHNUNFQrZ0s5akc3QUtLanY5M1gxbGNmVU5OVmFhbnRyb3BxZGRuRENjSW9hN2xrMjlTOTIrLzVDcE92UTA0Vko3OUtVZS83aUkvSGg0MFU2YzNQeXVQamhtV0tOOEc4RnZudzFBL3ptWC92VjVoL1QrQ1hzdFJNVXA0a09GT2paaVVsV0JrRlFZZEFMaXRSWlhSemYzUnFXdW1kZ0Y3OU5RREJPYTJWL2lZU0hBQUFBQUJKUlU1RXJrSmdnZz09Jyk7XFxuICBib3R0b206IDEwcHg7XFxuICByaWdodDogNTVweDtcXG59XFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbmF2aWdhdGlvbiBkaXYudmlzLWJ1dHRvbi52aXMtem9vbUV4dGVuZHMge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUI0QUFBQWVDQVlBQUFBN01LNmlBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBQUFnWTBoU1RRQUFlaVVBQUlDREFBRDUvd0FBZ09rQUFIVXdBQURxWUFBQU9wZ0FBQmR2a2wvRlJnQUFCcHRKUkVGVWVOcXNsMjFRbE5jVngvLy9jeDloSWlwdUFKSGFzZ0hsUmR3MHhheTd5SzdzbWc2c2IyRFNkdHFaZHVMVU5FTm1PazF0UXVNNFU3VXpUdnNoU1JsRlp6b05DV1NTU1RKcCs2Vk5rTENBZVFIQm9DQ2dxTkJFMHdVcUwrS3V3SWlpWlo5K2VIYTNhQVMzU2Y4ek84L0wzbnQrOTV4N3o3bjNZV2xwS1VRRUpBRWdjaDkrSm9sYTl4RUMyQURCVmdBT0txd0NZQXFLRGdVSkJJSFBCV3dGV1FOZGJ5WkZCd0FDMEdHSUFIUVNqMy84SEhSZGh6WWJkRGZ3ZzRJakFzR3ZJQ2dYQXJvWUJpQ0VEa0JCQUNCWm95U1Q0Z0R3UXFoN21RNGNFa2hRRDBFQklJZ2dSTVFBaDJFaUV2RVlBR3JkUjNZU3FJWUNJRURhb3RWRGVZbnUvcnlFalNPcjQzUEhsOFdtVEJQQTZQUlE3SVdKcnZoVC91YmtVLzdtMUV2WCsxS0VVaDdVZytXa1BFWGdkVVNrUit4cmQwTko0cWpyOEFFSTlwR0FJN21vNzhtSGZuRitZL0sySzdpSFVoZXV2Skc2Y09VTnovTHZEd1BvYnJwU2wvUnVmMlZPeTlVUHM0UlNUU0FOd0g0WTQ0OUVWZG50OW9qSEllZ2hDSFlMZ1Irbi83enQ0TnAzMnRJV1pVNGhTcG5qVmsxdC9jYVBmT08zL2YrK01OSDVUVkpjaXNvRW9vNGtzZ2JzWHdZZmRSMStrUXBsUXVDRk5TODJQcC85KzE1OFJUa1RDMGNlME9LdXRRZU9wNVBNRTBxY1VCcXlCbXdHT0M4dno0QVdWT3lFNENVcVlPL0RoK3AzcGovL0JiNm1IbGxxQ3l4ZDhPRFZUNjkrdUZLb09ZVFNuekZnN1NKcHpIRk5RWVdpUXJVSXNDTjlWK3VPaDM3NXp6MTc5cFNHSTFGU1V1SzEyKzIrYUdEdDdlM211cm82VC9oNTc5NjlsWmR2RHJUK1piQTZuMEIxbmZQVk43ZTBQak1qSWdJSWRrRUFSMUpSMzI5eUR2YUUwK2wvaFFLQTFXcjFiZDY4MlNzaWtVVzdLK08zUGVzVE52YVNBaVhhTGhHQnZPODZSRkVvSjRBZGFjK2VEeHNnaVpLU0VtOU5UWTNuNU1tVDVtakJIUjBkNXZyNmVzK21UWnU4U3FuSSt4K3MrT2w1alJvMGF1WDFqdGVwUWFFQUFES1dXSWJjeTdaR1VtYjc5dTFldTkzdUkrbXRyYTMxSExqNVRHRHM5ckJKSUNDTm4xR1JDS0dDVUpBVXV6enc2Q2ZiVEI2UHg3dDI3Vm9mQUcvWVhsNkNleXc5TG12SU4zVXhaVWFmS1JBQ1d5Q0VMY0hWUDN2azRmRGFiRFpmKzJOL0Q5Zytmc0xFRUZTb29GR0RvZ1pORmtCUmdTQ3NUY1dtMDY2amdSQVU0ZXQvRjV1OW54Um9zbUNMUm1FK1FkZ1NYQ056aFcvczlyREo2M3dWSng3N1YrVjhZUzZVTmFXOEJkT2NxengrM1VqdDBGOEJjcjFHTUlNVTVDekpIWityZzZJR0NZVjJQaW1veUlLNmx6SVdyeGtQVFZHbVJvcUpGQ3lMVFptZXE0TUI1ZjNCVkFEbmJwY1FrelN0VVFNQWswWUtCUGZ6eGxoQTk1TlFRZTQzUUJvdEJFQ0FGRnlaSG82ZHo2Q0tDaXpBUEZQaXZ6VVdxeG0yQXFJZ253a0Z2Wk5uNHVjekdLM0hhaDd3cGV0OThVWjg1UjhhS1NjSWNYWUVXcE1Ma3g4ZnZsZUhwTmpsQVd0VHNha1FhMHBWS0djSlFxTUdVcUNIQnZmZGpwL2dUUDZ4d0Z6Zzg1UGR5YUgySjRTVW93S2l3Mzg4OWU0S0JBQ25UNTgyVzV1S1RWMnV1c0FkVUZsZ3pCY0ZRb0ZHRFQzNUh3Vys4Mm1ocWFlbnh3d0E0V3RZZlJOblVrTVpVcXNKcEVrbjhjWFU1eWt0WXcySmpzVENNUUR3ZXIwZWt0NkdoZ1pQVVZHUmQzZnU3cWpxZFU5TWo3bWxwY1ZEMHR2UzB1S3hXQ3lWQU5CNXJTM3g4czNCRkVVRmdUVEx0dVpuZFFITEJNU2ZCNnB5WnRmcU1EUTNOemZxVGNKaXNmaWNUcWMzQkkrOGJ4aDlMOGNvcmFyTTNmbkRvSVQrckFDQVUvN203TU9mSGJDRXdRRFEyTmpvNmVycWlucVRPSGZ1WE5qamlJMjMreXN0WjhjN3NtbWtXZ1ZKY04rK2ZSQVJmTERobGFjRVVxVkVRMW5tNzd4UHJIalNoLytEam8zV21OL3MvNk9IRU9nSVByMmg2M3RWdXE1RHVkMXVrRVRXb0szem9ya3pUaWlPTm4vVEtsTk00bGoyNG0rUGYxM28yd09WSHFHQTVNc0FYaktQckRhcW5NdmxRbmpUemh5ME5sdzBkNW9JNXAzeU42MmFtcmsrdmU1QjUraFhnYjQ3V0dYNTIrVjNOZ29GT3ZRS0FHVWtrVHFjYlp5NVhDN1hIWWY0ekVGcjNhWFU3amloNXVpZFBQT3R2c216aXhacjhWTXJIakJIZGRMc0hqK1o5RmIvbjlhMStUL0pEYVhleTBJcEV6RUtrSG5VOEpqNzkrK1BlRXdTU2ltUVJHUCtHejhqNURWRkJWS1F0akJqNkpHbE50L0Q4WStPcE1kbFRwaGlFcWNCNHRxdHNWamZqVXRMTGt4MEovZE9ualdQVGcrbEVBUklFSHdhUUpWUUlZZ2dBQ0MvcXhpNnJuOFpITDRYRVRTc2YwTVUxSE9rL0NGR1lnQXdza1VxWTVlQml0Unh6bjcvYTBWMUVFQndkcWtONmpQSTd5NHhQbUhtQzV1bmJXZFFSTXFQMmQ4NnFBTk9rc1U2Z3ZtQXJOUVJOQ2xxQUJuUWdZdUswa3JJK3dDT0F5SDNESy92cU9YaGFmM1BBTzdtSVJqRE5WMjVBQUFBQUVsRlRrU3VRbUNDJyk7XFxuICBib3R0b206IDUwcHg7XFxuICByaWdodDogMTVweDtcXG59XFxuXCI7XG5zdHlsZUluamVjdChjc3NfMjQ4eiQxKTtcblxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgQWxleCBvbiAxMS82LzIwMTQuXHJcbiAqL1xuZnVuY3Rpb24ga2V5Y2hhcm0ob3B0aW9ucykge1xuICB2YXIgcHJldmVudERlZmF1bHQgPSBvcHRpb25zICYmIG9wdGlvbnMucHJldmVudERlZmF1bHQgfHwgZmFsc2U7XG4gIHZhciBjb250YWluZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGFpbmVyIHx8IHdpbmRvdztcbiAgdmFyIF9leHBvcnRGdW5jdGlvbnMgPSB7fTtcbiAgdmFyIF9ib3VuZCA9IHtcbiAgICBrZXlkb3duOiB7fSxcbiAgICBrZXl1cDoge31cbiAgfTtcbiAgdmFyIF9rZXlzID0ge307XG4gIHZhciBpOyAvLyBhIC0gelxuXG4gIGZvciAoaSA9IDk3OyBpIDw9IDEyMjsgaSsrKSB7XG4gICAgX2tleXNbU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSB7XG4gICAgICBjb2RlOiA2NSArIChpIC0gOTcpLFxuICAgICAgc2hpZnQ6IGZhbHNlXG4gICAgfTtcbiAgfSAvLyBBIC0gWlxuXG5cbiAgZm9yIChpID0gNjU7IGkgPD0gOTA7IGkrKykge1xuICAgIF9rZXlzW1N0cmluZy5mcm9tQ2hhckNvZGUoaSldID0ge1xuICAgICAgY29kZTogaSxcbiAgICAgIHNoaWZ0OiB0cnVlXG4gICAgfTtcbiAgfSAvLyAwIC0gOVxuXG5cbiAgZm9yIChpID0gMDsgaSA8PSA5OyBpKyspIHtcbiAgICBfa2V5c1snJyArIGldID0ge1xuICAgICAgY29kZTogNDggKyBpLFxuICAgICAgc2hpZnQ6IGZhbHNlXG4gICAgfTtcbiAgfSAvLyBGMSAtIEYxMlxuXG5cbiAgZm9yIChpID0gMTsgaSA8PSAxMjsgaSsrKSB7XG4gICAgX2tleXNbJ0YnICsgaV0gPSB7XG4gICAgICBjb2RlOiAxMTEgKyBpLFxuICAgICAgc2hpZnQ6IGZhbHNlXG4gICAgfTtcbiAgfSAvLyBudW0wIC0gbnVtOVxuXG5cbiAgZm9yIChpID0gMDsgaSA8PSA5OyBpKyspIHtcbiAgICBfa2V5c1snbnVtJyArIGldID0ge1xuICAgICAgY29kZTogOTYgKyBpLFxuICAgICAgc2hpZnQ6IGZhbHNlXG4gICAgfTtcbiAgfSAvLyBudW1wYWQgbWlzY1xuXG5cbiAgX2tleXNbJ251bSonXSA9IHtcbiAgICBjb2RlOiAxMDYsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydudW0rJ10gPSB7XG4gICAgY29kZTogMTA3LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snbnVtLSddID0ge1xuICAgIGNvZGU6IDEwOSxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ251bS8nXSA9IHtcbiAgICBjb2RlOiAxMTEsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydudW0uJ10gPSB7XG4gICAgY29kZTogMTEwLFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9OyAvLyBhcnJvd3NcblxuICBfa2V5c1snbGVmdCddID0ge1xuICAgIGNvZGU6IDM3LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1sndXAnXSA9IHtcbiAgICBjb2RlOiAzOCxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ3JpZ2h0J10gPSB7XG4gICAgY29kZTogMzksXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydkb3duJ10gPSB7XG4gICAgY29kZTogNDAsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07IC8vIGV4dHJhIGtleXNcblxuICBfa2V5c1snc3BhY2UnXSA9IHtcbiAgICBjb2RlOiAzMixcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ2VudGVyJ10gPSB7XG4gICAgY29kZTogMTMsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydzaGlmdCddID0ge1xuICAgIGNvZGU6IDE2LFxuICAgIHNoaWZ0OiB1bmRlZmluZWRcbiAgfTtcbiAgX2tleXNbJ2VzYyddID0ge1xuICAgIGNvZGU6IDI3LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snYmFja3NwYWNlJ10gPSB7XG4gICAgY29kZTogOCxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ3RhYiddID0ge1xuICAgIGNvZGU6IDksXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydjdHJsJ10gPSB7XG4gICAgY29kZTogMTcsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydhbHQnXSA9IHtcbiAgICBjb2RlOiAxOCxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ2RlbGV0ZSddID0ge1xuICAgIGNvZGU6IDQ2LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1sncGFnZXVwJ10gPSB7XG4gICAgY29kZTogMzMsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydwYWdlZG93biddID0ge1xuICAgIGNvZGU6IDM0LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9OyAvLyBzeW1ib2xzXG5cbiAgX2tleXNbJz0nXSA9IHtcbiAgICBjb2RlOiAxODcsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWyctJ10gPSB7XG4gICAgY29kZTogMTg5LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snXSddID0ge1xuICAgIGNvZGU6IDIyMSxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ1snXSA9IHtcbiAgICBjb2RlOiAyMTksXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG5cbiAgdmFyIGRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBoYW5kbGVFdmVudChldmVudCwgJ2tleWRvd24nKTtcbiAgfTtcblxuICB2YXIgdXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBoYW5kbGVFdmVudChldmVudCwgJ2tleXVwJyk7XG4gIH07IC8vIGhhbmRsZSB0aGUgYWN0dWFseSBib3VuZCBrZXkgd2l0aCB0aGUgZXZlbnRcblxuXG4gIHZhciBoYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgdHlwZSkge1xuICAgIGlmIChfYm91bmRbdHlwZV1bZXZlbnQua2V5Q29kZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGJvdW5kID0gX2JvdW5kW3R5cGVdW2V2ZW50LmtleUNvZGVdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChib3VuZFtpXS5zaGlmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYm91bmRbaV0uZm4oZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGJvdW5kW2ldLnNoaWZ0ID09IHRydWUgJiYgZXZlbnQuc2hpZnRLZXkgPT0gdHJ1ZSkge1xuICAgICAgICAgIGJvdW5kW2ldLmZuKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChib3VuZFtpXS5zaGlmdCA9PSBmYWxzZSAmJiBldmVudC5zaGlmdEtleSA9PSBmYWxzZSkge1xuICAgICAgICAgIGJvdW5kW2ldLmZuKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJldmVudERlZmF1bHQgPT0gdHJ1ZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gYmluZCBhIGtleSB0byBhIGNhbGxiYWNrXG5cblxuICBfZXhwb3J0RnVuY3Rpb25zLmJpbmQgPSBmdW5jdGlvbiAoa2V5LCBjYWxsYmFjaywgdHlwZSkge1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHR5cGUgPSAna2V5ZG93bic7XG4gICAgfVxuXG4gICAgaWYgKF9rZXlzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQga2V5OiBcIiArIGtleSk7XG4gICAgfVxuXG4gICAgaWYgKF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdID0gW107XG4gICAgfVxuXG4gICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0ucHVzaCh7XG4gICAgICBmbjogY2FsbGJhY2ssXG4gICAgICBzaGlmdDogX2tleXNba2V5XS5zaGlmdFxuICAgIH0pO1xuICB9OyAvLyBiaW5kIGFsbCBrZXlzIHRvIGEgY2FsbCBiYWNrIChkZW1vIHB1cnBvc2VzKVxuXG5cbiAgX2V4cG9ydEZ1bmN0aW9ucy5iaW5kQWxsID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdHlwZSA9ICdrZXlkb3duJztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gX2tleXMpIHtcbiAgICAgIGlmIChfa2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIF9leHBvcnRGdW5jdGlvbnMuYmluZChrZXksIGNhbGxiYWNrLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIGdldCB0aGUga2V5IGxhYmVsIGZyb20gYW4gZXZlbnRcblxuXG4gIF9leHBvcnRGdW5jdGlvbnMuZ2V0S2V5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZm9yICh2YXIga2V5IGluIF9rZXlzKSB7XG4gICAgICBpZiAoX2tleXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkgPT0gdHJ1ZSAmJiBfa2V5c1trZXldLnNoaWZ0ID09IHRydWUgJiYgZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUpIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5ID09IGZhbHNlICYmIF9rZXlzW2tleV0uc2hpZnQgPT0gZmFsc2UgJiYgZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUpIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gX2tleXNba2V5XS5jb2RlICYmIGtleSA9PSAnc2hpZnQnKSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBcInVua25vd24ga2V5LCBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiO1xuICB9OyAvLyB1bmJpbmQgZWl0aGVyIGEgc3BlY2lmaWMgY2FsbGJhY2sgZnJvbSBhIGtleSBvciBhbGwgb2YgdGhlbSAoYnkgbGVhdmluZyBjYWxsYmFjayB1bmRlZmluZWQpXG5cblxuICBfZXhwb3J0RnVuY3Rpb25zLnVuYmluZCA9IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdHlwZSA9ICdrZXlkb3duJztcbiAgICB9XG5cbiAgICBpZiAoX2tleXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXk6IFwiICsga2V5KTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIG5ld0JpbmRpbmdzID0gW107XG4gICAgICB2YXIgYm91bmQgPSBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXTtcblxuICAgICAgaWYgKGJvdW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghKGJvdW5kW2ldLmZuID09IGNhbGxiYWNrICYmIGJvdW5kW2ldLnNoaWZ0ID09IF9rZXlzW2tleV0uc2hpZnQpKSB7XG4gICAgICAgICAgICBuZXdCaW5kaW5ncy5wdXNoKF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPSBuZXdCaW5kaW5ncztcbiAgICB9IGVsc2Uge1xuICAgICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPSBbXTtcbiAgICB9XG4gIH07IC8vIHJlc2V0IGFsbCBib3VuZCB2YXJpYWJsZXMuXG5cblxuICBfZXhwb3J0RnVuY3Rpb25zLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIF9ib3VuZCA9IHtcbiAgICAgIGtleWRvd246IHt9LFxuICAgICAga2V5dXA6IHt9XG4gICAgfTtcbiAgfTsgLy8gdW5iaW5kIGFsbCBsaXN0ZW5lcnMgYW5kIHJlc2V0IGFsbCB2YXJpYWJsZXMuXG5cblxuICBfZXhwb3J0RnVuY3Rpb25zLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgX2JvdW5kID0ge1xuICAgICAga2V5ZG93bjoge30sXG4gICAgICBrZXl1cDoge31cbiAgICB9O1xuICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93biwgdHJ1ZSk7XG4gICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdXAsIHRydWUpO1xuICB9OyAvLyBjcmVhdGUgbGlzdGVuZXJzLlxuXG5cbiAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duLCB0cnVlKTtcbiAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdXAsIHRydWUpOyAvLyByZXR1cm4gdGhlIHB1YmxpYyBmdW5jdGlvbnMuXG5cbiAgcmV0dXJuIF9leHBvcnRGdW5jdGlvbnM7XG59XG5cbi8qKlxuICogTmF2aWdhdGlvbiBIYW5kbGVyXG4gKi9cblxudmFyIE5hdmlnYXRpb25IYW5kbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIE5hdmlnYXRpb25IYW5kbGVyKGJvZHksIGNhbnZhcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmF2aWdhdGlvbkhhbmRsZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmljb25zQ3JlYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMubmF2aWdhdGlvbkhhbW1lcnMgPSBbXTtcbiAgICB0aGlzLmJvdW5kRnVuY3Rpb25zID0ge307XG4gICAgdGhpcy50b3VjaFRpbWUgPSAwO1xuICAgIHRoaXMuYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJhY3RpdmF0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5hY3RpdmF0ZWQgPSB0cnVlO1xuXG4gICAgICBfdGhpcy5jb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCk7XG4gICAgfSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZWFjdGl2YXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmFjdGl2YXRlZCA9IGZhbHNlO1xuXG4gICAgICBfdGhpcy5jb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCk7XG4gICAgfSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5rZXljaGFybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF90aGlzLmtleWNoYXJtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTmF2aWdhdGlvbkhhbmRsZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY3JlYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb3IgcmVmcmVzaGVzIG5hdmlnYXRpb24gYW5kIHNldHMga2V5IGJpbmRpbmdzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uQnV0dG9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5pY29uc0NyZWF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5sb2FkTmF2aWdhdGlvbkVsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pY29uc0NyZWF0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5jbGVhbk5hdmlnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBwcmV2aW91cyBuYXZpZ2F0aW9uIGl0ZW1zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGVhbk5hdmlnYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW5OYXZpZ2F0aW9uKCkge1xuICAgICAgLy8gY2xlYW4gaGFtbWVyIGJpbmRpbmdzXG4gICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5sZW5ndGggIT0gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmF2aWdhdGlvbkhhbW1lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkhhbW1lcnMgPSBbXTtcbiAgICAgIH0gLy8gY2xlYW4gdXAgcHJldmlvdXMgbmF2aWdhdGlvbiBpdGVtc1xuXG5cbiAgICAgIGlmICh0aGlzLm5hdmlnYXRpb25ET00gJiYgdGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXSAmJiB0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmljb25zQ3JlYXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGlvbiBvZiB0aGUgbmF2aWdhdGlvbiBjb250cm9scyBub2Rlcy4gVGhleSBhcmUgZHJhd24gb3ZlciB0aGUgcmVzdCBvZiB0aGUgbm9kZXMgYW5kIGFyZSBub3QgYWZmZWN0ZWQgYnkgc2NhbGUgYW5kIHRyYW5zbGF0aW9uXG4gICAgICogdGhleSBoYXZlIGEgdHJpZ2dlckZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBvbiBjbGljay4gSWYgdGhlIHBvc2l0aW9uIG9mIHRoZSBuYXZpZ2F0aW9uIGNvbnRyb2xzIGlzIGRlcGVuZGVudFxuICAgICAqIG9uIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoIG9yIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCwgd2UgZmxhZyBob3Jpem9udGFsQWxpZ25MZWZ0IGFuZCB2ZXJ0aWNhbEFsaWduVG9wIGZhbHNlLlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgbG9jYXRpb24gd2lsbCBiZSBjb3JyZWN0ZWQgYnkgdGhlIF9yZWxvY2F0ZU5hdmlnYXRpb24gZnVuY3Rpb24gb24gYSBzaXplIGNoYW5nZSBvZiB0aGUgY2FudmFzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvYWROYXZpZ2F0aW9uRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZE5hdmlnYXRpb25FbGVtZW50cygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmNsZWFuTmF2aWdhdGlvbigpO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NID0ge307XG4gICAgICB2YXIgbmF2aWdhdGlvbkRpdnMgPSBbXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJ6b29tSW5cIiwgXCJ6b29tT3V0XCIsIFwiem9vbUV4dGVuZHNcIl07XG4gICAgICB2YXIgbmF2aWdhdGlvbkRpdkFjdGlvbnMgPSBbXCJfbW92ZVVwXCIsIFwiX21vdmVEb3duXCIsIFwiX21vdmVMZWZ0XCIsIFwiX21vdmVSaWdodFwiLCBcIl96b29tSW5cIiwgXCJfem9vbU91dFwiLCBcIl9maXRcIl07XG4gICAgICB0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0uY2xhc3NOYW1lID0gXCJ2aXMtbmF2aWdhdGlvblwiO1xuICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmF2aWdhdGlvbkRpdnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW25hdmlnYXRpb25EaXZzW2ldXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1cIiArIG5hdmlnYXRpb25EaXZzW2ldO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdLmFwcGVuZENoaWxkKHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0pO1xuICAgICAgICB2YXIgaGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dKTtcblxuICAgICAgICBpZiAobmF2aWdhdGlvbkRpdkFjdGlvbnNbaV0gPT09IFwiX2ZpdFwiKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICAgICAgb25Ub3VjaChoYW1tZXIsIGJpbmQkNihfY29udGV4dCA9IHRoaXMuX2ZpdCkuY2FsbChfY29udGV4dCwgdGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfY29udGV4dDI7XG5cbiAgICAgICAgICBvblRvdWNoKGhhbW1lciwgYmluZCQ2KF9jb250ZXh0MiA9IHRoaXMuYmluZFRvUmVkcmF3KS5jYWxsKF9jb250ZXh0MiwgdGhpcywgbmF2aWdhdGlvbkRpdkFjdGlvbnNbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkhhbW1lcnMucHVzaChoYW1tZXIpO1xuICAgICAgfSAvLyB1c2UgYSBoYW1tZXIgZm9yIHRoZSByZWxlYXNlIHNvIHdlIGRvIG5vdCByZXF1aXJlIHRoZSBvbmUgdXNlZCBpbiB0aGUgcmVzdCBvZiB0aGUgbmV0d29ya1xuICAgICAgLy8gdGhlIG9uZSB0aGUgcmVzdCB1c2VzIGNhbiBiZSBvdmVybG9hZGVkIGJ5IHRoZSBtYW5pcHVsYXRpb24gc3lzdGVtLlxuXG5cbiAgICAgIHZhciBoYW1tZXJGcmFtZSA9IG5ldyBIYW1tZXIodGhpcy5jYW52YXMuZnJhbWUpO1xuICAgICAgb25SZWxlYXNlKGhhbW1lckZyYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5fc3RvcE1vdmVtZW50KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubmF2aWdhdGlvbkhhbW1lcnMucHVzaChoYW1tZXJGcmFtZSk7XG4gICAgICB0aGlzLmljb25zQ3JlYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZFRvUmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRUb1JlZHJhdyhhY3Rpb24pIHtcbiAgICAgIGlmICh0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX2NvbnRleHQzO1xuXG4gICAgICAgIHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSA9IGJpbmQkNihfY29udGV4dDMgPSB0aGlzW2FjdGlvbl0pLmNhbGwoX2NvbnRleHQzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsIHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RhcnRSZW5kZXJpbmdcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5iaW5kRnJvbVJlZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRGcm9tUmVkcmF3KGFjdGlvbikge1xuICAgICAgaWYgKHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIiwgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdG9wUmVuZGVyaW5nXCIpO1xuICAgICAgICBkZWxldGUgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGlzIHN0b3BzIGFsbCBtb3ZlbWVudCBpbmR1Y2VkIGJ5IHRoZSBuYXZpZ2F0aW9uIGJ1dHRvbnNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maXQoKSB7XG4gICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDcwMCkge1xuICAgICAgICAvLyBUT0RPOiBmaXggdWdseSBoYWNrIHRvIGF2b2lkIGhhbW1lcidzIGRvdWJsZSBmaXJlaW5nIG9mIGV2ZW50IChiZWNhdXNlIHdlIHVzZSByZWxlYXNlPylcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImZpdFwiLCB7XG4gICAgICAgICAgZHVyYXRpb246IDcwMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhpcyBzdG9wcyBhbGwgbW92ZW1lbnQgaW5kdWNlZCBieSB0aGUgbmF2aWdhdGlvbiBidXR0b25zXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0b3BNb3ZlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RvcE1vdmVtZW50KCkge1xuICAgICAgZm9yICh2YXIgYm91bmRBY3Rpb24gaW4gdGhpcy5ib3VuZEZ1bmN0aW9ucykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm91bmRGdW5jdGlvbnMsIGJvdW5kQWN0aW9uKSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIiwgdGhpcy5ib3VuZEZ1bmN0aW9uc1tib3VuZEFjdGlvbl0pO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RvcFJlbmRlcmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmJvdW5kRnVuY3Rpb25zID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tb3ZlVXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVVcCgpIHtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkgKz0gdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tb3ZlRG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZURvd24oKSB7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55IC09IHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbW92ZUxlZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVMZWZ0KCkge1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCArPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21vdmVSaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZVJpZ2h0KCkge1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCAtPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3pvb21JblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfem9vbUluKCkge1xuICAgICAgdmFyIHNjYWxlT2xkID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZSAqICgxICsgdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnpvb20pO1xuICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICB2YXIgc2NhbGVGcmFjID0gc2NhbGUgLyBzY2FsZU9sZDtcbiAgICAgIHZhciB0eCA9ICgxIC0gc2NhbGVGcmFjKSAqIHRoaXMuY2FudmFzLmNhbnZhc1ZpZXdDZW50ZXIueCArIHRyYW5zbGF0aW9uLnggKiBzY2FsZUZyYWM7XG4gICAgICB2YXIgdHkgPSAoMSAtIHNjYWxlRnJhYykgKiB0aGlzLmNhbnZhcy5jYW52YXNWaWV3Q2VudGVyLnkgKyB0cmFuc2xhdGlvbi55ICogc2NhbGVGcmFjO1xuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBzY2FsZTtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiB0eCxcbiAgICAgICAgeTogdHlcbiAgICAgIH07XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiem9vbVwiLCB7XG4gICAgICAgIGRpcmVjdGlvbjogXCIrXCIsXG4gICAgICAgIHNjYWxlOiB0aGlzLmJvZHkudmlldy5zY2FsZSxcbiAgICAgICAgcG9pbnRlcjogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl96b29tT3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF96b29tT3V0KCkge1xuICAgICAgdmFyIHNjYWxlT2xkID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZSAvICgxICsgdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnpvb20pO1xuICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICB2YXIgc2NhbGVGcmFjID0gc2NhbGUgLyBzY2FsZU9sZDtcbiAgICAgIHZhciB0eCA9ICgxIC0gc2NhbGVGcmFjKSAqIHRoaXMuY2FudmFzLmNhbnZhc1ZpZXdDZW50ZXIueCArIHRyYW5zbGF0aW9uLnggKiBzY2FsZUZyYWM7XG4gICAgICB2YXIgdHkgPSAoMSAtIHNjYWxlRnJhYykgKiB0aGlzLmNhbnZhcy5jYW52YXNWaWV3Q2VudGVyLnkgKyB0cmFuc2xhdGlvbi55ICogc2NhbGVGcmFjO1xuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBzY2FsZTtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiB0eCxcbiAgICAgICAgeTogdHlcbiAgICAgIH07XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiem9vbVwiLCB7XG4gICAgICAgIGRpcmVjdGlvbjogXCItXCIsXG4gICAgICAgIHNjYWxlOiB0aGlzLmJvZHkudmlldy5zY2FsZSxcbiAgICAgICAgcG9pbnRlcjogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJpbmQgYWxsIGtleXMgdXNpbmcga2V5Y2hhcm0uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25maWd1cmVLZXlib2FyZEJpbmRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMua2V5Y2hhcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmtleWNoYXJtLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZXlib2FyZC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQuYmluZFRvV2luZG93ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5rZXljaGFybSA9IGtleWNoYXJtKHtcbiAgICAgICAgICAgIGNvbnRhaW5lcjogd2luZG93LFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtID0ga2V5Y2hhcm0oe1xuICAgICAgICAgICAgY29udGFpbmVyOiB0aGlzLmNhbnZhcy5mcmFtZSxcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmtleWNoYXJtLnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0NCwgX2NvbnRleHQ1LCBfY29udGV4dDYsIF9jb250ZXh0NywgX2NvbnRleHQ4LCBfY29udGV4dDksIF9jb250ZXh0MTAsIF9jb250ZXh0MTEsIF9jb250ZXh0MTIsIF9jb250ZXh0MTMsIF9jb250ZXh0MTQsIF9jb250ZXh0MTUsIF9jb250ZXh0MTYsIF9jb250ZXh0MTcsIF9jb250ZXh0MTgsIF9jb250ZXh0MTksIF9jb250ZXh0MjAsIF9jb250ZXh0MjEsIF9jb250ZXh0MjIsIF9jb250ZXh0MjMsIF9jb250ZXh0MjQsIF9jb250ZXh0MjUsIF9jb250ZXh0MjYsIF9jb250ZXh0Mjc7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQ0ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDQsIFwidXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl9tb3ZlVXBcIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0NSA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQ1LCBcImRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl9tb3ZlRG93blwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQ2ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDYsIFwibGVmdFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVMZWZ0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDcgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0NywgXCJyaWdodFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVSaWdodFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQ4ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDgsIFwiPVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQ5ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDksIFwibnVtK1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQxMCA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxMCwgXCJudW0tXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQxMSA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxMSwgXCItXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQxMiA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxMiwgXCJbXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQxMyA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxMywgXCJdXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDE0ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE0LCBcInBhZ2V1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQxNSA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxNSwgXCJwYWdlZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MTYgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MTYsIFwidXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZVVwXCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQxNyA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxNywgXCJkb3duXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX21vdmVEb3duXCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQxOCA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxOCwgXCJsZWZ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX21vdmVMZWZ0XCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQxOSA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxOSwgXCJyaWdodFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlUmlnaHRcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDIwID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDIwLCBcIj1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQyMSA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQyMSwgXCJudW0rXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MjIgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjIsIFwibnVtLVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG5cbiAgICAgICAgICBiaW5kJDYoX2NvbnRleHQyMyA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQyMywgXCItXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDI0ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDI0LCBcIltcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQ2KF9jb250ZXh0MjUgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjUsIFwiXVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDI2ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDI2LCBcInBhZ2V1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkNihfY29udGV4dDI3ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDI3LCBcInBhZ2Vkb3duXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOYXZpZ2F0aW9uSGFuZGxlcjtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2Ygc3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGdldEl0ZXJhdG9yTWV0aG9kJDEobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKGlzQXJyYXkkMihvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ0KG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQxNTsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDQobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZShfY29udGV4dDE1ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0MTUsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb20kMyhvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ0KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNChhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbi8qKlxuICogSGFuZGxlciBmb3IgaW50ZXJhY3Rpb25zXG4gKi9cblxudmFyIEludGVyYWN0aW9uSGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqIEBwYXJhbSB7U2VsZWN0aW9uSGFuZGxlcn0gc2VsZWN0aW9uSGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gSW50ZXJhY3Rpb25IYW5kbGVyKGJvZHksIGNhbnZhcywgc2VsZWN0aW9uSGFuZGxlcikge1xuICAgIHZhciBfY29udGV4dCwgX2NvbnRleHQyLCBfY29udGV4dDMsIF9jb250ZXh0NCwgX2NvbnRleHQ1LCBfY29udGV4dDYsIF9jb250ZXh0NywgX2NvbnRleHQ4LCBfY29udGV4dDksIF9jb250ZXh0MTAsIF9jb250ZXh0MTEsIF9jb250ZXh0MTIsIF9jb250ZXh0MTM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW50ZXJhY3Rpb25IYW5kbGVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyID0gc2VsZWN0aW9uSGFuZGxlcjtcbiAgICB0aGlzLm5hdmlnYXRpb25IYW5kbGVyID0gbmV3IE5hdmlnYXRpb25IYW5kbGVyKGJvZHksIGNhbnZhcyk7IC8vIGJpbmQgdGhlIGV2ZW50cyBmcm9tIGhhbW1lciB0byBmdW5jdGlvbnMgaW4gdGhpcyBvYmplY3RcblxuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblRhcCA9IGJpbmQkNihfY29udGV4dCA9IHRoaXMub25UYXApLmNhbGwoX2NvbnRleHQsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblRvdWNoID0gYmluZCQ2KF9jb250ZXh0MiA9IHRoaXMub25Ub3VjaCkuY2FsbChfY29udGV4dDIsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRvdWJsZVRhcCA9IGJpbmQkNihfY29udGV4dDMgPSB0aGlzLm9uRG91YmxlVGFwKS5jYWxsKF9jb250ZXh0MywgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uSG9sZCA9IGJpbmQkNihfY29udGV4dDQgPSB0aGlzLm9uSG9sZCkuY2FsbChfY29udGV4dDQsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdTdGFydCA9IGJpbmQkNihfY29udGV4dDUgPSB0aGlzLm9uRHJhZ1N0YXJ0KS5jYWxsKF9jb250ZXh0NSwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZyA9IGJpbmQkNihfY29udGV4dDYgPSB0aGlzLm9uRHJhZykuY2FsbChfY29udGV4dDYsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdFbmQgPSBiaW5kJDYoX2NvbnRleHQ3ID0gdGhpcy5vbkRyYWdFbmQpLmNhbGwoX2NvbnRleHQ3LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZVdoZWVsID0gYmluZCQ2KF9jb250ZXh0OCA9IHRoaXMub25Nb3VzZVdoZWVsKS5jYWxsKF9jb250ZXh0OCwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUGluY2ggPSBiaW5kJDYoX2NvbnRleHQ5ID0gdGhpcy5vblBpbmNoKS5jYWxsKF9jb250ZXh0OSwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uTW91c2VNb3ZlID0gYmluZCQ2KF9jb250ZXh0MTAgPSB0aGlzLm9uTW91c2VNb3ZlKS5jYWxsKF9jb250ZXh0MTAsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblJlbGVhc2UgPSBiaW5kJDYoX2NvbnRleHQxMSA9IHRoaXMub25SZWxlYXNlKS5jYWxsKF9jb250ZXh0MTEsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkNvbnRleHQgPSBiaW5kJDYoX2NvbnRleHQxMiA9IHRoaXMub25Db250ZXh0KS5jYWxsKF9jb250ZXh0MTIsIHRoaXMpO1xuICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICB0aGlzLmRyYWcgPSB7fTtcbiAgICB0aGlzLnBpbmNoID0ge307XG4gICAgdGhpcy5wb3B1cCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvcHVwT2JqID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9wdXBUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIgPSBiaW5kJDYoX2NvbnRleHQxMyA9IHRoaXMuZ2V0UG9pbnRlcikuY2FsbChfY29udGV4dDEzLCB0aGlzKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZHJhZ05vZGVzOiB0cnVlLFxuICAgICAgZHJhZ1ZpZXc6IHRydWUsXG4gICAgICBob3ZlcjogZmFsc2UsXG4gICAgICBrZXlib2FyZDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgc3BlZWQ6IHtcbiAgICAgICAgICB4OiAxMCxcbiAgICAgICAgICB5OiAxMCxcbiAgICAgICAgICB6b29tOiAwLjAyXG4gICAgICAgIH0sXG4gICAgICAgIGJpbmRUb1dpbmRvdzogdHJ1ZSxcbiAgICAgICAgYXV0b0ZvY3VzOiB0cnVlXG4gICAgICB9LFxuICAgICAgbmF2aWdhdGlvbkJ1dHRvbnM6IGZhbHNlLFxuICAgICAgdG9vbHRpcERlbGF5OiAzMDAsXG4gICAgICB6b29tVmlldzogdHJ1ZSxcbiAgICAgIHpvb21TcGVlZDogMVxuICAgIH07XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEludGVyYWN0aW9uSGFuZGxlciwgW3tcbiAgICBrZXk6IFwiYmluZEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5wb3B1cFRpbWVyKTtcbiAgICAgICAgZGVsZXRlIF90aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZXh0ZW5kIGFsbCBidXQgdGhlIHZhbHVlcyBpbiBmaWVsZHNcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtcImhpZGVFZGdlc09uRHJhZ1wiLCBcImhpZGVFZGdlc09uWm9vbVwiLCBcImhpZGVOb2Rlc09uRHJhZ1wiLCBcImtleWJvYXJkXCIsIFwibXVsdGlzZWxlY3RcIiwgXCJzZWxlY3RhYmxlXCIsIFwic2VsZWN0Q29ubmVjdGVkRWRnZXNcIl07XG4gICAgICAgIHNlbGVjdGl2ZU5vdERlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBtZXJnZSB0aGUga2V5Ym9hcmQgb3B0aW9ucyBpbi5cblxuICAgICAgICBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCBcImtleWJvYXJkXCIpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXApIHtcbiAgICAgICAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMudG9vbHRpcCwgb3B0aW9ucy50b29sdGlwKTtcblxuICAgICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXAuY29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy50b29sdGlwLmNvbG9yID0gcGFyc2VDb2xvcihvcHRpb25zLnRvb2x0aXAuY29sb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm5hdmlnYXRpb25IYW5kbGVyLnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwb2ludGVyIGxvY2F0aW9uIGZyb20gYSB0b3VjaCBsb2NhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSB0b3VjaFxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnRlcih0b3VjaCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdG91Y2gueCAtIGdldEFic29sdXRlTGVmdCh0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMpLFxuICAgICAgICB5OiB0b3VjaC55IC0gZ2V0QWJzb2x1dGVUb3AodGhpcy5jYW52YXMuZnJhbWUuY2FudmFzKVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT24gc3RhcnQgb2YgYSB0b3VjaCBnZXN0dXJlLCBzdG9yZSB0aGUgcG9pbnRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uVG91Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Ub3VjaChldmVudCkge1xuICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy50b3VjaFRpbWUgPiA1MCkge1xuICAgICAgICB0aGlzLmRyYWcucG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB0aGlzLmRyYWcucGluY2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBpbmNoLnNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7IC8vIHRvIGF2b2lkIGRvdWJsZSBmaXJlaW5nIG9mIHRoaXMgZXZlbnQgYmVjYXVzZSB3ZSBoYXZlIHR3byBoYW1tZXIgaW5zdGFuY2VzLiAob24gY2FudmFzIGFuZCBvbiBmcmFtZSlcblxuICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgdGFwL2NsaWNrIGV2ZW50OiBzZWxlY3QvdW5zZWxlY3QgYSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblRhcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblRhcChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBtdWx0aXNlbGVjdCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5vcHRpb25zLm11bHRpc2VsZWN0ICYmIChldmVudC5jaGFuZ2VkUG9pbnRlcnNbMF0uY3RybEtleSB8fCBldmVudC5jaGFuZ2VkUG9pbnRlcnNbMF0ubWV0YUtleSk7XG4gICAgICB0aGlzLmNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhwb2ludGVyLCBtdWx0aXNlbGVjdCk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuY29tbWl0QW5kRW1pdChwb2ludGVyLCBldmVudCk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiY2xpY2tcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgZG91YmxldGFwIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkRvdWJsZVRhcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRvdWJsZVRhcChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkb3VibGVDbGlja1wiLCBldmVudCwgcG9pbnRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGhhbmRsZSBsb25nIHRhcCBldmVudDogbXVsdGkgc2VsZWN0IG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkhvbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Ib2xkKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdmFyIG11bHRpc2VsZWN0ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLm9wdGlvbnMubXVsdGlzZWxlY3Q7XG4gICAgICB0aGlzLmNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhwb2ludGVyLCBtdWx0aXNlbGVjdCk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuY29tbWl0QW5kRW1pdChwb2ludGVyLCBldmVudCk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiY2xpY2tcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImhvbGRcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgdGhlIHJlbGVhc2Ugb2YgdGhlIHNjcmVlblxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25SZWxlYXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVsZWFzZShldmVudCkge1xuICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy50b3VjaFRpbWUgPiAxMCkge1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwicmVsZWFzZVwiLCBldmVudCwgcG9pbnRlcik7IC8vIHRvIGF2b2lkIGRvdWJsZSBmaXJlaW5nIG9mIHRoaXMgZXZlbnQgYmVjYXVzZSB3ZSBoYXZlIHR3byBoYW1tZXIgaW5zdGFuY2VzLiAob24gY2FudmFzIGFuZCBvbiBmcmFtZSlcblxuICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Db250ZXh0KGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcih7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcIm9uY29udGV4dFwiLCBldmVudCwgcG9pbnRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhbmQgZGVzZWxlY3Qgbm9kZXMgZGVwZW5kaW5nIGN1cnJlbnQgc2VsZWN0aW9uIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FkZD1mYWxzZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrU2VsZWN0aW9uQ2hhbmdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1NlbGVjdGlvbkNoYW5nZXMocG9pbnRlcikge1xuICAgICAgdmFyIGFkZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIGlmIChhZGQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdEFkZGl0aW9uYWxPblBvaW50KHBvaW50ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE9uUG9pbnQocG9pbnRlcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgbm9kZSBhbmQgZWRnZSBpZCdzIGZyb20gdGhlIGZpcnN0IHNldCB0aGF0IGFyZSBwcmVzZW50IGluIHRoZSBzZWNvbmQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7bm9kZXM6IEFycmF5LjxOb2RlPiwgZWRnZXM6IEFycmF5Ljx2aXMuRWRnZT59fSBmaXJzdFNldFxuICAgICAqIEBwYXJhbSB7e25vZGVzOiBBcnJheS48Tm9kZT4sIGVkZ2VzOiBBcnJheS48dmlzLkVkZ2U+fX0gc2Vjb25kU2V0XG4gICAgICogQHJldHVybnMge3tub2RlczogQXJyYXkuPE5vZGU+LCBlZGdlczogQXJyYXkuPHZpcy5FZGdlPn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXRlcm1pbmVEaWZmZXJlbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVEaWZmZXJlbmNlKGZpcnN0U2V0LCBzZWNvbmRTZXQpIHtcbiAgICAgIHZhciBhcnJheURpZmYgPSBmdW5jdGlvbiBhcnJheURpZmYoZmlyc3RBcnIsIHNlY29uZEFycikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXJzdEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGZpcnN0QXJyW2ldO1xuXG4gICAgICAgICAgaWYgKGluZGV4T2Yoc2Vjb25kQXJyKS5jYWxsKHNlY29uZEFyciwgdmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlczogYXJyYXlEaWZmKGZpcnN0U2V0Lm5vZGVzLCBzZWNvbmRTZXQubm9kZXMpLFxuICAgICAgICBlZGdlczogYXJyYXlEaWZmKGZpcnN0U2V0LmVkZ2VzLCBzZWNvbmRTZXQuZWRnZXMpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBvbkRyYWdTdGFydC5cbiAgICAgKiBJdCBpcyBzZXBhcmF0ZWQgb3V0IGJlY2F1c2Ugd2UgY2FuIHRoZW4gb3ZlcmxvYWQgaXQgZm9yIHRoZSBkYXRhbWFuaXB1bGF0aW9uIHN5c3RlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uRHJhZ1N0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGRyYWdnaW5nLCBkbyBub3Qgc3RhcnRcbiAgICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBvbiB0b3VjaCBzY3JlZW5zIHdpdGggbXVsdGlwbGUgZmluZ2Vyc1xuICAgICAgaWYgKHRoaXMuZHJhZy5kcmFnZ2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vaW4gY2FzZSB0aGUgdG91Y2ggZXZlbnQgd2FzIHRyaWdnZXJlZCBvbiBhbiBleHRlcm5hbCBkaXYsIGRvIHRoZSBpbml0aWFsIHRvdWNoIG5vdy5cblxuXG4gICAgICBpZiAodGhpcy5kcmFnLnBvaW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm9uVG91Y2goZXZlbnQpO1xuICAgICAgfSAvLyBub3RlOiBkcmFnLnBvaW50ZXIgaXMgc2V0IGluIG9uVG91Y2ggdG8gZ2V0IHRoZSBpbml0aWFsIHRvdWNoIGxvY2F0aW9uXG5cblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHRoaXMuZHJhZy5wb2ludGVyKTtcbiAgICAgIHRoaXMuZHJhZy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLmRyYWcuc2VsZWN0aW9uID0gW107XG4gICAgICB0aGlzLmRyYWcudHJhbnNsYXRpb24gPSBhc3NpZ24kMih7fSwgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24pOyAvLyBjb3B5IHRoZSBvYmplY3RcblxuICAgICAgdGhpcy5kcmFnLm5vZGVJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGV2ZW50LnNyY0V2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgIHRoaXMuYm9keS5zZWxlY3Rpb25Cb3guc2hvdyA9IHRydWU7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQgPSB7XG4gICAgICAgICAgeDogdGhpcy5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci54KSxcbiAgICAgICAgICB5OiB0aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLnkpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uZW5kID0ge1xuICAgICAgICAgIHg6IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCksXG4gICAgICAgICAgeTogdGhpcy5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci55KVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy5kcmFnTm9kZXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5kcmFnLm5vZGVJZCA9IG5vZGUuaWQ7IC8vIHNlbGVjdCB0aGUgY2xpY2tlZCBub2RlIGlmIG5vdCB5ZXQgc2VsZWN0ZWRcblxuICAgICAgICBpZiAobm9kZS5pc1NlbGVjdGVkKCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICBub2RlczogW25vZGUuaWRdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gYWZ0ZXIgc2VsZWN0IHRvIGNvbnRhaW4gdGhlIG5vZGVcblxuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnU3RhcnRcIiwgZXZlbnQsIHRoaXMuZHJhZy5wb2ludGVyKTsgLy8gY3JlYXRlIGFuIGFycmF5IHdpdGggdGhlIHNlbGVjdGVkIG5vZGVzIGFuZCB0aGVpciBvcmlnaW5hbCBsb2NhdGlvbiBhbmQgc3RhdHVzXG5cbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQodGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZXMoKSksXG4gICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgX25vZGUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBzID0ge1xuICAgICAgICAgICAgICBpZDogX25vZGUuaWQsXG4gICAgICAgICAgICAgIG5vZGU6IF9ub2RlLFxuICAgICAgICAgICAgICAvLyBzdG9yZSBvcmlnaW5hbCB4LCB5LCB4Rml4ZWQgYW5kIHlGaXhlZCwgbWFrZSB0aGUgbm9kZSB0ZW1wb3JhcmlseSBGaXhlZFxuICAgICAgICAgICAgICB4OiBfbm9kZS54LFxuICAgICAgICAgICAgICB5OiBfbm9kZS55LFxuICAgICAgICAgICAgICB4Rml4ZWQ6IF9ub2RlLm9wdGlvbnMuZml4ZWQueCxcbiAgICAgICAgICAgICAgeUZpeGVkOiBfbm9kZS5vcHRpb25zLmZpeGVkLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfbm9kZS5vcHRpb25zLmZpeGVkLnggPSB0cnVlO1xuICAgICAgICAgICAgX25vZGUub3B0aW9ucy5maXhlZC55ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZy5zZWxlY3Rpb24ucHVzaChzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgaWYgbm8gbm9kZSBpcyBzZWxlY3RlZCBhbmQgdGh1cyB0aGUgdmlldyBpcyBkcmFnZ2VkLlxuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ1N0YXJ0XCIsIGV2ZW50LCB0aGlzLmRyYWcucG9pbnRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogaGFuZGxlIGRyYWcgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uRHJhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWcoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5kcmFnLnBpbmNoZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyByZW1vdmUgdGhlIGZvY3VzIG9uIG5vZGUgaWYgaXQgaXMgZm9jdXNzZWQgb24gYnkgdGhlIGZvY3VzT25Ob2RlXG5cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInVubG9ja05vZGVcIik7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZHJhZy5zZWxlY3Rpb247XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmxlbmd0aCAmJiB0aGlzLm9wdGlvbnMuZHJhZ05vZGVzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnZ2luZ1wiLCBldmVudCwgcG9pbnRlcik7IC8vIGNhbGN1bGF0ZSBkZWx0YSdzIGFuZCBuZXcgbG9jYXRpb25cblxuICAgICAgICB2YXIgZGVsdGFYID0gcG9pbnRlci54IC0gdGhpcy5kcmFnLnBvaW50ZXIueDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IHBvaW50ZXIueSAtIHRoaXMuZHJhZy5wb2ludGVyLnk7IC8vIHVwZGF0ZSBwb3NpdGlvbiBvZiBhbGwgc2VsZWN0ZWQgbm9kZXNcblxuICAgICAgICBmb3JFYWNoJDIoc2VsZWN0aW9uKS5jYWxsKHNlbGVjdGlvbiwgZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBub2RlID0gc2VsZWN0aW9uLm5vZGU7IC8vIG9ubHkgbW92ZSB0aGUgbm9kZSBpZiBpdCB3YXMgbm90IGZpeGVkIGluaXRpYWxseVxuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbi54Rml4ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBub2RlLnggPSBfdGhpczIuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKF90aGlzMi5jYW52YXMuX1hjb252ZXJ0Q2FudmFzVG9ET00oc2VsZWN0aW9uLngpICsgZGVsdGFYKTtcbiAgICAgICAgICB9IC8vIG9ubHkgbW92ZSB0aGUgbm9kZSBpZiBpdCB3YXMgbm90IGZpeGVkIGluaXRpYWxseVxuXG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uLnlGaXhlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUueSA9IF90aGlzMi5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMoX3RoaXMyLmNhbnZhcy5fWWNvbnZlcnRDYW52YXNUb0RPTShzZWxlY3Rpb24ueSkgKyBkZWx0YVkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIHN0YXJ0IHRoZSBzaW11bGF0aW9uIG9mIHRoZSBwaHlzaWNzXG5cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIHNlbGVjdGlvbiBib3hcbiAgICAgICAgaWYgKGV2ZW50LnNyY0V2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdnaW5nXCIsIGV2ZW50LCBwb2ludGVyLCB1bmRlZmluZWQsIHRydWUpOyAvLyBpZiB0aGUgZHJhZyB3YXMgbm90IHN0YXJ0ZWQgcHJvcGVybHkgYmVjYXVzZSB0aGUgY2xpY2sgc3RhcnRlZCBvdXRzaWRlIHRoZSBuZXR3b3JrIGRpdiwgc3RhcnQgaXQgbm93LlxuXG4gICAgICAgICAgaWYgKHRoaXMuZHJhZy5wb2ludGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25EcmFnU3RhcnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uZW5kID0ge1xuICAgICAgICAgICAgeDogdGhpcy5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci54KSxcbiAgICAgICAgICAgIHk6IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgfSAvLyBtb3ZlIHRoZSBuZXR3b3JrXG5cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRyYWdWaWV3ID09PSB0cnVlICYmICFldmVudC5zcmNFdmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnZ2luZ1wiLCBldmVudCwgcG9pbnRlciwgdW5kZWZpbmVkLCB0cnVlKTsgLy8gaWYgdGhlIGRyYWcgd2FzIG5vdCBzdGFydGVkIHByb3Blcmx5IGJlY2F1c2UgdGhlIGNsaWNrIHN0YXJ0ZWQgb3V0c2lkZSB0aGUgbmV0d29yayBkaXYsIHN0YXJ0IGl0IG5vdy5cblxuICAgICAgICAgIGlmICh0aGlzLmRyYWcucG9pbnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uRHJhZ1N0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGlmZlggPSBwb2ludGVyLnggLSB0aGlzLmRyYWcucG9pbnRlci54O1xuICAgICAgICAgIHZhciBkaWZmWSA9IHBvaW50ZXIueSAtIHRoaXMuZHJhZy5wb2ludGVyLnk7XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgICAgICB4OiB0aGlzLmRyYWcudHJhbnNsYXRpb24ueCArIGRpZmZYLFxuICAgICAgICAgICAgeTogdGhpcy5kcmFnLnRyYW5zbGF0aW9uLnkgKyBkaWZmWVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGhhbmRsZSBkcmFnIHN0YXJ0IGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkRyYWdFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5kcmFnLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnNob3cpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MTQ7XG5cbiAgICAgICAgdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5zaG93ID0gZmFsc2U7XG4gICAgICAgIHZhciBzZWxlY3Rpb25Cb3hQb3NpdGlvbiA9IHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb247XG4gICAgICAgIHZhciBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heCA9IHtcbiAgICAgICAgICBtaW5YOiBNYXRoLm1pbihzZWxlY3Rpb25Cb3hQb3NpdGlvbi5zdGFydC54LCBzZWxlY3Rpb25Cb3hQb3NpdGlvbi5lbmQueCksXG4gICAgICAgICAgbWluWTogTWF0aC5taW4oc2VsZWN0aW9uQm94UG9zaXRpb24uc3RhcnQueSwgc2VsZWN0aW9uQm94UG9zaXRpb24uZW5kLnkpLFxuICAgICAgICAgIG1heFg6IE1hdGgubWF4KHNlbGVjdGlvbkJveFBvc2l0aW9uLnN0YXJ0LngsIHNlbGVjdGlvbkJveFBvc2l0aW9uLmVuZC54KSxcbiAgICAgICAgICBtYXhZOiBNYXRoLm1heChzZWxlY3Rpb25Cb3hQb3NpdGlvbi5zdGFydC55LCBzZWxlY3Rpb25Cb3hQb3NpdGlvbi5lbmQueSlcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdG9CZVNlbGVjdGVkTm9kZXMgPSBmaWx0ZXIoX2NvbnRleHQxNCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcykuY2FsbChfY29udGV4dDE0LCBmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBfdGhpczMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIHJldHVybiBub2RlLnggPj0gc2VsZWN0aW9uQm94UG9zaXRpb25NaW5NYXgubWluWCAmJiBub2RlLnggPD0gc2VsZWN0aW9uQm94UG9zaXRpb25NaW5NYXgubWF4WCAmJiBub2RlLnkgPj0gc2VsZWN0aW9uQm94UG9zaXRpb25NaW5NYXgubWluWSAmJiBub2RlLnkgPD0gc2VsZWN0aW9uQm94UG9zaXRpb25NaW5NYXgubWF4WTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yRWFjaCQyKHRvQmVTZWxlY3RlZE5vZGVzKS5jYWxsKHRvQmVTZWxlY3RlZE5vZGVzLCBmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE9iamVjdChfdGhpczMuYm9keS5ub2Rlc1tub2RlSWRdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmNvbW1pdEFuZEVtaXQocG9pbnRlciwgZXZlbnQpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ0VuZFwiLCBldmVudCwgdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlciksIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmRyYWcuc2VsZWN0aW9uO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgIGZvckVhY2gkMihzZWxlY3Rpb24pLmNhbGwoc2VsZWN0aW9uLCBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCB4Rml4ZWQgYW5kIHlGaXhlZFxuICAgICAgICAgICAgcy5ub2RlLm9wdGlvbnMuZml4ZWQueCA9IHMueEZpeGVkO1xuICAgICAgICAgICAgcy5ub2RlLm9wdGlvbnMuZml4ZWQueSA9IHMueUZpeGVkO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdFbmRcIiwgZXZlbnQsIHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnRW5kXCIsIGV2ZW50LCB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHBpbmNoIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25QaW5jaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblBpbmNoKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdGhpcy5kcmFnLnBpbmNoZWQgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5waW5jaFtcInNjYWxlXCJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5waW5jaC5zY2FsZSA9IDE7XG4gICAgICB9IC8vIFRPRE86IGVuYWJsZWQgbW92aW5nIHdoaWxlIHBpbmNoaW5nP1xuXG5cbiAgICAgIHZhciBzY2FsZSA9IHRoaXMucGluY2guc2NhbGUgKiBldmVudC5zY2FsZTtcbiAgICAgIHRoaXMuem9vbShzY2FsZSwgcG9pbnRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFpvb20gdGhlIG5ldHdvcmsgaW4gb3Igb3V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgYSBudW1iZXIgYXJvdW5kIDEsIGFuZCBiZXR3ZWVuIDAuMDEgYW5kIDEwXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyICAgIFBvc2l0aW9uIG9uIHNjcmVlblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ6b29tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb20oc2NhbGUsIHBvaW50ZXIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbVZpZXcgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIHNjYWxlT2xkID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG5cbiAgICAgICAgaWYgKHNjYWxlIDwgMC4wMDAwMSkge1xuICAgICAgICAgIHNjYWxlID0gMC4wMDAwMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2FsZSA+IDEwKSB7XG4gICAgICAgICAgc2NhbGUgPSAxMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmVTY2FsZURyYWdQb2ludGVyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICh0aGlzLmRyYWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLmRyYWcuZHJhZ2dpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHByZVNjYWxlRHJhZ1BvaW50ZXIgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh0aGlzLmRyYWcucG9pbnRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vICsgdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAvIDJcblxuXG4gICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuICAgICAgICB2YXIgc2NhbGVGcmFjID0gc2NhbGUgLyBzY2FsZU9sZDtcbiAgICAgICAgdmFyIHR4ID0gKDEgLSBzY2FsZUZyYWMpICogcG9pbnRlci54ICsgdHJhbnNsYXRpb24ueCAqIHNjYWxlRnJhYztcbiAgICAgICAgdmFyIHR5ID0gKDEgLSBzY2FsZUZyYWMpICogcG9pbnRlci55ICsgdHJhbnNsYXRpb24ueSAqIHNjYWxlRnJhYztcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgICAgeDogdHgsXG4gICAgICAgICAgeTogdHlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocHJlU2NhbGVEcmFnUG9pbnRlciAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgcG9zdFNjYWxlRHJhZ1BvaW50ZXIgPSB0aGlzLmNhbnZhcy5jYW52YXNUb0RPTShwcmVTY2FsZURyYWdQb2ludGVyKTtcbiAgICAgICAgICB0aGlzLmRyYWcucG9pbnRlci54ID0gcG9zdFNjYWxlRHJhZ1BvaW50ZXIueDtcbiAgICAgICAgICB0aGlzLmRyYWcucG9pbnRlci55ID0gcG9zdFNjYWxlRHJhZ1BvaW50ZXIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcblxuICAgICAgICBpZiAoc2NhbGVPbGQgPCBzY2FsZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ6b29tXCIsIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCIrXCIsXG4gICAgICAgICAgICBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUsXG4gICAgICAgICAgICBwb2ludGVyOiBwb2ludGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInpvb21cIiwge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiBcIi1cIixcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLmJvZHkudmlldy5zY2FsZSxcbiAgICAgICAgICAgIHBvaW50ZXI6IHBvaW50ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyIGZvciBtb3VzZSB3aGVlbCBldmVudCwgdXNlZCB0byB6b29tIHRoZSB0aW1lbGluZVxuICAgICAqIFNlZSBodHRwOi8vYWRvbWFzLm9yZy9qYXZhc2NyaXB0LW1vdXNlLXdoZWVsL1xuICAgICAqICAgICBodHRwczovL2dpdGh1Yi5jb20vRWlnaHRNZWRpYS9oYW1tZXIuanMvaXNzdWVzLzI1NlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSAgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25Nb3VzZVdoZWVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VXaGVlbChldmVudCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy56b29tVmlldyA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBJZiBkZWx0YSBpcyBub256ZXJvLCBoYW5kbGUgaXQuXG4gICAgICAgIC8vIEJhc2ljYWxseSwgZGVsdGEgaXMgbm93IHBvc2l0aXZlIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCB1cCxcbiAgICAgICAgLy8gYW5kIG5lZ2F0aXZlLCBpZiB3aGVlbCB3YXMgc2Nyb2xsZWQgZG93bi5cbiAgICAgICAgaWYgKGV2ZW50LmRlbHRhWSAhPT0gMCkge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbmV3IHNjYWxlXG4gICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgICAgc2NhbGUgKj0gMSArIChldmVudC5kZWx0YVkgPCAwID8gMSA6IC0xKSAqICh0aGlzLm9wdGlvbnMuem9vbVNwZWVkICogMC4xKTsgLy8gY2FsY3VsYXRlIHRoZSBwb2ludGVyIGxvY2F0aW9uXG5cbiAgICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcih7XG4gICAgICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgICAgIH0pOyAvLyBhcHBseSB0aGUgbmV3IHNjYWxlXG5cbiAgICAgICAgICB0aGlzLnpvb20oc2NhbGUsIHBvaW50ZXIpO1xuICAgICAgICB9IC8vIFByZXZlbnQgZGVmYXVsdCBhY3Rpb25zIGNhdXNlZCBieSBtb3VzZSB3aGVlbC5cblxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdXNlIG1vdmUgaGFuZGxlciBmb3IgY2hlY2tpbmcgd2hldGhlciB0aGUgdGl0bGUgbW92ZXMgb3ZlciBhIG5vZGUgd2l0aCBhIHRpdGxlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uTW91c2VNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoe1xuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICB9KTtcbiAgICAgIHZhciBwb3B1cFZpc2libGUgPSBmYWxzZTsgLy8gY2hlY2sgaWYgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgbm9kZSBpcyBzdGlsbCBzZWxlY3RlZFxuXG4gICAgICBpZiAodGhpcy5wb3B1cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwLmhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLl9jaGVja0hpZGVQb3B1cChwb2ludGVyKTtcbiAgICAgICAgfSAvLyBpZiB0aGUgcG9wdXAgd2FzIG5vdCBoaWRkZW4gYWJvdmVcblxuXG4gICAgICAgIGlmICh0aGlzLnBvcHVwLmhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBwb3B1cFZpc2libGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucG9wdXAuc2V0UG9zaXRpb24ocG9pbnRlci54ICsgMywgcG9pbnRlci55IC0gNSk7XG4gICAgICAgICAgdGhpcy5wb3B1cC5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaWYgd2UgYmluZCB0aGUga2V5Ym9hcmQgdG8gdGhlIGRpdiwgd2UgaGF2ZSB0byBoaWdobGlnaHQgaXQgdG8gdXNlIGl0LiBUaGlzIGhpZ2hsaWdodHMgaXQgb24gbW91c2Ugb3Zlci5cblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmtleWJvYXJkLmF1dG9Gb2N1cyAmJiB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuYmluZFRvV2luZG93ID09PSBmYWxzZSAmJiB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5mb2N1cygpO1xuICAgICAgfSAvLyBzdGFydCBhIHRpbWVvdXQgdGhhdCB3aWxsIGNoZWNrIGlmIHRoZSBtb3VzZSBpcyBwb3NpdGlvbmVkIGFib3ZlIGFuIGVsZW1lbnRcblxuXG4gICAgICBpZiAocG9wdXBWaXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cFRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMucG9wdXBUaW1lcik7IC8vIHN0b3AgYW55IHJ1bm5pbmcgY2FsY3VsYXRpb25UaW1lclxuXG4gICAgICAgICAgdGhpcy5wb3B1cFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmRyYWcuZHJhZ2dpbmcpIHtcbiAgICAgICAgICB0aGlzLnBvcHVwVGltZXIgPSBzZXRUaW1lb3V0JDEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5fY2hlY2tTaG93UG9wdXAocG9pbnRlcik7XG4gICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnRvb2x0aXBEZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gYWRkaW5nIGhvdmVyIGhpZ2hsaWdodHNcblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5ob3Zlck9iamVjdChldmVudCwgcG9pbnRlcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIGFuIGVsZW1lbnQgb24gdGhlIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBuZXR3b3JrXG4gICAgICogKGEgbm9kZSBvciBlZGdlKS4gSWYgc28sIGFuZCBpZiB0aGlzIGVsZW1lbnQgaGFzIGEgdGl0bGUsXG4gICAgICogc2hvdyBhIHBvcHVwIHdpbmRvdyB3aXRoIGl0cyB0aXRsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLCB5Om51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrU2hvd1BvcHVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja1Nob3dQb3B1cChwb2ludGVyKSB7XG4gICAgICB2YXIgeCA9IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCk7XG5cbiAgICAgIHZhciB5ID0gdGhpcy5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci55KTtcblxuICAgICAgdmFyIHBvaW50ZXJPYmogPSB7XG4gICAgICAgIGxlZnQ6IHgsXG4gICAgICAgIHRvcDogeSxcbiAgICAgICAgcmlnaHQ6IHgsXG4gICAgICAgIGJvdHRvbTogeVxuICAgICAgfTtcbiAgICAgIHZhciBwcmV2aW91c1BvcHVwT2JqSWQgPSB0aGlzLnBvcHVwT2JqID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0aGlzLnBvcHVwT2JqLmlkO1xuICAgICAgdmFyIG5vZGVVbmRlckN1cnNvciA9IGZhbHNlO1xuICAgICAgdmFyIHBvcHVwVHlwZSA9IFwibm9kZVwiOyAvLyBjaGVjayBpZiBhIG5vZGUgaXMgdW5kZXIgdGhlIGN1cnNvci5cblxuICAgICAgaWYgKHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBzZWFyY2ggdGhlIG5vZGVzIGZvciBvdmVybGFwLCBzZWxlY3QgdGhlIHRvcCBvbmUgaW4gY2FzZSBvZiBtdWx0aXBsZSBub2Rlc1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBvdmVybGFwcGluZ05vZGVzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG5cbiAgICAgICAgICBpZiAobm9kZS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm9kZVVuZGVyQ3Vyc29yID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKG5vZGUuZ2V0VGl0bGUoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG92ZXJsYXBwaW5nTm9kZXMucHVzaChub2RlSW5kaWNlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJsYXBwaW5nTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBvdmVybGFwcGluZyBub2Rlcywgc2VsZWN0IHRoZSBsYXN0IG9uZSwgdGhpcyBpcyB0aGUgb25lIHdoaWNoIGlzIGRyYXduIG9uIHRvcCBvZiB0aGUgb3RoZXJzXG4gICAgICAgICAgdGhpcy5wb3B1cE9iaiA9IG5vZGVzW292ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXV07IC8vIGlmIHlvdSBob3ZlciBvdmVyIGEgbm9kZSwgdGhlIHRpdGxlIG9mIHRoZSBlZGdlIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBzaG93bi5cblxuICAgICAgICAgIG5vZGVVbmRlckN1cnNvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCAmJiBub2RlVW5kZXJDdXJzb3IgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIHNlYXJjaCB0aGUgZWRnZXMgZm9yIG92ZXJsYXBcbiAgICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzO1xuICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICAgIHZhciBlZGdlO1xuICAgICAgICB2YXIgb3ZlcmxhcHBpbmdFZGdlcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlZGdlSW5kaWNlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbX2ldXTtcblxuICAgICAgICAgIGlmIChlZGdlLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUgJiYgZWRnZS5nZXRUaXRsZSgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdFZGdlcy5wdXNoKGVkZ2VJbmRpY2VzW19pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJsYXBwaW5nRWRnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMucG9wdXBPYmogPSBlZGdlc1tvdmVybGFwcGluZ0VkZ2VzW292ZXJsYXBwaW5nRWRnZXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICAgIHBvcHVwVHlwZSA9IFwiZWRnZVwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBvcHVwT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2hvdyBwb3B1cCBtZXNzYWdlIHdpbmRvd1xuICAgICAgICBpZiAodGhpcy5wb3B1cE9iai5pZCAhPT0gcHJldmlvdXNQb3B1cE9iaklkKSB7XG4gICAgICAgICAgaWYgKHRoaXMucG9wdXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cCA9IG5ldyBQb3B1cCh0aGlzLmNhbnZhcy5mcmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wb3B1cC5wb3B1cFRhcmdldFR5cGUgPSBwb3B1cFR5cGU7XG4gICAgICAgICAgdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkID0gdGhpcy5wb3B1cE9iai5pZDsgLy8gYWRqdXN0IGEgc21hbGwgb2Zmc2V0IHN1Y2ggdGhhdCB0aGUgbW91c2UgY3Vyc29yIGlzIGxvY2F0ZWQgaW4gdGhlXG4gICAgICAgICAgLy8gYm90dG9tIGxlZnQgbG9jYXRpb24gb2YgdGhlIHBvcHVwLCBhbmQgeW91IGNhbiBlYXNpbHkgbW92ZSBvdmVyIHRoZVxuICAgICAgICAgIC8vIHBvcHVwIGFyZWFcblxuICAgICAgICAgIHRoaXMucG9wdXAuc2V0UG9zaXRpb24ocG9pbnRlci54ICsgMywgcG9pbnRlci55IC0gNSk7XG4gICAgICAgICAgdGhpcy5wb3B1cC5zZXRUZXh0KHRoaXMucG9wdXBPYmouZ2V0VGl0bGUoKSk7XG4gICAgICAgICAgdGhpcy5wb3B1cC5zaG93KCk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInNob3dQb3B1cFwiLCB0aGlzLnBvcHVwT2JqLmlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucG9wdXAuaGlkZSgpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJoaWRlUG9wdXBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBvcHVwIG11c3QgYmUgaGlkZGVuLCB3aGljaCBpcyB0aGUgY2FzZSB3aGVuIHRoZSBtb3VzZSBpcyBub1xuICAgICAqIGxvbmdlciBob3ZlcmluZyBvbiB0aGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4Om51bWJlciwgeTpudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jaGVja0hpZGVQb3B1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tIaWRlUG9wdXAocG9pbnRlcikge1xuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuXG4gICAgICB2YXIgc3RpbGxPbk9iaiA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5wb3B1cC5wb3B1cFRhcmdldFR5cGUgPT09IFwibm9kZVwiKSB7XG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3RpbGxPbk9iaiA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopOyAvLyBpZiB0aGUgbW91c2UgaXMgc3RpbGwgb25lIHRoZSBub2RlLCB3ZSBoYXZlIHRvIGNoZWNrIGlmIGl0IGlzIG5vdCBhbHNvIG9uIG9uZSB0aGF0IGlzIGRyYXduIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAvLyB3ZSBpbml0aWFsbHkgb25seSBjaGVjayBzdGlsbE9uT2JqIGJlY2F1c2UgdGhpcyBpcyBtdWNoIGZhc3Rlci5cblxuICAgICAgICAgIGlmIChzdGlsbE9uT2JqID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgb3Zlck5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHBvaW50ZXIpO1xuICAgICAgICAgICAgc3RpbGxPbk9iaiA9IG92ZXJOb2RlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG92ZXJOb2RlLmlkID09PSB0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdChwb2ludGVyKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0aWxsT25PYmogPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0aWxsT25PYmogPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucG9wdXBPYmogPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucG9wdXAuaGlkZSgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaGlkZVBvcHVwXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbnRlcmFjdGlvbkhhbmRsZXI7XG59KCk7XG5cbnZhciB1bmN1cnJ5VGhpcyQxID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciByZWRlZmluZUFsbCQxID0gcmVkZWZpbmVBbGwkMztcbnZhciBnZXRXZWFrRGF0YSA9IGludGVybmFsTWV0YWRhdGEuZXhwb3J0cy5nZXRXZWFrRGF0YTtcbnZhciBhbk9iamVjdCA9IGFuT2JqZWN0JGQ7XG52YXIgaXNPYmplY3QkMSA9IGlzT2JqZWN0JGo7XG52YXIgYW5JbnN0YW5jZSA9IGFuSW5zdGFuY2UkMztcbnZhciBpdGVyYXRlID0gaXRlcmF0ZSQzO1xudmFyIEFycmF5SXRlcmF0aW9uTW9kdWxlID0gYXJyYXlJdGVyYXRpb247XG52YXIgaGFzT3duID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yO1xudmFyIGZpbmQgPSBBcnJheUl0ZXJhdGlvbk1vZHVsZS5maW5kO1xudmFyIGZpbmRJbmRleCA9IEFycmF5SXRlcmF0aW9uTW9kdWxlLmZpbmRJbmRleDtcbnZhciBzcGxpY2UgPSB1bmN1cnJ5VGhpcyQxKFtdLnNwbGljZSk7XG52YXIgaWQgPSAwOyAvLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcblxudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoc3RvcmUpIHtcbiAgcmV0dXJuIHN0b3JlLmZyb3plbiB8fCAoc3RvcmUuZnJvemVuID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xuXG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbnRyaWVzID0gW107XG59O1xuXG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcbiAgcmV0dXJuIGZpbmQoc3RvcmUuZW50cmllcywgZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblxuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtlbHNlIHRoaXMuZW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4KHRoaXMuZW50cmllcywgZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZiAofmluZGV4KSBzcGxpY2UodGhpcy5lbnRyaWVzLCBpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xudmFyIGNvbGxlY3Rpb25XZWFrJDEgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIFByb3RvdHlwZSk7XG4gICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcbiAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcbiAgICAgICAgaWQ6IGlkKyssXG4gICAgICAgIGZyb3plbjogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB7XG4gICAgICAgIHRoYXQ6IHRoYXQsXG4gICAgICAgIEFTX0VOVFJJRVM6IElTX01BUFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIFByb3RvdHlwZSA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLnNldChrZXksIHZhbHVlKTtlbHNlIGRhdGFbc3RhdGUuaWRdID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgcmVkZWZpbmVBbGwkMShQcm90b3R5cGUsIHtcbiAgICAgIC8vIGB7IFdlYWtNYXAsIFdlYWtTZXQgfS5wcm90b3R5cGUuZGVsZXRlKGtleSlgIG1ldGhvZHNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha21hcC5wcm90b3R5cGUuZGVsZXRlXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWtzZXQucHJvdG90eXBlLmRlbGV0ZVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFpc09iamVjdCQxKGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiBoYXNPd24oZGF0YSwgc3RhdGUuaWQpICYmIGRlbGV0ZSBkYXRhW3N0YXRlLmlkXTtcbiAgICAgIH0sXG4gICAgICAvLyBgeyBXZWFrTWFwLCBXZWFrU2V0IH0ucHJvdG90eXBlLmhhcyhrZXkpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAucHJvdG90eXBlLmhhc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrc2V0LnByb3RvdHlwZS5oYXNcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIWlzT2JqZWN0JDEoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmIGhhc093bihkYXRhLCBzdGF0ZS5pZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwkMShQcm90b3R5cGUsIElTX01BUCA/IHtcbiAgICAgIC8vIGBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAucHJvdG90eXBlLmdldFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0JDEoa2V5KSkge1xuICAgICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcbiAgICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLmdldChrZXkpO1xuICAgICAgICAgIHJldHVybiBkYXRhID8gZGF0YVtzdGF0ZS5pZF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha21hcC5wcm90b3R5cGUuc2V0XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSA6IHtcbiAgICAgIC8vIGBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha3NldC5wcm90b3R5cGUuYWRkXG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIHZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cbn07XG5cbnZhciBnbG9iYWwkMSA9IGdsb2JhbCRQO1xudmFyIHVuY3VycnlUaGlzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciByZWRlZmluZUFsbCA9IHJlZGVmaW5lQWxsJDM7XG52YXIgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZSA9IGludGVybmFsTWV0YWRhdGEuZXhwb3J0cztcbnZhciBjb2xsZWN0aW9uID0gY29sbGVjdGlvbiQzO1xudmFyIGNvbGxlY3Rpb25XZWFrID0gY29sbGVjdGlvbldlYWskMTtcbnZhciBpc09iamVjdCA9IGlzT2JqZWN0JGo7XG52YXIgaXNFeHRlbnNpYmxlID0gb2JqZWN0SXNFeHRlbnNpYmxlO1xudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZS5lbmZvcmNlO1xudmFyIE5BVElWRV9XRUFLX01BUCA9IG5hdGl2ZVdlYWtNYXA7XG52YXIgSVNfSUUxMSA9ICFnbG9iYWwkMS5BY3RpdmVYT2JqZWN0ICYmICdBY3RpdmVYT2JqZWN0JyBpbiBnbG9iYWwkMTtcbnZhciBJbnRlcm5hbFdlYWtNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59OyAvLyBgV2Vha01hcGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha21hcC1jb25zdHJ1Y3RvclxuXG5cbnZhciAkV2Vha01hcCA9IGNvbGxlY3Rpb24oJ1dlYWtNYXAnLCB3cmFwcGVyLCBjb2xsZWN0aW9uV2Vhayk7IC8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbi8vIFdlIGNhbid0IHVzZSBmZWF0dXJlIGRldGVjdGlvbiBiZWNhdXNlIGl0IGNyYXNoIHNvbWUgb2xkIElFIGJ1aWxkc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ4NVxuXG5pZiAoTkFUSVZFX1dFQUtfTUFQICYmIElTX0lFMTEpIHtcbiAgSW50ZXJuYWxXZWFrTWFwID0gY29sbGVjdGlvbldlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgJ1dlYWtNYXAnLCB0cnVlKTtcbiAgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZS5lbmFibGUoKTtcbiAgdmFyIFdlYWtNYXBQcm90b3R5cGUgPSAkV2Vha01hcC5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVEZWxldGUgPSB1bmN1cnJ5VGhpcyhXZWFrTWFwUHJvdG90eXBlWydkZWxldGUnXSk7XG4gIHZhciBuYXRpdmVIYXMgPSB1bmN1cnJ5VGhpcyhXZWFrTWFwUHJvdG90eXBlLmhhcyk7XG4gIHZhciBuYXRpdmVHZXQgPSB1bmN1cnJ5VGhpcyhXZWFrTWFwUHJvdG90eXBlLmdldCk7XG4gIHZhciBuYXRpdmVTZXQgPSB1bmN1cnJ5VGhpcyhXZWFrTWFwUHJvdG90eXBlLnNldCk7XG4gIHJlZGVmaW5lQWxsKFdlYWtNYXBQcm90b3R5cGUsIHtcbiAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlRGVsZXRlKHRoaXMsIGtleSkgfHwgc3RhdGUuZnJvemVuWydkZWxldGUnXShrZXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmF0aXZlRGVsZXRlKHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUhhcyh0aGlzLCBrZXkpIHx8IHN0YXRlLmZyb3plbi5oYXMoa2V5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZUhhcyh0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVIYXModGhpcywga2V5KSA/IG5hdGl2ZUdldCh0aGlzLCBrZXkpIDogc3RhdGUuZnJvemVuLmdldChrZXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmF0aXZlR2V0KHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XG4gICAgICAgIG5hdGl2ZUhhcyh0aGlzLCBrZXkpID8gbmF0aXZlU2V0KHRoaXMsIGtleSwgdmFsdWUpIDogc3RhdGUuZnJvemVuLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBuYXRpdmVTZXQodGhpcywga2V5LCB2YWx1ZSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBwYXRoID0gcGF0aCR5O1xudmFyIHdlYWtNYXAkMiA9IHBhdGguV2Vha01hcDtcblxudmFyIHBhcmVudCQxID0gd2Vha01hcCQyO1xudmFyIHdlYWtNYXAkMSA9IHBhcmVudCQxO1xuXG52YXIgd2Vha01hcCA9IHdlYWtNYXAkMTtcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59XG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpLCB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2Ygc3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGdldEl0ZXJhdG9yTWV0aG9kJDEobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKGlzQXJyYXkkMihvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMyhvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQyOyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMyhvLCBtaW5MZW4pOyB2YXIgbiA9IHNsaWNlKF9jb250ZXh0MiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDIsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb20kMyhvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQzKG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMyhhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxudmFyIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3JfcHJldmlvdXNTZWxlY3Rpb24sIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBfU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2NvbW1pdEhhbmRsZXI7XG4vKipcclxuICogQHBhcmFtIHByZXZcclxuICogQHBhcmFtIG5leHRcclxuICovXG5cbmZ1bmN0aW9uIGRpZmZTZXRzKHByZXYsIG5leHQpIHtcbiAgdmFyIGRpZmYgPSBuZXcgc2V0KCk7XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMobmV4dCksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgaXRlbSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoIXByZXYuaGFzKGl0ZW0pKSB7XG4gICAgICAgIGRpZmYuYWRkKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgcmV0dXJuIGRpZmY7XG59XG5cbnZhciBTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcik7XG5cbiAgICBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uLnNldCh0aGlzLCBuZXcgc2V0KCkpO1xuXG4gICAgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24uc2V0KHRoaXMsIG5ldyBzZXQoKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yLCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgXCJmXCIpLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGl0ZW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9pdGVtcyA9IGl0ZW1zOyBfaSA8IF9pdGVtcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBfaXRlbXNbX2ldO1xuXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKS5hZGQoaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBpdGVtc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwLCBfaXRlbXMyID0gaXRlbXM7IF9pMiA8IF9pdGVtczIubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgaXRlbSA9IF9pdGVtczJbX2kyXTtcblxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIikuZGVsZXRlKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKS5jbGVhcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDaGFuZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoYW5nZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRlZDogX3RvQ29uc3VtYWJsZUFycmF5KGRpZmZTZXRzKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9wcmV2aW91c1NlbGVjdGlvbiwgXCJmXCIpLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIikpKSxcbiAgICAgICAgZGVsZXRlZDogX3RvQ29uc3VtYWJsZUFycmF5KGRpZmZTZXRzKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uLCBcImZcIikpKSxcbiAgICAgICAgcHJldmlvdXM6IF90b0NvbnN1bWFibGVBcnJheShuZXcgc2V0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9wcmV2aW91c1NlbGVjdGlvbiwgXCJmXCIpKSksXG4gICAgICAgIGN1cnJlbnQ6IF90b0NvbnN1bWFibGVBcnJheShuZXcgc2V0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKSkpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21taXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tbWl0KCkge1xuICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLmdldENoYW5nZXMoKTtcblxuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIiksIFwiZlwiKTtcblxuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgbmV3IHNldChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3JfcHJldmlvdXNTZWxlY3Rpb24sIFwiZlwiKSksIFwiZlwiKTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKGNoYW5nZXMuYWRkZWQpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICBpdGVtLnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKGNoYW5nZXMuZGVsZXRlZCksXG4gICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfaXRlbSA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgIF9pdGVtLnVuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yO1xufSgpO1xuXG5fU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uID0gbmV3IHdlYWtNYXAoKSwgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24gPSBuZXcgd2Vha01hcCgpO1xudmFyIFNlbGVjdGlvbkFjY3VtdWxhdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2VsZWN0aW9uQWNjdW11bGF0b3IoKSB7XG4gICAgdmFyIGNvbW1pdEhhbmRsZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbGVjdGlvbkFjY3VtdWxhdG9yKTtcblxuICAgIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9ub2Rlcy5zZXQodGhpcywgbmV3IFNpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcigpKTtcblxuICAgIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcy5zZXQodGhpcywgbmV3IFNpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcigpKTtcblxuICAgIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9jb21taXRIYW5kbGVyLnNldCh0aGlzLCB2b2lkIDApO1xuXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfY29tbWl0SGFuZGxlciwgY29tbWl0SGFuZGxlciwgXCJmXCIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNlbGVjdGlvbkFjY3VtdWxhdG9yLCBbe1xuICAgIGtleTogXCJzaXplTm9kZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9ub2RlcywgXCJmXCIpLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpemVFZGdlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Tm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZXMoKSB7XG4gICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMsIFwiZlwiKS5nZXRTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWRnZXMoKSB7XG4gICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfZWRnZXMsIFwiZlwiKS5nZXRTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTm9kZXMoKSB7XG4gICAgICB2YXIgX2NsYXNzUHJpdmF0ZUZpZWxkR2U7XG5cbiAgICAgIChfY2xhc3NQcml2YXRlRmllbGRHZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzLCBcImZcIikpLmFkZC5hcHBseShfY2xhc3NQcml2YXRlRmllbGRHZSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWRnZXMoKSB7XG4gICAgICB2YXIgX2NsYXNzUHJpdmF0ZUZpZWxkR2UyO1xuXG4gICAgICAoX2NsYXNzUHJpdmF0ZUZpZWxkR2UyID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfZWRnZXMsIFwiZlwiKSkuYWRkLmFwcGx5KF9jbGFzc1ByaXZhdGVGaWVsZEdlMiwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlTm9kZXMobm9kZSkge1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMsIFwiZlwiKS5kZWxldGUobm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZUVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUVkZ2VzKGVkZ2UpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzLCBcImZcIikuZGVsZXRlKGVkZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzLCBcImZcIikuY2xlYXIoKTtcblxuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfZWRnZXMsIFwiZlwiKS5jbGVhcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21taXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tbWl0KCkge1xuICAgICAgdmFyIF9jbGFzc1ByaXZhdGVGaWVsZEdlMywgX2NvbnRleHQ7XG5cbiAgICAgIHZhciBzdW1tYXJ5ID0ge1xuICAgICAgICBub2RlczogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMsIFwiZlwiKS5jb21taXQoKSxcbiAgICAgICAgZWRnZXM6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzLCBcImZcIikuY29tbWl0KClcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICByZXN0W19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIChfY2xhc3NQcml2YXRlRmllbGRHZTMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9jb21taXRIYW5kbGVyLCBcImZcIikpLmNhbGwuYXBwbHkoX2NsYXNzUHJpdmF0ZUZpZWxkR2UzLCBjb25jYXQoX2NvbnRleHQgPSBbdGhpcywgc3VtbWFyeV0pLmNhbGwoX2NvbnRleHQsIHJlc3QpKTtcblxuICAgICAgcmV0dXJuIHN1bW1hcnk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNlbGVjdGlvbkFjY3VtdWxhdG9yO1xufSgpO1xuX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzID0gbmV3IHdlYWtNYXAoKSwgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzID0gbmV3IHdlYWtNYXAoKSwgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2NvbW1pdEhhbmRsZXIgPSBuZXcgd2Vha01hcCgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBzeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0SXRlcmF0b3JNZXRob2QkMShvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoaXNBcnJheSQyKG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQyKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobywgbWluTGVuKSB7IHZhciBfY29udGV4dDM7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQyKG8sIG1pbkxlbik7IHZhciBuID0gc2xpY2UoX2NvbnRleHQzID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0MywgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbSQzKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDIobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQyKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuLyoqXG4gKiBUaGUgaGFuZGxlciBmb3Igc2VsZWN0aW9uc1xuICovXG5cbnZhciBTZWxlY3Rpb25IYW5kbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIFNlbGVjdGlvbkhhbmRsZXIoYm9keSwgY2FudmFzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWxlY3Rpb25IYW5kbGVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7IC8vIFRPRE86IENvbnNpZGVyIGZpcmluZyBhbiBldmVudCBvbiBhbnkgY2hhbmdlIHRvIHRoZSBzZWxlY3Rpb24sIG5vdFxuICAgIC8vIG9ubHkgdGhvc2UgY2F1c2VkIGJ5IGNsaWNrcyBhbmQgdGFwcy4gSXQgd291bGQgYmUgZWFzeSB0byBpbXBsZW1lbnRcbiAgICAvLyBub3cgYW5kIChhdCBsZWFzdCB0byBtZSkgaXQgc2VlbXMgbGlrZSBzb21ldGhpbmcgdGhhdCBjb3VsZCBiZVxuICAgIC8vIHF1aXRlIHVzZWZ1bC5cblxuICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yID0gbmV3IFNlbGVjdGlvbkFjY3VtdWxhdG9yKCk7XG4gICAgdGhpcy5ob3Zlck9iaiA9IHtcbiAgICAgIG5vZGVzOiB7fSxcbiAgICAgIGVkZ2VzOiB7fVxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIG11bHRpc2VsZWN0OiBmYWxzZSxcbiAgICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICBzZWxlY3RDb25uZWN0ZWRFZGdlczogdHJ1ZSxcbiAgICAgIGhvdmVyQ29ubmVjdGVkRWRnZXM6IHRydWVcbiAgICB9O1xuXG4gICAgYXNzaWduJDIodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFNlbGVjdGlvbkhhbmRsZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbXCJtdWx0aXNlbGVjdFwiLCBcImhvdmVyQ29ubmVjdGVkRWRnZXNcIiwgXCJzZWxlY3RhYmxlXCIsIFwic2VsZWN0Q29ubmVjdGVkRWRnZXNcIl07XG4gICAgICAgIHNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBoYW5kbGVzIHRoZSBzZWxlY3Rpb24gcGFydCBvZiB0aGUgdGFwO1xuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RPblBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE9uUG9pbnQocG9pbnRlcikge1xuICAgICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXROb2RlQXQocG9pbnRlcikgfHwgdGhpcy5nZXRFZGdlQXQocG9pbnRlcik7IC8vIHVuc2VsZWN0IGFmdGVyIGdldHRpbmcgdGhlIG9iamVjdHMgaW4gb3JkZXIgdG8gcmVzdG9yZSB3aWR0aCBhbmQgaGVpZ2h0LlxuXG4gICAgICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcblxuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0T2JqZWN0KG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdEFkZGl0aW9uYWxPblBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdEFkZGl0aW9uYWxPblBvaW50KHBvaW50ZXIpIHtcbiAgICAgIHZhciBzZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXROb2RlQXQocG9pbnRlcikgfHwgdGhpcy5nZXRFZGdlQXQocG9pbnRlcik7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAob2JqLmlzU2VsZWN0ZWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0aW9uQ2hhbmdlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzdGFuZGFyZCBmaWVsZHMgZm9yIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgT2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRCYXNlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRCYXNlRXZlbnQoZXZlbnQsIHBvaW50ZXIpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICBwcm9wZXJ0aWVzW1wicG9pbnRlclwiXSA9IHtcbiAgICAgICAgRE9NOiB7XG4gICAgICAgICAgeDogcG9pbnRlci54LFxuICAgICAgICAgIHk6IHBvaW50ZXIueVxuICAgICAgICB9LFxuICAgICAgICBjYW52YXM6IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHBvaW50ZXIpXG4gICAgICB9O1xuICAgICAgcHJvcGVydGllc1tcImV2ZW50XCJdID0gZXZlbnQ7XG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gZXZlbnQgd2hpY2ggdGhlIHVzZXIgY2FuIGNhdGNoLlxuICAgICAqXG4gICAgICogVGhpcyBhZGRzIHNvbWUgZXh0cmEgZGF0YSB0byB0aGUgZXZlbnQgd2l0aCByZXNwZWN0IHRvIGN1cnNvciBwb3NpdGlvbiBhbmRcbiAgICAgKiBzZWxlY3RlZCBub2RlcyBhbmQgZWRnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlICAgICAgICAgICAgICAgICAgICAgICAgICBOYW1lIG9mIGV2ZW50IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgICAgICAgICAgICBPYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBzY3JlZW4gY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICogQHBhcmFtIHtvYmplY3QgfCB1bmRlZmluZWR9IG9sZFNlbGVjdGlvbiAgICAgICAgICAgICBJZiBwcmVzZW50LCBzZWxlY3Rpb24gc3RhdGUgYmVmb3JlIGV2ZW50IG9jY3VyZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58dW5kZWZpbmVkfSBbZW1wdHlTZWxlY3Rpb249ZmFsc2VdICBJbmRpY2F0ZSBpZiBzZWxlY3Rpb24gZGF0YSBzaG91bGQgYmUgcGFzc2VkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZUNsaWNrRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVDbGlja0V2ZW50KGV2ZW50VHlwZSwgZXZlbnQsIHBvaW50ZXIsIG9sZFNlbGVjdGlvbikge1xuICAgICAgdmFyIGVtcHR5U2VsZWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9pbml0QmFzZUV2ZW50KGV2ZW50LCBwb2ludGVyKTtcblxuICAgICAgaWYgKGVtcHR5U2VsZWN0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIHByb3BlcnRpZXMubm9kZXMgPSBbXTtcbiAgICAgICAgcHJvcGVydGllcy5lZGdlcyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRtcCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHByb3BlcnRpZXMubm9kZXMgPSB0bXAubm9kZXM7XG4gICAgICAgIHByb3BlcnRpZXMuZWRnZXMgPSB0bXAuZWRnZXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChvbGRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wZXJ0aWVzW1wicHJldmlvdXNTZWxlY3Rpb25cIl0gPSBvbGRTZWxlY3Rpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudFR5cGUgPT0gXCJjbGlja1wiKSB7XG4gICAgICAgIC8vIEZvciB0aGUgdGltZSBiZWluZywgcmVzdHJpY3QgdGhpcyBmdW5jdGlvbmFsaXR5IHRvXG4gICAgICAgIC8vIGp1c3QgdGhlIGNsaWNrIGV2ZW50LlxuICAgICAgICBwcm9wZXJ0aWVzLml0ZW1zID0gdGhpcy5nZXRDbGlja2VkSXRlbXMocG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5jb250cm9sRWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BlcnRpZXMuY29udHJvbEVkZ2UgPSBldmVudC5jb250cm9sRWRnZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChldmVudFR5cGUsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoaWdobGlnaHRFZGdlcz10aGlzLm9wdGlvbnMuc2VsZWN0Q29ubmVjdGVkRWRnZXNdXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0T2JqZWN0KG9iaikge1xuICAgICAgdmFyIGhpZ2hsaWdodEVkZ2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLm9wdGlvbnMuc2VsZWN0Q29ubmVjdGVkRWRnZXM7XG5cbiAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIGlmIChoaWdobGlnaHRFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzJF9zZWxlY3Rpb25BY2N1bTtcblxuICAgICAgICAgICAgKF90aGlzJF9zZWxlY3Rpb25BY2N1bSA9IHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yKS5hZGRFZGdlcy5hcHBseShfdGhpcyRfc2VsZWN0aW9uQWNjdW0sIF90b0NvbnN1bWFibGVBcnJheShvYmouZWRnZXMpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5hZGROb2RlcyhvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmFkZEVkZ2VzKG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc2VsZWN0T2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2VsZWN0T2JqZWN0KG9iaikge1xuICAgICAgaWYgKG9iai5pc1NlbGVjdGVkKCkgPT09IHRydWUpIHtcbiAgICAgICAgb2JqLnNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbVNlbGVjdGlvbihvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXRyaWV2ZSBhbGwgbm9kZXMgb3ZlcmxhcHBpbmcgd2l0aCBnaXZlbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICogQHJldHVybnMge251bWJlcltdfSAgIEFuIGFycmF5IHdpdGggaWQncyBvZiB0aGUgb3ZlcmxhcHBpbmcgbm9kZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChvYmplY3QpIHtcbiAgICAgIHZhciBvdmVybGFwcGluZ05vZGVzID0gW107XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSB0aGlzLmJvZHkubm9kZUluZGljZXNbaV07XG5cbiAgICAgICAgaWYgKG5vZGVzW25vZGVJZF0uaXNPdmVybGFwcGluZ1dpdGgob2JqZWN0KSkge1xuICAgICAgICAgIG92ZXJsYXBwaW5nTm9kZXMucHVzaChub2RlSWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdmVybGFwcGluZ05vZGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBwb3NpdGlvbiBvYmplY3QgaW4gY2FudmFzc3BhY2UgZnJvbSBhIHNpbmdsZSBwb2ludCBpbiBzY3JlZW5zcGFjZVxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcikge1xuICAgICAgdmFyIGNhbnZhc1BvcyA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHBvaW50ZXIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogY2FudmFzUG9zLnggLSAxLFxuICAgICAgICB0b3A6IGNhbnZhc1Bvcy55ICsgMSxcbiAgICAgICAgcmlnaHQ6IGNhbnZhc1Bvcy54ICsgMSxcbiAgICAgICAgYm90dG9tOiBjYW52YXNQb3MueSAtIDFcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdG9wIG5vZGUgYXQgdGhlIHBhc3NlZCBwb2ludCAobGlrZSBhIGNsaWNrKVxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0dXJuTm9kZT10cnVlXVxuICAgICAqIEByZXR1cm5zIHtOb2RlIHwgdW5kZWZpbmVkfSBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXROb2RlQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZUF0KHBvaW50ZXIpIHtcbiAgICAgIHZhciByZXR1cm5Ob2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAvLyB3ZSBmaXJzdCBjaGVjayBpZiB0aGlzIGlzIGFuIG5hdmlnYXRpb24gY29udHJvbHMgZWxlbWVudFxuICAgICAgdmFyIHBvc2l0aW9uT2JqZWN0ID0gdGhpcy5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG5cbiAgICAgIHZhciBvdmVybGFwcGluZ05vZGVzID0gdGhpcy5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgocG9zaXRpb25PYmplY3QpOyAvLyBpZiB0aGVyZSBhcmUgb3ZlcmxhcHBpbmcgbm9kZXMsIHNlbGVjdCB0aGUgbGFzdCBvbmUsIHRoaXMgaXMgdGhlXG4gICAgICAvLyBvbmUgd2hpY2ggaXMgZHJhd24gb24gdG9wIG9mIHRoZSBvdGhlcnNcblxuXG4gICAgICBpZiAob3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChyZXR1cm5Ob2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1tvdmVybGFwcGluZ05vZGVzW292ZXJsYXBwaW5nTm9kZXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBvdmVybGFwcGluZ05vZGVzW292ZXJsYXBwaW5nTm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJldHJpZXZlIGFsbCBlZGdlcyBvdmVybGFwcGluZyB3aXRoIGdpdmVuIG9iamVjdCwgc2VsZWN0b3IgaXMgYXJvdW5kIGNlbnRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAgQW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBvdmVybGFwcGluZ0VkZ2VzIEFuIGFycmF5IHdpdGggaWQncyBvZiB0aGUgb3ZlcmxhcHBpbmcgbm9kZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEVkZ2VzT3ZlcmxhcHBpbmdXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QsIG92ZXJsYXBwaW5nRWRnZXMpIHtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkuZWRnZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2VJZCA9IHRoaXMuYm9keS5lZGdlSW5kaWNlc1tpXTtcblxuICAgICAgICBpZiAoZWRnZXNbZWRnZUlkXS5pc092ZXJsYXBwaW5nV2l0aChvYmplY3QpKSB7XG4gICAgICAgICAgb3ZlcmxhcHBpbmdFZGdlcy5wdXNoKGVkZ2VJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0cmlldmUgYWxsIG5vZGVzIG92ZXJsYXBwaW5nIHdpdGggZ2l2ZW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0ICBBbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gICBBbiBhcnJheSB3aXRoIGlkJ3Mgb2YgdGhlIG92ZXJsYXBwaW5nIG5vZGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRBbGxFZGdlc092ZXJsYXBwaW5nV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWxsRWRnZXNPdmVybGFwcGluZ1dpdGgob2JqZWN0KSB7XG4gICAgICB2YXIgb3ZlcmxhcHBpbmdFZGdlcyA9IFtdO1xuXG4gICAgICB0aGlzLl9nZXRFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QsIG92ZXJsYXBwaW5nRWRnZXMpO1xuXG4gICAgICByZXR1cm4gb3ZlcmxhcHBpbmdFZGdlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBlZGdlcyBuZWFyZXN0IHRvIHRoZSBwYXNzZWQgcG9pbnQgKGxpa2UgYSBjbGljaylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHVybkVkZ2U9dHJ1ZV1cbiAgICAgKiBAcmV0dXJucyB7RWRnZSB8IHVuZGVmaW5lZH0gbm9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWRnZUF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVkZ2VBdChwb2ludGVyKSB7XG4gICAgICB2YXIgcmV0dXJuRWRnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBlZGdlcywgcGljayBjbG9zZXN0IHdpdGhpbiAxMFxuICAgICAgdmFyIGNhbnZhc1BvcyA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHBvaW50ZXIpO1xuICAgICAgdmFyIG1pbmRpc3QgPSAxMDtcbiAgICAgIHZhciBvdmVybGFwcGluZ0VkZ2UgPSBudWxsO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5lZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZUlkID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzW2ldO1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJZF07XG5cbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkKSB7XG4gICAgICAgICAgdmFyIHhGcm9tID0gZWRnZS5mcm9tLng7XG4gICAgICAgICAgdmFyIHlGcm9tID0gZWRnZS5mcm9tLnk7XG4gICAgICAgICAgdmFyIHhUbyA9IGVkZ2UudG8ueDtcbiAgICAgICAgICB2YXIgeVRvID0gZWRnZS50by55O1xuICAgICAgICAgIHZhciBkaXN0ID0gZWRnZS5lZGdlVHlwZS5nZXREaXN0YW5jZVRvRWRnZSh4RnJvbSwgeUZyb20sIHhUbywgeVRvLCBjYW52YXNQb3MueCwgY2FudmFzUG9zLnkpO1xuXG4gICAgICAgICAgaWYgKGRpc3QgPCBtaW5kaXN0KSB7XG4gICAgICAgICAgICBvdmVybGFwcGluZ0VkZ2UgPSBlZGdlSWQ7XG4gICAgICAgICAgICBtaW5kaXN0ID0gZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG92ZXJsYXBwaW5nRWRnZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAocmV0dXJuRWRnZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuZWRnZXNbb3ZlcmxhcHBpbmdFZGdlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gb3ZlcmxhcHBpbmdFZGdlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgb2JqZWN0IHRvIHRoZSBzZWxlY3Rpb24gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRUb0hvdmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRUb0hvdmVyKG9iaikge1xuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgdGhpcy5ob3Zlck9iai5ub2Rlc1tvYmouaWRdID0gb2JqO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ob3Zlck9iai5lZGdlc1tvYmouaWRdID0gb2JqO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzaW5nbGUgb3B0aW9uIGZyb20gc2VsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlRnJvbVNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRnJvbVNlbGVjdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyRfc2VsZWN0aW9uQWNjdW0yO1xuXG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmRlbGV0ZU5vZGVzKG9iaik7XG5cbiAgICAgICAgKF90aGlzJF9zZWxlY3Rpb25BY2N1bTIgPSB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvcikuZGVsZXRlRWRnZXMuYXBwbHkoX3RoaXMkX3NlbGVjdGlvbkFjY3VtMiwgX3RvQ29uc3VtYWJsZUFycmF5KG9iai5lZGdlcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZGVsZXRlRWRnZXMob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zZWxlY3QgYWxsIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuc2VsZWN0QWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2VsZWN0QWxsKCkge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2VsZWN0ZWQgbm9kZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3RlZE5vZGVDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZE5vZGVDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5zaXplTm9kZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgbnVtYmVyIG9mIHNlbGVjdGVkIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0ZWRFZGdlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWRFZGdlQ291bnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3Iuc2l6ZUVkZ2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgdGhlIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hvdmVyQ29ubmVjdGVkRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hvdmVyQ29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcbiAgICAgICAgZWRnZS5ob3ZlciA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fYWRkVG9Ib3ZlcihlZGdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBoaWdobGlnaHQgZnJvbSBhIG5vZGUgb3IgZWRnZSwgaW4gcmVzcG9uc2UgdG8gbW91c2UgbW92ZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudFxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlciBvYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBzY3JlZW4gY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICogQHBhcmFtIHtOb2RlfHZpcy5FZGdlfSBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdEJsdXJFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0Qmx1ckV2ZW50KGV2ZW50LCBwb2ludGVyLCBvYmplY3QpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5faW5pdEJhc2VFdmVudChldmVudCwgcG9pbnRlcik7XG5cbiAgICAgIGlmIChvYmplY3QuaG92ZXIgPT09IHRydWUpIHtcbiAgICAgICAgb2JqZWN0LmhvdmVyID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLm5vZGUgPSBvYmplY3QuaWQ7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImJsdXJOb2RlXCIsIHByb3BlcnRpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BlcnRpZXMuZWRnZSA9IG9iamVjdC5pZDtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYmx1ckVkZ2VcIiwgcHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBoaWdobGlnaHQgZm9yIGEgbm9kZSBvciBlZGdlLCBpbiByZXNwb25zZSB0byBtb3VzZSBtb3ZlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyIG9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IHNjcmVlbiBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKiBAcGFyYW0ge05vZGV8dmlzLkVkZ2V9IG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBob3ZlckNoYW5nZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdEhvdmVyRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdEhvdmVyRXZlbnQoZXZlbnQsIHBvaW50ZXIsIG9iamVjdCkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9pbml0QmFzZUV2ZW50KGV2ZW50LCBwb2ludGVyKTtcblxuICAgICAgdmFyIGhvdmVyQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAob2JqZWN0LmhvdmVyID09PSBmYWxzZSkge1xuICAgICAgICBvYmplY3QuaG92ZXIgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX2FkZFRvSG92ZXIob2JqZWN0KTtcblxuICAgICAgICBob3ZlckNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5ub2RlID0gb2JqZWN0LmlkO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJob3Zlck5vZGVcIiwgcHJvcGVydGllcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcGVydGllcy5lZGdlID0gb2JqZWN0LmlkO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJob3ZlckVkZ2VcIiwgcHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhvdmVyQ2hhbmdlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhY3Rpb25zIGluIHJlc3BvbnNlIHRvIGEgbW91c2UgbW92ZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgfCBvYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBzY3JlZW4gY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJob3Zlck9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBob3Zlck9iamVjdChldmVudCwgcG9pbnRlcikge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXMuZ2V0Tm9kZUF0KHBvaW50ZXIpO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5nZXRFZGdlQXQocG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBob3ZlckNoYW5nZWQgPSBmYWxzZTsgLy8gcmVtb3ZlIGFsbCBub2RlIGhvdmVyIGhpZ2hsaWdodHNcblxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuaG92ZXJPYmoubm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmhvdmVyT2JqLm5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgJiYgb2JqZWN0LmlkICE9IG5vZGVJZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBFZGdlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRCbHVyRXZlbnQoZXZlbnQsIHBvaW50ZXIsIHRoaXMuaG92ZXJPYmoubm9kZXNbbm9kZUlkXSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ob3Zlck9iai5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgaG92ZXJDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcmVtb3ZpbmcgYWxsIGVkZ2UgaG92ZXIgaGlnaGxpZ2h0c1xuXG5cbiAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmhvdmVyT2JqLmVkZ2VzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ob3Zlck9iai5lZGdlcywgZWRnZUlkKSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBob3ZlciBoYXMgYmVlbiBjaGFuZ2VkIGhlcmUgaXQgbWVhbnMgdGhhdCB0aGUgbm9kZSBoYXMgYmVlbiBob3ZlcmVkIG92ZXIgb3Igb2ZmXG4gICAgICAgICAgLy8gd2UgdGhlbiBkbyBub3QgdXNlIHRoZSBlbWl0Qmx1ckV2ZW50IG1ldGhvZCBoZXJlLlxuICAgICAgICAgIGlmIChob3ZlckNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXS5ob3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICB9IC8vIGlmIHRoZSBibHVyIHJlbWFpbnMgdGhlIHNhbWUgYW5kIHRoZSBvYmplY3QgaXMgdW5kZWZpbmVkIChtb3VzZSBvZmYpIG9yIGFub3RoZXJcbiAgICAgICAgICAvLyBlZGdlIGhhcyBiZWVuIGhvdmVyZWQsIG9yIGFub3RoZXIgbm9kZSBoYXMgYmVlbiBob3ZlcmVkIHdlIGJsdXIgdGhlIGVkZ2UuXG4gICAgICAgICAgZWxzZSBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgRWRnZSAmJiBvYmplY3QuaWQgIT0gZWRnZUlkIHx8IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgJiYgIW9iamVjdC5ob3Zlcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0Qmx1ckV2ZW50KGV2ZW50LCBwb2ludGVyLCB0aGlzLmhvdmVyT2JqLmVkZ2VzW2VkZ2VJZF0pO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICAgIGhvdmVyQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgaG92ZXJlZEVkZ2VzQ291bnQgPSBrZXlzJDQodGhpcy5ob3Zlck9iai5lZGdlcykubGVuZ3RoO1xuXG4gICAgICAgIHZhciBob3ZlcmVkTm9kZXNDb3VudCA9IGtleXMkNCh0aGlzLmhvdmVyT2JqLm5vZGVzKS5sZW5ndGg7XG5cbiAgICAgICAgdmFyIG5ld09ubHlIb3ZlcmVkRWRnZSA9IG9iamVjdCBpbnN0YW5jZW9mIEVkZ2UgJiYgaG92ZXJlZEVkZ2VzQ291bnQgPT09IDAgJiYgaG92ZXJlZE5vZGVzQ291bnQgPT09IDA7XG4gICAgICAgIHZhciBuZXdPbmx5SG92ZXJlZE5vZGUgPSBvYmplY3QgaW5zdGFuY2VvZiBOb2RlICYmIGhvdmVyZWRFZGdlc0NvdW50ID09PSAwICYmIGhvdmVyZWROb2Rlc0NvdW50ID09PSAwO1xuXG4gICAgICAgIGlmIChob3ZlckNoYW5nZWQgfHwgbmV3T25seUhvdmVyZWRFZGdlIHx8IG5ld09ubHlIb3ZlcmVkTm9kZSkge1xuICAgICAgICAgIGhvdmVyQ2hhbmdlZCA9IHRoaXMuZW1pdEhvdmVyRXZlbnQoZXZlbnQsIHBvaW50ZXIsIG9iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTm9kZSAmJiB0aGlzLm9wdGlvbnMuaG92ZXJDb25uZWN0ZWRFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuX2hvdmVyQ29ubmVjdGVkRWRnZXMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaG92ZXJDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tbWl0IHRoZSBzZWxlY3Rpb24gY2hhbmdlcyBidXQgZG9uJ3QgZW1pdCBhbnkgZXZlbnRzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWl0V2l0aG91dEVtaXR0aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1pdFdpdGhvdXRFbWl0dGluZygpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmNvbW1pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYW5kIGRlc2VsZWN0IG5vZGVzIGRlcGVuZGluZyBjdXJyZW50IHNlbGVjdGlvbiBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBGb3IgY2hhbmdpbmcgbm9kZXMsIHNlbGVjdC9kZXNlbGVjdCBldmVudHMgYXJlIGZpcmVkLlxuICAgICAqXG4gICAgICogTk9URTogRm9yIGEgZ2l2ZW4gZWRnZSwgaWYgb25lIGNvbm5lY3Rpbmcgbm9kZSBpcyBkZXNlbGVjdGVkIGFuZCB3aXRoIHRoZVxuICAgICAqIHNhbWUgY2xpY2sgdGhlIG90aGVyIG5vZGUgaXMgc2VsZWN0ZWQsIG5vIGV2ZW50cyBmb3IgdGhlIGVkZ2Ugd2lsbCBmaXJlLiBJdFxuICAgICAqIHdhcyBzZWxlY3RlZCBhbmQgaXQgd2lsbCByZW1haW4gc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgLSBUaGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGVcbiAgICAgKiBjbGljaywgdGFwLCBkcmFnZW5k4oCmIHRoYXQgdHJpZ2dlcmVkIHRoaXMuXG4gICAgICogQHBhcmFtIHtVSUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWl0QW5kRW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21taXRBbmRFbWl0KHBvaW50ZXIsIGV2ZW50KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgdmFyIHNlbGVjdGlvbkNoYW5nZXMgPSB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5jb21taXQoKTtcblxuICAgICAgdmFyIHByZXZpb3VzU2VsZWN0aW9uID0ge1xuICAgICAgICBub2Rlczogc2VsZWN0aW9uQ2hhbmdlcy5ub2Rlcy5wcmV2aW91cyxcbiAgICAgICAgZWRnZXM6IHNlbGVjdGlvbkNoYW5nZXMuZWRnZXMucHJldmlvdXNcbiAgICAgIH07XG5cbiAgICAgIGlmIChzZWxlY3Rpb25DaGFuZ2VzLmVkZ2VzLmRlbGV0ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ2xpY2tFdmVudChcImRlc2VsZWN0RWRnZVwiLCBldmVudCwgcG9pbnRlciwgcHJldmlvdXNTZWxlY3Rpb24pO1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3Rpb25DaGFuZ2VzLm5vZGVzLmRlbGV0ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ2xpY2tFdmVudChcImRlc2VsZWN0Tm9kZVwiLCBldmVudCwgcG9pbnRlciwgcHJldmlvdXNTZWxlY3Rpb24pO1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3Rpb25DaGFuZ2VzLm5vZGVzLmFkZGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJzZWxlY3ROb2RlXCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0aW9uQ2hhbmdlcy5lZGdlcy5hZGRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDbGlja0V2ZW50KFwic2VsZWN0RWRnZVwiLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH0gLy8gZmlyZSB0aGUgc2VsZWN0IGV2ZW50IGlmIGFueXRoaW5nIGhhcyBiZWVuIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWRcblxuXG4gICAgICBpZiAoc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gc2VsZWN0IG9yIHVuc2VsZWN0XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDbGlja0V2ZW50KFwic2VsZWN0XCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2RlIGFuZCBlZGdlIGlkcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt7bm9kZXM6IEFycmF5LjxzdHJpbmc+LCBlZGdlczogQXJyYXkuPHN0cmluZz59fSBBcnJheXMgd2l0aCB0aGVcbiAgICAgKiBpZHMgb2YgdGhlIHNlbGVjdGVkIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlczogdGhpcy5nZXRTZWxlY3RlZE5vZGVJZHMoKSxcbiAgICAgICAgZWRnZXM6IHRoaXMuZ2V0U2VsZWN0ZWRFZGdlSWRzKClcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IHdpdGggc2VsZWN0ZWQgbm9kZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3RlZE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkTm9kZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0Tm9kZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBlZGdlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgd2l0aCBzZWxlY3RlZCBlZGdlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGVkRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWRFZGdlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXRFZGdlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgaWRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlIHNlbGVjdGVkIG5vZGVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0ZWROb2RlSWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkTm9kZUlkcygpIHtcbiAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgcmV0dXJuIG1hcCQzKF9jb250ZXh0ID0gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0Tm9kZXMoKSkuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuaWQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBlZGdlIGlkcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZSBzZWxlY3RlZCBlZGdlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGVkRWRnZUlkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZEVkZ2VJZHMoKSB7XG4gICAgICB2YXIgX2NvbnRleHQyO1xuXG4gICAgICByZXR1cm4gbWFwJDMoX2NvbnRleHQyID0gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0RWRnZXMoKSkuY2FsbChfY29udGV4dDIsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlLmlkO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3tub2RlczogQXJyYXkuPHN0cmluZz4sIGVkZ2VzOiBBcnJheS48c3RyaW5nPn19IHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgIXNlbGVjdGlvbi5ub2RlcyAmJiAhc2VsZWN0aW9uLmVkZ2VzKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTZWxlY3Rpb24gbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBub2RlcyBhbmQvb3IgZWRnZXMgcHJvcGVydGllc1wiKTtcbiAgICAgIH0gLy8gZmlyc3QgdW5zZWxlY3QgYW55IHNlbGVjdGVkIG5vZGUsIGlmIG9wdGlvbiBpcyB0cnVlIG9yIHVuZGVmaW5lZFxuXG5cbiAgICAgIGlmIChvcHRpb25zLnVuc2VsZWN0QWxsIHx8IG9wdGlvbnMudW5zZWxlY3RBbGwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3Rpb24ubm9kZXMpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoc2VsZWN0aW9uLm5vZGVzKSxcbiAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBpZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaWRdO1xuXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ05vZGUgd2l0aCBpZCBcIicgKyBpZCArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH0gLy8gZG9uJ3Qgc2VsZWN0IGVkZ2VzIHdpdGggaXRcblxuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdE9iamVjdChub2RlLCBvcHRpb25zLmhpZ2hsaWdodEVkZ2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0aW9uLmVkZ2VzKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihzZWxlY3Rpb24uZWRnZXMpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBfaWQgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1tfaWRdO1xuXG4gICAgICAgICAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0VkZ2Ugd2l0aCBpZCBcIicgKyBfaWQgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0T2JqZWN0KGVkZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuXG4gICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5jb21taXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2VsZWN0IHplcm8gb3IgbW9yZSBub2RlcyB3aXRoIHRoZSBvcHRpb24gdG8gaGlnaGxpZ2h0IGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IHNlbGVjdGlvbiAgICAgQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoaWdobGlnaHRFZGdlc11cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE5vZGVzKHNlbGVjdGlvbikge1xuICAgICAgdmFyIGhpZ2hsaWdodEVkZ2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBcIlNlbGVjdGlvbiBtdXN0IGJlIGFuIGFycmF5IHdpdGggaWRzXCI7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvbih7XG4gICAgICAgIG5vZGVzOiBzZWxlY3Rpb25cbiAgICAgIH0sIHtcbiAgICAgICAgaGlnaGxpZ2h0RWRnZXM6IGhpZ2hsaWdodEVkZ2VzXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2VsZWN0IHplcm8gb3IgbW9yZSBlZGdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBzZWxlY3Rpb24gICAgIEFuIGFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgbm9kZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RFZGdlcyhzZWxlY3Rpb24pIHtcbiAgICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5sZW5ndGggPT09IHVuZGVmaW5lZCkgdGhyb3cgXCJTZWxlY3Rpb24gbXVzdCBiZSBhbiBhcnJheSB3aXRoIGlkc1wiO1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oe1xuICAgICAgICBlZGdlczogc2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhlIHNlbGVjdGlvbjogcmVtb3ZlIGlkcyBvZiBub2RlcyB3aGljaCBubyBsb25nZXIgZXhpc3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgbm9kZSBpbiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXROb2RlcygpKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2Rlcywgbm9kZS5pZCkpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5kZWxldGVOb2Rlcyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBlZGdlIGluIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmdldEVkZ2VzKCkpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5LmVkZ2VzLCBlZGdlLmlkKSkge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmRlbGV0ZUVkZ2VzKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBhbGwgdGhlIHZpc3VhbCBlbGVtZW50cyBjbGlja2VkIHdoaWNoIGFyZSBvbiB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAgICpcbiAgICAgKiBBbGwgZWxlbWVudHMgYXJlIHJldHVybmVkOyB0aGlzIGluY2x1ZGVzIG5vZGVzLCBlZGdlcyBhbmQgdGhlaXIgbGFiZWxzLlxuICAgICAqIFRoZSBvcmRlciByZXR1cm5lZCBpcyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0LCBpLmUuIGVsZW1lbnQgMCBvZiB0aGUgcmV0dXJuXG4gICAgICogdmFsdWUgaXMgdGhlIHRvcG1vc3QgaXRlbSBjbGlja2VkIG9uLlxuICAgICAqXG4gICAgICogVGhlIHJldHVybiB2YWx1ZSBjb25zaXN0cyBvZiBhbiBhcnJheSBvZiB0aGUgZm9sbG93aW5nIHBvc3NpYmxlIGVsZW1lbnRzOlxuICAgICAqXG4gICAgICogLSBge25vZGVJZDpudW1iZXJ9YCAgICAgICAgICAgICAtIG5vZGUgd2l0aCBnaXZlbiBpZCBjbGlja2VkIG9uXG4gICAgICogLSBge25vZGVJZDpudW1iZXIsIGxhYmVsSWQ6MH1gICAtIGxhYmVsIG9mIG5vZGUgd2l0aCBnaXZlbiBpZCBjbGlja2VkIG9uXG4gICAgICogLSBge2VkZ2VJZDpudW1iZXJ9YCAgICAgICAgICAgICAtIGVkZ2Ugd2l0aCBnaXZlbiBpZCBjbGlja2VkIG9uXG4gICAgICogLSBge2VkZ2U6bnVtYmVyLCBsYWJlbElkOjB9YCAgICAtIGxhYmVsIG9mIGVkZ2Ugd2l0aCBnaXZlbiBpZCBjbGlja2VkIG9uXG4gICAgICpcbiAgICAgKiAjIyBOT1RFU1xuICAgICAqXG4gICAgICogLSBDdXJyZW50bHksIHRoZXJlIGlzIG9ubHkgb25lIGxhYmVsIGFzc29jaWF0ZWQgd2l0aCBhIG5vZGUgb3IgYW4gZWRnZSxcbiAgICAgKiAgIGJ1dCB0aGlzIGlzIGV4cGVjdGVkIHRvIGNoYW5nZSBzb21ld2hlcmUgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiAtIFNpbmNlIHRoZXJlIGlzIG5vIHotaW5kZXhpbmcgeWV0LCBpdCBpcyBub3QgcmVhbGx5IHBvc3NpYmxlIHRvIHNldCB0aGUgbm9kZXMgYW5kXG4gICAgICogICBlZGdlcyBpbiB0aGUgY29ycmVjdCBvcmRlci4gRm9yIHRoZSB0aW1lIGJlaW5nLCBub2RlcyBjb21lIGZpcnN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9pbnRlciAgbW91c2UgcG9zaXRpb24gaW4gc2NyZWVuIGNvb3JkaW5hdGVzXG4gICAgICogQHJldHVybnMge0FycmF5Ljxub2RlQ2xpY2tJdGVtfG5vZGVMYWJlbENsaWNrSXRlbXxlZGdlQ2xpY2tJdGVtfGVkZ2VMYWJlbENsaWNrSXRlbT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldENsaWNrZWRJdGVtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGlja2VkSXRlbXMocG9pbnRlcikge1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICB2YXIgaXRlbXMgPSBbXTsgLy8gTm90ZSByZXZlcnNlIG9yZGVyOyB3ZSB3YW50IHRoZSB0b3Btb3N0IGNsaWNrZWQgaXRlbXMgdG8gYmUgZmlyc3QgaW4gdGhlIGFycmF5XG4gICAgICAvLyBBbHNvIG5vdGUgdGhhdCBzZWxlY3RlZCBub2RlcyBhcmUgZGlzcmVnYXJkZWQgaGVyZTsgdGhlc2Ugbm9ybWFsbHkgZGlzcGxheSBvbiB0b3BcblxuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gbm9kZUluZGljZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgIHZhciByZXQgPSBub2RlLmdldEl0ZW1zT25Qb2ludChwb2ludCk7XG4gICAgICAgIGl0ZW1zLnB1c2guYXBwbHkoaXRlbXMsIHJldCk7IC8vIEFwcGVuZCB0aGUgcmV0dXJuIHZhbHVlIHRvIHRoZSBydW5uaW5nIGxpc3QuXG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcztcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgX2kgPSBlZGdlSW5kaWNlcy5sZW5ndGggLSAxOyBfaSA+PSAwOyBfaS0tKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbX2ldXTtcblxuICAgICAgICB2YXIgX3JldCA9IGVkZ2UuZ2V0SXRlbXNPblBvaW50KHBvaW50KTtcblxuICAgICAgICBpdGVtcy5wdXNoLmFwcGx5KGl0ZW1zLCBfcmV0KTsgLy8gQXBwZW5kIHRoZSByZXR1cm4gdmFsdWUgdG8gdGhlIHJ1bm5pbmcgbGlzdC5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTZWxlY3Rpb25IYW5kbGVyO1xufSgpO1xuXG52YXIgdGltc29ydCQxID0ge307XG5cbi8qKioqXG4gKiBUaGUgTUlUIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTWFyY28gWmljY2FyZGlcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqKioqL1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB7XG4gICAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICAgIH1cbiAgfSkoY29tbW9uanNHbG9iYWwsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICAgIGV4cG9ydHMuc29ydCA9IHNvcnQ7XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgREVGQVVMVF9NSU5fTUVSR0UgPSAzMjtcbiAgICB2YXIgREVGQVVMVF9NSU5fR0FMTE9QSU5HID0gNztcbiAgICB2YXIgREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEggPSAyNTY7XG4gICAgdmFyIFBPV0VSU19PRl9URU4gPSBbMWUwLCAxZTEsIDFlMiwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5XTtcblxuICAgIGZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICAgIGlmICh4IDwgMWU1KSB7XG4gICAgICAgIGlmICh4IDwgMWUyKSB7XG4gICAgICAgICAgcmV0dXJuIHggPCAxZTEgPyAwIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4IDwgMWU0KSB7XG4gICAgICAgICAgcmV0dXJuIHggPCAxZTMgPyAyIDogMztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiA0O1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA8IDFlNykge1xuICAgICAgICByZXR1cm4geCA8IDFlNiA/IDUgOiA2O1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA8IDFlOSkge1xuICAgICAgICByZXR1cm4geCA8IDFlOCA/IDcgOiA4O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gOTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbHBoYWJldGljYWxDb21wYXJlKGEsIGIpIHtcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAofn5hID09PSBhICYmIH5+YiA9PT0gYikge1xuICAgICAgICBpZiAoYSA9PT0gMCB8fCBiID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPCAwIHx8IGIgPCAwKSB7XG4gICAgICAgICAgaWYgKGIgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGEgPSAtYTtcbiAgICAgICAgICBiID0gLWI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWwgPSBsb2cxMChhKTtcbiAgICAgICAgdmFyIGJsID0gbG9nMTAoYik7XG4gICAgICAgIHZhciB0ID0gMDtcblxuICAgICAgICBpZiAoYWwgPCBibCkge1xuICAgICAgICAgIGEgKj0gUE9XRVJTX09GX1RFTltibCAtIGFsIC0gMV07XG4gICAgICAgICAgYiAvPSAxMDtcbiAgICAgICAgICB0ID0gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYWwgPiBibCkge1xuICAgICAgICAgIGIgKj0gUE9XRVJTX09GX1RFTlthbCAtIGJsIC0gMV07XG4gICAgICAgICAgYSAvPSAxMDtcbiAgICAgICAgICB0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBhU3RyID0gU3RyaW5nKGEpO1xuICAgICAgdmFyIGJTdHIgPSBTdHJpbmcoYik7XG5cbiAgICAgIGlmIChhU3RyID09PSBiU3RyKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYVN0ciA8IGJTdHIgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWluUnVuTGVuZ3RoKG4pIHtcbiAgICAgIHZhciByID0gMDtcblxuICAgICAgd2hpbGUgKG4gPj0gREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICAgICAgciB8PSBuICYgMTtcbiAgICAgICAgbiA+Pj0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG4gKyByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSkge1xuICAgICAgdmFyIHJ1bkhpID0gbG8gKyAxO1xuXG4gICAgICBpZiAocnVuSGkgPT09IGhpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcGFyZShhcnJheVtydW5IaSsrXSwgYXJyYXlbbG9dKSA8IDApIHtcbiAgICAgICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pIDwgMCkge1xuICAgICAgICAgIHJ1bkhpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXZlcnNlUnVuKGFycmF5LCBsbywgcnVuSGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pID49IDApIHtcbiAgICAgICAgICBydW5IaSsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydW5IaSAtIGxvO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJldmVyc2VSdW4oYXJyYXksIGxvLCBoaSkge1xuICAgICAgaGktLTtcblxuICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgdmFyIHQgPSBhcnJheVtsb107XG4gICAgICAgIGFycmF5W2xvKytdID0gYXJyYXlbaGldO1xuICAgICAgICBhcnJheVtoaS0tXSA9IHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBzdGFydCwgY29tcGFyZSkge1xuICAgICAgaWYgKHN0YXJ0ID09PSBsbykge1xuICAgICAgICBzdGFydCsrO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgc3RhcnQgPCBoaTsgc3RhcnQrKykge1xuICAgICAgICB2YXIgcGl2b3QgPSBhcnJheVtzdGFydF07XG4gICAgICAgIHZhciBsZWZ0ID0gbG87XG4gICAgICAgIHZhciByaWdodCA9IHN0YXJ0O1xuXG4gICAgICAgIHdoaWxlIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgICAgICB2YXIgbWlkID0gbGVmdCArIHJpZ2h0ID4+PiAxO1xuXG4gICAgICAgICAgaWYgKGNvbXBhcmUocGl2b3QsIGFycmF5W21pZF0pIDwgMCkge1xuICAgICAgICAgICAgcmlnaHQgPSBtaWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuID0gc3RhcnQgLSBsZWZ0O1xuXG4gICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGFycmF5W2xlZnQgKyAzXSA9IGFycmF5W2xlZnQgKyAyXTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGFycmF5W2xlZnQgKyAyXSA9IGFycmF5W2xlZnQgKyAxXTtcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGFycmF5W2xlZnQgKyAxXSA9IGFycmF5W2xlZnRdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgICAgICAgIGFycmF5W2xlZnQgKyBuXSA9IGFycmF5W2xlZnQgKyBuIC0gMV07XG4gICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbbGVmdF0gPSBwaXZvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnYWxsb3BMZWZ0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICAgICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgICAgdmFyIG1heE9mZnNldCA9IDA7XG4gICAgICB2YXIgb2Zmc2V0ID0gMTtcblxuICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pID4gMCkge1xuICAgICAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPiAwKSB7XG4gICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgIG9mZnNldCArPSBoaW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8PSAwKSB7XG4gICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gICAgICB9XG5cbiAgICAgIGxhc3RPZmZzZXQrKztcblxuICAgICAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIG1dKSA+IDApIHtcbiAgICAgICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdhbGxvcFJpZ2h0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICAgICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgICAgdmFyIG1heE9mZnNldCA9IDA7XG4gICAgICB2YXIgb2Zmc2V0ID0gMTtcblxuICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pIDwgMCkge1xuICAgICAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDwgMCkge1xuICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtcCA9IGxhc3RPZmZzZXQ7XG4gICAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID49IDApIHtcbiAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgICB9XG5cbiAgICAgIGxhc3RPZmZzZXQrKztcblxuICAgICAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIG1dKSA8IDApIHtcbiAgICAgICAgICBvZmZzZXQgPSBtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciBUaW1Tb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGltU29ydChhcnJheSwgY29tcGFyZSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltU29ydCk7XG5cbiAgICAgICAgdGhpcy5hcnJheSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IG51bGw7XG4gICAgICAgIHRoaXMubWluR2FsbG9wID0gREVGQVVMVF9NSU5fR0FMTE9QSU5HO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMudG1wU3RvcmFnZUxlbmd0aCA9IERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIO1xuICAgICAgICB0aGlzLnN0YWNrTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5ydW5TdGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMucnVuTGVuZ3RoID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFja1NpemUgPSAwO1xuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA8IDIgKiBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCkge1xuICAgICAgICAgIHRoaXMudG1wU3RvcmFnZUxlbmd0aCA9IHRoaXMubGVuZ3RoID4+PiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50bXAgPSBuZXcgQXJyYXkodGhpcy50bXBTdG9yYWdlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zdGFja0xlbmd0aCA9IHRoaXMubGVuZ3RoIDwgMTIwID8gNSA6IHRoaXMubGVuZ3RoIDwgMTU0MiA/IDEwIDogdGhpcy5sZW5ndGggPCAxMTkxNTEgPyAxOSA6IDQwO1xuICAgICAgICB0aGlzLnJ1blN0YXJ0ID0gbmV3IEFycmF5KHRoaXMuc3RhY2tMZW5ndGgpO1xuICAgICAgICB0aGlzLnJ1bkxlbmd0aCA9IG5ldyBBcnJheSh0aGlzLnN0YWNrTGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgVGltU29ydC5wcm90b3R5cGUucHVzaFJ1biA9IGZ1bmN0aW9uIHB1c2hSdW4ocnVuU3RhcnQsIHJ1bkxlbmd0aCkge1xuICAgICAgICB0aGlzLnJ1blN0YXJ0W3RoaXMuc3RhY2tTaXplXSA9IHJ1blN0YXJ0O1xuICAgICAgICB0aGlzLnJ1bkxlbmd0aFt0aGlzLnN0YWNrU2l6ZV0gPSBydW5MZW5ndGg7XG4gICAgICAgIHRoaXMuc3RhY2tTaXplICs9IDE7XG4gICAgICB9O1xuXG4gICAgICBUaW1Tb3J0LnByb3RvdHlwZS5tZXJnZVJ1bnMgPSBmdW5jdGlvbiBtZXJnZVJ1bnMoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMuc3RhY2tTaXplIC0gMjtcblxuICAgICAgICAgIGlmIChuID49IDEgJiYgdGhpcy5ydW5MZW5ndGhbbiAtIDFdIDw9IHRoaXMucnVuTGVuZ3RoW25dICsgdGhpcy5ydW5MZW5ndGhbbiArIDFdIHx8IG4gPj0gMiAmJiB0aGlzLnJ1bkxlbmd0aFtuIC0gMl0gPD0gdGhpcy5ydW5MZW5ndGhbbl0gKyB0aGlzLnJ1bkxlbmd0aFtuIC0gMV0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bkxlbmd0aFtuIC0gMV0gPCB0aGlzLnJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5ydW5MZW5ndGhbbl0gPiB0aGlzLnJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubWVyZ2VBdChuKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVGltU29ydC5wcm90b3R5cGUuZm9yY2VNZXJnZVJ1bnMgPSBmdW5jdGlvbiBmb3JjZU1lcmdlUnVucygpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2tTaXplID4gMSkge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5zdGFja1NpemUgLSAyO1xuXG4gICAgICAgICAgaWYgKG4gPiAwICYmIHRoaXMucnVuTGVuZ3RoW24gLSAxXSA8IHRoaXMucnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubWVyZ2VBdChuKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVGltU29ydC5wcm90b3R5cGUubWVyZ2VBdCA9IGZ1bmN0aW9uIG1lcmdlQXQoaSkge1xuICAgICAgICB2YXIgY29tcGFyZSA9IHRoaXMuY29tcGFyZTtcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgdmFyIHN0YXJ0MSA9IHRoaXMucnVuU3RhcnRbaV07XG4gICAgICAgIHZhciBsZW5ndGgxID0gdGhpcy5ydW5MZW5ndGhbaV07XG4gICAgICAgIHZhciBzdGFydDIgPSB0aGlzLnJ1blN0YXJ0W2kgKyAxXTtcbiAgICAgICAgdmFyIGxlbmd0aDIgPSB0aGlzLnJ1bkxlbmd0aFtpICsgMV07XG4gICAgICAgIHRoaXMucnVuTGVuZ3RoW2ldID0gbGVuZ3RoMSArIGxlbmd0aDI7XG5cbiAgICAgICAgaWYgKGkgPT09IHRoaXMuc3RhY2tTaXplIC0gMykge1xuICAgICAgICAgIHRoaXMucnVuU3RhcnRbaSArIDFdID0gdGhpcy5ydW5TdGFydFtpICsgMl07XG4gICAgICAgICAgdGhpcy5ydW5MZW5ndGhbaSArIDFdID0gdGhpcy5ydW5MZW5ndGhbaSArIDJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGFja1NpemUtLTtcbiAgICAgICAgdmFyIGsgPSBnYWxsb3BSaWdodChhcnJheVtzdGFydDJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcbiAgICAgICAgc3RhcnQxICs9IGs7XG4gICAgICAgIGxlbmd0aDEgLT0gaztcblxuICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aDIgPSBnYWxsb3BMZWZ0KGFycmF5W3N0YXJ0MSArIGxlbmd0aDEgLSAxXSwgYXJyYXksIHN0YXJ0MiwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aDEgPD0gbGVuZ3RoMikge1xuICAgICAgICAgIHRoaXMubWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubWVyZ2VIaWdoKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVGltU29ydC5wcm90b3R5cGUubWVyZ2VMb3cgPSBmdW5jdGlvbiBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgICAgICB2YXIgY29tcGFyZSA9IHRoaXMuY29tcGFyZTtcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgdmFyIHRtcCA9IHRoaXMudG1wO1xuICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MSArIGldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnNvcjEgPSAwO1xuICAgICAgICB2YXIgY3Vyc29yMiA9IHN0YXJ0MjtcbiAgICAgICAgdmFyIGRlc3QgPSBzdGFydDE7XG4gICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluR2FsbG9wID0gdGhpcy5taW5HYWxsb3A7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgY291bnQxID0gMDtcbiAgICAgICAgICB2YXIgY291bnQyID0gMDtcbiAgICAgICAgICB2YXIgZXhpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbY3Vyc29yMl0sIHRtcFtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuICAgICAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcbiAgICAgICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgICAgIGNvdW50MiA9IDA7XG5cbiAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBtaW5HYWxsb3ApO1xuXG4gICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvdW50MSA9IGdhbGxvcFJpZ2h0KGFycmF5W2N1cnNvcjJdLCB0bXAsIGN1cnNvcjEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZXN0ICs9IGNvdW50MTtcbiAgICAgICAgICAgICAgY3Vyc29yMSArPSBjb3VudDE7XG4gICAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuXG4gICAgICAgICAgICAgIGlmIChsZW5ndGgxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvdW50MiA9IGdhbGxvcExlZnQodG1wW2N1cnNvcjFdLCBhcnJheSwgY3Vyc29yMiwgbGVuZ3RoMiwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVzdCArPSBjb3VudDI7XG4gICAgICAgICAgICAgIGN1cnNvcjIgKz0gY291bnQyO1xuICAgICAgICAgICAgICBsZW5ndGgyIC09IGNvdW50MjtcblxuICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcblxuICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbkdhbGxvcC0tO1xuICAgICAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgIG1pbkdhbGxvcCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWluR2FsbG9wICs9IDI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1pbkdhbGxvcCA9IG1pbkdhbGxvcDtcblxuICAgICAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgICAgIHRoaXMubWluR2FsbG9wID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXJnZUxvdyBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBUaW1Tb3J0LnByb3RvdHlwZS5tZXJnZUhpZ2ggPSBmdW5jdGlvbiBtZXJnZUhpZ2goc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLmNvbXBhcmU7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLnRtcDtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDIgKyBpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJzb3IxID0gc3RhcnQxICsgbGVuZ3RoMSAtIDE7XG4gICAgICAgIHZhciBjdXJzb3IyID0gbGVuZ3RoMiAtIDE7XG4gICAgICAgIHZhciBkZXN0ID0gc3RhcnQyICsgbGVuZ3RoMiAtIDE7XG4gICAgICAgIHZhciBjdXN0b21DdXJzb3IgPSAwO1xuICAgICAgICB2YXIgY3VzdG9tRGVzdCA9IDA7XG4gICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICBjdXN0b21DdXJzb3IgPSBkZXN0IC0gKGxlbmd0aDIgLSAxKTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5HYWxsb3AgPSB0aGlzLm1pbkdhbGxvcDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBjb3VudDEgPSAwO1xuICAgICAgICAgIHZhciBjb3VudDIgPSAwO1xuICAgICAgICAgIHZhciBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoY29tcGFyZSh0bXBbY3Vyc29yMl0sIGFycmF5W2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG4gICAgICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgICAgICBjb3VudDIgPSAwO1xuXG4gICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuICAgICAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IG1pbkdhbGxvcCk7XG5cbiAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY291bnQxID0gbGVuZ3RoMSAtIGdhbGxvcFJpZ2h0KHRtcFtjdXJzb3IyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgbGVuZ3RoMSAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgICAgIGRlc3QgLT0gY291bnQxO1xuICAgICAgICAgICAgICBjdXJzb3IxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG4gICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgICAgZm9yIChpID0gY291bnQxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuXG4gICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY291bnQyID0gbGVuZ3RoMiAtIGdhbGxvcExlZnQoYXJyYXlbY3Vyc29yMV0sIHRtcCwgMCwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICAgIGRlc3QgLT0gY291bnQyO1xuICAgICAgICAgICAgICBjdXJzb3IyIC09IGNvdW50MjtcbiAgICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG4gICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMiArIDE7XG5cbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gdG1wW2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGxlbmd0aDIgPD0gMSkge1xuICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWluR2FsbG9wLS07XG4gICAgICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWluR2FsbG9wIDwgMCkge1xuICAgICAgICAgICAgbWluR2FsbG9wID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtaW5HYWxsb3AgKz0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWluR2FsbG9wID0gbWluR2FsbG9wO1xuXG4gICAgICAgIGlmIChtaW5HYWxsb3AgPCAxKSB7XG4gICAgICAgICAgdGhpcy5taW5HYWxsb3AgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWVyZ2VIaWdoIHByZWNvbmRpdGlvbnMgd2VyZSBub3QgcmVzcGVjdGVkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBUaW1Tb3J0O1xuICAgIH0oKTtcblxuICAgIGZ1bmN0aW9uIHNvcnQoYXJyYXksIGNvbXBhcmUsIGxvLCBoaSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW4gb25seSBzb3J0IGFycmF5cycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbXBhcmUpIHtcbiAgICAgICAgY29tcGFyZSA9IGFscGhhYmV0aWNhbENvbXBhcmU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb21wYXJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGhpID0gbG87XG4gICAgICAgIGxvID0gY29tcGFyZTtcbiAgICAgICAgY29tcGFyZSA9IGFscGhhYmV0aWNhbENvbXBhcmU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbG8pIHtcbiAgICAgICAgbG8gPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhpKSB7XG4gICAgICAgIGhpID0gYXJyYXkubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVtYWluaW5nID0gaGkgLSBsbztcblxuICAgICAgaWYgKHJlbWFpbmluZyA8IDIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcnVuTGVuZ3RoID0gMDtcblxuICAgICAgaWYgKHJlbWFpbmluZyA8IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG4gICAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0cyA9IG5ldyBUaW1Tb3J0KGFycmF5LCBjb21wYXJlKTtcbiAgICAgIHZhciBtaW5SdW4gPSBtaW5SdW5MZW5ndGgocmVtYWluaW5nKTtcblxuICAgICAgZG8ge1xuICAgICAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChydW5MZW5ndGggPCBtaW5SdW4pIHtcbiAgICAgICAgICB2YXIgZm9yY2UgPSByZW1haW5pbmc7XG5cbiAgICAgICAgICBpZiAoZm9yY2UgPiBtaW5SdW4pIHtcbiAgICAgICAgICAgIGZvcmNlID0gbWluUnVuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBsbyArIGZvcmNlLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgICAgICAgcnVuTGVuZ3RoID0gZm9yY2U7XG4gICAgICAgIH1cblxuICAgICAgICB0cy5wdXNoUnVuKGxvLCBydW5MZW5ndGgpO1xuICAgICAgICB0cy5tZXJnZVJ1bnMoKTtcbiAgICAgICAgcmVtYWluaW5nIC09IHJ1bkxlbmd0aDtcbiAgICAgICAgbG8gKz0gcnVuTGVuZ3RoO1xuICAgICAgfSB3aGlsZSAocmVtYWluaW5nICE9PSAwKTtcblxuICAgICAgdHMuZm9yY2VNZXJnZVJ1bnMoKTtcbiAgICB9XG4gIH0pO1xufSkodGltc29ydCQxKTtcblxudmFyIHRpbXNvcnQgPSB0aW1zb3J0JDE7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogSW50ZXJmYWNlIGRlZmluaXRpb24gZm9yIGRpcmVjdGlvbiBzdHJhdGVneSBjbGFzc2VzLlxuICpcbiAqIFRoaXMgY2xhc3MgZGVzY3JpYmVzIHRoZSBpbnRlcmZhY2UgZm9yIHRoZSBTdHJhdGVneVxuICogcGF0dGVybiBjbGFzc2VzIHVzZWQgdG8gZGlmZmVyZW50aWF0ZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbFxuICogZGlyZWN0aW9uIG9mIGhpZXJhcmNoaWNhbCByZXN1bHRzLlxuICpcbiAqIEZvciBhIGdpdmVuIGRpcmVjdGlvbiwgb25lIGNvb3JkaW5hdGUgd2lsbCBiZSAnZml4ZWQnLCBtZWFuaW5nIHRoYXQgaXQgaXNcbiAqIGRldGVybWluZWQgYnkgbGV2ZWwuXG4gKiBUaGUgb3RoZXIgY29vcmRpbmF0ZSBpcyAndW5maXhlZCcsIG1lYW5pbmcgdGhhdCB0aGUgbm9kZXMgb24gYSBnaXZlbiBsZXZlbFxuICogY2FuIHN0aWxsIG1vdmUgYWxvbmcgdGhhdCBjb29yZGluYXRlLiBTbzpcbiAqXG4gKiAtIGB2ZXJ0aWNhbGAgbGF5b3V0OiBgeGAgdW5maXhlZCwgYHlgIGZpeGVkIHBlciBsZXZlbFxuICogLSBgaG9yaXpvbnRhbGAgbGF5b3V0OiBgeGAgZml4ZWQgcGVyIGxldmVsLCBgeWAgdW5maXhlZFxuICpcbiAqIFRoZSBsb2NhbCBtZXRob2RzIGFyZSBzdHVicyBhbmQgc2hvdWxkIGJlIHJlZ2FyZGVkIGFzIGFic3RyYWN0LlxuICogRGVyaXZlZCBjbGFzc2VzICoqbXVzdCoqIGltcGxlbWVudCBhbGwgdGhlIG1ldGhvZHMgdGhlbXNlbHZlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBEaXJlY3Rpb25JbnRlcmZhY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEaXJlY3Rpb25JbnRlcmZhY2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpcmVjdGlvbkludGVyZmFjZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGlyZWN0aW9uSW50ZXJmYWNlLCBbe1xuICAgIGtleTogXCJhYnN0cmFjdFwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhYnN0cmFjdCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGluc3RhbnRpYXRlIGFic3RyYWN0IGNsYXNzIVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGR1bW15IGNhbGwgd2hpY2ggaXMgdXNlZCB0byBzdXBwcmVzcyB0aGUganNkb2MgZXJyb3JzIG9mIHR5cGU6XG4gICAgICpcbiAgICAgKiAgIFwiJ3BhcmFtJyBpcyBhc3NpZ25lZCBhIHZhbHVlIGJ1dCBuZXZlciB1c2VkXCJcbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZha2VfdXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZha2VfdXNlKCkgey8vIERvIG5vdGhpbmcgc3BlY2lhbFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUeXBlIHRvIHVzZSB0byB0cmFuc2xhdGUgZHluYW1pYyBjdXJ2ZXMgdG8sIGluIHRoZSBjYXNlIG9mIGhpZXJhcmNoaWNhbCBsYXlvdXQuXG4gICAgICogRHluYW1pYyBjdXJ2ZXMgZG8gbm90IHdvcmsgZm9yIHRoZXNlLlxuICAgICAqXG4gICAgICogVGhlIHZhbHVlIHNob3VsZCBiZSBwZXJwZW5kaWN1bGFyIHRvIHRoZSBhY3R1YWwgZGlyZWN0aW9uIG9mIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBEaXJlY3Rpb24sIGVpdGhlciAndmVydGljYWwnIG9yICdob3Jpem9udGFsJ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3VydmVUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnZlVHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGNvb3JkaW5hdGUgdGhhdCBpcyBub3QgZml4ZWQgZm9yIHRoaXMgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHJlYWRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSBvZiB0aGUgdW5maXhlZCBjb29yZGluYXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NpdGlvbihub2RlKSB7XG4gICAgICB0aGlzLmZha2VfdXNlKG5vZGUpO1xuICAgICAgcmV0dXJuIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZSB0aGF0IGlzIG5vdCBmaXhlZCBmb3IgdGhpcyBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gYWRqdXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZXZlbF0gaWYgc3BlY2lmaWVkLCB0aGUgaGllcmFyY2h5IGxldmVsIHRoYXQgdGhpcyBub2RlIHNob3VsZCBiZSBmaXhlZCB0b1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5mYWtlX3VzZShub2RlLCBwb3NpdGlvbiwgbGV2ZWwpO1xuICAgICAgdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdpZHRoIG9mIGEgdHJlZS5cbiAgICAgKlxuICAgICAqIEEgYHRyZWVgIGhlcmUgaXMgYSBzdWJzZXQgb2Ygbm9kZXMgd2l0aGluIHRoZSBuZXR3b3JrIHdoaWNoIGFyZSBub3QgY29ubmVjdGVkIHRvIG90aGVyIG5vZGVzLFxuICAgICAqIG9ubHkgYW1vbmcgdGhlbXNlbHZlcy4gSW4gZXNzZW5jZSwgaXQgaXMgYSBzdWItbmV0d29yay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggbnVtYmVyIG9mIGEgdHJlZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSB3aWR0aCBvZiBhIHRyZWUgaW4gdGhlIHZpZXcgY29vcmRpbmF0ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFRyZWVTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyZWVTaXplKGluZGV4KSB7XG4gICAgICB0aGlzLmZha2VfdXNlKGluZGV4KTtcbiAgICAgIHJldHVybiB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNvcnQgYXJyYXkgb2Ygbm9kZXMgb24gdGhlIHVuZml4ZWQgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBOb3RlOioqIGNocm9tZSBoYXMgbm9uLXN0YWJsZSBzb3J0aW5nIGltcGxlbWVudGF0aW9uLCB3aGljaFxuICAgICAqIGhhcyBhIHRlbmRlbmN5IHRvIGNoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIGFycmF5IGl0ZW1zLFxuICAgICAqIGV2ZW4gaWYgdGhlIGN1c3RvbSBzb3J0IGZ1bmN0aW9uIHJldHVybnMgMC5cbiAgICAgKlxuICAgICAqIEZvciB0aGlzIHJlYXNvbiwgYW4gZXh0ZXJuYWwgc29ydCBpbXBsZW1lbnRhdGlvbiBpcyB1c2VkLFxuICAgICAqIHdoaWNoIGhhcyB0aGUgYWRkZWQgYmVuZWZpdCBvZiBiZWluZyBmYXN0ZXIgdGhhbiB0aGUgc3RhbmRhcmRcbiAgICAgKiBwbGF0Zm9ybXMgaW1wbGVtZW50YXRpb24uIFRoaXMgaGFzIGJlZW4gdmVyaWZpZWQgb24gYG5vZGUuanNgLFxuICAgICAqIGBmaXJlZm94YCBhbmQgYGNocm9tZWAgKGFsbCBsaW51eCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZUFycmF5IGFycmF5IG9mIG5vZGVzIHRvIHNvcnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29ydChub2RlQXJyYXkpIHtcbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZUFycmF5KTtcbiAgICAgIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzaWduIHRoZSBmaXhlZCBjb29yZGluYXRlIG9mIHRoZSBub2RlIHRvIHRoZSBnaXZlbiBsZXZlbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIGFkanVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwgdG8gZml4IHRvXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml4KG5vZGUsIGxldmVsKSB7XG4gICAgICB0aGlzLmZha2VfdXNlKG5vZGUsIGxldmVsKTtcbiAgICAgIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFuIG9mZnNldCB0byB0aGUgdW5maXhlZCBjb29yZGluYXRlIG9mIHRoZSBnaXZlbiBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlSWR9IG5vZGVJZCBJZCBvZiB0aGUgbm9kZSB0byBhZGp1c3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlmZiBPZmZzZXQgdG8gYWRkIHRvIHRoZSB1bmZpeGVkIGNvb3JkaW5hdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KG5vZGVJZCwgZGlmZikge1xuICAgICAgdGhpcy5mYWtlX3VzZShub2RlSWQsIGRpZmYpO1xuICAgICAgdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEaXJlY3Rpb25JbnRlcmZhY2U7XG59KCk7XG4vKipcbiAqIFZlcnRpY2FsIFN0cmF0ZWd5XG4gKlxuICogQ29vcmRpbmF0ZSBgeWAgaXMgZml4ZWQgb24gbGV2ZWxzLCBjb29yZGluYXRlIGB4YCBpcyB1bmZpeGVkLlxuICpcbiAqIEBhdWdtZW50cyBEaXJlY3Rpb25JbnRlcmZhY2VcbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgVmVydGljYWxTdHJhdGVneSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0RpcmVjdGlvbkludGVyZmFjZSkge1xuICBfaW5oZXJpdHMoVmVydGljYWxTdHJhdGVneSwgX0RpcmVjdGlvbkludGVyZmFjZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihWZXJ0aWNhbFN0cmF0ZWd5KTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGxheW91dCByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBMYXlvdXRFbmdpbmUgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBWZXJ0aWNhbFN0cmF0ZWd5KGxheW91dCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWZXJ0aWNhbFN0cmF0ZWd5KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhWZXJ0aWNhbFN0cmF0ZWd5LCBbe1xuICAgIGtleTogXCJjdXJ2ZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VydmVUeXBlKCkge1xuICAgICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLng7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxheW91dC5oaWVyYXJjaGljYWwuYWRkVG9PcmRlcmluZyhub2RlLCBsZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUueCA9IHBvc2l0aW9uO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFRyZWVTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyZWVTaXplKGluZGV4KSB7XG4gICAgICB2YXIgcmVzID0gdGhpcy5sYXlvdXQuaGllcmFyY2hpY2FsLmdldFRyZWVTaXplKHRoaXMubGF5b3V0LmJvZHkubm9kZXMsIGluZGV4KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogcmVzLm1pbl94LFxuICAgICAgICBtYXg6IHJlcy5tYXhfeFxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQobm9kZUFycmF5KSB7XG4gICAgICB0aW1zb3J0LnNvcnQobm9kZUFycmF5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS54IC0gYi54O1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpeChub2RlLCBsZXZlbCkge1xuICAgICAgbm9kZS55ID0gdGhpcy5sYXlvdXQub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICogbGV2ZWw7XG4gICAgICBub2RlLm9wdGlvbnMuZml4ZWQueSA9IHRydWU7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQobm9kZUlkLCBkaWZmKSB7XG4gICAgICB0aGlzLmxheW91dC5ib2R5Lm5vZGVzW25vZGVJZF0ueCArPSBkaWZmO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWZXJ0aWNhbFN0cmF0ZWd5O1xufShEaXJlY3Rpb25JbnRlcmZhY2UpO1xuLyoqXG4gKiBIb3Jpem9udGFsIFN0cmF0ZWd5XG4gKlxuICogQ29vcmRpbmF0ZSBgeGAgaXMgZml4ZWQgb24gbGV2ZWxzLCBjb29yZGluYXRlIGB5YCBpcyB1bmZpeGVkLlxuICpcbiAqIEBhdWdtZW50cyBEaXJlY3Rpb25JbnRlcmZhY2VcbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgSG9yaXpvbnRhbFN0cmF0ZWd5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRGlyZWN0aW9uSW50ZXJmYWNlMikge1xuICBfaW5oZXJpdHMoSG9yaXpvbnRhbFN0cmF0ZWd5LCBfRGlyZWN0aW9uSW50ZXJmYWNlMik7XG5cbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoSG9yaXpvbnRhbFN0cmF0ZWd5KTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGxheW91dCByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBMYXlvdXRFbmdpbmUgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBIb3Jpem9udGFsU3RyYXRlZ3kobGF5b3V0KSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIb3Jpem9udGFsU3RyYXRlZ3kpO1xuXG4gICAgX3RoaXMyID0gX3N1cGVyMi5jYWxsKHRoaXMpO1xuICAgIF90aGlzMi5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhIb3Jpem9udGFsU3RyYXRlZ3ksIFt7XG4gICAga2V5OiBcImN1cnZlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJ2ZVR5cGUoKSB7XG4gICAgICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxheW91dC5oaWVyYXJjaGljYWwuYWRkVG9PcmRlcmluZyhub2RlLCBsZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUueSA9IHBvc2l0aW9uO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFRyZWVTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyZWVTaXplKGluZGV4KSB7XG4gICAgICB2YXIgcmVzID0gdGhpcy5sYXlvdXQuaGllcmFyY2hpY2FsLmdldFRyZWVTaXplKHRoaXMubGF5b3V0LmJvZHkubm9kZXMsIGluZGV4KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogcmVzLm1pbl95LFxuICAgICAgICBtYXg6IHJlcy5tYXhfeVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQobm9kZUFycmF5KSB7XG4gICAgICB0aW1zb3J0LnNvcnQobm9kZUFycmF5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS55IC0gYi55O1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpeChub2RlLCBsZXZlbCkge1xuICAgICAgbm9kZS54ID0gdGhpcy5sYXlvdXQub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICogbGV2ZWw7XG4gICAgICBub2RlLm9wdGlvbnMuZml4ZWQueCA9IHRydWU7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQobm9kZUlkLCBkaWZmKSB7XG4gICAgICB0aGlzLmxheW91dC5ib2R5Lm5vZGVzW25vZGVJZF0ueSArPSBkaWZmO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIb3Jpem9udGFsU3RyYXRlZ3k7XG59KERpcmVjdGlvbkludGVyZmFjZSk7XG5cbnZhciAkID0gX2V4cG9ydDtcbnZhciAkZXZlcnkgPSBhcnJheUl0ZXJhdGlvbi5ldmVyeTtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gYXJyYXlNZXRob2RJc1N0cmljdCQ2O1xudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdldmVyeScpOyAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG5cbiQoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6ICFTVFJJQ1RfTUVUSE9EXG59LCB7XG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuXG4gIC8qICwgdGhpc0FyZyAqL1xuICApIHtcbiAgICByZXR1cm4gJGV2ZXJ5KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwgPSBlbnRyeVZpcnR1YWwkbDtcbnZhciBldmVyeSQzID0gZW50cnlWaXJ0dWFsKCdBcnJheScpLmV2ZXJ5O1xuXG52YXIgaXNQcm90b3R5cGVPZiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kID0gZXZlcnkkMztcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIGV2ZXJ5JDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmV2ZXJ5O1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlIHx8IGlzUHJvdG90eXBlT2YoQXJyYXlQcm90b3R5cGUsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlLmV2ZXJ5ID8gbWV0aG9kIDogb3duO1xufTtcblxudmFyIHBhcmVudCA9IGV2ZXJ5JDI7XG52YXIgZXZlcnkkMSA9IHBhcmVudDtcblxudmFyIGV2ZXJ5ID0gZXZlcnkkMTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2Ygc3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGdldEl0ZXJhdG9yTWV0aG9kJDEobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKGlzQXJyYXkkMihvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQxKG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQ5OyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMShvLCBtaW5MZW4pOyB2YXIgbiA9IHNsaWNlKF9jb250ZXh0OSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDksIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb20kMyhvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLyoqXHJcbiAqIFRyeSB0byBhc3NpZ24gbGV2ZWxzIHRvIG5vZGVzIGFjY29yZGluZyB0byB0aGVpciBwb3NpdGlvbnMgaW4gdGhlIGN5Y2xpYyDigJxoaWVyYXJjaHnigJ0uXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlcyAtIFZpc2libGUgbm9kZXMgb2YgdGhlIGdyYXBoLlxyXG4gKiBAcGFyYW0gbGV2ZWxzIC0gSWYgcHJlc2VudCBsZXZlbHMgd2lsbCBiZSBhZGRlZCB0byBpdCwgaWYgbm90IGEgbmV3IG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAqIEByZXR1cm5zIFBvcHVsYXRlZCBub2RlIGxldmVscy5cclxuICovXG5mdW5jdGlvbiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb25DeWNsaWMobm9kZXMsIGxldmVscykge1xuICB2YXIgZWRnZXMgPSBuZXcgc2V0KCk7XG5cbiAgZm9yRWFjaCQyKG5vZGVzKS5jYWxsKG5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBfY29udGV4dDtcblxuICAgIGZvckVhY2gkMihfY29udGV4dCA9IG5vZGUuZWRnZXMpLmNhbGwoX2NvbnRleHQsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICBpZiAoZWRnZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgZWRnZXMuYWRkKGVkZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBmb3JFYWNoJDIoZWRnZXMpLmNhbGwoZWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgdmFyIGZyb21JZCA9IGVkZ2UuZnJvbS5pZDtcbiAgICB2YXIgdG9JZCA9IGVkZ2UudG8uaWQ7XG5cbiAgICBpZiAobGV2ZWxzW2Zyb21JZF0gPT0gbnVsbCkge1xuICAgICAgbGV2ZWxzW2Zyb21JZF0gPSAwO1xuICAgIH1cblxuICAgIGlmIChsZXZlbHNbdG9JZF0gPT0gbnVsbCB8fCBsZXZlbHNbZnJvbUlkXSA+PSBsZXZlbHNbdG9JZF0pIHtcbiAgICAgIGxldmVsc1t0b0lkXSA9IGxldmVsc1tmcm9tSWRdICsgMTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBsZXZlbHM7XG59XG4vKipcclxuICogQXNzaWduIGxldmVscyB0byBub2RlcyBhY2NvcmRpbmcgdG8gdGhlaXIgcG9zaXRpb25zIGluIHRoZSBoaWVyYXJjaHkuIExlYXZlcyB3aWxsIGJlIGxpbmVkIHVwIGF0IHRoZSBib3R0b20gYW5kIGFsbCBvdGhlciBub2RlcyBhcyBjbG9zZSB0byB0aGVpciBjaGlsZHJlbiBhcyBwb3NzaWJsZS5cclxuICpcclxuICogQHBhcmFtIG5vZGVzIC0gVmlzaWJsZSBub2RlcyBvZiB0aGUgZ3JhcGguXHJcbiAqIEByZXR1cm5zIFBvcHVsYXRlZCBub2RlIGxldmVscy5cclxuICovXG5cblxuZnVuY3Rpb24gZmlsbExldmVsc0J5RGlyZWN0aW9uTGVhdmVzKG5vZGVzKSB7XG4gIHJldHVybiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb24oIC8vIFBpY2sgb25seSBsZWF2ZXMgKG5vZGVzIHdpdGhvdXQgY2hpbGRyZW4pLlxuICBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBfY29udGV4dDIsIF9jb250ZXh0MztcblxuICAgIHJldHVybiBldmVyeShfY29udGV4dDIgPSBmaWx0ZXIoX2NvbnRleHQzID0gbm9kZS5lZGdlcyAvLyBUYWtlIG9ubHkgdmlzaWJsZSBub2RlcyBpbnRvIGFjY291bnQuXG4gICAgKS5jYWxsKF9jb250ZXh0MywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBub2Rlcy5oYXMoZWRnZS50b0lkKTtcbiAgICB9KSAvLyBDaGVjayB0aGF0IGFsbCBlZGdlcyBsZWFkIHRvIHRoaXMgbm9kZSAobGVhZikuXG4gICAgKS5jYWxsKF9jb250ZXh0MiwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLnRvID09PSBub2RlO1xuICAgIH0pO1xuICB9LCAvLyBVc2UgdGhlIGxvd2VzdCBsZXZlbC5cbiAgZnVuY3Rpb24gKG5ld0xldmVsLCBvbGRMZXZlbCkge1xuICAgIHJldHVybiBvbGRMZXZlbCA+IG5ld0xldmVsO1xuICB9LCAvLyBHbyBhZ2FpbnN0IHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VzLlxuICBcImZyb21cIiwgbm9kZXMpO1xufVxuLyoqXHJcbiAqIEFzc2lnbiBsZXZlbHMgdG8gbm9kZXMgYWNjb3JkaW5nIHRvIHRoZWlyIHBvc2l0aW9ucyBpbiB0aGUgaGllcmFyY2h5LiBSb290cyB3aWxsIGJlIGxpbmVkIHVwIGF0IHRoZSB0b3AgYW5kIGFsbCBub2RlcyBhcyBjbG9zZSB0byB0aGVpciBwYXJlbnRzIGFzIHBvc3NpYmxlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbm9kZXMgLSBWaXNpYmxlIG5vZGVzIG9mIHRoZSBncmFwaC5cclxuICogQHJldHVybnMgUG9wdWxhdGVkIG5vZGUgbGV2ZWxzLlxyXG4gKi9cblxuZnVuY3Rpb24gZmlsbExldmVsc0J5RGlyZWN0aW9uUm9vdHMobm9kZXMpIHtcbiAgcmV0dXJuIGZpbGxMZXZlbHNCeURpcmVjdGlvbiggLy8gUGljayBvbmx5IHJvb3RzIChub2RlcyB3aXRob3V0IHBhcmVudHMpLlxuICBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBfY29udGV4dDQsIF9jb250ZXh0NTtcblxuICAgIHJldHVybiBldmVyeShfY29udGV4dDQgPSBmaWx0ZXIoX2NvbnRleHQ1ID0gbm9kZS5lZGdlcyAvLyBUYWtlIG9ubHkgdmlzaWJsZSBub2RlcyBpbnRvIGFjY291bnQuXG4gICAgKS5jYWxsKF9jb250ZXh0NSwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBub2Rlcy5oYXMoZWRnZS50b0lkKTtcbiAgICB9KSAvLyBDaGVjayB0aGF0IGFsbCBlZGdlcyBsZWFkIGZyb20gdGhpcyBub2RlIChyb290KS5cbiAgICApLmNhbGwoX2NvbnRleHQ0LCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuZnJvbSA9PT0gbm9kZTtcbiAgICB9KTtcbiAgfSwgLy8gVXNlIHRoZSBoaWdoZXN0IGxldmVsLlxuICBmdW5jdGlvbiAobmV3TGV2ZWwsIG9sZExldmVsKSB7XG4gICAgcmV0dXJuIG9sZExldmVsIDwgbmV3TGV2ZWw7XG4gIH0sIC8vIEdvIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VzLlxuICBcInRvXCIsIG5vZGVzKTtcbn1cbi8qKlxyXG4gKiBBc3NpZ24gbGV2ZWxzIHRvIG5vZGVzIGFjY29yZGluZyB0byB0aGVpciBwb3NpdGlvbnMgaW4gdGhlIGhpZXJhcmNoeS5cclxuICpcclxuICogQHBhcmFtIGlzRW50cnlOb2RlIC0gQ2hlY2tzIGFuZCByZXR1cm4gdHJ1ZSBpZiB0aGUgZ3JhcGggc2hvdWxkIGJlIHRyYXZlcnNlZCBmcm9tIHRoaXMgbm9kZS5cclxuICogQHBhcmFtIHNob3VsZExldmVsQmVSZXBsYWNlZCAtIENoZWNrcyBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZSBsZXZlbCBvZiBnaXZlbiBub2RlIHNob3VsZCBiZSB1cGRhdGVkIHRvIHRoZSBuZXcgdmFsdWUuXHJcbiAqIEBwYXJhbSBkaXJlY3Rpb24gLSBXaGV0ZXIgdGhlIGdyYXBoIHNob3VsZCBiZSB0cmF2ZXJzZWQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgZWRnZXMgYFwidG9cImAgb3IgaW4gdGhlIG90aGVyIHdheSBgXCJmcm9tXCJgLlxyXG4gKiBAcGFyYW0gbm9kZXMgLSBWaXNpYmxlIG5vZGVzIG9mIHRoZSBncmFwaC5cclxuICogQHJldHVybnMgUG9wdWxhdGVkIG5vZGUgbGV2ZWxzLlxyXG4gKi9cblxuZnVuY3Rpb24gZmlsbExldmVsc0J5RGlyZWN0aW9uKGlzRW50cnlOb2RlLCBzaG91bGRMZXZlbEJlUmVwbGFjZWQsIGRpcmVjdGlvbiwgbm9kZXMpIHtcbiAgdmFyIF9jb250ZXh0NjtcblxuICB2YXIgbGV2ZWxzID0gY3JlYXRlJDUobnVsbCk7IC8vIElmIGFjeWNsaWMsIHRoZSBncmFwaCBjYW4gYmUgd2Fsa2VkIHRocm91Z2ggd2l0aCAobW9zdCBsaWtlbHkgd2F5KSBmZXdlclxuICAvLyBzdGVwcyB0aGFuIHRoZSBudW1iZXIgYmVsbG93LiBUaGUgZXhhY3QgdmFsdWUgaXNuJ3QgdG9vIGltcG9ydGFudCBhcyBsb25nXG4gIC8vIGFzIGl0J3MgcXVpY2sgdG8gY29tcHV0ZSAoZG9lc24ndCBpbXBhY3QgYWN5Y2xpYyBncmFwaHMgdG9vIG11Y2gpLCBpc1xuICAvLyBoaWdoZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHN0ZXBzIGFjdHVhbGx5IG5lZWRlZCAoZG9lc24ndCBjdXQgb2ZmIGJlZm9yZVxuICAvLyBhY3ljbGljIGdyYXBoIGlzIHdhbGtlZCB0aHJvdWdoKSBhbmQgcHJldmVudHMgaW5maW5pdGUgbG9vcHMgKGN1dHMgb2ZmIGZvclxuICAvLyBjeWNsaWMgZ3JhcGhzKS5cblxuXG4gIHZhciBsaW1pdCA9IHJlZHVjZShfY29udGV4dDYgPSBfdG9Db25zdW1hYmxlQXJyYXkodmFsdWVzKG5vZGVzKS5jYWxsKG5vZGVzKSkpLmNhbGwoX2NvbnRleHQ2LCBmdW5jdGlvbiAoYWNjLCBub2RlKSB7XG4gICAgcmV0dXJuIGFjYyArIDEgKyBub2RlLmVkZ2VzLmxlbmd0aDtcbiAgfSwgMCk7XG5cbiAgdmFyIGVkZ2VJZFByb3AgPSBkaXJlY3Rpb24gKyBcIklkXCI7XG4gIHZhciBuZXdMZXZlbERpZmYgPSBkaXJlY3Rpb24gPT09IFwidG9cIiA/IDEgOiAtMTtcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShub2RlcyksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgIGVudHJ5Tm9kZUlkID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgZW50cnlOb2RlID0gX3N0ZXAkdmFsdWVbMV07XG5cbiAgICAgIGlmICggLy8gU2tpcCBpZiB0aGUgbm9kZSBpcyBub3QgdmlzaWJsZS5cbiAgICAgICFub2Rlcy5oYXMoZW50cnlOb2RlSWQpIHx8IC8vIFNraXAgaWYgdGhlIG5vZGUgaXMgbm90IGFuIGVudHJ5IG5vZGUuXG4gICAgICAhaXNFbnRyeU5vZGUoZW50cnlOb2RlKSkge1xuICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgfSAvLyBMaW5lIHVwIGFsbCB0aGUgZW50cnkgbm9kZXMgb24gbGV2ZWwgMC5cblxuXG4gICAgICBsZXZlbHNbZW50cnlOb2RlSWRdID0gMDtcbiAgICAgIHZhciBzdGFjayA9IFtlbnRyeU5vZGVdO1xuICAgICAgdmFyIGRvbmUgPSAwO1xuICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG5cbiAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICAgIHZhciBfY29udGV4dDcsIF9jb250ZXh0ODtcblxuICAgICAgICBpZiAoIW5vZGVzLmhhcyhlbnRyeU5vZGVJZCkpIHtcbiAgICAgICAgICAvLyBTa2lwIGlmIHRoZSBub2RlIGlzIG5vdCB2aXNpYmxlLlxuICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3TGV2ZWwgPSBsZXZlbHNbbm9kZS5pZF0gKyBuZXdMZXZlbERpZmY7XG5cbiAgICAgICAgZm9yRWFjaCQyKF9jb250ZXh0NyA9IGZpbHRlcihfY29udGV4dDggPSBub2RlLmVkZ2VzKS5jYWxsKF9jb250ZXh0OCwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICByZXR1cm4gKC8vIElnbm9yZSBkaXNjb25uZWN0ZWQgZWRnZXMuXG4gICAgICAgICAgICBlZGdlLmNvbm5lY3RlZCAmJiAvLyBJZ25vcmUgY2lyY3VsYXIgZWRnZXMuXG4gICAgICAgICAgICBlZGdlLnRvICE9PSBlZGdlLmZyb20gJiYgLy8gSWdub3JlIGVkZ2VzIGxlYWRpbmcgdG8gdGhlIG5vZGUgdGhhdCdzIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgICAgICBlZGdlW2RpcmVjdGlvbl0gIT09IG5vZGUgJiYgLy8gSWdub3JlIGVkZ2VzIGNvbm5lY3RpbmcgdG8gYW4gaW52aXNpYmxlIG5vZGUuXG4gICAgICAgICAgICBub2Rlcy5oYXMoZWRnZS50b0lkKSAmJiAvLyBJZ25vcmUgZWRnZXMgY29ubmVjdGluZyBmcm9tIGFuIGludmlzaWJsZSBub2RlLlxuICAgICAgICAgICAgbm9kZXMuaGFzKGVkZ2UuZnJvbUlkKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pKS5jYWxsKF9jb250ZXh0NywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZUlkID0gZWRnZVtlZGdlSWRQcm9wXTtcbiAgICAgICAgICB2YXIgb2xkTGV2ZWwgPSBsZXZlbHNbdGFyZ2V0Tm9kZUlkXTtcblxuICAgICAgICAgIGlmIChvbGRMZXZlbCA9PSBudWxsIHx8IHNob3VsZExldmVsQmVSZXBsYWNlZChuZXdMZXZlbCwgb2xkTGV2ZWwpKSB7XG4gICAgICAgICAgICBsZXZlbHNbdGFyZ2V0Tm9kZUlkXSA9IG5ld0xldmVsO1xuICAgICAgICAgICAgc3RhY2sucHVzaChlZGdlW2RpcmVjdGlvbl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRvbmUgPiBsaW1pdCkge1xuICAgICAgICAgIC8vIFRoaXMgd291bGQgcnVuIGZvcmV2ZXIgb24gYSBjeWNsaWMgZ3JhcGguXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHY6IHtcbiAgICAgICAgICAgICAgdjogZmlsbExldmVsc0J5RGlyZWN0aW9uQ3ljbGljKG5vZGVzLCBsZXZlbHMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK2RvbmU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHdoaWxlIChub2RlID0gc3RhY2sucG9wKCkpIHtcbiAgICAgICAgdmFyIF9yZXQyID0gX2xvb3AyKCk7XG5cbiAgICAgICAgaWYgKF9yZXQyID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoX3R5cGVvZihfcmV0MikgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0Mi52O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcCgpO1xuXG4gICAgICBpZiAoX3JldCA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICAgIGlmIChfdHlwZW9mKF9yZXQpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldC52O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgcmV0dXJuIGxldmVscztcbn1cblxuLyoqXG4gKiBUaGVyZSdzIGEgbWl4LXVwIHdpdGggdGVybXMgaW4gdGhlIGNvZGUuIEZvbGxvd2luZyBhcmUgdGhlIGZvcm1hbCBkZWZpbml0aW9uczpcbiAqXG4gKiAgIHRyZWUgICAtIGEgc3RyaWN0IGhpZXJhcmNoaWNhbCBuZXR3b3JrLCBpLmUuIGV2ZXJ5IG5vZGUgaGFzIGF0IG1vc3Qgb25lIHBhcmVudFxuICogICBmb3Jlc3QgLSBhIGNvbGxlY3Rpb24gb2YgdHJlZXMuIFRoZXNlIGRpc3RpbmN0IHRyZWVzIGFyZSB0aHVzIG5vdCBjb25uZWN0ZWQuXG4gKlxuICogU286XG4gKiAtIGluIGEgbmV0d29yayB0aGF0IGlzIG5vdCBhIHRyZWUsIHRoZXJlIGV4aXN0IG5vZGVzIHdpdGggbXVsdGlwbGUgcGFyZW50cy5cbiAqIC0gYSBuZXR3b3JrIGNvbnNpc3Rpbmcgb2YgdW5jb25uZWN0ZWQgc3ViLW5ldHdvcmtzLCBvZiB3aGljaCBhdCBsZWFzdCBvbmVcbiAqICAgaXMgbm90IGEgdHJlZSwgaXMgbm90IGEgZm9yZXN0LlxuICpcbiAqIEluIHRoZSBjb2RlLCB0aGUgZGVmaW5pdGlvbnMgYXJlOlxuICpcbiAqICAgdHJlZSAgIC0gYW55IGRpc2Nvbm5lY3RlZCBzdWItbmV0d29yaywgc3RyaWN0IGhpZXJhcmNoaWNhbCBvciBub3QuXG4gKiAgIGZvcmVzdCAtIGEgYnVuY2ggb2YgdGhlc2Ugc3ViLW5ldHdvcmtzXG4gKlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0cmVlIGFuZCBub3QtdHJlZSBpcyBpbXBvcnRhbnQgaW4gdGhlIGNvZGUsIG5vdGFibHkgd2l0aGluXG4gKiB0byB0aGUgYmxvY2stc2hpZnRpbmcgYWxnb3JpdGhtLiBUaGUgYWxnb3JpdGhtIGFzc3VtZXMgZm9ybWFsIHRyZWVzIGFuZCBmYWlsc1xuICogZm9yIG5vdC10cmVlcywgb2Z0ZW4gaW4gYSBzcGVjdGFjdWxhciBtYW5uZXIgKHNlYXJjaCBmb3IgJ2V4cGxvZGluZyBuZXR3b3JrJyBpbiB0aGUgaXNzdWVzKS5cbiAqXG4gKiBJbiBvcmRlciB0byBkaXN0aW5ndWlzaCB0aGUgZGVmaW5pdGlvbnMgaW4gdGhlIGZvbGxvd2luZyBjb2RlLCB0aGUgYWRqZWN0aXZlICdmb3JtYWwnIGlzXG4gKiB1c2VkLiBJZiAnZm9ybWFsJyBpcyBhYnNlbnQsIHlvdSBtdXN0IGFzc3VtZSB0aGUgbm9uLWZvcm1hbCBkZWZpbml0aW9uLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIE5PVEVTXG4gKiA9PT09PVxuICpcbiAqIEEgaGllcmFyY2hpY2FsIGxheW91dCBpcyBhIGRpZmZlcmVudCB0aGluZyBmcm9tIGEgaGllcmFyY2hpY2FsIG5ldHdvcmsuXG4gKiBUaGUgbGF5b3V0IGlzIGEgd2F5IHRvIGFycmFuZ2UgdGhlIG5vZGVzIGluIHRoZSB2aWV3OyB0aGlzIGNhbiBiZSBkb25lXG4gKiBvbiBub24taGllcmFyY2hpY2FsIG5ldHdvcmtzIGFzIHdlbGwuIFRoZSBjb252ZXJzZSBpcyBhbHNvIHBvc3NpYmxlLlxuICovXG4vKipcbiAqIENvbnRhaW5lciBmb3IgZGVyaXZlZCBkYXRhIG9uIGN1cnJlbnQgbmV0d29yaywgcmVsYXRpbmcgdG8gaGllcmFyY2h5LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIEhpZXJhcmNoaWNhbFN0YXR1cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBIaWVyYXJjaGljYWxTdGF0dXMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhpZXJhcmNoaWNhbFN0YXR1cyk7XG5cbiAgICB0aGlzLmNoaWxkcmVuUmVmZXJlbmNlID0ge307IC8vIGNoaWxkIGlkJ3MgcGVyIG5vZGUgaWRcblxuICAgIHRoaXMucGFyZW50UmVmZXJlbmNlID0ge307IC8vIHBhcmVudCBpZCdzIHBlciBub2RlIGlkXG5cbiAgICB0aGlzLnRyZWVzID0ge307IC8vIHRyZWUgaWQgcGVyIG5vZGUgaWQ7IGkuZS4gdG8gd2hpY2ggdHJlZSBkb2VzIGdpdmVuIG5vZGUgaWQgYmVsb25nXG5cbiAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nID0ge307IC8vIFRoZSBub2RlcyBwZXIgbGV2ZWwsIGluIHRoZSBkaXNwbGF5IG9yZGVyXG5cbiAgICB0aGlzLmxldmVscyA9IHt9OyAvLyBoaWVyYXJjaHkgbGV2ZWwgcGVyIG5vZGUgaWRcblxuICAgIHRoaXMuZGlzdHJpYnV0aW9uSW5kZXggPSB7fTsgLy8gVGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGluIHRoZSBsZXZlbCBzb3J0aW5nIG9yZGVyLCBwZXIgbm9kZSBpZC5cblxuICAgIHRoaXMuaXNUcmVlID0gZmFsc2U7IC8vIFRydWUgaWYgY3VycmVudCBuZXR3b3JrIGlzIGEgZm9ybWFsIHRyZWVcblxuICAgIHRoaXMudHJlZUluZGV4ID0gLTE7IC8vIEhpZ2hlc3QgdHJlZSBpZCBpbiBjdXJyZW50IG5ldHdvcmsuXG4gIH1cbiAgLyoqXG4gICAqIEFkZCB0aGUgcmVsYXRpb24gYmV0d2VlbiBnaXZlbiBub2RlcyB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlLmlkfSBwYXJlbnROb2RlSWRcbiAgICogQHBhcmFtIHtOb2RlLmlkfSBjaGlsZE5vZGVJZFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhIaWVyYXJjaGljYWxTdGF0dXMsIFt7XG4gICAga2V5OiBcImFkZFJlbGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFJlbGF0aW9uKHBhcmVudE5vZGVJZCwgY2hpbGROb2RlSWQpIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuUmVmZXJlbmNlW3BhcmVudE5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuUmVmZXJlbmNlW3BhcmVudE5vZGVJZF0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdLnB1c2goY2hpbGROb2RlSWQpO1xuXG4gICAgICBpZiAodGhpcy5wYXJlbnRSZWZlcmVuY2VbY2hpbGROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRSZWZlcmVuY2VbY2hpbGROb2RlSWRdID0gW107XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFyZW50UmVmZXJlbmNlW2NoaWxkTm9kZUlkXS5wdXNoKHBhcmVudE5vZGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBjdXJyZW50IHN0YXRlIGlzIGZvciBhIGZvcm1hbCB0cmVlIG9yIGZvcm1hbCBmb3Jlc3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBjYXNlIGlmIGV2ZXJ5IG5vZGUgaGFzIGF0IG1vc3Qgb25lIHBhcmVudC5cbiAgICAgKlxuICAgICAqIFByZTogcGFyZW50UmVmZXJlbmNlIGluaXQnZWQgcHJvcGVybHkgZm9yIGN1cnJlbnQgbmV0d29ya1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tJZlRyZWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tJZlRyZWUoKSB7XG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMucGFyZW50UmVmZXJlbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudFJlZmVyZW5jZVtpXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy5pc1RyZWUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5pc1RyZWUgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBzZXBhcmF0ZSB0cmVlcyBpbiB0aGUgY3VycmVudCBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm51bVRyZWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG51bVRyZWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJlZUluZGV4ICsgMTsgLy8gVGhpcyBhc3N1bWVzIHRoZSBpbmRleGVzIGFyZSBhc3NpZ25lZCBjb25zZWNpdGl2ZWx5XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2lnbiBhIHRyZWUgaWQgdG8gYSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHRyZWVJZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VHJlZUluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRyZWVJbmRleChub2RlLCB0cmVlSWQpIHtcbiAgICAgIGlmICh0cmVlSWQgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBEb24ndCBib3RoZXJcblxuICAgICAgaWYgKHRoaXMudHJlZXNbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRyZWVzW25vZGUuaWRdID0gdHJlZUlkO1xuICAgICAgICB0aGlzLnRyZWVJbmRleCA9IE1hdGgubWF4KHRyZWVJZCwgdGhpcy50cmVlSW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgbGV2ZWwgZm9yIGdpdmVuIGlkIGlzIGRlZmluZWQuXG4gICAgICpcbiAgICAgKiBTZXRzIGxldmVsIHRvIHplcm8gZm9yIGdpdmVuIG5vZGUgaWQgaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuc3VyZUxldmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZUxldmVsKG5vZGVJZCkge1xuICAgICAgaWYgKHRoaXMubGV2ZWxzW25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxldmVsc1tub2RlSWRdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBtYXhpbXVtIGxldmVsIG9mIGEgYnJhbmNoLlxuICAgICAqXG4gICAgICogVE9ETzogTmV2ZXIgZW50ZXJlZDsgZmluZCBhIHRlc3QgY2FzZSB0byB0ZXN0IHRoaXMhXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXhMZXZlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhMZXZlbChub2RlSWQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBhY2N1bXVsYXRvciA9IHt9O1xuXG4gICAgICB2YXIgX2dldE1heExldmVsID0gZnVuY3Rpb24gX2dldE1heExldmVsKG5vZGVJZCkge1xuICAgICAgICBpZiAoYWNjdW11bGF0b3Jbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yW25vZGVJZF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGV2ZWwgPSBfdGhpcy5sZXZlbHNbbm9kZUlkXTtcblxuICAgICAgICBpZiAoX3RoaXMuY2hpbGRyZW5SZWZlcmVuY2Vbbm9kZUlkXSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IF90aGlzLmNoaWxkcmVuUmVmZXJlbmNlW25vZGVJZF07XG5cbiAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsZXZlbCA9IE1hdGgubWF4KGxldmVsLCBfZ2V0TWF4TGV2ZWwoY2hpbGRyZW5baV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhY2N1bXVsYXRvcltub2RlSWRdID0gbGV2ZWw7XG4gICAgICAgIHJldHVybiBsZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfZ2V0TWF4TGV2ZWwobm9kZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVBXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlQlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGV2ZWxEb3duc3RyZWFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxldmVsRG93bnN0cmVhbShub2RlQSwgbm9kZUIpIHtcbiAgICAgIGlmICh0aGlzLmxldmVsc1tub2RlQi5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBzZXQgaW5pdGlhbCBsZXZlbFxuICAgICAgICBpZiAodGhpcy5sZXZlbHNbbm9kZUEuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmxldmVsc1tub2RlQS5pZF0gPSAwO1xuICAgICAgICB9IC8vIHNldCBsZXZlbFxuXG5cbiAgICAgICAgdGhpcy5sZXZlbHNbbm9kZUIuaWRdID0gdGhpcy5sZXZlbHNbbm9kZUEuaWRdICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU21hbGwgdXRpbCBtZXRob2QgdG8gc2V0IHRoZSBtaW5pbXVtIGxldmVscyBvZiB0aGUgbm9kZXMgdG8gemVyby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBub2Rlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TWluTGV2ZWxUb1plcm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWluTGV2ZWxUb1plcm8obm9kZXMpIHtcbiAgICAgIHZhciBtaW5MZXZlbCA9IDFlOTsgLy8gZ2V0IHRoZSBtaW5pbXVtIGxldmVsXG5cbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMubGV2ZWxzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWluTGV2ZWwgPSBNYXRoLm1pbih0aGlzLmxldmVsc1tub2RlSWRdLCBtaW5MZXZlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIHN1YnRyYWN0IHRoZSBtaW5pbXVtIGZyb20gdGhlIHNldCBzbyB3ZSBoYXZlIGEgcmFuZ2Ugc3RhcnRpbmcgZnJvbSAwXG5cblxuICAgICAgZm9yICh2YXIgX25vZGVJZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVzLCBfbm9kZUlkKSkge1xuICAgICAgICAgIGlmICh0aGlzLmxldmVsc1tfbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxldmVsc1tfbm9kZUlkXSAtPSBtaW5MZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtaW4gYW5kIG1heCB4eS1jb29yZGluYXRlcyBvZiBhIGdpdmVuIHRyZWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBub2Rlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHt7bWluX3g6IG51bWJlciwgbWF4X3g6IG51bWJlciwgbWluX3k6IG51bWJlciwgbWF4X3k6IG51bWJlcn19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmVlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShub2RlcywgaW5kZXgpIHtcbiAgICAgIHZhciBtaW5feCA9IDFlOTtcbiAgICAgIHZhciBtYXhfeCA9IC0xZTk7XG4gICAgICB2YXIgbWluX3kgPSAxZTk7XG4gICAgICB2YXIgbWF4X3kgPSAtMWU5O1xuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy50cmVlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMudHJlZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICBpZiAodGhpcy50cmVlc1tub2RlSWRdID09PSBpbmRleCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgbWluX3ggPSBNYXRoLm1pbihub2RlLngsIG1pbl94KTtcbiAgICAgICAgICAgIG1heF94ID0gTWF0aC5tYXgobm9kZS54LCBtYXhfeCk7XG4gICAgICAgICAgICBtaW5feSA9IE1hdGgubWluKG5vZGUueSwgbWluX3kpO1xuICAgICAgICAgICAgbWF4X3kgPSBNYXRoLm1heChub2RlLnksIG1heF95KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluX3g6IG1pbl94LFxuICAgICAgICBtYXhfeDogbWF4X3gsXG4gICAgICAgIG1pbl95OiBtaW5feSxcbiAgICAgICAgbWF4X3k6IG1heF95XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0d28gbm9kZXMgaGF2ZSB0aGUgc2FtZSBwYXJlbnQocylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHR3byBub2RlcyBoYXZlIGEgc2FtZSBhbmNlc3RvciBub2RlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhhc1NhbWVQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzU2FtZVBhcmVudChub2RlMSwgbm9kZTIpIHtcbiAgICAgIHZhciBwYXJlbnRzMSA9IHRoaXMucGFyZW50UmVmZXJlbmNlW25vZGUxLmlkXTtcbiAgICAgIHZhciBwYXJlbnRzMiA9IHRoaXMucGFyZW50UmVmZXJlbmNlW25vZGUyLmlkXTtcblxuICAgICAgaWYgKHBhcmVudHMxID09PSB1bmRlZmluZWQgfHwgcGFyZW50czIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50czEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJlbnRzMi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChwYXJlbnRzMVtpXSA9PSBwYXJlbnRzMltqXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdHdvIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlMVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGlzIHNvLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluU2FtZVN1Yk5ldHdvcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5TYW1lU3ViTmV0d29yayhub2RlMSwgbm9kZTIpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyZWVzW25vZGUxLmlkXSA9PT0gdGhpcy50cmVlc1tub2RlMi5pZF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgdGhlIGRpc3RpbmN0IGxldmVscyBpbiB0aGUgY3VycmVudCBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRMZXZlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGV2ZWxzKCkge1xuICAgICAgcmV0dXJuIGtleXMkNCh0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbm9kZSB0byB0aGUgb3JkZXJpbmcgcGVyIGxldmVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFRvT3JkZXJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVG9PcmRlcmluZyhub2RlLCBsZXZlbCkge1xuICAgICAgaWYgKHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzUHJlc2VudCA9IGZhbHNlO1xuICAgICAgdmFyIGN1ckxldmVsID0gdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG5cbiAgICAgIGZvciAodmFyIG4gaW4gY3VyTGV2ZWwpIHtcbiAgICAgICAgLy9pZiAoY3VyTGV2ZWxbbl0uaWQgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgaWYgKGN1ckxldmVsW25dID09PSBub2RlKSB7XG4gICAgICAgICAgaXNQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzUHJlc2VudCkge1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXS5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbkluZGV4W25vZGUuaWRdID0gdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGllcmFyY2hpY2FsU3RhdHVzO1xufSgpO1xuLyoqXG4gKiBUaGUgTGF5b3V0IEVuZ2luZVxuICovXG5cblxudmFyIExheW91dEVuZ2luZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKi9cbiAgZnVuY3Rpb24gTGF5b3V0RW5naW5lKGJvZHkpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5b3V0RW5naW5lKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7IC8vIE1ha2Ugc3VyZSB0aGVyZSBhbHdheXMgaXMgc29tZSBSTkcgYmVjYXVzZSB0aGUgc2V0T3B0aW9ucyBtZXRob2Qgd29uJ3RcbiAgICAvLyBzZXQgaXQgdW5sZXNzIHRoZXJlJ3MgYSBzZWVkIGZvciBpdC5cblxuICAgIHRoaXMuX3Jlc2V0Uk5HKE1hdGgucmFuZG9tKCkgKyBcIjpcIiArIG5vdyQxKCkpO1xuXG4gICAgdGhpcy5zZXRQaHlzaWNzID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5vcHRpb25zQmFja3VwID0ge1xuICAgICAgcGh5c2ljczoge31cbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICByYW5kb21TZWVkOiB1bmRlZmluZWQsXG4gICAgICBpbXByb3ZlZExheW91dDogdHJ1ZSxcbiAgICAgIGNsdXN0ZXJUaHJlc2hvbGQ6IDE1MCxcbiAgICAgIGhpZXJhcmNoaWNhbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgbGV2ZWxTZXBhcmF0aW9uOiAxNTAsXG4gICAgICAgIG5vZGVTcGFjaW5nOiAxMDAsXG4gICAgICAgIHRyZWVTcGFjaW5nOiAyMDAsXG4gICAgICAgIGJsb2NrU2hpZnRpbmc6IHRydWUsXG4gICAgICAgIGVkZ2VNaW5pbWl6YXRpb246IHRydWUsXG4gICAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB0cnVlLFxuICAgICAgICBkaXJlY3Rpb246IFwiVURcIixcbiAgICAgICAgLy8gVUQsIERVLCBMUiwgUkxcbiAgICAgICAgc29ydE1ldGhvZDogXCJodWJzaXplXCIgLy8gaHVic2l6ZSwgZGlyZWN0ZWRcblxuICAgICAgfVxuICAgIH07XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKExheW91dEVuZ2luZSwgW3tcbiAgICBrZXk6IFwiYmluZEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zZXR1cEhpZXJhcmNoaWNhbExheW91dCgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhTG9hZGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmxheW91dE5ldHdvcmsoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVzZXRIaWVyYXJjaGljYWxMYXlvdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfYWRqdXN0RWRnZXNGb3JIaWVyYXJjaGljYWxMYXlvdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgIT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gZ2V0IHRoZSB0eXBlIG9mIHN0YXRpYyBzbW9vdGggY3VydmUgaW4gY2FzZSBpdCBpcyByZXF1aXJlZFxuXG5cbiAgICAgICAgdmFyIHR5cGUgPSBfdGhpczIuZGlyZWN0aW9uLmN1cnZlVHlwZSgpOyAvLyBmb3JjZSBhbGwgZWRnZXMgaW50byBzdGF0aWMgc21vb3RoIGN1cnZlcy5cblxuXG4gICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcIl9mb3JjZURpc2FibGVEeW5hbWljQ3VydmVzXCIsIHR5cGUsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFsbE9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGFsbE9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGhpZXJhcmNoaWNhbCA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWw7XG4gICAgICAgIHZhciBwcmV2SGllcmFyY2hpY2FsU3RhdGUgPSBoaWVyYXJjaGljYWwuZW5hYmxlZDtcbiAgICAgICAgc2VsZWN0aXZlRGVlcEV4dGVuZChbXCJyYW5kb21TZWVkXCIsIFwiaW1wcm92ZWRMYXlvdXRcIiwgXCJjbHVzdGVyVGhyZXNob2xkXCJdLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCBcImhpZXJhcmNoaWNhbFwiKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5yYW5kb21TZWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9yZXNldFJORyhvcHRpb25zLnJhbmRvbVNlZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhpZXJhcmNoaWNhbC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHByZXZIaWVyYXJjaGljYWxTdGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gcmVmcmVzaCB0aGUgb3ZlcnJpZGRlbiBvcHRpb25zIGZvciBub2RlcyBhbmQgZWRnZXMuXG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVmcmVzaFwiLCB0cnVlKTtcbiAgICAgICAgICB9IC8vIG1ha2Ugc3VyZSB0aGUgbGV2ZWwgc2VwYXJhdGlvbiBpcyB0aGUgcmlnaHQgd2F5IHVwXG5cblxuICAgICAgICAgIGlmIChoaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSBcIlJMXCIgfHwgaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gXCJEVVwiKSB7XG4gICAgICAgICAgICBpZiAoaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgIGhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zZXREaXJlY3Rpb25TdHJhdGVneSgpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzZXRIaWVyYXJjaGljYWxMYXlvdXRcIik7IC8vIGJlY2F1c2UgdGhlIGhpZXJhcmNoaWNhbCBzeXN0ZW0gbmVlZHMgaXQncyBvd24gcGh5c2ljcyBhbmQgc21vb3RoIGN1cnZlIHNldHRpbmdzLFxuICAgICAgICAgIC8vIHdlIGFkYXB0IHRoZSBvdGhlciBvcHRpb25zIGlmIG5lZWRlZC5cblxuICAgICAgICAgIHJldHVybiB0aGlzLmFkYXB0QWxsT3B0aW9uc0ZvckhpZXJhcmNoaWNhbExheW91dChhbGxPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJldkhpZXJhcmNoaWNhbFN0YXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBvdmVycmlkZGVuIG9wdGlvbnMgZm9yIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZWZyZXNoXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZXBFeHRlbmQoYWxsT3B0aW9ucywgdGhpcy5vcHRpb25zQmFja3VwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbE9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvciB3aXRoIGdpdmVuIHNlZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gc2VlZCAtIFRoZSBzZWVkIHRoYXQgd2lsbCBiZSBmb3J3YXJkZWQgdGhlIHRoZSBSTkcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVzZXRSTkdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2V0Uk5HKHNlZWQpIHtcbiAgICAgIHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQgPSBzZWVkO1xuICAgICAgdGhpcy5fcm5nID0gQWxlYSh0aGlzLmluaXRpYWxSYW5kb21TZWVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYWxsT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGFwdEFsbE9wdGlvbnNGb3JIaWVyYXJjaGljYWxMYXlvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRhcHRBbGxPcHRpb25zRm9ySGllcmFyY2hpY2FsTGF5b3V0KGFsbE9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGJhY2t1cFBoeXNpY3MgPSB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljczsgLy8gc2V0IHRoZSBwaHlzaWNzXG5cbiAgICAgICAgaWYgKGFsbE9wdGlvbnMucGh5c2ljcyA9PT0gdW5kZWZpbmVkIHx8IGFsbE9wdGlvbnMucGh5c2ljcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFsbE9wdGlvbnMucGh5c2ljcyA9IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGJhY2t1cFBoeXNpY3MuZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGJhY2t1cFBoeXNpY3MuZW5hYmxlZCxcbiAgICAgICAgICAgIHNvbHZlcjogXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIlxuICAgICAgICAgIH07XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5lbmFibGVkID0gYmFja3VwUGh5c2ljcy5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogYmFja3VwUGh5c2ljcy5lbmFibGVkO1xuICAgICAgICAgIGJhY2t1cFBoeXNpY3Muc29sdmVyID0gYmFja3VwUGh5c2ljcy5zb2x2ZXIgfHwgXCJiYXJuZXNIdXRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGFsbE9wdGlvbnMucGh5c2ljcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLmVuYWJsZWQgPSBhbGxPcHRpb25zLnBoeXNpY3MuZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFsbE9wdGlvbnMucGh5c2ljcy5lbmFibGVkO1xuICAgICAgICAgIGJhY2t1cFBoeXNpY3Muc29sdmVyID0gYWxsT3B0aW9ucy5waHlzaWNzLnNvbHZlciB8fCBcImJhcm5lc0h1dFwiO1xuICAgICAgICAgIGFsbE9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgPSBcImhpZXJhcmNoaWNhbFJlcHVsc2lvblwiO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE9wdGlvbnMucGh5c2ljcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLnNvbHZlciA9IFwiYmFybmVzSHV0XCI7XG4gICAgICAgICAgYWxsT3B0aW9ucy5waHlzaWNzID0ge1xuICAgICAgICAgICAgc29sdmVyOiBcImhpZXJhcmNoaWNhbFJlcHVsc2lvblwiXG4gICAgICAgICAgfTtcbiAgICAgICAgfSAvLyBnZXQgdGhlIHR5cGUgb2Ygc3RhdGljIHNtb290aCBjdXJ2ZSBpbiBjYXNlIGl0IGlzIHJlcXVpcmVkXG5cblxuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuZGlyZWN0aW9uLmN1cnZlVHlwZSgpOyAvLyBkaXNhYmxlIHNtb290aCBjdXJ2ZXMgaWYgbm90aGluZyBpcyBkZWZpbmVkLiBJZiBzbW9vdGggY3VydmVzIGhhdmUgYmVlbiB0dXJuZWQgb24sXG4gICAgICAgIC8vIHR1cm4gdGhlbSBpbnRvIHN0YXRpYyBzbW9vdGggY3VydmVzLlxuXG4gICAgICAgIGlmIChhbGxPcHRpb25zLmVkZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXMgPSB7XG4gICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogXCJkeW5hbWljXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGFsbE9wdGlvbnMuZWRnZXMgPSB7XG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0ge1xuICAgICAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IFwiZHluYW1pY1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXMgPSB7XG4gICAgICAgICAgICAgIHNtb290aDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgsXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzbW9vdGggPSBhbGxPcHRpb25zLmVkZ2VzLnNtb290aDsgLy8gYWxsb3cgY3VzdG9tIHR5cGVzIGV4Y2VwdCBmb3IgZHluYW1pY1xuXG4gICAgICAgICAgICBpZiAoc21vb3RoLnR5cGUgIT09IHVuZGVmaW5lZCAmJiBzbW9vdGgudHlwZSAhPT0gXCJkeW5hbWljXCIpIHtcbiAgICAgICAgICAgICAgdHlwZSA9IHNtb290aC50eXBlO1xuICAgICAgICAgICAgfSAvLyBUT0RPOiB0aGlzIGlzIG9wdGlvbnMgbWVyZ2luZzsgc2VlIGlmIHRoZSBzdGFuZGFyZCByb3V0aW5lcyBjYW4gYmUgdXNlZCBoZXJlLlxuXG5cbiAgICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcyA9IHtcbiAgICAgICAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogc21vb3RoLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBzbW9vdGguZW5hYmxlZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBzbW9vdGgudHlwZSA9PT0gdW5kZWZpbmVkID8gXCJkeW5hbWljXCIgOiBzbW9vdGgudHlwZSxcbiAgICAgICAgICAgICAgICByb3VuZG5lc3M6IHNtb290aC5yb3VuZG5lc3MgPT09IHVuZGVmaW5lZCA/IDAuNSA6IHNtb290aC5yb3VuZG5lc3MsXG4gICAgICAgICAgICAgICAgZm9yY2VEaXJlY3Rpb246IHNtb290aC5mb3JjZURpcmVjdGlvbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBzbW9vdGguZm9yY2VEaXJlY3Rpb25cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTsgLy8gTk9URTogQ29weWluZyBhbiBvYmplY3QgdG8gc2VsZjsgdGhpcyBpcyBiYXNpY2FsbHkgc2V0dGluZyBkZWZhdWx0cyBmb3IgdW5kZWZpbmVkIHZhcmlhYmxlc1xuXG4gICAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogc21vb3RoLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBzbW9vdGguZW5hYmxlZCxcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgcm91bmRuZXNzOiBzbW9vdGgucm91bmRuZXNzID09PSB1bmRlZmluZWQgPyAwLjUgOiBzbW9vdGgucm91bmRuZXNzLFxuICAgICAgICAgICAgICBmb3JjZURpcmVjdGlvbjogc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IHNtb290aC5mb3JjZURpcmVjdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRm9yY2UgYWxsIGVkZ2VzIGludG8gc3RhdGljIHNtb290aCBjdXJ2ZXMuXG4gICAgICAgIC8vIE9ubHkgYXBwbGllcyB0byBlZGdlcyB0aGF0IGRvIG5vdCB1c2UgdGhlIGdsb2JhbCBvcHRpb25zIGZvciBzbW9vdGguXG5cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXNcIiwgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGxPcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBub2Rlc0FycmF5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwb3NpdGlvbkluaXRpYWxseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbkluaXRpYWxseShub2Rlc0FycmF5KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0Uk5HKHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQpO1xuXG4gICAgICAgIHZhciByYWRpdXMgPSBub2Rlc0FycmF5Lmxlbmd0aCArIDUwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNBcnJheVtpXTtcblxuICAgICAgICAgIHZhciBhbmdsZSA9IDIgKiBNYXRoLlBJICogdGhpcy5fcm5nKCk7XG5cbiAgICAgICAgICBpZiAobm9kZS54ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGUueCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobm9kZS55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGUueSA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlIEthbWFkYSBLYXdhaSB0byBwb3NpdGlvbiBub2Rlcy4gVGhpcyBpcyBxdWl0ZSBhIGhlYXZ5IGFsZ29yaXRobSBzbyBpZiB0aGVyZSBhcmUgYSBsb3Qgb2Ygbm9kZXMgd2VcbiAgICAgKiBjbHVzdGVyIHRoZW0gZmlyc3QgdG8gcmVkdWNlIHRoZSBhbW91bnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsYXlvdXROZXR3b3JrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dE5ldHdvcmsoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkICE9PSB0cnVlICYmIHRoaXMub3B0aW9ucy5pbXByb3ZlZExheW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlczsgLy8gZmlyc3QgY2hlY2sgaWYgd2Ugc2hvdWxkIEthbWFkYSBLYXdhaSB0byBsYXlvdXQuIFRoZSB0aHJlc2hvbGQgaXMgaWYgbGVzcyB0aGFuIGhhbGYgb2YgdGhlIHZpc2libGVcbiAgICAgICAgLy8gbm9kZXMgaGF2ZSBwcmVkZWZpbmVkIHBvc2l0aW9ucyB3ZSB1c2UgdGhpcy5cblxuICAgICAgICB2YXIgcG9zaXRpb25EZWZpbmVkID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpbmRpY2VzW2ldXTtcblxuICAgICAgICAgIGlmIChub2RlLnByZWRlZmluZWRQb3NpdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcG9zaXRpb25EZWZpbmVkICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIGxlc3MgdGhhbiBoYWxmIG9mIHRoZSBub2RlcyBoYXZlIGEgcHJlZGVmaW5lZCBwb3NpdGlvbiB3ZSBjb250aW51ZVxuXG5cbiAgICAgICAgaWYgKHBvc2l0aW9uRGVmaW5lZCA8IDAuNSAqIGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIE1BWF9MRVZFTFMgPSAxMDtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSAwO1xuICAgICAgICAgIHZhciBjbHVzdGVyVGhyZXNob2xkID0gdGhpcy5vcHRpb25zLmNsdXN0ZXJUaHJlc2hvbGQ7IC8vXG4gICAgICAgICAgLy8gRGVmaW5lIHRoZSBvcHRpb25zIGZvciB0aGUgaGlkZGVuIGNsdXN0ZXIgbm9kZXNcbiAgICAgICAgICAvLyBUaGVzZSBvcHRpb25zIGRvbid0IHByb3BhZ2F0ZSBvdXRzaWRlIHRoZSBjbHVzdGVyaW5nIHBoYXNlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gU29tZSBvcHRpb25zIGFyZSBleHBsaWNpdGx5IGRpc2FibGVkLCBiZWNhdXNlIHRoZXkgbWF5IGJlIHNldCBpbiBncm91cCBvciBkZWZhdWx0IG5vZGUgb3B0aW9ucy5cbiAgICAgICAgICAvLyBUaGUgY2x1c3RlcnMgYXJlIG5ldmVyIGRpc3BsYXllZCwgc28gbW9zdCBleHBsaWNpdCBzZXR0aW5ncyBoZXJlIHNlcnZlIGFzIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUaGUgZXhwbGljaXQgc2V0dGluZyBvZiAnc2hhcGUnIGlzIHRvIGF2b2lkIGBzaGFwZTogJ2ltYWdlJ2A7IGltYWdlcyBhcmUgbm90IHBhc3NlZCB0byB0aGUgaGlkZGVuXG4gICAgICAgICAgLy8gY2x1c3RlciBub2RlcywgbGVhZGluZyB0byBhbiBleGNlcHRpb24gb24gY3JlYXRpb24uXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBBbGwgc2V0dGluZ3MgaGVyZSBhcmUgcGVyZm9ybWFuY2UgcmVsYXRlZCwgZXhjZXB0IHdoZW4gbm90ZWQgb3RoZXJ3aXNlLlxuICAgICAgICAgIC8vXG5cbiAgICAgICAgICB2YXIgY2x1c3Rlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgc2hhcGU6IFwiZWxsaXBzZVwiLFxuICAgICAgICAgICAgICAvLyBCdWdmaXg6IGF2b2lkIHR5cGUgJ2ltYWdlJywgbm8gaW1hZ2VzIHN1cHBsaWVkXG4gICAgICAgICAgICAgIGxhYmVsOiBcIlwiLFxuICAgICAgICAgICAgICAvLyBhdm9pZCBsYWJlbCBoYW5kbGluZ1xuICAgICAgICAgICAgICBncm91cDogXCJcIixcbiAgICAgICAgICAgICAgLy8gYXZvaWQgZ3JvdXAgaGFuZGxpbmdcbiAgICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICAgIG11bHRpOiBmYWxzZVxuICAgICAgICAgICAgICB9IC8vIGF2b2lkIGZvbnQgcHJvcGFnYXRpb25cblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsdXN0ZXJFZGdlUHJvcGVydGllczoge1xuICAgICAgICAgICAgICBsYWJlbDogXCJcIixcbiAgICAgICAgICAgICAgLy8gYXZvaWQgbGFiZWwgaGFuZGxpbmdcbiAgICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICAgIG11bHRpOiBmYWxzZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAvLyBhdm9pZCBmb250IHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlIC8vIGF2b2lkIGRyYXdpbmcgcGVuYWx0eSBmb3IgY29tcGxleCBlZGdlc1xuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9OyAvLyBpZiB0aGVyZSBhcmUgYSBsb3Qgb2Ygbm9kZXMsIHdlIGNsdXN0ZXIgYmVmb3JlIHdlIHJ1biB0aGUgYWxnb3JpdGhtLlxuICAgICAgICAgIC8vIE5PVEU6IHRoaXMgcGFydCBmYWlscyB0byBmaW5kIGNsdXN0ZXJzIGZvciBsYXJnZSBzY2FsZS1mcmVlIG5ldHdvcmtzLCB3aGljaCBzaG91bGRcbiAgICAgICAgICAvLyAgICAgICBiZSBlYXNpbHkgY2x1c3RlcmFibGUuXG4gICAgICAgICAgLy8gVE9ETzogZXhhbWluZSB3aHkgdGhpcyBpcyBzb1xuXG4gICAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoID4gY2x1c3RlclRocmVzaG9sZCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0TGVuZ3RoID0gaW5kaWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHdoaWxlIChpbmRpY2VzLmxlbmd0aCA+IGNsdXN0ZXJUaHJlc2hvbGQgJiYgbGV2ZWwgPD0gTUFYX0xFVkVMUykge1xuICAgICAgICAgICAgICAvL2NvbnNvbGUudGltZShcImNsdXN0ZXJpbmdcIilcbiAgICAgICAgICAgICAgbGV2ZWwgKz0gMTtcbiAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IGluZGljZXMubGVuZ3RoOyAvLyBpZiB0aGVyZSBhcmUgbWFueSBub2RlcyB3ZSBkbyBhIGh1YnNpemUgY2x1c3RlclxuXG4gICAgICAgICAgICAgIGlmIChsZXZlbCAlIDMgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkubW9kdWxlcy5jbHVzdGVyaW5nLmNsdXN0ZXJCcmlkZ2VzKGNsdXN0ZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkubW9kdWxlcy5jbHVzdGVyaW5nLmNsdXN0ZXJPdXRsaWVycyhjbHVzdGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgYWZ0ZXIgPSBpbmRpY2VzLmxlbmd0aDtcblxuICAgICAgICAgICAgICBpZiAoYmVmb3JlID09IGFmdGVyICYmIGxldmVsICUgMyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlY2x1c3RlckFsbCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9sYXlvdXRGYWlsZWRcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVGhpcyBuZXR3b3JrIGNvdWxkIG5vdCBiZSBwb3NpdGlvbmVkIGJ5IHRoaXMgdmVyc2lvbiBvZiB0aGUgaW1wcm92ZWQgbGF5b3V0IGFsZ29yaXRobS5cIiArIFwiIFBsZWFzZSBkaXNhYmxlIGltcHJvdmVkTGF5b3V0IGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSAvL2NvbnNvbGUudGltZUVuZChcImNsdXN0ZXJpbmdcIilcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhiZWZvcmUsbGV2ZWwsYWZ0ZXIpO1xuXG4gICAgICAgICAgICB9IC8vIGluY3JlYXNlIHRoZSBzaXplIG9mIHRoZSBlZGdlc1xuXG5cbiAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmthbWFkYUthd2FpLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICBzcHJpbmdMZW5ndGg6IE1hdGgubWF4KDE1MCwgMiAqIHN0YXJ0TGVuZ3RoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxldmVsID4gTUFYX0xFVkVMUykge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVGhlIGNsdXN0ZXJpbmcgZGlkbid0IHN1Y2NlZWQgd2l0aGluIHRoZSBhbW91bnQgb2YgaW50ZXJhdGlvbnMgYWxsb3dlZCxcIiArIFwiIHByb2dyZXNzaW5nIHdpdGggcGFydGlhbCByZXN1bHQuXCIpO1xuICAgICAgICAgIH0gLy8gcG9zaXRpb24gdGhlIHN5c3RlbSBmb3IgdGhlc2Ugbm9kZXMgYW5kIGVkZ2VzXG5cblxuICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmthbWFkYUthd2FpLnNvbHZlKGluZGljZXMsIHRoaXMuYm9keS5lZGdlSW5kaWNlcywgdHJ1ZSk7IC8vIHNoaWZ0IHRvIGNlbnRlciBwb2ludFxuXG4gICAgICAgICAgdGhpcy5fc2hpZnRUb0NlbnRlcigpOyAvLyBwZXJ0dXJiIHRoZSBub2RlcyBhIGxpdHRsZSBiaXQgdG8gZm9yY2UgdGhlIHBoeXNpY3MgdG8ga2ljayBpblxuXG5cbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gNzA7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaW5kaWNlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIC8vIE9ubHkgcGVydHVyYiB0aGUgbm9kZXMgdGhhdCBhcmVuJ3QgZml4ZWRcbiAgICAgICAgICAgIHZhciBfbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpbmRpY2VzW19pXV07XG5cbiAgICAgICAgICAgIGlmIChfbm9kZS5wcmVkZWZpbmVkUG9zaXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIF9ub2RlLnggKz0gKDAuNSAtIHRoaXMuX3JuZygpKSAqIG9mZnNldDtcbiAgICAgICAgICAgICAgX25vZGUueSArPSAoMC41IC0gdGhpcy5fcm5nKCkpICogb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gdW5jbHVzdGVyIGFsbCBjbHVzdGVyc1xuXG5cbiAgICAgICAgICB0aGlzLl9kZWNsdXN0ZXJBbGwoKTsgLy8gcmVwb3NpdGlvbiBhbGwgYmV6aWVyIG5vZGVzLlxuXG5cbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlIGFsbCB0aGUgbm9kZXMgdG93YXJkcyB0byB0aGUgY2VudGVyIHNvIGdyYXZpdGF0aW9uYWwgcHVsbCB3aWwgbm90IG1vdmUgdGhlIG5vZGVzIGF3YXkgZnJvbSB2aWV3XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NoaWZ0VG9DZW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NoaWZ0VG9DZW50ZXIoKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBOZXR3b3JrVXRpbC5nZXRSYW5nZUNvcmUodGhpcy5ib2R5Lm5vZGVzLCB0aGlzLmJvZHkubm9kZUluZGljZXMpO1xuICAgICAgdmFyIGNlbnRlciA9IE5ldHdvcmtVdGlsLmZpbmRDZW50ZXIocmFuZ2UpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO1xuICAgICAgICBub2RlLnggLT0gY2VudGVyLng7XG4gICAgICAgIG5vZGUueSAtPSBjZW50ZXIueTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwYW5kcyBhbGwgY2x1c3RlcnNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVjbHVzdGVyQWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWNsdXN0ZXJBbGwoKSB7XG4gICAgICB2YXIgY2x1c3RlcnNQcmVzZW50ID0gdHJ1ZTtcblxuICAgICAgd2hpbGUgKGNsdXN0ZXJzUHJlc2VudCA9PT0gdHJ1ZSkge1xuICAgICAgICBjbHVzdGVyc1ByZXNlbnQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJzUHJlc2VudCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJvZHkubW9kdWxlcy5jbHVzdGVyaW5nLm9wZW5DbHVzdGVyKHRoaXMuYm9keS5ub2RlSW5kaWNlc1tpXSwge30sIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2x1c3RlcnNQcmVzZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNlZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxSYW5kb21TZWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBtYWluIGZ1bmN0aW9uIHRvIGxheW91dCB0aGUgbm9kZXMgaW4gYSBoaWVyYXJjaGljYWwgd2F5LlxuICAgICAqIEl0IGNoZWNrcyBpZiB0aGUgbm9kZSBkZXRhaWxzIGFyZSBzdXBwbGllZCBjb3JyZWN0bHlcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXR1cEhpZXJhcmNoaWNhbExheW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEhpZXJhcmNoaWNhbExheW91dCgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgPT09IHRydWUgJiYgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBzaXplIG9mIHRoZSBsYXJnZXN0IGh1YnMgYW5kIGNoZWNrIGlmIHRoZSB1c2VyIGhhcyBkZWZpbmVkIGEgbGV2ZWwgZm9yIGEgbm9kZS5cbiAgICAgICAgdmFyIG5vZGUsIG5vZGVJZDtcbiAgICAgICAgdmFyIGRlZmluZWRMZXZlbCA9IGZhbHNlO1xuICAgICAgICB2YXIgdW5kZWZpbmVkTGV2ZWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0Tm9kZU9uTGV2ZWwgPSB7fTtcbiAgICAgICAgdGhpcy5oaWVyYXJjaGljYWwgPSBuZXcgSGllcmFyY2hpY2FsU3RhdHVzKCk7XG5cbiAgICAgICAgZm9yIChub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcblxuICAgICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5sZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGRlZmluZWRMZXZlbCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlSWRdID0gbm9kZS5vcHRpb25zLmxldmVsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5kZWZpbmVkTGV2ZWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBpZiB0aGUgdXNlciBkZWZpbmVkIHNvbWUgbGV2ZWxzIGJ1dCBub3QgYWxsLCBhbGVydCBhbmQgcnVuIHdpdGhvdXQgaGllcmFyY2hpY2FsIGxheW91dFxuXG5cbiAgICAgICAgaWYgKHVuZGVmaW5lZExldmVsID09PSB0cnVlICYmIGRlZmluZWRMZXZlbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvIHVzZSB0aGUgaGllcmFyY2hpY2FsIGxheW91dCwgbm9kZXMgcmVxdWlyZSBlaXRoZXIgbm8gcHJlZGVmaW5lZCBsZXZlbHNcIiArIFwiIG9yIGxldmVscyBoYXZlIHRvIGJlIGRlZmluZWQgZm9yIGFsbCBub2Rlcy5cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVmaW5lIGxldmVscyBpZiB1bmRlZmluZWQgYnkgdGhlIHVzZXJzLiBCYXNlZCBvbiBodWJzaXplLlxuICAgICAgICAgIGlmICh1bmRlZmluZWRMZXZlbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHNvcnRNZXRob2QgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnNvcnRNZXRob2Q7XG5cbiAgICAgICAgICAgIGlmIChzb3J0TWV0aG9kID09PSBcImh1YnNpemVcIikge1xuICAgICAgICAgICAgICB0aGlzLl9kZXRlcm1pbmVMZXZlbHNCeUh1YnNpemUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc29ydE1ldGhvZCA9PT0gXCJkaXJlY3RlZFwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0RpcmVjdGVkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvcnRNZXRob2QgPT09IFwiY3VzdG9tXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGZhbGxiYWNrIGZvciBjYXNlcyB3aGVyZSB0aGVyZSBhcmUgbm9kZXMgYnV0IG5vIGVkZ2VzXG5cblxuICAgICAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIF9ub2RlSWQyKSkge1xuICAgICAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbC5lbnN1cmVMZXZlbChfbm9kZUlkMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBjaGVjayB0aGUgZGlzdHJpYnV0aW9uIG9mIHRoZSBub2RlcyBwZXIgbGV2ZWwuXG5cblxuICAgICAgICAgIHZhciBkaXN0cmlidXRpb24gPSB0aGlzLl9nZXREaXN0cmlidXRpb24oKTsgLy8gZ2V0IHRoZSBwYXJlbnQgY2hpbGRyZW4gcmVsYXRpb25zLlxuXG5cbiAgICAgICAgICB0aGlzLl9nZW5lcmF0ZU1hcCgpOyAvLyBwbGFjZSB0aGUgbm9kZXMgb24gdGhlIGNhbnZhcy5cblxuXG4gICAgICAgICAgdGhpcy5fcGxhY2VOb2Rlc0J5SGllcmFyY2h5KGRpc3RyaWJ1dGlvbik7IC8vIGNvbmRlbnNlIHRoZSB3aGl0ZXNwYWNlLlxuXG5cbiAgICAgICAgICB0aGlzLl9jb25kZW5zZUhpZXJhcmNoeSgpOyAvLyBzaGlmdCB0byBjZW50ZXIgc28gZ3Jhdml0eSBkb2VzIG5vdCBoYXZlIHRvIGRvIG11Y2hcblxuXG4gICAgICAgICAgdGhpcy5fc2hpZnRUb0NlbnRlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY29uZGVuc2VIaWVyYXJjaHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbmRlbnNlSGllcmFyY2h5KCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIC8vIEdsb2JhbCB2YXIgaW4gdGhpcyBzY29wZSB0byBkZWZpbmUgd2hlbiB0aGUgbW92ZW1lbnQgaGFzIHN0b3BwZWQuXG4gICAgICB2YXIgc3RpbGxTaGlmdGluZyA9IGZhbHNlO1xuICAgICAgdmFyIGJyYW5jaGVzID0ge307IC8vIGZpcnN0IHdlIGhhdmUgc29tZSBtZXRob2RzIHRvIGhlbHAgc2hpZnRpbmcgdHJlZXMgYXJvdW5kLlxuICAgICAgLy8gdGhlIG1haW4gbWV0aG9kIHRvIHNoaWZ0IHRoZSB0cmVlc1xuXG4gICAgICB2YXIgc2hpZnRUcmVlcyA9IGZ1bmN0aW9uIHNoaWZ0VHJlZXMoKSB7XG4gICAgICAgIHZhciB0cmVlU2l6ZXMgPSBnZXRUcmVlU2l6ZXMoKTtcbiAgICAgICAgdmFyIHNoaWZ0QnkgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZVNpemVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIHZhciBkaWZmID0gdHJlZVNpemVzW2ldLm1heCAtIHRyZWVTaXplc1tpICsgMV0ubWluO1xuICAgICAgICAgIHNoaWZ0QnkgKz0gZGlmZiArIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC50cmVlU3BhY2luZztcbiAgICAgICAgICBzaGlmdFRyZWUoaSArIDEsIHNoaWZ0QnkpO1xuICAgICAgICB9XG4gICAgICB9OyAvLyBzaGlmdCBhIHNpbmdsZSB0cmVlIGJ5IGFuIG9mZnNldFxuXG5cbiAgICAgIHZhciBzaGlmdFRyZWUgPSBmdW5jdGlvbiBzaGlmdFRyZWUoaW5kZXgsIG9mZnNldCkge1xuICAgICAgICB2YXIgdHJlZXMgPSBfdGhpczMuaGllcmFyY2hpY2FsLnRyZWVzO1xuXG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0cmVlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodHJlZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGlmICh0cmVlc1tub2RlSWRdID09PSBpbmRleCkge1xuICAgICAgICAgICAgICBfdGhpczMuZGlyZWN0aW9uLnNoaWZ0KG5vZGVJZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07IC8vIGdldCB0aGUgd2lkdGggb2YgYWxsIHRyZWVzXG5cblxuICAgICAgdmFyIGdldFRyZWVTaXplcyA9IGZ1bmN0aW9uIGdldFRyZWVTaXplcygpIHtcbiAgICAgICAgdmFyIHRyZWVXaWR0aHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzMy5oaWVyYXJjaGljYWwubnVtVHJlZXMoKTsgaSsrKSB7XG4gICAgICAgICAgdHJlZVdpZHRocy5wdXNoKF90aGlzMy5kaXJlY3Rpb24uZ2V0VHJlZVNpemUoaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyZWVXaWR0aHM7XG4gICAgICB9OyAvLyBnZXQgYSBtYXAgb2YgYWxsIG5vZGVzIGluIHRoaXMgYnJhbmNoXG5cblxuICAgICAgdmFyIGdldEJyYW5jaE5vZGVzID0gZnVuY3Rpb24gZ2V0QnJhbmNoTm9kZXMoc291cmNlLCBtYXApIHtcbiAgICAgICAgaWYgKG1hcFtzb3VyY2UuaWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFwW3NvdXJjZS5pZF0gPSB0cnVlO1xuXG4gICAgICAgIGlmIChfdGhpczMuaGllcmFyY2hpY2FsLmNoaWxkcmVuUmVmZXJlbmNlW3NvdXJjZS5pZF0pIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBfdGhpczMuaGllcmFyY2hpY2FsLmNoaWxkcmVuUmVmZXJlbmNlW3NvdXJjZS5pZF07XG5cbiAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBnZXRCcmFuY2hOb2RlcyhfdGhpczMuYm9keS5ub2Rlc1tjaGlsZHJlbltpXV0sIG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9OyAvLyBnZXQgYSBtaW4gbWF4IHdpZHRoIGFzIHdlbGwgYXMgdGhlIG1heGltdW0gbW92ZW1lbnQgc3BhY2UgaXQgaGFzIG9uIGVpdGhlciBzaWRlc1xuICAgICAgLy8gd2UgdXNlIG1pbiBtYXggdGVybWlub2xvZ3kgYmVjYXVzZSB3aWR0aCBhbmQgaGVpZ2h0IGNhbiBpbnRlcmNoYW5nZSBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGF5b3V0XG5cblxuICAgICAgdmFyIGdldEJyYW5jaEJvdW5kYXJ5ID0gZnVuY3Rpb24gZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTWFwKSB7XG4gICAgICAgIHZhciBtYXhMZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMWU5O1xuICAgICAgICB2YXIgbWluU3BhY2UgPSAxZTk7XG4gICAgICAgIHZhciBtYXhTcGFjZSA9IDFlOTtcbiAgICAgICAgdmFyIG1pbiA9IDFlOTtcbiAgICAgICAgdmFyIG1heCA9IC0xZTk7XG5cbiAgICAgICAgZm9yICh2YXIgYnJhbmNoTm9kZSBpbiBicmFuY2hNYXApIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGJyYW5jaE1hcCwgYnJhbmNoTm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXMzLmJvZHkubm9kZXNbYnJhbmNoTm9kZV07XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBfdGhpczMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlLmlkXTtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlKTsgLy8gZ2V0IHRoZSBzcGFjZSBhcm91bmQgdGhlIG5vZGUuXG5cblxuICAgICAgICAgICAgdmFyIF90aGlzMyRfZ2V0U3BhY2VBcm91biA9IF90aGlzMy5fZ2V0U3BhY2VBcm91bmROb2RlKG5vZGUsIGJyYW5jaE1hcCksXG4gICAgICAgICAgICAgICAgX3RoaXMzJF9nZXRTcGFjZUFyb3VuMiA9IF9zbGljZWRUb0FycmF5KF90aGlzMyRfZ2V0U3BhY2VBcm91biwgMiksXG4gICAgICAgICAgICAgICAgbWluU3BhY2VOb2RlID0gX3RoaXMzJF9nZXRTcGFjZUFyb3VuMlswXSxcbiAgICAgICAgICAgICAgICBtYXhTcGFjZU5vZGUgPSBfdGhpczMkX2dldFNwYWNlQXJvdW4yWzFdO1xuXG4gICAgICAgICAgICBtaW5TcGFjZSA9IE1hdGgubWluKG1pblNwYWNlTm9kZSwgbWluU3BhY2UpO1xuICAgICAgICAgICAgbWF4U3BhY2UgPSBNYXRoLm1pbihtYXhTcGFjZU5vZGUsIG1heFNwYWNlKTsgLy8gdGhlIHdpZHRoIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHRoZSBsZXZlbHMgdHdvIG5vZGVzIGhhdmUgaW4gY29tbW9uLiBUaGlzIGlzIHdoeSB3ZSBmaWx0ZXIgb24gdGhpcy5cblxuICAgICAgICAgICAgaWYgKGxldmVsIDw9IG1heExldmVsKSB7XG4gICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHBvc2l0aW9uLCBtaW4pO1xuICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChwb3NpdGlvbiwgbWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW21pbiwgbWF4LCBtaW5TcGFjZSwgbWF4U3BhY2VdO1xuICAgICAgfTsgLy8gY2hlY2sgd2hhdCB0aGUgbWF4aW11bSBsZXZlbCBpcyB0aGVzZSBub2RlcyBoYXZlIGluIGNvbW1vbi5cblxuXG4gICAgICB2YXIgZ2V0Q29sbGlzaW9uTGV2ZWwgPSBmdW5jdGlvbiBnZXRDb2xsaXNpb25MZXZlbChub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgdmFyIG1heExldmVsMSA9IF90aGlzMy5oaWVyYXJjaGljYWwuZ2V0TWF4TGV2ZWwobm9kZTEuaWQpO1xuXG4gICAgICAgIHZhciBtYXhMZXZlbDIgPSBfdGhpczMuaGllcmFyY2hpY2FsLmdldE1heExldmVsKG5vZGUyLmlkKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5taW4obWF4TGV2ZWwxLCBtYXhMZXZlbDIpO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQ29uZGVuc2UgZWxlbWVudHMuIFRoZXNlIGNhbiBiZSBub2RlcyBvciBicmFuY2hlcyBkZXBlbmRpbmcgb24gdGhlIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBsZXZlbHNcbiAgICAgICAqIEBwYXJhbSB7Kn0gY2VudGVyUGFyZW50c1xuICAgICAgICovXG5cblxuICAgICAgdmFyIHNoaWZ0RWxlbWVudHNDbG9zZXIgPSBmdW5jdGlvbiBzaGlmdEVsZW1lbnRzQ2xvc2VyKGNhbGxiYWNrLCBsZXZlbHMsIGNlbnRlclBhcmVudHMpIHtcbiAgICAgICAgdmFyIGhpZXIgPSBfdGhpczMuaGllcmFyY2hpY2FsO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgICAgIHZhciBsZXZlbE5vZGVzID0gaGllci5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG5cbiAgICAgICAgICBpZiAobGV2ZWxOb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldmVsTm9kZXMubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlMSA9IGxldmVsTm9kZXNbal07XG4gICAgICAgICAgICAgIHZhciBub2RlMiA9IGxldmVsTm9kZXNbaiArIDFdOyAvLyBOT1RFOiBsb2dpYyBtYWludGFpbmVkIGFzIGl0IHdhczsgaWYgbm9kZXMgaGF2ZSBzYW1lIGFuY2VzdG9yLFxuICAgICAgICAgICAgICAvLyAgICAgICB0aGVuIG9mIGNvdXJzZSB0aGV5IGFyZSBpbiB0aGUgc2FtZSBzdWItbmV0d29yay5cblxuICAgICAgICAgICAgICBpZiAoaGllci5oYXNTYW1lUGFyZW50KG5vZGUxLCBub2RlMikgJiYgaGllci5pblNhbWVTdWJOZXR3b3JrKG5vZGUxLCBub2RlMikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlMSwgbm9kZTIsIGNlbnRlclBhcmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9OyAvLyBjYWxsYmFjayBmb3Igc2hpZnRpbmcgYnJhbmNoZXNcblxuXG4gICAgICB2YXIgYnJhbmNoU2hpZnRDYWxsYmFjayA9IGZ1bmN0aW9uIGJyYW5jaFNoaWZ0Q2FsbGJhY2sobm9kZTEsIG5vZGUyKSB7XG4gICAgICAgIHZhciBjZW50ZXJQYXJlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICAgIC8vd2luZG93LkNBTExCQUNLUy5wdXNoKCgpID0+IHtcbiAgICAgICAgdmFyIHBvczEgPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUxKTtcblxuICAgICAgICB2YXIgcG9zMiA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZTIpO1xuXG4gICAgICAgIHZhciBkaWZmQWJzID0gTWF0aC5hYnMocG9zMiAtIHBvczEpO1xuICAgICAgICB2YXIgbm9kZVNwYWNpbmcgPSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7IC8vY29uc29sZS5sb2coXCJOT1cgQ0hFQ0tJTkc6XCIsIG5vZGUxLmlkLCBub2RlMi5pZCwgZGlmZkFicyk7XG5cbiAgICAgICAgaWYgKGRpZmZBYnMgPiBub2RlU3BhY2luZykge1xuICAgICAgICAgIHZhciBicmFuY2hOb2RlczEgPSB7fTtcbiAgICAgICAgICB2YXIgYnJhbmNoTm9kZXMyID0ge307XG4gICAgICAgICAgZ2V0QnJhbmNoTm9kZXMobm9kZTEsIGJyYW5jaE5vZGVzMSk7XG4gICAgICAgICAgZ2V0QnJhbmNoTm9kZXMobm9kZTIsIGJyYW5jaE5vZGVzMik7IC8vIGNoZWNrIHRoZSBsYXJnZXN0IGRpc3RhbmNlIGJldHdlZW4gdGhlIGJyYW5jaGVzXG5cbiAgICAgICAgICB2YXIgbWF4TGV2ZWwgPSBnZXRDb2xsaXNpb25MZXZlbChub2RlMSwgbm9kZTIpO1xuICAgICAgICAgIHZhciBicmFuY2hOb2RlQm91bmRhcnkxID0gZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMxLCBtYXhMZXZlbCk7XG4gICAgICAgICAgdmFyIGJyYW5jaE5vZGVCb3VuZGFyeTIgPSBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczIsIG1heExldmVsKTtcbiAgICAgICAgICB2YXIgbWF4MSA9IGJyYW5jaE5vZGVCb3VuZGFyeTFbMV07XG4gICAgICAgICAgdmFyIG1pbjIgPSBicmFuY2hOb2RlQm91bmRhcnkyWzBdO1xuICAgICAgICAgIHZhciBtaW5TcGFjZTIgPSBicmFuY2hOb2RlQm91bmRhcnkyWzJdOyAvL2NvbnNvbGUubG9nKG5vZGUxLmlkLCBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczEsIG1heExldmVsKSwgbm9kZTIuaWQsXG4gICAgICAgICAgLy8gICAgICAgICAgICBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczIsIG1heExldmVsKSwgbWF4TGV2ZWwpO1xuXG4gICAgICAgICAgdmFyIGRpZmZCcmFuY2ggPSBNYXRoLmFicyhtYXgxIC0gbWluMik7XG5cbiAgICAgICAgICBpZiAoZGlmZkJyYW5jaCA+IG5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbWF4MSAtIG1pbjIgKyBub2RlU3BhY2luZztcblxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IC1taW5TcGFjZTIgKyBub2RlU3BhY2luZykge1xuICAgICAgICAgICAgICBvZmZzZXQgPSAtbWluU3BhY2UyICsgbm9kZVNwYWNpbmc7IC8vY29uc29sZS5sb2coXCJSRVNFVFRJTkcgT0ZGU0VUXCIsIG1heDEgLSBtaW4yICsgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZywgLW1pblNwYWNlMiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNISUZUSU5HXCIsIG5vZGUyLmlkLCBvZmZzZXQpO1xuICAgICAgICAgICAgICBfdGhpczMuX3NoaWZ0QmxvY2sobm9kZTIuaWQsIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgc3RpbGxTaGlmdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChjZW50ZXJQYXJlbnQgPT09IHRydWUpIF90aGlzMy5fY2VudGVyUGFyZW50KG5vZGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTt9KVxuXG4gICAgICB9O1xuXG4gICAgICB2YXIgbWluaW1pemVFZGdlTGVuZ3RoID0gZnVuY3Rpb24gbWluaW1pemVFZGdlTGVuZ3RoKGl0ZXJhdGlvbnMsIG5vZGUpIHtcbiAgICAgICAgLy93aW5kb3cuQ0FMTEJBQ0tTLnB1c2goKCkgPT4ge1xuICAgICAgICAvLyAgY29uc29sZS5sb2coXCJ0c1wiLG5vZGUuaWQpO1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZS5pZDtcbiAgICAgICAgdmFyIGFsbEVkZ2VzID0gbm9kZS5lZGdlcztcbiAgICAgICAgdmFyIG5vZGVMZXZlbCA9IF90aGlzMy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGUuaWRdOyAvLyBnYXRoZXIgY29uc3RhbnRzXG5cbiAgICAgICAgdmFyIEMyID0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb247XG4gICAgICAgIHZhciByZWZlcmVuY2VOb2RlcyA9IHt9O1xuICAgICAgICB2YXIgYWJvdmVFZGdlcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGFsbEVkZ2VzW2ldO1xuXG4gICAgICAgICAgaWYgKGVkZ2UudG9JZCAhPSBlZGdlLmZyb21JZCkge1xuICAgICAgICAgICAgdmFyIG90aGVyTm9kZSA9IGVkZ2UudG9JZCA9PSBub2RlSWQgPyBlZGdlLmZyb20gOiBlZGdlLnRvO1xuICAgICAgICAgICAgcmVmZXJlbmNlTm9kZXNbYWxsRWRnZXNbaV0uaWRdID0gb3RoZXJOb2RlO1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMzLmhpZXJhcmNoaWNhbC5sZXZlbHNbb3RoZXJOb2RlLmlkXSA8IG5vZGVMZXZlbCkge1xuICAgICAgICAgICAgICBhYm92ZUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGRpZmZlcmVudGlhdGVkIHN1bSBvZiBsZW5ndGhzIGJhc2VkIG9uIG9ubHkgbW92aW5nIG9uZSBub2RlIG92ZXIgb25lIGF4aXNcblxuXG4gICAgICAgIHZhciBnZXRGeCA9IGZ1bmN0aW9uIGdldEZ4KHBvaW50LCBlZGdlcykge1xuICAgICAgICAgIHZhciBzdW0gPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZWRnZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pMl0uaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pMl0uaWRdKSAtIHBvaW50O1xuICAgICAgICAgICAgICBzdW0gKz0gYSAvIE1hdGguc3FydChhICogYSArIEMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9OyAvLyBkb3VibHkgZGlmZmVyZW50aWF0ZWQgc3VtIG9mIGxlbmd0aHMgYmFzZWQgb24gb25seSBtb3Zpbmcgb25lIG5vZGUgb3ZlciBvbmUgYXhpc1xuXG5cbiAgICAgICAgdmFyIGdldERGeCA9IGZ1bmN0aW9uIGdldERGeChwb2ludCwgZWRnZXMpIHtcbiAgICAgICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGVkZ2VzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICAgIGlmIChyZWZlcmVuY2VOb2Rlc1tlZGdlc1tfaTNdLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBhID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihyZWZlcmVuY2VOb2Rlc1tlZGdlc1tfaTNdLmlkXSkgLSBwb2ludDtcbiAgICAgICAgICAgICAgc3VtIC09IEMyICogTWF0aC5wb3coYSAqIGEgKyBDMiwgLTEuNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0R3Vlc3MgPSBmdW5jdGlvbiBnZXRHdWVzcyhpdGVyYXRpb25zLCBlZGdlcykge1xuICAgICAgICAgIHZhciBndWVzcyA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7IC8vIE5ld3RvbidzIG1ldGhvZCBmb3Igb3B0aW1pemF0aW9uXG5cblxuICAgICAgICAgIHZhciBndWVzc01hcCA9IHt9O1xuXG4gICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgaXRlcmF0aW9uczsgX2k0KyspIHtcbiAgICAgICAgICAgIHZhciBmeCA9IGdldEZ4KGd1ZXNzLCBlZGdlcyk7XG4gICAgICAgICAgICB2YXIgZGZ4ID0gZ2V0REZ4KGd1ZXNzLCBlZGdlcyk7IC8vIHdlIGxpbWl0IHRoZSBtb3ZlbWVudCB0byBhdm9pZCBpbnN0YWJpbGl0eS5cblxuICAgICAgICAgICAgdmFyIGxpbWl0ID0gNDA7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBNYXRoLm1heCgtbGltaXQsIE1hdGgubWluKGxpbWl0LCBNYXRoLnJvdW5kKGZ4IC8gZGZ4KSkpO1xuICAgICAgICAgICAgZ3Vlc3MgPSBndWVzcyAtIHJhdGlvOyAvLyByZWR1Y2UgZHVwbGljYXRlc1xuXG4gICAgICAgICAgICBpZiAoZ3Vlc3NNYXBbZ3Vlc3NdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGd1ZXNzTWFwW2d1ZXNzXSA9IF9pNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZ3Vlc3M7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG1vdmVCcmFuY2ggPSBmdW5jdGlvbiBtb3ZlQnJhbmNoKGd1ZXNzKSB7XG4gICAgICAgICAgLy8gcG9zaXRpb24gbm9kZSBpZiB0aGVyZSBpcyBzcGFjZVxuICAgICAgICAgIHZhciBub2RlUG9zaXRpb24gPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUpOyAvLyBjaGVjayBtb3ZhYmxlIGFyZWEgb2YgdGhlIGJyYW5jaFxuXG5cbiAgICAgICAgICBpZiAoYnJhbmNoZXNbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGJyYW5jaE5vZGVzID0ge307XG4gICAgICAgICAgICBnZXRCcmFuY2hOb2Rlcyhub2RlLCBicmFuY2hOb2Rlcyk7XG4gICAgICAgICAgICBicmFuY2hlc1tub2RlLmlkXSA9IGJyYW5jaE5vZGVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBicmFuY2hCb3VuZGFyeSA9IGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaGVzW25vZGUuaWRdKTtcbiAgICAgICAgICB2YXIgbWluU3BhY2VCcmFuY2ggPSBicmFuY2hCb3VuZGFyeVsyXTtcbiAgICAgICAgICB2YXIgbWF4U3BhY2VCcmFuY2ggPSBicmFuY2hCb3VuZGFyeVszXTtcbiAgICAgICAgICB2YXIgZGlmZiA9IGd1ZXNzIC0gbm9kZVBvc2l0aW9uOyAvLyBjaGVjayBpZiB3ZSBhcmUgYWxsb3dlZCB0byBtb3ZlIHRoZSBub2RlOlxuXG4gICAgICAgICAgdmFyIGJyYW5jaE9mZnNldCA9IDA7XG5cbiAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgIGJyYW5jaE9mZnNldCA9IE1hdGgubWluKGRpZmYsIG1heFNwYWNlQnJhbmNoIC0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICAgICBicmFuY2hPZmZzZXQgPSAtTWF0aC5taW4oLWRpZmYsIG1pblNwYWNlQnJhbmNoIC0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYnJhbmNoT2Zmc2V0ICE9IDApIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJtb3ZpbmcgYnJhbmNoOlwiLGJyYW5jaE9mZnNldCwgbWF4U3BhY2VCcmFuY2gsIG1pblNwYWNlQnJhbmNoKVxuICAgICAgICAgICAgX3RoaXMzLl9zaGlmdEJsb2NrKG5vZGUuaWQsIGJyYW5jaE9mZnNldCk7IC8vdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG5cblxuICAgICAgICAgICAgc3RpbGxTaGlmdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtb3ZlTm9kZSA9IGZ1bmN0aW9uIG1vdmVOb2RlKGd1ZXNzKSB7XG4gICAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7IC8vIHBvc2l0aW9uIG5vZGUgaWYgdGhlcmUgaXMgc3BhY2VcblxuXG4gICAgICAgICAgdmFyIF90aGlzMyRfZ2V0U3BhY2VBcm91bjMgPSBfdGhpczMuX2dldFNwYWNlQXJvdW5kTm9kZShub2RlKSxcbiAgICAgICAgICAgICAgX3RoaXMzJF9nZXRTcGFjZUFyb3VuNCA9IF9zbGljZWRUb0FycmF5KF90aGlzMyRfZ2V0U3BhY2VBcm91bjMsIDIpLFxuICAgICAgICAgICAgICBtaW5TcGFjZSA9IF90aGlzMyRfZ2V0U3BhY2VBcm91bjRbMF0sXG4gICAgICAgICAgICAgIG1heFNwYWNlID0gX3RoaXMzJF9nZXRTcGFjZUFyb3VuNFsxXTtcblxuICAgICAgICAgIHZhciBkaWZmID0gZ3Vlc3MgLSBub2RlUG9zaXRpb247IC8vIGNoZWNrIGlmIHdlIGFyZSBhbGxvd2VkIHRvIG1vdmUgdGhlIG5vZGU6XG5cbiAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSBub2RlUG9zaXRpb247XG5cbiAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gTWF0aC5taW4obm9kZVBvc2l0aW9uICsgKG1heFNwYWNlIC0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKSwgZ3Vlc3MpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gTWF0aC5tYXgobm9kZVBvc2l0aW9uIC0gKG1pblNwYWNlIC0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKSwgZ3Vlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXdQb3NpdGlvbiAhPT0gbm9kZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwibW92aW5nIE5vZGU6XCIsZGlmZiwgbWluU3BhY2UsIG1heFNwYWNlKTtcbiAgICAgICAgICAgIF90aGlzMy5kaXJlY3Rpb24uc2V0UG9zaXRpb24obm9kZSwgbmV3UG9zaXRpb24pOyAvL3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuXG5cbiAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ3Vlc3MgPSBnZXRHdWVzcyhpdGVyYXRpb25zLCBhYm92ZUVkZ2VzKTtcbiAgICAgICAgbW92ZUJyYW5jaChndWVzcyk7XG4gICAgICAgIGd1ZXNzID0gZ2V0R3Vlc3MoaXRlcmF0aW9ucywgYWxsRWRnZXMpO1xuICAgICAgICBtb3ZlTm9kZShndWVzcyk7IC8vfSlcbiAgICAgIH07IC8vIG1ldGhvZCB0byByZW1vdmUgd2hpdGVzcGFjZSBiZXR3ZWVuIGJyYW5jaGVzLiBCZWNhdXNlIHdlIGRvIGJvdHRvbSB1cCwgd2UgY2FuIGNlbnRlciB0aGUgcGFyZW50cy5cblxuXG4gICAgICB2YXIgbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAgPSBmdW5jdGlvbiBtaW5pbWl6ZUVkZ2VMZW5ndGhCb3R0b21VcChpdGVyYXRpb25zKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSBfdGhpczMuaGllcmFyY2hpY2FsLmdldExldmVscygpO1xuXG4gICAgICAgIGxldmVscyA9IHJldmVyc2UobGV2ZWxzKS5jYWxsKGxldmVscyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2pdO1xuICAgICAgICAgICAgdmFyIGxldmVsTm9kZXMgPSBfdGhpczMuaGllcmFyY2hpY2FsLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsZXZlbE5vZGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIG1pbmltaXplRWRnZUxlbmd0aCgxMDAwLCBsZXZlbE5vZGVzW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RpbGxTaGlmdGluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZJTklTSEVEIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwIElOIFwiICsgaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07IC8vIG1ldGhvZCB0byByZW1vdmUgd2hpdGVzcGFjZSBiZXR3ZWVuIGJyYW5jaGVzLiBCZWNhdXNlIHdlIGRvIGJvdHRvbSB1cCwgd2UgY2FuIGNlbnRlciB0aGUgcGFyZW50cy5cblxuXG4gICAgICB2YXIgc2hpZnRCcmFuY2hlc0Nsb3NlckJvdHRvbVVwID0gZnVuY3Rpb24gc2hpZnRCcmFuY2hlc0Nsb3NlckJvdHRvbVVwKGl0ZXJhdGlvbnMpIHtcbiAgICAgICAgdmFyIGxldmVscyA9IF90aGlzMy5oaWVyYXJjaGljYWwuZ2V0TGV2ZWxzKCk7XG5cbiAgICAgICAgbGV2ZWxzID0gcmV2ZXJzZShsZXZlbHMpLmNhbGwobGV2ZWxzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzaGlmdEVsZW1lbnRzQ2xvc2VyKGJyYW5jaFNoaWZ0Q2FsbGJhY2ssIGxldmVscywgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoc3RpbGxTaGlmdGluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZJTklTSEVEIHNoaWZ0QnJhbmNoZXNDbG9zZXJCb3R0b21VcCBJTiBcIiArIChpKzEpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTsgLy8gY2VudGVyIGFsbCBwYXJlbnRzXG5cblxuICAgICAgdmFyIGNlbnRlckFsbFBhcmVudHMgPSBmdW5jdGlvbiBjZW50ZXJBbGxQYXJlbnRzKCkge1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gX3RoaXMzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF90aGlzMy5ib2R5Lm5vZGVzLCBub2RlSWQpKSBfdGhpczMuX2NlbnRlclBhcmVudChfdGhpczMuYm9keS5ub2Rlc1tub2RlSWRdKTtcbiAgICAgICAgfVxuICAgICAgfTsgLy8gY2VudGVyIGFsbCBwYXJlbnRzXG5cblxuICAgICAgdmFyIGNlbnRlckFsbFBhcmVudHNCb3R0b21VcCA9IGZ1bmN0aW9uIGNlbnRlckFsbFBhcmVudHNCb3R0b21VcCgpIHtcbiAgICAgICAgdmFyIGxldmVscyA9IF90aGlzMy5oaWVyYXJjaGljYWwuZ2V0TGV2ZWxzKCk7XG5cbiAgICAgICAgbGV2ZWxzID0gcmV2ZXJzZShsZXZlbHMpLmNhbGwobGV2ZWxzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICAgICAgICB2YXIgbGV2ZWxOb2RlcyA9IF90aGlzMy5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBfdGhpczMuX2NlbnRlclBhcmVudChsZXZlbE5vZGVzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07IC8vIHRoZSBhY3R1YWwgd29yayBpcyBkb25lIGhlcmUuXG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuYmxvY2tTaGlmdGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAoNSk7XG4gICAgICAgIGNlbnRlckFsbFBhcmVudHMoKTtcbiAgICAgIH0gLy8gbWluaW1pemUgZWRnZSBsZW5ndGhcblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lZGdlTWluaW1pemF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwKDIwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwucGFyZW50Q2VudHJhbGl6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgY2VudGVyQWxsUGFyZW50c0JvdHRvbVVwKCk7XG4gICAgICB9XG5cbiAgICAgIHNoaWZ0VHJlZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBnaXZlcyB0aGUgc3BhY2UgYXJvdW5kIHRoZSBub2RlLiBJRiBhIG1hcCBpcyBzdXBwbGllZCwgaXQgd2lsbCBvbmx5IGNoZWNrIGFnYWluc3Qgbm9kZXMgTk9UIGluIHRoZSBtYXAuXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIG9ubHkgZ2V0IHRoZSBkaXN0YW5jZXMgdG8gbm9kZXMgb3V0c2lkZSBvZiBhIGJyYW5jaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7e05vZGUuaWQ6IHZpcy5Ob2RlfX0gbWFwXG4gICAgICogQHJldHVybnMge251bWJlcltdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U3BhY2VBcm91bmROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTcGFjZUFyb3VuZE5vZGUobm9kZSwgbWFwKSB7XG4gICAgICB2YXIgdXNlTWFwID0gdHJ1ZTtcblxuICAgICAgaWYgKG1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVzZU1hcCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZS5pZF07XG5cbiAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaGllcmFyY2hpY2FsLmRpc3RyaWJ1dGlvbkluZGV4W25vZGUuaWRdO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlKTtcbiAgICAgICAgdmFyIG9yZGVyaW5nID0gdGhpcy5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuICAgICAgICB2YXIgbWluU3BhY2UgPSAxZTk7XG4gICAgICAgIHZhciBtYXhTcGFjZSA9IDFlOTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICB2YXIgcHJldk5vZGUgPSBvcmRlcmluZ1tpbmRleCAtIDFdO1xuXG4gICAgICAgICAgaWYgKHVzZU1hcCA9PT0gdHJ1ZSAmJiBtYXBbcHJldk5vZGUuaWRdID09PSB1bmRlZmluZWQgfHwgdXNlTWFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIHByZXZQb3MgPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihwcmV2Tm9kZSk7XG4gICAgICAgICAgICBtaW5TcGFjZSA9IHBvc2l0aW9uIC0gcHJldlBvcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggIT0gb3JkZXJpbmcubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IG9yZGVyaW5nW2luZGV4ICsgMV07XG5cbiAgICAgICAgICBpZiAodXNlTWFwID09PSB0cnVlICYmIG1hcFtuZXh0Tm9kZS5pZF0gPT09IHVuZGVmaW5lZCB8fCB1c2VNYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5leHROb2RlKTtcbiAgICAgICAgICAgIG1heFNwYWNlID0gTWF0aC5taW4obWF4U3BhY2UsIG5leHRQb3MgLSBwb3NpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFttaW5TcGFjZSwgbWF4U3BhY2VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2UgdXNlIHRoaXMgbWV0aG9kIHRvIGNlbnRlciBhIHBhcmVudCBub2RlIGFuZCBjaGVjayBpZiBpdCBkb2VzIG5vdCBjcm9zcyBvdGhlciBub2RlcyB3aGVuIGl0IGRvZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NlbnRlclBhcmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2VudGVyUGFyZW50KG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLmhpZXJhcmNoaWNhbC5wYXJlbnRSZWZlcmVuY2Vbbm9kZS5pZF0pIHtcbiAgICAgICAgdmFyIHBhcmVudHMgPSB0aGlzLmhpZXJhcmNoaWNhbC5wYXJlbnRSZWZlcmVuY2Vbbm9kZS5pZF07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcmVudElkID0gcGFyZW50c1tpXTtcbiAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMuYm9keS5ub2Rlc1twYXJlbnRJZF07XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdO1xuXG4gICAgICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgcmFuZ2Ugb2YgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSB0aGlzLl9nZXRDZW50ZXJQb3NpdGlvbihjaGlsZHJlbik7XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHBhcmVudE5vZGUpO1xuXG4gICAgICAgICAgICB2YXIgX3RoaXMkX2dldFNwYWNlQXJvdW5kID0gdGhpcy5fZ2V0U3BhY2VBcm91bmROb2RlKHBhcmVudE5vZGUpLFxuICAgICAgICAgICAgICAgIF90aGlzJF9nZXRTcGFjZUFyb3VuZDIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0U3BhY2VBcm91bmQsIDIpLFxuICAgICAgICAgICAgICAgIG1pblNwYWNlID0gX3RoaXMkX2dldFNwYWNlQXJvdW5kMlswXSxcbiAgICAgICAgICAgICAgICBtYXhTcGFjZSA9IF90aGlzJF9nZXRTcGFjZUFyb3VuZDJbMV07XG5cbiAgICAgICAgICAgIHZhciBkaWZmID0gcG9zaXRpb24gLSBuZXdQb3NpdGlvbjtcblxuICAgICAgICAgICAgaWYgKGRpZmYgPCAwICYmIE1hdGguYWJzKGRpZmYpIDwgbWF4U3BhY2UgLSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nIHx8IGRpZmYgPiAwICYmIE1hdGguYWJzKGRpZmYpIDwgbWluU3BhY2UgLSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKHBhcmVudE5vZGUsIG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBwbGFjZXMgdGhlIG5vZGVzIG9uIHRoZSBjYW52YXMgYmFzZWQgb24gdGhlIGhpZXJhcmNoaWFsIGRpc3RyaWJ1dGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkaXN0cmlidXRpb24gfCBvYnRhaW5lZCBieSB0aGUgZnVuY3Rpb24gdGhpcy5fZ2V0RGlzdHJpYnV0aW9uKClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BsYWNlTm9kZXNCeUhpZXJhcmNoeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VOb2Rlc0J5SGllcmFyY2h5KGRpc3RyaWJ1dGlvbikge1xuICAgICAgdGhpcy5wb3NpdGlvbmVkTm9kZXMgPSB7fTsgLy8gc3RhcnQgcGxhY2luZyBhbGwgdGhlIGxldmVsIDAgbm9kZXMgZmlyc3QuIFRoZW4gcmVjdXJzaXZlbHkgcG9zaXRpb24gdGhlaXIgYnJhbmNoZXMuXG5cbiAgICAgIGZvciAodmFyIGxldmVsIGluIGRpc3RyaWJ1dGlvbikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpc3RyaWJ1dGlvbiwgbGV2ZWwpKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICAgICAgLy8gc29ydCBub2RlcyBpbiBsZXZlbCBieSBwb3NpdGlvbjpcbiAgICAgICAgICB2YXIgbm9kZUFycmF5ID0ga2V5cyQ0KGRpc3RyaWJ1dGlvbltsZXZlbF0pO1xuXG4gICAgICAgICAgbm9kZUFycmF5ID0gdGhpcy5faW5kZXhBcnJheVRvTm9kZXMobm9kZUFycmF5KTtcblxuICAgICAgICAgIHNvcnQoX2NvbnRleHQgPSB0aGlzLmRpcmVjdGlvbikuY2FsbChfY29udGV4dCwgbm9kZUFycmF5KTtcblxuICAgICAgICAgIHZhciBoYW5kbGVkTm9kZUNvdW50ID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVBcnJheVtpXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb25lZE5vZGVzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nO1xuICAgICAgICAgICAgICB2YXIgcG9zID0gc3BhY2luZyAqIGhhbmRsZWROb2RlQ291bnQ7IC8vIFdlIGdldCB0aGUgWCBvciBZIHZhbHVlcyB3ZSBuZWVkIGFuZCBzdG9yZSB0aGVtIGluIHBvcyBhbmQgcHJldmlvdXNQb3MuXG4gICAgICAgICAgICAgIC8vIFRoZSBnZXQgYW5kIHNldCBtYWtlIHN1cmUgd2UgZ2V0IFggb3IgWVxuXG4gICAgICAgICAgICAgIGlmIChoYW5kbGVkTm9kZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGVBcnJheVtpIC0gMV0pICsgc3BhY2luZztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKG5vZGUsIHBvcywgbGV2ZWwpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlUG9zaXRpb25BbmRDb250aW51ZShub2RlLCBsZXZlbCwgcG9zKTtcblxuICAgICAgICAgICAgICBoYW5kbGVkTm9kZUNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSByZWN1cnNpdmVseSBjYWxsZWQgZnVuY3Rpb24gdG8gZW51bWVyYXRlIHRoZSBicmFuY2hlcyBmcm9tIHRoZSBsYXJnZXN0IGh1YnMgYW5kIHBsYWNlIHRoZSBub2Rlc1xuICAgICAqIG9uIGEgWCBwb3NpdGlvbiB0aGF0IGVuc3VyZXMgdGhlcmUgd2lsbCBiZSBubyBvdmVybGFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBwYXJlbnRJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJlbnRMZXZlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGxhY2VCcmFuY2hOb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VCcmFuY2hOb2RlcyhwYXJlbnRJZCwgcGFyZW50TGV2ZWwpIHtcbiAgICAgIHZhciBfY29udGV4dDI7XG5cbiAgICAgIHZhciBjaGlsZFJlZiA9IHRoaXMuaGllcmFyY2hpY2FsLmNoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXTsgLy8gaWYgdGhpcyBpcyBub3QgYSBwYXJlbnQsIGNhbmNlbCB0aGUgcGxhY2luZy4gVGhpcyBjYW4gaGFwcGVuIHdpdGggbXVsdGlwbGUgcGFyZW50cyB0byBvbmUgY2hpbGQuXG5cbiAgICAgIGlmIChjaGlsZFJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZ2V0IGEgbGlzdCBvZiBjaGlsZE5vZGVzXG5cblxuICAgICAgdmFyIGNoaWxkTm9kZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZFJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZE5vZGVzLnB1c2godGhpcy5ib2R5Lm5vZGVzW2NoaWxkUmVmW2ldXSk7XG4gICAgICB9IC8vIHVzZSB0aGUgcG9zaXRpb25zIHRvIG9yZGVyIHRoZSBub2Rlcy5cblxuXG4gICAgICBzb3J0KF9jb250ZXh0MiA9IHRoaXMuZGlyZWN0aW9uKS5jYWxsKF9jb250ZXh0MiwgY2hpbGROb2Rlcyk7IC8vIHBvc2l0aW9uIHRoZSBjaGlsZE5vZGVzXG5cblxuICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgY2hpbGROb2Rlcy5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW19pNV07XG4gICAgICAgIHZhciBjaGlsZE5vZGVMZXZlbCA9IHRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1tjaGlsZE5vZGUuaWRdOyAvLyBjaGVjayBpZiB0aGUgY2hpbGQgbm9kZSBpcyBiZWxvdyB0aGUgcGFyZW50IG5vZGUgYW5kIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gcG9zaXRpb25lZC5cblxuICAgICAgICBpZiAoY2hpbGROb2RlTGV2ZWwgPiBwYXJlbnRMZXZlbCAmJiB0aGlzLnBvc2l0aW9uZWROb2Rlc1tjaGlsZE5vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBnZXQgdGhlIGFtb3VudCBvZiBzcGFjZSByZXF1aXJlZCBmb3IgdGhpcyBub2RlLiBJZiBwYXJlbnQgdGhlIHdpZHRoIGlzIGJhc2VkIG9uIHRoZSBhbW91bnQgb2YgY2hpbGRyZW4uXG4gICAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nO1xuICAgICAgICAgIHZhciBwb3MgPSB2b2lkIDA7IC8vIHdlIGdldCB0aGUgWCBvciBZIHZhbHVlcyB3ZSBuZWVkIGFuZCBzdG9yZSB0aGVtIGluIHBvcyBhbmQgcHJldmlvdXNQb3MuXG4gICAgICAgICAgLy8gVGhlIGdldCBhbmQgc2V0IG1ha2Ugc3VyZSB3ZSBnZXQgWCBvciBZXG5cbiAgICAgICAgICBpZiAoX2k1ID09PSAwKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbih0aGlzLmJvZHkubm9kZXNbcGFyZW50SWRdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24oY2hpbGROb2Rlc1tfaTUgLSAxXSkgKyBzcGFjaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKGNoaWxkTm9kZSwgcG9zLCBjaGlsZE5vZGVMZXZlbCk7XG5cbiAgICAgICAgICB0aGlzLl92YWxpZGF0ZVBvc2l0aW9uQW5kQ29udGludWUoY2hpbGROb2RlLCBjaGlsZE5vZGVMZXZlbCwgcG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY2VudGVyIHRoZSBwYXJlbnQgbm9kZXMuXG5cblxuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX2dldENlbnRlclBvc2l0aW9uKGNoaWxkTm9kZXMpO1xuXG4gICAgICB0aGlzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbih0aGlzLmJvZHkubm9kZXNbcGFyZW50SWRdLCBjZW50ZXIsIHBhcmVudExldmVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgY2hlY2tzIGZvciBvdmVybGFwIGFuZCBpZiByZXF1aXJlZCBzaGlmdHMgdGhlIGJyYW5jaC4gSXQgYWxzbyBrZWVwcyByZWNvcmRzIG9mIHBvc2l0aW9uZWQgbm9kZXMuXG4gICAgICogRmluYWxseSBpdCB3aWxsIGNhbGwgX3BsYWNlQnJhbmNoTm9kZXMgdG8gcGxhY2UgdGhlIGJyYW5jaCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3ZhbGlkYXRlUG9zaXRpb25BbmRDb250aW51ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdmFsaWRhdGVQb3NpdGlvbkFuZENvbnRpbnVlKG5vZGUsIGxldmVsLCBwb3MpIHtcbiAgICAgIC8vIFRoaXMgbWV0aG9kIG9ubHkgd29ya3MgZm9yIGZvcm1hbCB0cmVlcyBhbmQgZm9ybWFsIGZvcmVzdHNcbiAgICAgIC8vIEVhcmx5IGV4aXQgaWYgdGhpcyBpcyBub3QgdGhlIGNhc2VcbiAgICAgIGlmICghdGhpcy5oaWVyYXJjaGljYWwuaXNUcmVlKSByZXR1cm47IC8vIGlmIG92ZXJsYXAgaGFzIGJlZW4gZGV0ZWN0ZWQsIHdlIHNoaWZ0IHRoZSBicmFuY2hcblxuICAgICAgaWYgKHRoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1BvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHRoaXMuYm9keS5ub2Rlc1t0aGlzLmxhc3ROb2RlT25MZXZlbFtsZXZlbF1dKTtcblxuICAgICAgICBpZiAocG9zIC0gcHJldmlvdXNQb3MgPCB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgdmFyIGRpZmYgPSBwcmV2aW91c1BvcyArIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcgLSBwb3M7XG5cbiAgICAgICAgICB2YXIgc2hhcmVkUGFyZW50ID0gdGhpcy5fZmluZENvbW1vblBhcmVudCh0aGlzLmxhc3ROb2RlT25MZXZlbFtsZXZlbF0sIG5vZGUuaWQpO1xuXG4gICAgICAgICAgdGhpcy5fc2hpZnRCbG9jayhzaGFyZWRQYXJlbnQud2l0aENoaWxkLCBkaWZmKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3ROb2RlT25MZXZlbFtsZXZlbF0gPSBub2RlLmlkOyAvLyBzdG9yZSBjaGFuZ2UgaW4gcG9zaXRpb24uXG5cbiAgICAgIHRoaXMucG9zaXRpb25lZE5vZGVzW25vZGUuaWRdID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fcGxhY2VCcmFuY2hOb2Rlcyhub2RlLmlkLCBsZXZlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY2VpdmVzIGFuIGFycmF5IHdpdGggbm9kZSBpbmRpY2VzIGFuZCByZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGFjdHVhbCBub2RlIHJlZmVyZW5jZXMuXG4gICAgICogVXNlZCBmb3Igc29ydGluZyBiYXNlZCBvbiBub2RlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlLmlkPn0gaWRBcnJheVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48Tm9kZT59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5kZXhBcnJheVRvTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luZGV4QXJyYXlUb05vZGVzKGlkQXJyYXkpIHtcbiAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXkucHVzaCh0aGlzLmJvZHkubm9kZXNbaWRBcnJheVtpXV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZ2V0IHRoZSBkaXN0cmlidXRpb24gb2YgbGV2ZWxzIGJhc2VkIG9uIGh1YnNpemVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaXN0cmlidXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RyaWJ1dGlvbigpIHtcbiAgICAgIHZhciBkaXN0cmlidXRpb24gPSB7fTtcbiAgICAgIHZhciBub2RlSWQsIG5vZGU7IC8vIHdlIGZpeCBZIGJlY2F1c2UgdGhlIGhpZXJhcmNoeSBpcyB2ZXJ0aWNhbCxcbiAgICAgIC8vIHdlIGZpeCBYIHNvIHdlIGRvIG5vdCBnaXZlIGEgbm9kZSBhbiB4IHBvc2l0aW9uIGZvciBhIHNlY29uZCB0aW1lLlxuICAgICAgLy8gdGhlIGZpeCBvZiBYIGlzIHJlbW92ZWQgYWZ0ZXIgdGhlIHggdmFsdWUgaGFzIGJlZW4gc2V0LlxuXG4gICAgICBmb3IgKG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVJZF0gPT09IHVuZGVmaW5lZCA/IDAgOiB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUlkXTtcbiAgICAgICAgICB0aGlzLmRpcmVjdGlvbi5maXgobm9kZSwgbGV2ZWwpO1xuXG4gICAgICAgICAgaWYgKGRpc3RyaWJ1dGlvbltsZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGlzdHJpYnV0aW9uW2xldmVsXSA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpc3RyaWJ1dGlvbltsZXZlbF1bbm9kZUlkXSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpc3RyaWJ1dGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBhY3RpdmUgKGkuZS4gdmlzaWJsZSkgZWRnZXMgZm9yIHRoaXMgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHJldHVybnMge0FycmF5Ljx2aXMuRWRnZT59IEFycmF5IG9mIGVkZ2UgaW5zdGFuY2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRBY3RpdmVFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWN0aXZlRWRnZXMobm9kZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvckVhY2gkMShub2RlLmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICB2YXIgX2NvbnRleHQzO1xuXG4gICAgICAgIGlmIChpbmRleE9mKF9jb250ZXh0MyA9IF90aGlzNC5ib2R5LmVkZ2VJbmRpY2VzKS5jYWxsKF9jb250ZXh0MywgZWRnZS5pZCkgIT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBodWJzaXplcyBmb3IgYWxsIGFjdGl2ZSBub2Rlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRIdWJTaXplc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SHViU2l6ZXMoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGh1YlNpemVzID0ge307XG4gICAgICB2YXIgbm9kZUlkcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIGZvckVhY2gkMShub2RlSWRzLCBmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgIHZhciBub2RlID0gX3RoaXM1LmJvZHkubm9kZXNbbm9kZUlkXTtcblxuICAgICAgICB2YXIgaHViU2l6ZSA9IF90aGlzNS5fZ2V0QWN0aXZlRWRnZXMobm9kZSkubGVuZ3RoO1xuXG4gICAgICAgIGh1YlNpemVzW2h1YlNpemVdID0gdHJ1ZTtcbiAgICAgIH0pOyAvLyBNYWtlIGFuIGFycmF5IG9mIHRoZSBzaXplIHNvcnRlZCBkZXNjZW5kaW5nXG5cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvckVhY2gkMShodWJTaXplcywgZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goTnVtYmVyKHNpemUpKTtcbiAgICAgIH0pO1xuXG4gICAgICBzb3J0KHRpbXNvcnQpLmNhbGwodGltc29ydCwgcmVzdWx0LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYiAtIGE7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhpcyBmdW5jdGlvbiBhbGxvY2F0ZXMgbm9kZXMgaW4gbGV2ZWxzIGJhc2VkIG9uIHRoZSByZWN1cnNpdmUgYnJhbmNoaW5nIGZyb20gdGhlIGxhcmdlc3QgaHVicy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGV0ZXJtaW5lTGV2ZWxzQnlIdWJzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVMZXZlbHNCeUh1YnNpemUoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdmFyIGxldmVsRG93bnN0cmVhbSA9IGZ1bmN0aW9uIGxldmVsRG93bnN0cmVhbShub2RlQSwgbm9kZUIpIHtcbiAgICAgICAgX3RoaXM2LmhpZXJhcmNoaWNhbC5sZXZlbERvd25zdHJlYW0obm9kZUEsIG5vZGVCKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBodWJTaXplcyA9IHRoaXMuX2dldEh1YlNpemVzKCk7XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgdmFyIGh1YlNpemUgPSBodWJTaXplc1tpXTtcbiAgICAgICAgaWYgKGh1YlNpemUgPT09IDApIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgIGZvckVhY2gkMShfdGhpczYuYm9keS5ub2RlSW5kaWNlcywgZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgIHZhciBub2RlID0gX3RoaXM2LmJvZHkubm9kZXNbbm9kZUlkXTtcblxuICAgICAgICAgIGlmIChodWJTaXplID09PSBfdGhpczYuX2dldEFjdGl2ZUVkZ2VzKG5vZGUpLmxlbmd0aCkge1xuICAgICAgICAgICAgX3RoaXM2Ll9jcmF3bE5ldHdvcmsobGV2ZWxEb3duc3RyZWFtLCBub2RlSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGh1YlNpemVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBfcmV0ID0gX2xvb3AoaSk7XG5cbiAgICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRPRE86IHJlbGVhc2UgZmVhdHVyZVxuICAgICAqIFRPRE86IERldGVybWluZSBpZiB0aGlzIGZlYXR1cmUgaXMgbmVlZGVkIGF0IGFsbFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXRlcm1pbmVMZXZlbHNDdXN0b21DYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2soKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIG1pbkxldmVsID0gMTAwMDAwOyAvLyBUT0RPOiB0aGlzIHNob3VsZCBjb21lIGZyb20gb3B0aW9ucy5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSBUaGlzIHNob3VsZCBldmVudHVhbGx5IGJlIGltcGxlbWVudGVkIHdpdGggdGhlc2UgcGFyYW1ldGVycyB1c2VkLlxuXG4gICAgICB2YXIgY3VzdG9tQ2FsbGJhY2sgPSBmdW5jdGlvbiBjdXN0b21DYWxsYmFjayhub2RlQSwgbm9kZUIsIGVkZ2UpIHt9OyAvLyBUT0RPOiBwZXJoYXBzIG1vdmUgdG8gSGllcmFyY2hpY2FsU3RhdHVzLlxuICAgICAgLy8gICAgICAgQnV0IEkgY3VycmVudGx5IGRvbid0IHNlZSB0aGUgcG9pbnQsIHRoaXMgbWV0aG9kIGlzIG5vdCB1c2VkLlxuXG5cbiAgICAgIHZhciBsZXZlbEJ5RGlyZWN0aW9uID0gZnVuY3Rpb24gbGV2ZWxCeURpcmVjdGlvbihub2RlQSwgbm9kZUIsIGVkZ2UpIHtcbiAgICAgICAgdmFyIGxldmVsQSA9IF90aGlzNy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVBLmlkXTsgLy8gc2V0IGluaXRpYWwgbGV2ZWxcblxuICAgICAgICBpZiAobGV2ZWxBID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsZXZlbEEgPSBfdGhpczcuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlQS5pZF0gPSBtaW5MZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWZmID0gY3VzdG9tQ2FsbGJhY2soTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKG5vZGVBLCBcIm5vZGVcIiksIE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhub2RlQiwgXCJub2RlXCIpLCBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMoZWRnZSwgXCJlZGdlXCIpKTtcbiAgICAgICAgX3RoaXM3LmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUIuaWRdID0gbGV2ZWxBICsgZGlmZjtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2NyYXdsTmV0d29yayhsZXZlbEJ5RGlyZWN0aW9uKTtcblxuICAgICAgdGhpcy5oaWVyYXJjaGljYWwuc2V0TWluTGV2ZWxUb1plcm8odGhpcy5ib2R5Lm5vZGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb2NhdGUgbm9kZXMgaW4gbGV2ZWxzIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXRlcm1pbmVMZXZlbHNEaXJlY3RlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lTGV2ZWxzRGlyZWN0ZWQoKSB7XG4gICAgICB2YXIgX2NvbnRleHQ0LFxuICAgICAgICAgIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIHZhciBub2RlcyA9IHJlZHVjZShfY29udGV4dDQgPSB0aGlzLmJvZHkubm9kZUluZGljZXMpLmNhbGwoX2NvbnRleHQ0LCBmdW5jdGlvbiAoYWNjLCBpZCkge1xuICAgICAgICBhY2Muc2V0KGlkLCBfdGhpczguYm9keS5ub2Rlc1tpZF0pO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwgbmV3IG1hcCgpKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuc2hha2VUb3dhcmRzID09PSBcInJvb3RzXCIpIHtcbiAgICAgICAgdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzID0gZmlsbExldmVsc0J5RGlyZWN0aW9uUm9vdHMobm9kZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzID0gZmlsbExldmVsc0J5RGlyZWN0aW9uTGVhdmVzKG5vZGVzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5oaWVyYXJjaGljYWwuc2V0TWluTGV2ZWxUb1plcm8odGhpcy5ib2R5Lm5vZGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBib29ra2VlcGluZyBvZiBwYXJlbnQgYW5kIGNoaWxkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZW5lcmF0ZU1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVNYXAoKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgdmFyIGZpbGxJblJlbGF0aW9ucyA9IGZ1bmN0aW9uIGZpbGxJblJlbGF0aW9ucyhwYXJlbnROb2RlLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgaWYgKF90aGlzOS5oaWVyYXJjaGljYWwubGV2ZWxzW2NoaWxkTm9kZS5pZF0gPiBfdGhpczkuaGllcmFyY2hpY2FsLmxldmVsc1twYXJlbnROb2RlLmlkXSkge1xuICAgICAgICAgIF90aGlzOS5oaWVyYXJjaGljYWwuYWRkUmVsYXRpb24ocGFyZW50Tm9kZS5pZCwgY2hpbGROb2RlLmlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fY3Jhd2xOZXR3b3JrKGZpbGxJblJlbGF0aW9ucyk7XG5cbiAgICAgIHRoaXMuaGllcmFyY2hpY2FsLmNoZWNrSWZUcmVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyYXdsIG92ZXIgdGhlIGVudGlyZSBuZXR3b3JrIGFuZCB1c2UgYSBjYWxsYmFjayBvbiBlYWNoIG5vZGUgY291cGxlIHRoYXQgaXMgY29ubmVjdGVkIHRvIGVhY2ggb3RoZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9ZnVuY3Rpb24oKXt9XSAgICAgICAgICB8IHdpbGwgcmVjZWl2ZSBub2RlQSwgbm9kZUIgYW5kIHRoZSBjb25uZWN0aW5nIGVkZ2UuIEEgYW5kIEIgYXJlIGRpc3RpbmN0LlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gc3RhcnRpbmdOb2RlSWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyYXdsTmV0d29ya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3Jhd2xOZXR3b3JrKCkge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgdmFyIHN0YXJ0aW5nTm9kZUlkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcHJvZ3Jlc3MgPSB7fTtcblxuICAgICAgdmFyIGNyYXdsZXIgPSBmdW5jdGlvbiBjcmF3bGVyKG5vZGUsIHRyZWUpIHtcbiAgICAgICAgaWYgKHByb2dyZXNzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBfdGhpczEwLmhpZXJhcmNoaWNhbC5zZXRUcmVlSW5kZXgobm9kZSwgdHJlZSk7XG5cbiAgICAgICAgICBwcm9ncmVzc1tub2RlLmlkXSA9IHRydWU7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZTtcblxuICAgICAgICAgIHZhciBlZGdlcyA9IF90aGlzMTAuX2dldEFjdGl2ZUVkZ2VzKG5vZGUpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcblxuICAgICAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGlmIChlZGdlLnRvSWQgPT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCAnPT09JyBiZWNhdXNlIGlkJ3MgY2FuIGJlIHN0cmluZyBhbmQgbnVtZXJpY1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGVkZ2UuZnJvbTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBlZGdlLnRvO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgIT0gY2hpbGROb2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ICchPT0nIGJlY2F1c2UgaWQncyBjYW4gYmUgc3RyaW5nIGFuZCBudW1lcmljXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobm9kZSwgY2hpbGROb2RlLCBlZGdlKTtcbiAgICAgICAgICAgICAgICBjcmF3bGVyKGNoaWxkTm9kZSwgdHJlZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChzdGFydGluZ05vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIENyYXdsIG92ZXIgYWxsIG5vZGVzXG4gICAgICAgIHZhciB0cmVlSW5kZXggPSAwOyAvLyBTZXJ2ZXMgdG8gcGFzcyBhIHVuaXF1ZSBpZCBmb3IgdGhlIGN1cnJlbnQgZGlzdGluY3QgdHJlZVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlc1tpXTtcblxuICAgICAgICAgIGlmIChwcm9ncmVzc1tub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBjcmF3bGVyKG5vZGUsIHRyZWVJbmRleCk7XG4gICAgICAgICAgICB0cmVlSW5kZXggKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyYXdsIGZyb20gdGhlIGdpdmVuIHN0YXJ0aW5nIG5vZGVcbiAgICAgICAgdmFyIF9ub2RlMiA9IHRoaXMuYm9keS5ub2Rlc1tzdGFydGluZ05vZGVJZF07XG5cbiAgICAgICAgaWYgKF9ub2RlMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vZGUgbm90IGZvdW5kOlwiLCBzdGFydGluZ05vZGVJZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3Jhd2xlcihfbm9kZTIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaGlmdCBhIGJyYW5jaCBhIGNlcnRhaW4gZGlzdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gcGFyZW50SWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlmZlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2hpZnRCbG9ja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hpZnRCbG9jayhwYXJlbnRJZCwgZGlmZikge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJvZ3Jlc3MgPSB7fTtcblxuICAgICAgdmFyIHNoaWZ0ZXIgPSBmdW5jdGlvbiBzaGlmdGVyKHBhcmVudElkKSB7XG4gICAgICAgIGlmIChwcm9ncmVzc1twYXJlbnRJZF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcm9ncmVzc1twYXJlbnRJZF0gPSB0cnVlO1xuXG4gICAgICAgIF90aGlzMTEuZGlyZWN0aW9uLnNoaWZ0KHBhcmVudElkLCBkaWZmKTtcblxuICAgICAgICB2YXIgY2hpbGRSZWYgPSBfdGhpczExLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF07XG5cbiAgICAgICAgaWYgKGNoaWxkUmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkUmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzaGlmdGVyKGNoaWxkUmVmW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNoaWZ0ZXIocGFyZW50SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgY29tbW9uIHBhcmVudCBiZXR3ZWVuIGJyYW5jaGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBjaGlsZEFcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IGNoaWxkQlxuICAgICAqIEByZXR1cm5zIHt7Zm91bmRQYXJlbnQsIHdpdGhDaGlsZH19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kQ29tbW9uUGFyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQ29tbW9uUGFyZW50KGNoaWxkQSwgY2hpbGRCKSB7XG4gICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG5cbiAgICAgIHZhciBwYXJlbnRzID0ge307XG5cbiAgICAgIHZhciBpdGVyYXRlUGFyZW50cyA9IGZ1bmN0aW9uIGl0ZXJhdGVQYXJlbnRzKHBhcmVudHMsIGNoaWxkKSB7XG4gICAgICAgIHZhciBwYXJlbnRSZWYgPSBfdGhpczEyLmhpZXJhcmNoaWNhbC5wYXJlbnRSZWZlcmVuY2VbY2hpbGRdO1xuXG4gICAgICAgIGlmIChwYXJlbnRSZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50UmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50UmVmW2ldO1xuICAgICAgICAgICAgcGFyZW50c1twYXJlbnRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGl0ZXJhdGVQYXJlbnRzKHBhcmVudHMsIHBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgZmluZFBhcmVudCA9IGZ1bmN0aW9uIGZpbmRQYXJlbnQocGFyZW50cywgY2hpbGQpIHtcbiAgICAgICAgdmFyIHBhcmVudFJlZiA9IF90aGlzMTIuaGllcmFyY2hpY2FsLnBhcmVudFJlZmVyZW5jZVtjaGlsZF07XG5cbiAgICAgICAgaWYgKHBhcmVudFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRSZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRSZWZbaV07XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRzW3BhcmVudF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvdW5kUGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICAgICAgd2l0aENoaWxkOiBjaGlsZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYnJhbmNoID0gZmluZFBhcmVudChwYXJlbnRzLCBwYXJlbnQpO1xuXG4gICAgICAgICAgICBpZiAoYnJhbmNoLmZvdW5kUGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmb3VuZFBhcmVudDogbnVsbCxcbiAgICAgICAgICB3aXRoQ2hpbGQ6IGNoaWxkXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBpdGVyYXRlUGFyZW50cyhwYXJlbnRzLCBjaGlsZEEpO1xuICAgICAgcmV0dXJuIGZpbmRQYXJlbnQocGFyZW50cywgY2hpbGRCKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzdHJhdGVneSBwYXR0ZXJuIGZvciBoYW5kbGluZyB0aGUgY29vcmRpbmF0ZXMgZ2l2ZW4gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGluZGl2aWR1YWwgaW5zdGFuY2VzIGNvbnRhaW4gYWxsIHRoZSBvcGVyYXRpb25zIGFuZCBkYXRhIHNwZWNpZmljIHRvIGEgbGF5b3V0IGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb05vdFVwZGF0ZT1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGlyZWN0aW9uU3RyYXRlZ3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGlyZWN0aW9uU3RyYXRlZ3koKSB7XG4gICAgICB2YXIgaXNWZXJ0aWNhbCA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSBcIlVEXCIgfHwgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09IFwiRFVcIjtcblxuICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBuZXcgVmVydGljYWxTdHJhdGVneSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gbmV3IEhvcml6b250YWxTdHJhdGVneSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgYSBicmFuY2ggZnJvbSB0aGUgcGFzc2VkIGxpc3Qgb2YgY2hpbGQgbm9kZXNcbiAgICAgKlxuICAgICAqIFRoaXMgdGFrZXMgaW50byBhY2NvdW50IHRoZSBwb3NpdGlvbnMgb2YgYWxsIHRoZSBjaGlsZCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGV8dmlzLk5vZGUuaWQ+fSBjaGlsZE5vZGVzICBBcnJheSBvZiBlaXRoZXIgY2hpbGQgbm9kZXMgb3Igbm9kZSBpZCdzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENlbnRlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDZW50ZXJQb3NpdGlvbihjaGlsZE5vZGVzKSB7XG4gICAgICB2YXIgbWluUG9zID0gMWU5O1xuICAgICAgdmFyIG1heFBvcyA9IC0xZTk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChjaGlsZE5vZGVzW2ldLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjaGlsZE5vZGVJZCA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgY2hpbGROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKGNoaWxkTm9kZSk7XG4gICAgICAgIG1pblBvcyA9IE1hdGgubWluKG1pblBvcywgcG9zaXRpb24pO1xuICAgICAgICBtYXhQb3MgPSBNYXRoLm1heChtYXhQb3MsIHBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDAuNSAqIChtaW5Qb3MgKyBtYXhQb3MpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYXlvdXRFbmdpbmU7XG59KCk7XG5cbnZhciBjc3NfMjQ4eiA9IFwiZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIHtcXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcblxcbiAgYm9yZGVyLXdpZHRoOiAwO1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4O1xcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG4gIGJvcmRlci1jb2xvcjogI2Q2ZDlkODtcXG4gIGJhY2tncm91bmQ6ICNmZmZmZmY7IC8qIE9sZCBicm93c2VycyAqL1xcbiAgYmFja2dyb3VuZDogLW1vei1saW5lYXItZ3JhZGllbnQoXFxuICAgIHRvcCxcXG4gICAgI2ZmZmZmZiAwJSxcXG4gICAgI2ZjZmNmYyA0OCUsXFxuICAgICNmYWZhZmEgNTAlLFxcbiAgICAjZmNmY2ZjIDEwMCVcXG4gICk7IC8qIEZGMy42KyAqL1xcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1ncmFkaWVudChcXG4gICAgbGluZWFyLFxcbiAgICBsZWZ0IHRvcCxcXG4gICAgbGVmdCBib3R0b20sXFxuICAgIGNvbG9yLXN0b3AoMCUsICNmZmZmZmYpLFxcbiAgICBjb2xvci1zdG9wKDQ4JSwgI2ZjZmNmYyksXFxuICAgIGNvbG9yLXN0b3AoNTAlLCAjZmFmYWZhKSxcXG4gICAgY29sb3Itc3RvcCgxMDAlLCAjZmNmY2ZjKVxcbiAgKTsgLyogQ2hyb21lLFNhZmFyaTQrICovXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjZmZmZmZmIDAlLFxcbiAgICAjZmNmY2ZjIDQ4JSxcXG4gICAgI2ZhZmFmYSA1MCUsXFxuICAgICNmY2ZjZmMgMTAwJVxcbiAgKTsgLyogQ2hyb21lMTArLFNhZmFyaTUuMSsgKi9cXG4gIGJhY2tncm91bmQ6IC1vLWxpbmVhci1ncmFkaWVudChcXG4gICAgdG9wLFxcbiAgICAjZmZmZmZmIDAlLFxcbiAgICAjZmNmY2ZjIDQ4JSxcXG4gICAgI2ZhZmFmYSA1MCUsXFxuICAgICNmY2ZjZmMgMTAwJVxcbiAgKTsgLyogT3BlcmEgMTEuMTArICovXFxuICBiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KFxcbiAgICB0b3AsXFxuICAgICNmZmZmZmYgMCUsXFxuICAgICNmY2ZjZmMgNDglLFxcbiAgICAjZmFmYWZhIDUwJSxcXG4gICAgI2ZjZmNmYyAxMDAlXFxuICApOyAvKiBJRTEwKyAqL1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxcbiAgICB0byBib3R0b20sXFxuICAgICNmZmZmZmYgMCUsXFxuICAgICNmY2ZjZmMgNDglLFxcbiAgICAjZmFmYWZhIDUwJSxcXG4gICAgI2ZjZmNmYyAxMDAlXFxuICApOyAvKiBXM0MgKi9cXG4gIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KCBzdGFydENvbG9yc3RyPScjZmZmZmZmJywgZW5kQ29sb3JzdHI9JyNmY2ZjZmMnLEdyYWRpZW50VHlwZT0wICk7IC8qIElFNi05ICovXFxuXFxuICBwYWRkaW5nLXRvcDogNHB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogMDtcXG4gIHRvcDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAyOHB4O1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1lZGl0LW1vZGUsXFxuZGl2LnZpcy1uZXR3b3JrIGJ1dHRvbi52aXMtZWRpdC1tb2RlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDVweDtcXG4gIGhlaWdodDogMzBweDtcXG59XFxuXFxuLyogRklYTUU6IHNob3VsZG4ndCB0aGUgdmlzLWNsb3NlIGJ1dHRvbiBiZSBhIGNoaWxkIG9mIHRoZSB2aXMtbWFuaXB1bGF0aW9uIGRpdj8gKi9cXG5cXG5kaXYudmlzLW5ldHdvcmsgYnV0dG9uLnZpcy1jbG9zZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICByaWdodDogMDtcXG4gIHRvcDogMDtcXG4gIHdpZHRoOiAzMHB4O1xcbiAgaGVpZ2h0OiAzMHB4O1xcblxcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAyMHB4IDNweDtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQWNBQUFBSENBWUFBQURFVWxmVEFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFEdkdhVlJZZEZoTlREcGpiMjB1WVdSdlltVXVlRzF3QUFBQUFBQThQM2h3WVdOclpYUWdZbVZuYVc0OUl1Kzd2eUlnYVdROUlsYzFUVEJOY0VObGFHbEllbkpsVTNwT1ZHTjZhMk01WkNJL1BnbzhlRHA0YlhCdFpYUmhJSGh0Ykc1ek9uZzlJbUZrYjJKbE9tNXpPbTFsZEdFdklpQjRPbmh0Y0hSclBTSkJaRzlpWlNCWVRWQWdRMjl5WlNBMUxqVXRZekF5TVNBM09TNHhOVFE1TVRFc0lESXdNVE12TVRBdk1qa3RNVEU2TkRjNk1UWWdJQ0FnSUNBZ0lDSStDaUFnSUR4eVpHWTZVa1JHSUhodGJHNXpPbkprWmowaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzh3TWk4eU1pMXlaR1l0YzNsdWRHRjRMVzV6SXlJK0NpQWdJQ0FnSUR4eVpHWTZSR1Z6WTNKcGNIUnBiMjRnY21SbU9tRmliM1YwUFNJaUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9uaHRjRDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmVHMXdUVTA5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5dGJTOGlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbk4wUlhaMFBTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZjMVI1Y0dVdlVtVnpiM1Z5WTJWRmRtVnVkQ01pQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T21SalBTSm9kSFJ3T2k4dmNIVnliQzV2Y21jdlpHTXZaV3hsYldWdWRITXZNUzR4THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmNHaHZkRzl6YUc5d1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM0JvYjNSdmMyaHZjQzh4TGpBdklnb2dJQ0FnSUNBZ0lDQWdJQ0I0Yld4dWN6cDBhV1ptUFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzUnBabVl2TVM0d0x5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZaWGhwWmowaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOWxlR2xtTHpFdU1DOGlQZ29nSUNBZ0lDQWdJQ0E4ZUcxd09rTnlaV0YwYjNKVWIyOXNQa0ZrYjJKbElGQm9iM1J2YzJodmNDQkRReUFvVjJsdVpHOTNjeWs4TDNodGNEcERjbVZoZEc5eVZHOXZiRDRLSUNBZ0lDQWdJQ0FnUEhodGNEcERjbVZoZEdWRVlYUmxQakl3TVRRdE1ESXRNVFJVTVRFNk5UVTZNelVyTURFNk1EQThMM2h0Y0RwRGNtVmhkR1ZFWVhSbFBnb2dJQ0FnSUNBZ0lDQThlRzF3T2sxbGRHRmtZWFJoUkdGMFpUNHlNREUwTFRBeUxURTBWREV5T2pBMU9qRTNLekF4T2pBd1BDOTRiWEE2VFdWMFlXUmhkR0ZFWVhSbFBnb2dJQ0FnSUNBZ0lDQThlRzF3T2sxdlpHbG1lVVJoZEdVK01qQXhOQzB3TWkweE5GUXhNam93TlRveE55c3dNVG93TUR3dmVHMXdPazF2WkdsbWVVUmhkR1UrQ2lBZ0lDQWdJQ0FnSUR4NGJYQk5UVHBKYm5OMFlXNWpaVWxFUG5odGNDNXBhV1E2TmpVMFltTTVZbVF0TVdJMllpMWpZalJoTFRsbE9XUXROV1kyTXpneE5EVmpaamswUEM5NGJYQk5UVHBKYm5OMFlXNWpaVWxFUGdvZ0lDQWdJQ0FnSUNBOGVHMXdUVTA2Ukc5amRXMWxiblJKUkQ1NGJYQXVaR2xrT2prNE1tTTJNR0l3TFdVelpqTXRNRGswTUMwNE1qVTBMVEZpWlRsaU5XRTBaVEU0TXp3dmVHMXdUVTA2Ukc5amRXMWxiblJKUkQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRTFOT2s5eWFXZHBibUZzUkc5amRXMWxiblJKUkQ1NGJYQXVaR2xrT2prNE1tTTJNR0l3TFdVelpqTXRNRGswTUMwNE1qVTBMVEZpWlRsaU5XRTBaVEU0TXp3dmVHMXdUVTA2VDNKcFoybHVZV3hFYjJOMWJXVnVkRWxFUGdvZ0lDQWdJQ0FnSUNBOGVHMXdUVTA2U0dsemRHOXllVDRLSUNBZ0lDQWdJQ0FnSUNBZ1BISmtaanBUWlhFK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4eVpHWTZiR2tnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZV04wYVc5dVBtTnlaV0YwWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbWx1YzNSaGJtTmxTVVErZUcxd0xtbHBaRG81T0RKak5qQmlNQzFsTTJZekxUQTVOREF0T0RJMU5DMHhZbVU1WWpWaE5HVXhPRE04TDNOMFJYWjBPbWx1YzNSaGJtTmxTVVErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHAzYUdWdVBqSXdNVFF0TURJdE1UUlVNVEU2TlRVNk16VXJNREU2TURBOEwzTjBSWFowT25kb1pXNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGtGa2IySmxJRkJvYjNSdmMyaHZjQ0JEUXlBb1YybHVaRzkzY3lrOEwzTjBSWFowT25OdlpuUjNZWEpsUVdkbGJuUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT214cFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbXhwSUhKa1pqcHdZWEp6WlZSNWNHVTlJbEpsYzI5MWNtTmxJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbUZqZEdsdmJqNXpZWFpsWkR3dmMzUkZkblE2WVdOMGFXOXVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPakl4T0RZeE5tTTJMVE0xTVdNdE5ESTBPUzA0WVdGa0xXSmtaRFEyWlRjek5XRTBORHd2YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbmRvWlc0K01qQXhOQzB3TWkweE5GUXhNVG8xTlRvek5Tc3dNVG93TUR3dmMzUkZkblE2ZDJobGJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uTnZablIzWVhKbFFXZGxiblErUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESUNoWGFXNWtiM2R6S1R3dmMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tTm9ZVzVuWldRK0x6d3ZjM1JGZG5RNlkyaGhibWRsWkQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh5WkdZNmJHa2djbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNllXTjBhVzl1UG5OaGRtVmtQQzl6ZEVWMmREcGhZM1JwYjI0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwcGJuTjBZVzVqWlVsRVBuaHRjQzVwYVdRNk5qVTBZbU01WW1RdE1XSTJZaTFqWWpSaExUbGxPV1F0TldZMk16Z3hORFZqWmprMFBDOXpkRVYyZERwcGJuTjBZVzVqWlVsRVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmQyaGxiajR5TURFMExUQXlMVEUwVkRFeU9qQTFPakUzS3pBeE9qQXdQQzl6ZEVWMmREcDNhR1Z1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENUJaRzlpWlNCUWFHOTBiM05vYjNBZ1EwTWdLRmRwYm1SdmQzTXBQQzl6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WTJoaGJtZGxaRDR2UEM5emRFVjJkRHBqYUdGdVoyVmtQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThMM0prWmpwc2FUNEtJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZVMlZ4UGdvZ0lDQWdJQ0FnSUNBOEwzaHRjRTFOT2tocGMzUnZjbmsrQ2lBZ0lDQWdJQ0FnSUR4a1l6cG1iM0p0WVhRK2FXMWhaMlV2Y0c1blBDOWtZenBtYjNKdFlYUStDaUFnSUNBZ0lDQWdJRHh3YUc5MGIzTm9iM0E2UTI5c2IzSk5iMlJsUGpNOEwzQm9iM1J2YzJodmNEcERiMnh2Y2sxdlpHVStDaUFnSUNBZ0lDQWdJRHh3YUc5MGIzTm9iM0E2U1VORFVISnZabWxzWlQ1elVrZENJRWxGUXpZeE9UWTJMVEl1TVR3dmNHaHZkRzl6YUc5d09rbERRMUJ5YjJacGJHVStDaUFnSUNBZ0lDQWdJRHgwYVdabU9rOXlhV1Z1ZEdGMGFXOXVQakU4TDNScFptWTZUM0pwWlc1MFlYUnBiMjQrQ2lBZ0lDQWdJQ0FnSUR4MGFXWm1PbGhTWlhOdmJIVjBhVzl1UGpjeU1EQXdNQzh4TURBd01Ed3ZkR2xtWmpwWVVtVnpiMngxZEdsdmJqNEtJQ0FnSUNBZ0lDQWdQSFJwWm1ZNldWSmxjMjlzZFhScGIyNCtOekl3TURBd0x6RXdNREF3UEM5MGFXWm1PbGxTWlhOdmJIVjBhVzl1UGdvZ0lDQWdJQ0FnSUNBOGRHbG1aanBTWlhOdmJIVjBhVzl1Vlc1cGRENHlQQzkwYVdabU9sSmxjMjlzZFhScGIyNVZibWwwUGdvZ0lDQWdJQ0FnSUNBOFpYaHBaanBEYjJ4dmNsTndZV05sUGpFOEwyVjRhV1k2UTI5c2IzSlRjR0ZqWlQ0S0lDQWdJQ0FnSUNBZ1BHVjRhV1k2VUdsNFpXeFlSR2x0Wlc1emFXOXVQamM4TDJWNGFXWTZVR2w0Wld4WVJHbHRaVzV6YVc5dVBnb2dJQ0FnSUNBZ0lDQThaWGhwWmpwUWFYaGxiRmxFYVcxbGJuTnBiMjQrTnp3dlpYaHBaanBRYVhobGJGbEVhVzFsYm5OcGIyNCtDaUFnSUNBZ0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBnb2dJQ0E4TDNKa1pqcFNSRVkrQ2p3dmVEcDRiWEJ0WlhSaFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvOFAzaHdZV05yWlhRZ1pXNWtQU0ozSWo4K2NaVVpNd0FBQUNCalNGSk5BQUI2SlFBQWdJTUFBUG4vQUFDQTZRQUFkVEFBQU9wZ0FBQTZtQUFBRjIrU1g4VkdBQUFBMkVsRVFWUjQyZ0RMQURUL0FTMHRMVVFGQlFVVkZ4Y1h0UEh4OGZQbDVlVU5DQWdJVENrcEtlc0VIeDhmR2dZR0JqSCsvdjRhK1BqNHFnUUVCRlU2T2pvZE1URXh6d1FVRkJTdkVCQVFFZlgxOVNEMTlmVnFORFEwQ0VsSlNkLzkvZjJ2QXdFQkFmcm41K2ZrQndjSExSWVdGZ3NYRnhmejI5dmJvOUxTMHV3RERRME5EZlB6ODFvckt5c1hJeU1qK09EZzRBdmg0ZUVhL2YzOTFnTWtKQ1JZUHo4L0tVaElTT01DQWdLaDhmSHhIUnNiR3g0VUZCUVFCRGs1T2VZN096djdDQWdJdFBiMjl2TUVCQVNhSlNVbFRRME5EZXNEQUV3cFQwS284UmkyQUFBQUFFbEZUa1N1UW1DQycpO1xcbiAgYm9yZGVyOiBub25lO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGJ1dHRvbi52aXMtY2xvc2U6aG92ZXIge1xcbiAgb3BhY2l0eTogMC42O1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24gYnV0dG9uLnZpcy1idXR0b24sXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtZWRpdC1tb2RlIGJ1dHRvbi52aXMtYnV0dG9uIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgZm9udC1mYW1pbHk6IHZlcmRhbmE7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBib3JkZXI6IG5vbmU7XFxuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogMTVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IDBweCAwcHg7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgaGVpZ2h0OiAyNHB4O1xcbiAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBwYWRkaW5nOiAwcHggOHB4IDBweCA4cHg7XFxuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLWtodG1sLXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24gYnV0dG9uLnZpcy1idXR0b246aG92ZXIge1xcbiAgYm94LXNoYWRvdzogMXB4IDFweCA4cHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24gYnV0dG9uLnZpcy1idXR0b246YWN0aXZlIHtcXG4gIGJveC1zaGFkb3c6IDFweCAxcHggOHB4IHJnYmEoMCwgMCwgMCwgMC41KTtcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIGJ1dHRvbi52aXMtYnV0dG9uLnZpcy1iYWNrIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCZ0FBQUFZQ0FZQUFBRGdkejM0QUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUVFT2FWUllkRmhOVERwamIyMHVZV1J2WW1VdWVHMXdBQUFBQUFBOFAzaHdZV05yWlhRZ1ltVm5hVzQ5SXUrN3Z5SWdhV1E5SWxjMVRUQk5jRU5sYUdsSWVuSmxVM3BPVkdONmEyTTVaQ0kvUGdvOGVEcDRiWEJ0WlhSaElIaHRiRzV6T25nOUltRmtiMkpsT201ek9tMWxkR0V2SWlCNE9uaHRjSFJyUFNKQlpHOWlaU0JZVFZBZ1EyOXlaU0ExTGpVdFl6QXlNU0EzT1M0eE5UUTVNVEVzSURJd01UTXZNVEF2TWprdE1URTZORGM2TVRZZ0lDQWdJQ0FnSUNJK0NpQWdJRHh5WkdZNlVrUkdJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUkrQ2lBZ0lDQWdJRHh5WkdZNlJHVnpZM0pwY0hScGIyNGdjbVJtT21GaWIzVjBQU0lpQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T25odGNEMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02WkdNOUltaDBkSEE2THk5d2RYSnNMbTl5Wnk5a1l5OWxiR1Z0Wlc1MGN5OHhMakV2SWdvZ0lDQWdJQ0FnSUNBZ0lDQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZjM1JGZG5ROUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlVWMlpXNTBJeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T25Cb2IzUnZjMmh2Y0QwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOXdhRzkwYjNOb2IzQXZNUzR3THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmRHbG1aajBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5MGFXWm1MekV1TUM4aUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9tVjRhV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdlpYaHBaaTh4TGpBdklqNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwRGNtVmhkRzl5Vkc5dmJENUJaRzlpWlNCUWFHOTBiM05vYjNBZ1EwTWdLRmRwYm1SdmQzTXBQQzk0YlhBNlEzSmxZWFJ2Y2xSdmIydytDaUFnSUNBZ0lDQWdJRHg0YlhBNlEzSmxZWFJsUkdGMFpUNHlNREUwTFRBeExUSXlWREU1T2pJME9qVXhLekF4T2pBd1BDOTRiWEE2UTNKbFlYUmxSR0YwWlQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBOWlhSaFpHRjBZVVJoZEdVK01qQXhOQzB3TWkwd05GUXhOVG93TVRvd09Tc3dNVG93TUR3dmVHMXdPazFsZEdGa1lYUmhSR0YwWlQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBOYjJScFpubEVZWFJsUGpJd01UUXRNREl0TURSVU1UVTZNREU2TURrck1ERTZNREE4TDNodGNEcE5iMlJwWm5sRVlYUmxQZ29nSUNBZ0lDQWdJQ0E4WkdNNlptOXliV0YwUG1sdFlXZGxMM0J1Wnp3dlpHTTZabTl5YldGMFBnb2dJQ0FnSUNBZ0lDQThlRzF3VFUwNlNXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09tSTJZalF3TWpWa0xUQXhOalF0TXpVME9DMWhPVGRsTFRRNFptWXhNV00zTlRZek16d3ZlRzF3VFUwNlNXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdQSGh0Y0UxTk9rUnZZM1Z0Wlc1MFNVUStlRzF3TG1ScFpEcEZRVGMyTWtZNU5qYzBPRE5GTXpFeE9UUTRRa1F4TTBVeVFrVTNPVGxCTVR3dmVHMXdUVTA2Ukc5amRXMWxiblJKUkQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRTFOT2s5eWFXZHBibUZzUkc5amRXMWxiblJKUkQ1NGJYQXVaR2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzk0YlhCTlRUcFBjbWxuYVc1aGJFUnZZM1Z0Wlc1MFNVUStDaUFnSUNBZ0lDQWdJRHg0YlhCTlRUcElhWE4wYjNKNVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9sTmxjVDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEprWmpwc2FTQnlaR1k2Y0dGeWMyVlVlWEJsUFNKU1pYTnZkWEpqWlNJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwaFkzUnBiMjQrWTNKbFlYUmxaRHd2YzNSRmRuUTZZV04wYVc5dVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5emRFVjJkRHBwYm5OMFlXNWpaVWxFUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2ZDJobGJqNHlNREUwTFRBeExUSXlWREU1T2pJME9qVXhLekF4T2pBd1BDOXpkRVYyZERwM2FHVnVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ1QlpHOWlaU0JRYUc5MGIzTm9iM0FnUTFNMklDaFhhVzVrYjNkektUd3ZjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHlaR1k2YkdrZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WVdOMGFXOXVQbk5oZG1Wa1BDOXpkRVYyZERwaFkzUnBiMjQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBwYm5OMFlXNWpaVWxFUG5odGNDNXBhV1E2UlVFMk1FRXlORVV4T1RnMFJUTXhNVUZFUVVaRlJrVTJSVU16TXpORk1ETThMM04wUlhaME9tbHVjM1JoYm1ObFNVUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcDNhR1Z1UGpJd01UUXRNREV0TWpOVU1UazZNVGc2TURjck1ERTZNREE4TDNOMFJYWjBPbmRvWlc0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQa0ZrYjJKbElGQm9iM1J2YzJodmNDQkRVellnS0ZkcGJtUnZkM01wUEM5emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNlkyaGhibWRsWkQ0dlBDOXpkRVYyZERwamFHRnVaMlZrUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4TDNKa1pqcHNhVDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEprWmpwc2FTQnlaR1k2Y0dGeWMyVlVlWEJsUFNKU1pYTnZkWEpqWlNJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwaFkzUnBiMjQrYzJGMlpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21sdWMzUmhibU5sU1VRK2VHMXdMbWxwWkRwbU9XUTNPR1k0WkMxbE56WTBMVGMxTkRndE9EWmlOeTFpTm1RMU9HTXpaRGcyT1RjOEwzTjBSWFowT21sdWMzUmhibU5sU1VRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwM2FHVnVQakl3TVRRdE1ESXRNRFJVTVRVNk1ERTZNRGtyTURFNk1EQThMM04wUlhaME9uZG9aVzQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBrRmtiMkpsSUZCb2IzUnZjMmh2Y0NCRFF5QW9WMmx1Wkc5M2N5azhMM04wUlhaME9uTnZablIzWVhKbFFXZGxiblErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBqYUdGdVoyVmtQaTg4TDNOMFJYWjBPbU5vWVc1blpXUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT214cFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbXhwSUhKa1pqcHdZWEp6WlZSNWNHVTlJbEpsYzI5MWNtTmxJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbUZqZEdsdmJqNWpiMjUyWlhKMFpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25CaGNtRnRaWFJsY25NK1puSnZiU0JoY0hCc2FXTmhkR2x2Ymk5MmJtUXVZV1J2WW1VdWNHaHZkRzl6YUc5d0lIUnZJR2x0WVdkbEwzQnVaend2YzNSRmRuUTZjR0Z5WVcxbGRHVnljejRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHlaR1k2YkdrZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WVdOMGFXOXVQbVJsY21sMlpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25CaGNtRnRaWFJsY25NK1kyOXVkbVZ5ZEdWa0lHWnliMjBnWVhCd2JHbGpZWFJwYjI0dmRtNWtMbUZrYjJKbExuQm9iM1J2YzJodmNDQjBieUJwYldGblpTOXdibWM4TDNOMFJYWjBPbkJoY21GdFpYUmxjbk0rQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9teHBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT214cElISmtaanB3WVhKelpWUjVjR1U5SWxKbGMyOTFjbU5sSWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21GamRHbHZiajV6WVhabFpEd3ZjM1JGZG5RNllXTjBhVzl1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT21JMllqUXdNalZrTFRBeE5qUXRNelUwT0MxaE9UZGxMVFE0Wm1ZeE1XTTNOVFl6TXp3dmMzUkZkblE2YVc1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25kb1pXNCtNakF4TkMwd01pMHdORlF4TlRvd01Ub3dPU3N3TVRvd01Ed3ZjM1JGZG5RNmQyaGxiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbk52Wm5SM1lYSmxRV2RsYm5RK1FXUnZZbVVnVUdodmRHOXphRzl3SUVORElDaFhhVzVrYjNkektUd3ZjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbU5vWVc1blpXUStMend2YzNSRmRuUTZZMmhoYm1kbFpENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9sTmxjVDRLSUNBZ0lDQWdJQ0FnUEM5NGJYQk5UVHBJYVhOMGIzSjVQZ29nSUNBZ0lDQWdJQ0E4ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjBnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBOGMzUlNaV1k2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT21ZNVpEYzRaamhrTFdVM05qUXROelUwT0MwNE5tSTNMV0kyWkRVNFl6TmtPRFk1Tnp3dmMzUlNaV1k2YVc1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdQSE4wVW1WbU9tUnZZM1Z0Wlc1MFNVUStlRzF3TG1ScFpEcEZRVGMyTWtZNU5qYzBPRE5GTXpFeE9UUTRRa1F4TTBVeVFrVTNPVGxCTVR3dmMzUlNaV1k2Wkc5amRXMWxiblJKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdQSE4wVW1WbU9tOXlhV2RwYm1Gc1JHOWpkVzFsYm5SSlJENTRiWEF1Wkdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5emRGSmxaanB2Y21sbmFXNWhiRVJ2WTNWdFpXNTBTVVErQ2lBZ0lDQWdJQ0FnSUR3dmVHMXdUVTA2UkdWeWFYWmxaRVp5YjIwK0NpQWdJQ0FnSUNBZ0lEeHdhRzkwYjNOb2IzQTZRMjlzYjNKTmIyUmxQak04TDNCb2IzUnZjMmh2Y0RwRGIyeHZjazF2WkdVK0NpQWdJQ0FnSUNBZ0lEeHdhRzkwYjNOb2IzQTZTVU5EVUhKdlptbHNaVDV6VWtkQ0lFbEZRell4T1RZMkxUSXVNVHd2Y0dodmRHOXphRzl3T2tsRFExQnliMlpwYkdVK0NpQWdJQ0FnSUNBZ0lEeDBhV1ptT2s5eWFXVnVkR0YwYVc5dVBqRThMM1JwWm1ZNlQzSnBaVzUwWVhScGIyNCtDaUFnSUNBZ0lDQWdJRHgwYVdabU9saFNaWE52YkhWMGFXOXVQamN5TURBNU1DOHhNREF3TUR3dmRHbG1aanBZVW1WemIyeDFkR2x2Ymo0S0lDQWdJQ0FnSUNBZ1BIUnBabVk2V1ZKbGMyOXNkWFJwYjI0K056SXdNRGt3THpFd01EQXdQQzkwYVdabU9sbFNaWE52YkhWMGFXOXVQZ29nSUNBZ0lDQWdJQ0E4ZEdsbVpqcFNaWE52YkhWMGFXOXVWVzVwZEQ0eVBDOTBhV1ptT2xKbGMyOXNkWFJwYjI1VmJtbDBQZ29nSUNBZ0lDQWdJQ0E4WlhocFpqcERiMnh2Y2xOd1lXTmxQakU4TDJWNGFXWTZRMjlzYjNKVGNHRmpaVDRLSUNBZ0lDQWdJQ0FnUEdWNGFXWTZVR2w0Wld4WVJHbHRaVzV6YVc5dVBqSTBQQzlsZUdsbU9sQnBlR1ZzV0VScGJXVnVjMmx2Ymo0S0lDQWdJQ0FnSUNBZ1BHVjRhV1k2VUdsNFpXeFpSR2x0Wlc1emFXOXVQakkwUEM5bGVHbG1PbEJwZUdWc1dVUnBiV1Z1YzJsdmJqNEtJQ0FnSUNBZ1BDOXlaR1k2UkdWelkzSnBjSFJwYjI0K0NpQWdJRHd2Y21SbU9sSkVSajRLUEM5NE9uaHRjRzFsZEdFK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2p3L2VIQmhZMnRsZENCbGJtUTlJbmNpUHo0anExVS9BQUFBSUdOSVVrMEFBSG9sQUFDQWd3QUErZjhBQUlEcEFBQjFNQUFBNm1BQUFEcVlBQUFYYjVKZnhVWUFBQVZUU1VSQlZIamFuRlZmVEZObkZQK2Q3N3ZlOHFlVkZiQnJwY1ZnUnJDUkZpa0ZCeUx4d1NBYUUzMm9SQ0hENkpNeHhoaG44RzJSeHhIM01zT1RieVlzbUNBeFBNbU1NWXRrSVVZbUs2ME9PMHFBSzIzQkZsTm9iMHVoM3g3V1M1akxaUHBMYm02K2svUDl6cm01djk4NTVQRjRVRmhZQ0FCZ2pJRXhCZ0FnSXFSU3FSSWk2Z0RRUmtRMVJHVEIzd2dSMGU4QUhnSDRTYS9YUi9FQmlBaUpSQUowNGNJRjVPZm5nNGcybjBna1VreEVOd0YwYzg0M0x6SEdRRVFRUWtDTEV4RUE5QUxvdFZnc1VRQVFRbWdOUWhKQ2JGNWtqQ0VVQ2wwbW9qNHQ1bmE3ZlRVMU5VcFZWVlhVWXJFa0FTQWNEaGU4ZWZPbXhPZnpXU2NtSnFvQmRCTlI5OUxTMGhXejJkeW5OU1NFQUYyOGVCR0ZoWVZnakNFY0RuOUhSRDFFaElNSEQzbzlIczlrV1ZsWkFoOUJLQlFxR0I0ZWRyNTgrZEtaKzZKYkpwT3BCd0JXVjFmQjYrcnFJTXN5SXBISUZjWllMMk1NcmEydFk1Y3VYUnJmdVhObkJ0dkFZREJrM0c2M29xcHFabTV1emdyZ1NES1pqQm9NaHVlWlRBYmM1WEloRm91VkV0RlR4aGlPSFRzMmR2NzhlUzgrRWZ2Mzc0K29xcHFabloyMWNzNVBKSlBKUGxtV2t5eW5uQnVNTVRRME5IaTd1cm8rbVZ5RHgrUHh1bHd1NzFaT2xrcWxTb25vSmhHaHZiMzlzOGsxbkR4NTBzczVoeVJKTjlQcGRLbEVSQjJhV2pTVmFFaWxVdnpCZ3djT1JWRXM1ZVhsb1hQbnprMXNWOEJrTWlVZERvZlA3L2RYWjdQWkRpbG5JaHc0Y0dCZVMxcGJXMlAzN3QxekJ3S0Jpa1FpVVVSRVdGaFlzSEhPMGQ3ZXZtMFJ1OTArLytyVnEyck8rWEdKaUp4RWhNckt5aGdBakk2T1dvZUhoNXRXVmxhKzRKekRack85Ylc1dW5od2NIR3p6Ky8zMm5wNGUreGFEYmZvSEFNeG1jNmlqbzJPMG9xSWlKa2tTTmpZMkhCSVJtUmxqTUp2TnlXZlBubG43Ky90UE1NWlFYbDYrME5iVzlxSzJ0alljajhmbG9hRWhxS3BxK0hDa2JEM1B6TXdZQmdZRzBOWFY5VXV1c0ZuYTJrRWdFTEFRRVE0ZE92U2lzN1B6TjQxQXI5ZG5ybDI3TnFDTmt2L0MzYnQzenk0dExWbUlDSnh6RUJGSlJCUW1vckxGeGNXQ3FxcXEwUGo0ZU8zWTJKaGJVWlRkcmEydEwycHJhOE9KUkdMSG5UdDN6a3FTOUsraHVIVTRFaEhNWm5Nb0dvMFc1T0loN25LNWpqTEdLcTFXNjl2RGh3OHJScU14TWpjM3QydDVlWG5YNU9Sa2xjL25NK2ZsNVNXbnBxYSswdXYxSy9uNStXczZuVzVObHVYTmQxNWUzcHBPcDF1ejJXeXpaODZjR1EwR2c2WkFJRkNaeldaL2xZam9rUkRpdU4vdnQ3VzB0TXczTlRVcGJyZDc4UDc5Kys1Z01GZ1JpVVRLSGo1OFdNWVlRM1YxOWV0VHAwNXRxNkxwNldrYjV4eENpRWZjN1haUE04YTZGeGNYVGZYMTlhLzFlbjJHY3k1cWFtcmVOalkyL3FHcTZqb1JaZTEyKzlUcDA2ZTNKWS9GWWdXUEh6OCttaHZyMy9DV2xwYmsrdnA2UG1Pc2VXVmxCUzZYUzlHU0pVa1NkcnM5M05EUThPZStmZnZDLzhmSkl5TWpkZEZvOUVzaTZwVmxlVmpUMm0wQThIcTl6cUdoSWVmbmpva25UNTQ0QTRHQU0vZURieE1SZUZOVEUwcEtTcEtxcXNhSTZQajgvTHhWVmRXTTNXNlBmQ3I1eE1URTF6bGxYUzB1TG42YVNxWEFHeHNib2RQcG9OZnJuNnVxQ3M3NUVVVlJySkZJWk1mZXZYc1hkVHJkeHNlSUU0bUVQREl5VXUvMysrdHluZDh5R28yOVJJUjBPZzI2ZnYwNmlvcUt3QmdENXh6djNyMjd6QmpySXlKSWtnU0h3ekZaV1ZtcDdObXpKMVphV3BvQWdHZzBXcWdvU3ZITXpJdzFHQXc2dHZqaGl0Rm83TlBXNWZ2MzcwSGQzZDBvS0NnQTUzelRRTXZMeStWQ2lLdVNKSDByU2RMbXp0Wnl0SVd2NVJQUkQwVDBZM0Z4OGR6V2ZieTZ1Z29wSG8vL3c0bWNjOGl5UE1jNXY1Rk9wNy9QWnJPZFFvaFdJbklDMkMyRWdCQmlnWWk4UW9pZnM5bHN2MDZuV3lJaWFGeGFnWGc4anI4R0FHeHVJZTdMQmVXaEFBQUFBRWxGVGtTdVFtQ0MnKTtcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIGRpdi52aXMtbm9uZTpob3ZlciB7XFxuICBib3gtc2hhZG93OiAxcHggMXB4IDhweCByZ2JhKDAsIDAsIDAsIDApO1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24gZGl2LnZpcy1ub25lOmFjdGl2ZSB7XFxuICBib3gtc2hhZG93OiAxcHggMXB4IDhweCByZ2JhKDAsIDAsIDAsIDApO1xcbn1cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24gZGl2LnZpcy1ub25lIHtcXG4gIHBhZGRpbmc6IDBweDtcXG4gIGxpbmUtaGVpZ2h0OiAyM3B4O1xcbn1cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24gZGl2Lm5vdGlmaWNhdGlvbiB7XFxuICBtYXJnaW46IDJweDtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24gYnV0dG9uLnZpcy1idXR0b24udmlzLWFkZCB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmdBQUFBWUNBWUFBQURnZHozNEFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVDJsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTm5WRlBwRmozMzN2UkNTNGlBbEV0dlVoVUlJRkpDaTRBVWtTWXFJUWtRU29naG9ka1ZVY0VSUlVVRUc4aWdpQU9Pam9DTUZWRXNESW9LMkFma0lhS09nNk9JaXNyNzRYdWphOWE4OStiTi9yWFhQdWVzODUyenp3ZkFDQXlXU0ROUk5ZQU1xVUllRWVDRHg4VEc0ZVF1UUlFS0pIQUFFQWl6WkNGei9TTUJBUGgrUER3cklzQUh2Z0FCZU5NTENBREFUWnZBTUJ5SC93L3FRcGxjQVlDRUFjQjBrVGhMQ0lBVUFFQjZqa0ttQUVCR0FZQ2RtQ1pUQUtBRUFHRExZMkxqQUZBdEFHQW5mK2JUQUlDZCtKbDdBUUJibENFVkFhQ1JBQ0FUWlloRUFHZzdBS3pQVm9wRkFGZ3dBQlJtUzhRNUFOZ3RBREJKVjJaSUFMQzNBTURPRUF1eUFBZ01BREJSaUlVcEFBUjdBR0RJSXlONEFJU1pBQlJHOGxjODhTdXVFT2NxQUFCNG1iSTh1U1E1UllGYkNDMXhCMWRYTGg0b3pra1hLeFEyWVFKaG1rQXV3bm1aR1RLQk5BL2c4OHdBQUtDUkZSSGdnL1A5ZU00T3JzN09ObzYyRGw4dDZyOEcveUppWXVQKzVjK3JjRUFBQU9GMGZ0SCtMQyt6R29BN0JvQnQvcUlsN2dSb1hndWdkZmVMWnJJUFFMVUFvT25hVi9OdytINDhQRVdoa0xuWjJlWGs1TmhLeEVKYlljcFhmZjVud2wvQVYvMXMrWDQ4L1BmMTRMN2lKSUV5WFlGSEJQamd3c3owVEtVY3o1SUpoR0xjNW85SC9MY0wvL3dkMHlMRVNXSzVXQ29VNDFFU2NZNUVtb3p6TXFVaWlVS1NLY1VsMHY5azR0OHMrd00rM3pVQXNHbytBWHVSTGFoZFl3UDJTeWNRV0hUQTR2Y0FBUEs3YjhIVUtBZ0RnR2lENGM5My8rOC8vVWVnSlFDQVprbVNjUUFBWGtRa0xsVEtzei9IQ0FBQVJLQ0JLckJCRy9UQkdDekFCaHpCQmR6QkMveGdOb1JDSk1UQ1FoQkNDbVNBSEhKZ0theUNRaWlHemJBZEttQXYxRUFkTk1CUmFJYVRjQTR1d2xXNERqMXdEL3BoQ0o3QktMeUJDUVJCeUFnVFlTSGFpQUZpaWxnampnZ1htWVg0SWNGSUJCS0xKQ0RKaUJSUklrdVJOVWd4VW9wVUlGVklIZkk5Y2dJNWgxeEd1cEU3eUFBeWd2eUd2RWN4bElHeVVUM1VETFZEdWFnM0dvUkdvZ3ZRWkhReG1vOFdvSnZRY3JRYVBZdzJvZWZRcTJnUDJvOCtROGN3d09nWUJ6UEViREF1eHNOQ3NUZ3NDWk5qeTdFaXJBeXJ4aHF3VnF3RHU0bjFZOCt4ZHdRU2dVWEFDVFlFZDBJZ1lSNUJTRmhNV0U3WVNLZ2dIQ1EwRWRvSk53a0RoRkhDSnlLVHFFdTBKcm9SK2NRWVlqSXhoMWhJTENQV0VvOFRMeEI3aUVQRU55UVNpVU15SjdtUUFrbXhwRlRTRXRKRzBtNVNJK2tzcVpzMFNCb2prOG5hWkd1eUJ6bVVMQ0FyeUlYa25lVEQ1RFBrRytRaDhsc0tuV0pBY2FUNFUrSW9Vc3BxU2hubEVPVTA1UVpsbURKQlZhT2FVdDJvb1ZRUk5ZOWFRcTJodGxLdlVZZW9FelIxbWpuTmd4WkpTNld0b3BYVEdtZ1hhUGRwcitoMHVoSGRsUjVPbDlCWDBzdnBSK2lYNkFQMGR3d05oaFdEeDRobktCbWJHQWNZWnhsM0dLK1lUS1laMDRzWngxUXdOekhybU9lWkQ1bHZWVmdxdGlwOEZaSEtDcFZLbFNhVkd5b3ZWS21xcHFyZXFndFY4MVhMVkkrcFhsTjlya1pWTTFQanFRblVscXRWcXAxUTYxTWJVMmVwTzZpSHFtZW9iMVEvcEg1Wi9Za0dXY05NdzA5RHBGR2dzVi9qdk1ZZ0MyTVpzM2dzSVdzTnE0WjFnVFhFSnJITjJYeDJLcnVZL1IyN2l6MnFxYUU1UXpOS00xZXpVdk9VWmo4SDQ1aHgrSngwVGdubktLZVg4MzZLM2hUdktlSXBHNlkwVExreFpWeHJxcGFYbGxpclNLdFJxMGZydlRhdTdhZWRwcjFGdTFuN2dRNUJ4MG9uWENkSFo0L09CWjNuVTlsVDNhY0tweFpOUFRyMXJpNnFhNlVib2J0RWQ3OXVwKzZZbnI1ZWdKNU1iNmZlZWIzbitoeDlMLzFVL1czNnAvVkhERmdHc3d3a0J0c016aGc4eFRWeGJ6d2RMOGZiOFZGRFhjTkFRNlZobFdHWDRZU1J1ZEU4bzlWR2pVWVBqR25HWE9NazQyM0diY2FqSmdZbUlTWkxUZXBON3BwU1RibW1LYVk3VER0TXg4M016YUxOMXBrMW16MHgxekxubStlYjE1dmZ0MkJhZUZvc3RxaTJ1R1ZKc3VSYXBsbnV0cnh1aFZvNVdhVllWVnBkczBhdG5hMGwxcnV0dTZjUnA3bE9rMDZybnRabnc3RHh0c20ycWJjWnNPWFlCdHV1dG0yMmZXRm5ZaGRudDhXdXcrNlR2Wk45dW4yTi9UMEhEWWZaRHFzZFdoMStjN1J5RkRwV090NmF6cHp1UDMzRjlKYnBMMmRZenhEUDJEUGp0aFBMS2NScG5WT2IwMGRuRjJlNWM0UHppSXVKUzRMTExwYytMcHNieHQzSXZlUktkUFZ4WGVGNjB2V2RtN09id3UybzI2L3VOdTVwN29mY244dzBueW1lV1ROejBNUElRK0JSNWRFL0M1K1ZNR3Zmckg1UFEwK0JaN1huSXk5akw1RlhyZGV3dDZWM3F2ZGg3eGMrOWo1eW4rTSs0enczM2pMZVdWL01OOEMzeUxmTFQ4TnZubCtGMzBOL0kvOWsvM3IvMFFDbmdDVUJad09KZ1VHQld3TDcrSHA4SWIrT1B6cmJaZmF5MmUxQmpLQzVRUlZCajRLdGd1WEJyU0ZveU95UXJTSDM1NWpPa2M1cERvVlFmdWpXMEFkaDVtR0x3MzRNSjRXSGhWZUdQNDV3aUZnYTBUR1hOWGZSM0VOejMwVDZSSlpFM3B0bk1VODVyeTFLTlNvK3FpNXFQTm8zdWpTNlA4WXVabG5NMVZpZFdFbHNTeHc1TGlxdU5tNXN2dC84N2ZPSDRwM2lDK043RjVndnlGMXdlYUhPd3ZTRnB4YXBMaElzT3BaQVRJaE9PSlR3UVJBcXFCYU1KZklUZHlXT0NubkNIY0puSWkvUk50R0kyRU5jS2g1TzhrZ3FUWHFTN0pHOE5Ya2t4VE9sTE9XNWhDZXBrTHhNRFV6ZG16cWVGcHAySUcweVBUcTlNWU9Ta1pCeFFxb2hUWk8yWitwbjVtWjJ5NnhsaGJMK3hXNkx0eThlbFFmSmE3T1FyQVZaTFFxMlFxYm9WRm9vMXlvSHNtZGxWMmEvelluS09aYXJuaXZON2N5enl0dVFONXp2bi8vdEVzSVM0WksycFlaTFZ5MGRXT2E5ckdvNXNqeHhlZHNLNHhVRks0WldCcXc4dUlxMkttM1ZUNnZ0VjVldWZyMG1lazFyZ1Y3QnlvTEJ0UUZyNnd0VkN1V0ZmZXZjMSsxZFQxZ3ZXZCsxWWZxR25ScytGWW1LcmhUYkY1Y1ZmOWdvM0hqbEc0ZHZ5citaM0pTMHFhdkV1V1RQWnRKbTZlYmVMWjViRHBhcWwrYVhEbTROMmRxMERkOVd0TzMxOWtYYkw1Zk5LTnU3ZzdaRHVhTy9QTGk4WmFmSnpzMDdQMVNrVlBSVStsUTI3dExkdFdIWCtHN1I3aHQ3dlBZMDdOWGJXN3ozL1Q3SnZ0dFZBVlZOMVdiVlpmdEorN1AzUDY2SnF1bjRsdnR0WGExT2JYSHR4d1BTQS8wSEl3NjIxN25VMVIzU1BWUlNqOVlyNjBjT3h4KysvcDN2ZHkwTk5nMVZqWnpHNGlOd1JIbms2ZmNKMy9jZURUcmFkb3g3ck9FSDB4OTJIV2NkTDJwQ212S2FScHRUbXZ0YllsdTZUOHcrMGRicTNucjhSOXNmRDV3MFBGbDVTdk5VeVduYTZZTFRrMmZ5ejR5ZGxaMTlmaTc1M0dEYm9yWjc1MlBPMzJvUGIrKzZFSFRoMGtYL2krYzd2RHZPWFBLNGRQS3kyK1VUVjdoWG1xODZYMjNxZE9vOC9wUFRUOGU3bkx1YXJybGNhN251ZXIyMWUyYjM2UnVlTjg3ZDlMMTU4UmIvMXRXZU9UM2R2Zk42Yi9mRjkvWGZGdDErY2lmOXpzdTcyWGNuN3EyOFQ3eGY5RUR0UWRsRDNZZlZQMXYrM05qdjNIOXF3SGVnODlIY1IvY0doWVBQL3BIMWp3OURCWStaajh1R0RZYnJuamcrT1RuaVAzTDk2ZnluUTg5a3p5YWVGLzZpL3N1dUZ4WXZmdmpWNjlmTzBaalJvWmZ5bDVPL2JYeWwvZXJBNnhtdjI4YkN4aDYreVhnek1WNzBWdnZ0d1hmY2R4M3ZvOThQVCtSOElIOG8vMmo1c2ZWVDBLZjdreG1Uay84RUE1anovR016TGRzQUFFRU9hVlJZZEZoTlREcGpiMjB1WVdSdlltVXVlRzF3QUFBQUFBQThQM2h3WVdOclpYUWdZbVZuYVc0OUl1Kzd2eUlnYVdROUlsYzFUVEJOY0VObGFHbEllbkpsVTNwT1ZHTjZhMk01WkNJL1BnbzhlRHA0YlhCdFpYUmhJSGh0Ykc1ek9uZzlJbUZrYjJKbE9tNXpPbTFsZEdFdklpQjRPbmh0Y0hSclBTSkJaRzlpWlNCWVRWQWdRMjl5WlNBMUxqVXRZekF5TVNBM09TNHhOVFE1TVRFc0lESXdNVE12TVRBdk1qa3RNVEU2TkRjNk1UWWdJQ0FnSUNBZ0lDSStDaUFnSUR4eVpHWTZVa1JHSUhodGJHNXpPbkprWmowaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzh3TWk4eU1pMXlaR1l0YzNsdWRHRjRMVzV6SXlJK0NpQWdJQ0FnSUR4eVpHWTZSR1Z6WTNKcGNIUnBiMjRnY21SbU9tRmliM1YwUFNJaUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9uaHRjRDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNlpHTTlJbWgwZEhBNkx5OXdkWEpzTG05eVp5OWtZeTlsYkdWdFpXNTBjeTh4TGpFdklnb2dJQ0FnSUNBZ0lDQWdJQ0I0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02YzNSRmRuUTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpVVjJaVzUwSXlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9uQm9iM1J2YzJodmNEMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzl3YUc5MGIzTm9iM0F2TVM0d0x5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZkR2xtWmowaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTBhV1ptTHpFdU1DOGlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbVY0YVdZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZaWGhwWmk4eExqQXZJajRLSUNBZ0lDQWdJQ0FnUEhodGNEcERjbVZoZEc5eVZHOXZiRDVCWkc5aVpTQlFhRzkwYjNOb2IzQWdRME1nS0ZkcGJtUnZkM01wUEM5NGJYQTZRM0psWVhSdmNsUnZiMncrQ2lBZ0lDQWdJQ0FnSUR4NGJYQTZRM0psWVhSbFJHRjBaVDR5TURFMExUQXhMVEl5VkRFNU9qSTBPalV4S3pBeE9qQXdQQzk0YlhBNlEzSmxZWFJsUkdGMFpUNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwTlpYUmhaR0YwWVVSaGRHVStNakF4TkMwd01pMHdORlF4TkRvME1Eb3lPU3N3TVRvd01Ed3ZlRzF3T2sxbGRHRmtZWFJoUkdGMFpUNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwTmIyUnBabmxFWVhSbFBqSXdNVFF0TURJdE1EUlVNVFE2TkRBNk1qa3JNREU2TURBOEwzaHRjRHBOYjJScFpubEVZWFJsUGdvZ0lDQWdJQ0FnSUNBOFpHTTZabTl5YldGMFBtbHRZV2RsTDNCdVp6d3ZaR002Wm05eWJXRjBQZ29nSUNBZ0lDQWdJQ0E4ZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPalZrTldJd05tUXdMVFZtTWpBdE9HRTBOQzFoTXpJd0xXWm1NVEV6TXpRd05EYzBZand2ZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnUEhodGNFMU5Pa1J2WTNWdFpXNTBTVVErZUcxd0xtUnBaRHBGUVRjMk1rWTVOamMwT0RORk16RXhPVFE0UWtReE0wVXlRa1UzT1RsQk1Ud3ZlRzF3VFUwNlJHOWpkVzFsYm5SSlJENEtJQ0FnSUNBZ0lDQWdQSGh0Y0UxTk9rOXlhV2RwYm1Gc1JHOWpkVzFsYm5SSlJENTRiWEF1Wkdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5NGJYQk5UVHBQY21sbmFXNWhiRVJ2WTNWdFpXNTBTVVErQ2lBZ0lDQWdJQ0FnSUR4NGJYQk5UVHBJYVhOMGIzSjVQZ29nSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbE5sY1Q0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhKa1pqcHNhU0J5WkdZNmNHRnljMlZVZVhCbFBTSlNaWE52ZFhKalpTSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGhZM1JwYjI0K1kzSmxZWFJsWkR3dmMzUkZkblE2WVdOMGFXOXVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOXpkRVYyZERwcGJuTjBZVzVqWlVsRVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmQyaGxiajR5TURFMExUQXhMVEl5VkRFNU9qSTBPalV4S3pBeE9qQXdQQzl6ZEVWMmREcDNhR1Z1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENUJaRzlpWlNCUWFHOTBiM05vYjNBZ1ExTTJJQ2hYYVc1a2IzZHpLVHd2YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh5WkdZNmJHa2djbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNllXTjBhVzl1UG5OaGRtVmtQQzl6ZEVWMmREcGhZM1JwYjI0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwcGJuTjBZVzVqWlVsRVBuaHRjQzVwYVdRNlJVRTJNRUV5TkVVeE9UZzBSVE14TVVGRVFVWkZSa1UyUlVNek16TkZNRE04TDNOMFJYWjBPbWx1YzNSaGJtTmxTVVErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHAzYUdWdVBqSXdNVFF0TURFdE1qTlVNVGs2TVRnNk1EY3JNREU2TURBOEwzTjBSWFowT25kb1pXNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGtGa2IySmxJRkJvYjNSdmMyaHZjQ0JEVXpZZ0tGZHBibVJ2ZDNNcFBDOXpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZMmhoYm1kbFpENHZQQzl6ZEVWMmREcGphR0Z1WjJWa1Bnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOEwzSmtaanBzYVQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhKa1pqcHNhU0J5WkdZNmNHRnljMlZVZVhCbFBTSlNaWE52ZFhKalpTSStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGhZM1JwYjI0K2MyRjJaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tbHVjM1JoYm1ObFNVUStlRzF3TG1scFpEbzJPV1ZtWVdFMU5TMDFaVEk1TFRJek5HVXRZVFV6TXkweE5Ea3hZak0xTkRObVltRThMM04wUlhaME9tbHVjM1JoYm1ObFNVUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcDNhR1Z1UGpJd01UUXRNREl0TURSVU1UUTZOREE2TWprck1ERTZNREE4TDNOMFJYWjBPbmRvWlc0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQa0ZrYjJKbElGQm9iM1J2YzJodmNDQkRReUFvVjJsdVpHOTNjeWs4TDNOMFJYWjBPbk52Wm5SM1lYSmxRV2RsYm5RK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwamFHRnVaMlZrUGk4OEwzTjBSWFowT21Ob1lXNW5aV1ErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9teHBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT214cElISmtaanB3WVhKelpWUjVjR1U5SWxKbGMyOTFjbU5sSWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21GamRHbHZiajVqYjI1MlpYSjBaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uQmhjbUZ0WlhSbGNuTStabkp2YlNCaGNIQnNhV05oZEdsdmJpOTJibVF1WVdSdlltVXVjR2h2ZEc5emFHOXdJSFJ2SUdsdFlXZGxMM0J1Wnp3dmMzUkZkblE2Y0dGeVlXMWxkR1Z5Y3o0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh5WkdZNmJHa2djbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNllXTjBhVzl1UG1SbGNtbDJaV1E4TDNOMFJYWjBPbUZqZEdsdmJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uQmhjbUZ0WlhSbGNuTStZMjl1ZG1WeWRHVmtJR1p5YjIwZ1lYQndiR2xqWVhScGIyNHZkbTVrTG1Ga2IySmxMbkJvYjNSdmMyaHZjQ0IwYnlCcGJXRm5aUzl3Ym1jOEwzTjBSWFowT25CaGNtRnRaWFJsY25NK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbXhwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9teHBJSEprWmpwd1lYSnpaVlI1Y0dVOUlsSmxjMjkxY21ObElqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tRmpkR2x2Ymo1ellYWmxaRHd2YzNSRmRuUTZZV04wYVc5dVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qVmtOV0l3Tm1Rd0xUVm1NakF0T0dFME5DMWhNekl3TFdabU1URXpNelF3TkRjMFlqd3ZjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uZG9aVzQrTWpBeE5DMHdNaTB3TkZReE5EbzBNRG95T1Nzd01Ub3dNRHd2YzNSRmRuUTZkMmhsYmo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25OdlpuUjNZWEpsUVdkbGJuUStRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJQ2hYYVc1a2IzZHpLVHd2YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21Ob1lXNW5aV1ErTHp3dmMzUkZkblE2WTJoaGJtZGxaRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbE5sY1Q0S0lDQWdJQ0FnSUNBZ1BDOTRiWEJOVFRwSWFYTjBiM0o1UGdvZ0lDQWdJQ0FnSUNBOGVHMXdUVTA2UkdWeWFYWmxaRVp5YjIwZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQThjM1JTWldZNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qWTVaV1poWVRVMUxUVmxNamt0TWpNMFpTMWhOVE16TFRFME9URmlNelUwTTJaaVlUd3ZjM1JTWldZNmFXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFVtVm1PbVJ2WTNWdFpXNTBTVVErZUcxd0xtUnBaRHBGUVRjMk1rWTVOamMwT0RORk16RXhPVFE0UWtReE0wVXlRa1UzT1RsQk1Ud3ZjM1JTWldZNlpHOWpkVzFsYm5SSlJENEtJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFVtVm1PbTl5YVdkcGJtRnNSRzlqZFcxbGJuUkpSRDU0YlhBdVpHbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOXpkRkpsWmpwdmNtbG5hVzVoYkVSdlkzVnRaVzUwU1VRK0NpQWdJQ0FnSUNBZ0lEd3ZlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMCtDaUFnSUNBZ0lDQWdJRHh3YUc5MGIzTm9iM0E2UTI5c2IzSk5iMlJsUGpNOEwzQm9iM1J2YzJodmNEcERiMnh2Y2sxdlpHVStDaUFnSUNBZ0lDQWdJRHh3YUc5MGIzTm9iM0E2U1VORFVISnZabWxzWlQ1elVrZENJRWxGUXpZeE9UWTJMVEl1TVR3dmNHaHZkRzl6YUc5d09rbERRMUJ5YjJacGJHVStDaUFnSUNBZ0lDQWdJRHgwYVdabU9rOXlhV1Z1ZEdGMGFXOXVQakU4TDNScFptWTZUM0pwWlc1MFlYUnBiMjQrQ2lBZ0lDQWdJQ0FnSUR4MGFXWm1PbGhTWlhOdmJIVjBhVzl1UGpjeU1EQTVNQzh4TURBd01Ed3ZkR2xtWmpwWVVtVnpiMngxZEdsdmJqNEtJQ0FnSUNBZ0lDQWdQSFJwWm1ZNldWSmxjMjlzZFhScGIyNCtOekl3TURrd0x6RXdNREF3UEM5MGFXWm1PbGxTWlhOdmJIVjBhVzl1UGdvZ0lDQWdJQ0FnSUNBOGRHbG1aanBTWlhOdmJIVjBhVzl1Vlc1cGRENHlQQzkwYVdabU9sSmxjMjlzZFhScGIyNVZibWwwUGdvZ0lDQWdJQ0FnSUNBOFpYaHBaanBEYjJ4dmNsTndZV05sUGpFOEwyVjRhV1k2UTI5c2IzSlRjR0ZqWlQ0S0lDQWdJQ0FnSUNBZ1BHVjRhV1k2VUdsNFpXeFlSR2x0Wlc1emFXOXVQakkwUEM5bGVHbG1PbEJwZUdWc1dFUnBiV1Z1YzJsdmJqNEtJQ0FnSUNBZ0lDQWdQR1Y0YVdZNlVHbDRaV3haUkdsdFpXNXphVzl1UGpJMFBDOWxlR2xtT2xCcGVHVnNXVVJwYldWdWMybHZiajRLSUNBZ0lDQWdQQzl5WkdZNlJHVnpZM0pwY0hScGIyNCtDaUFnSUR3dmNtUm1PbEpFUmo0S1BDOTRPbmh0Y0cxbGRHRStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0Nqdy9lSEJoWTJ0bGRDQmxibVE5SW5jaVB6NVdLcXA5QUFBQUlHTklVazBBQUhvbEFBQ0Fnd0FBK2Y4QUFJRHBBQUIxTUFBQTZtQUFBRHFZQUFBWGI1SmZ4VVlBQUFZWFNVUkJWSGphZkZadFVGVFhHWDdlOXoyN3N2ZXVNQ3dZVjhFbHJBN1lTRllIdEpVUGthYUkwYVJxRzh3UDAwelV6bGpESU5OU0EvMlJPdHBPMjRTeG5haGx4allkN1NTam1Va3ltY3hZbERoUVB6SEdpc0VWcDhId1lXQ1ZWVmdFc3JzdUxuTDc0KzV1cVRGOVorN2NPL2Q4UE85NXp2Tzg1MUJsWlNWMFhRY0FNRE9ZR1FCQVJEaFgzSlJtTURZWndMUE1XQXpHSEFDWUlnd1M0Nm9CTkJOd3RPTDhDd0U4RWtTRVVDZ0UyckpsQzJ3Mkc0Z284WndvL2JNRGdub0c2Z3hMZkFBQVl2UERNQ0NzektUQU1JQUdBaHJXbmYxNUFBQU13d0FSSVJLSmdEWnYzZ3k3M1E0aUFqUGp4SXI5VlZPTVJoYkFZS0I4enZyTzBsbHJmRXNkS3dMWmVrNllBUFNGdnRTdTNHdExhd3UwWko2NjI1U0hHQlFCMVQ4OHQ2TXh2b3BnTUFqYXVuVXJkRjBITStQNHl2MjdETVllSm1CMVJxVzNKbmYzdFFYMnAwTDRQOUVYdXFFZDdQbURwK1h1TVU5c1JidlhubnQxVHh4QUNnb0tZTFZhY2J6c1FEVUpHa1NBVGU2cWkyOHVQdHp1c002S3hpZTZOSExHVVgzbHhWVU5YOVN0UEhubjR3eTNuanVVWWN1Nm4ycE5pNjZhdmNFWG5CeVAvbnY4YWlhSXlycXoyZ081QTkrOUZJMUdJZm41K1doWmRUQWRqRk1rd012Wk95N3VXblRBT3ozTDRZazcxbTN0NjlmZGZURG9VR1RCZUhUVWZpSFE2bG83WjJPWEp2cERBQ2hLZSthT0NkS1JLV3haMisxcWIzeXlkM0dZbVJrUTdHUUJWczk5d2Z2Nm9uM2VSMms0UGRUa0RFYkg3SXVTOC9zdmxkLzU2MVBKUy9wRGsxL2J6d3g5NHB6ZTd4YzV2L0grWVBZNnI1QkFrZHJKek9EVEs0NmxFNlBlWUVKdDd1KzhqK09ad0NCaUVBZ0FvTmdLSm9FUWY2UHZOdmRyWGd0Wm9OaFNmN3EwS1ozQjJBUW1WTXplMEptdDU0Uy9EY0RDVmlnMk5jdkVVR3hKQUU0UGwrWU9yMGl2NkJSU0lQQW1CZUJaQW1IbEUyc0g0cDF1aHJxMXMwTW5uRVFNQnNmOHdSQVNBSUNRUUNDSVROMVg3L3NPdWMwa2dPVnAzL2ZQczJXSHYrY29HN2dRT0pVbkxHc1VDVHhFalB6VW9oRUErTmZJV1VkdHgwK2VmekExa1NTa0lHeUJBUU5DS2dIQUVCQUozdTc5VTdraUFjV29lbS9nYjVGZDMzbnJIM2twK1NNV3R1QUIrR2xsTUp4TWpDeDlRUmdBM3VpcUw1a3dIaVRscHhiM3NtbGZNREdZR1BQMWhjTUFrSnZzOFNjcGZkSnNwZGorTUs2UGYrNSt1Mjl2eWI0bFI0K0JHRXppVkVTQWtFcHc2QXYxT2hVcEhDejRxT1hiekZXejROY2RqL3YvbzA4THQ5Mk9ERGdaRENFRkpZb1VHSDRtenVnUDkycHVQVGYwcEQzSDd3dmZkRlpkcVN4bk10V2pvR0FBbUc5Zk9MeGp3ZXNkalQyL1h6SVE3a3Mzc3ljWU1TRXdHSE50V2Y1YmtYNU5rWUNKQnhVQlhpR1YwWEh2b3NPdDU0WmV5MzNqL0srOFAzMysrdmpuYmlHSmJiTEUrSjlTQU5BYjZuSjJCNzl3Y1V3RVRBd1FRN2ZNalB6TXZmUDhqYTg3SFVJS01PaWFBcU1aaHJHbUxkQXk3OGVacnd3c1RTMGVPYlRzK0lkdGdWYW54QlVFeHFHYmI1VnpySUlTR0lvVVhzbXFiZ0VoSmxkQ1FXcVJmMjdTdlBBbi9vOFhtZ0xoWnNVa1I0bGwzN21oazNuOTRaNE9selkvN05MY1laZm03bzF6MnpUNHZzdlVOU1hxcHJCQ2ttaVRGYlBYOTAvZmg4R0lUMnNmK3pUUGRETWY0ZFZuTmc0eitFMGl4c0dlQnM5amQ1VmlTZ0xIakNiL3BlYVIrTUQzZDQvWkpnMmxseXVHMlZ3eTdRV0FzOFBObm4xZjd2a0dTR3hBekU2bWsra3hreC9wLzR1bmZmU0NSMGhBb0wxRUJDWWlQTmRXTmN3a05RVENSN2ZlV1g2Zys3Zi9BN0k4cmN3L1U2VUVlME5kcmhjL1c3bXRMOXp0bXFsU2dzdFNTL3pUSjI4ZGFscE9wa1JyeXJ3Ymh3QkFDZ3NMTVdQR0RPVDRsbDNxeWVxQWtKVGRDRjdQL0NyVVkvR2tMTDFyRSsyaFRiU0g4KzBMYi9XRXVoemh5YUE5MDVibGY5VmQvODk1V25ad0xIclBldmlyL2N2T0Ixb0xZcFR0THJtNm9ZR0lNREV4QWFxdHJVVktTZ3FZR1NLQ2swV0hxNWlra1dFV3ROTDBpbXY1cVVXK1JjbExSakpzcmhCQXVIMS9RTDhSN0hSNHh5NW5lc2N1UDIzRTZoT0E2bUx2K3NiNHVUdzZPZ3FxcTZ1RHBta1FrY1N0b3JYNFhSY00xRmpaK2t2RkZqQ0pLVTFXcGtOSkpVcUlNdFgxUnlMZVgzSnRRMEpSaG1HWVovTDI3ZHVSbkp5Y3VGR0lTT0o5cHFoNWxyQjZpWWdxR094UnJPYWE1NERjWm1LdmtKeGs4SkhDOXJLaCtLVmhPc0Q0K0RqK013QURJZjhuNW00eEd3QUFBQUJKUlU1RXJrSmdnZz09Jyk7XFxufVxcblxcbmRpdi52aXMtbmV0d29yayBkaXYudmlzLW1hbmlwdWxhdGlvbiBidXR0b24udmlzLWJ1dHRvbi52aXMtZWRpdCxcXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1lZGl0LW1vZGUgYnV0dG9uLnZpcy1idXR0b24udmlzLWVkaXQge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJnQUFBQVlDQVlBQUFEZ2R6MzRBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBRUVPYVZSWWRGaE5URHBqYjIwdVlXUnZZbVV1ZUcxd0FBQUFBQUE4UDNod1lXTnJaWFFnWW1WbmFXNDlJdSs3dnlJZ2FXUTlJbGMxVFRCTmNFTmxhR2xJZW5KbFUzcE9WR042YTJNNVpDSS9QZ284ZURwNGJYQnRaWFJoSUhodGJHNXpPbmc5SW1Ga2IySmxPbTV6T20xbGRHRXZJaUI0T25odGNIUnJQU0pCWkc5aVpTQllUVkFnUTI5eVpTQTFMalV0WXpBeU1TQTNPUzR4TlRRNU1URXNJREl3TVRNdk1UQXZNamt0TVRFNk5EYzZNVFlnSUNBZ0lDQWdJQ0krQ2lBZ0lEeHlaR1k2VWtSR0lIaHRiRzV6T25Ka1pqMGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNVGs1T1M4d01pOHlNaTF5WkdZdGMzbHVkR0Y0TFc1ekl5SStDaUFnSUNBZ0lEeHlaR1k2UkdWelkzSnBjSFJwYjI0Z2NtUm1PbUZpYjNWMFBTSWlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbmh0Y0QwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0x5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZaR005SW1oMGRIQTZMeTl3ZFhKc0xtOXlaeTlrWXk5bGJHVnRaVzUwY3k4eExqRXZJZ29nSUNBZ0lDQWdJQ0FnSUNCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmMzUkZkblE5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVVYyWlc1MEl5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbkJvYjNSdmMyaHZjRDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5d2FHOTBiM05vYjNBdk1TNHdMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02ZEdsbVpqMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzkwYVdabUx6RXVNQzhpQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T21WNGFXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2WlhocFppOHhMakF2SWo0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBEY21WaGRHOXlWRzl2YkQ1QlpHOWlaU0JRYUc5MGIzTm9iM0FnUTBNZ0tGZHBibVJ2ZDNNcFBDOTRiWEE2UTNKbFlYUnZjbFJ2YjJ3K0NpQWdJQ0FnSUNBZ0lEeDRiWEE2UTNKbFlYUmxSR0YwWlQ0eU1ERTBMVEF4TFRJeVZERTVPakkwT2pVeEt6QXhPakF3UEM5NGJYQTZRM0psWVhSbFJHRjBaVDRLSUNBZ0lDQWdJQ0FnUEhodGNEcE5aWFJoWkdGMFlVUmhkR1UrTWpBeE5DMHdNaTB3TlZReE5Eb3hNam95TlNzd01Ub3dNRHd2ZUcxd09rMWxkR0ZrWVhSaFJHRjBaVDRLSUNBZ0lDQWdJQ0FnUEhodGNEcE5iMlJwWm5sRVlYUmxQakl3TVRRdE1ESXRNRFZVTVRRNk1USTZNalVyTURFNk1EQThMM2h0Y0RwTmIyUnBabmxFWVhSbFBnb2dJQ0FnSUNBZ0lDQThaR002Wm05eWJXRjBQbWx0WVdkbEwzQnVaend2WkdNNlptOXliV0YwUGdvZ0lDQWdJQ0FnSUNBOGVHMXdUVTA2U1c1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pZNU9UTTNaR1pqTFRKak56UXRZVFUwWVMwNU9USXpMVFF5TW1aaE5ETmtNamxqTkR3dmVHMXdUVTA2U1c1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRTFOT2tSdlkzVnRaVzUwU1VRK2VHMXdMbVJwWkRwRlFUYzJNa1k1TmpjME9ETkZNekV4T1RRNFFrUXhNMFV5UWtVM09UbEJNVHd2ZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDRLSUNBZ0lDQWdJQ0FnUEhodGNFMU5Pazl5YVdkcGJtRnNSRzlqZFcxbGJuUkpSRDU0YlhBdVpHbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOTRiWEJOVFRwUGNtbG5hVzVoYkVSdlkzVnRaVzUwU1VRK0NpQWdJQ0FnSUNBZ0lEeDRiWEJOVFRwSWFYTjBiM0o1UGdvZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT2xObGNUNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BISmtaanBzYVNCeVpHWTZjR0Z5YzJWVWVYQmxQU0pTWlhOdmRYSmpaU0krQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBoWTNScGIyNCtZM0psWVhSbFpEd3ZjM1JGZG5RNllXTjBhVzl1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzl6ZEVWMmREcHBibk4wWVc1alpVbEVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZkMmhsYmo0eU1ERTBMVEF4TFRJeVZERTVPakkwT2pVeEt6QXhPakF3UEM5emRFVjJkRHAzYUdWdVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDVCWkc5aVpTQlFhRzkwYjNOb2IzQWdRMU0ySUNoWGFXNWtiM2R6S1R3dmMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4eVpHWTZiR2tnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZV04wYVc5dVBuTmhkbVZrUEM5emRFVjJkRHBoWTNScGIyNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHBibk4wWVc1alpVbEVQbmh0Y0M1cGFXUTZSVUUyTUVFeU5FVXhPVGcwUlRNeE1VRkVRVVpGUmtVMlJVTXpNek5GTURNOEwzTjBSWFowT21sdWMzUmhibU5sU1VRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwM2FHVnVQakl3TVRRdE1ERXRNak5VTVRrNk1UZzZNRGNyTURFNk1EQThMM04wUlhaME9uZG9aVzQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBrRmtiMkpsSUZCb2IzUnZjMmh2Y0NCRFV6WWdLRmRwYm1SdmQzTXBQQzl6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WTJoaGJtZGxaRDR2UEM5emRFVjJkRHBqYUdGdVoyVmtQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThMM0prWmpwc2FUNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BISmtaanBzYVNCeVpHWTZjR0Z5YzJWVWVYQmxQU0pTWlhOdmRYSmpaU0krQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBoWTNScGIyNCtjMkYyWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbWx1YzNSaGJtTmxTVVErZUcxd0xtbHBaRG96T1dOaE56RTVaQzAzWXpObExUVXlOR0V0WW1ZMU5TMDNOR1ZtTW1NMU16RTBZVGM4TDNOMFJYWjBPbWx1YzNSaGJtTmxTVVErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHAzYUdWdVBqSXdNVFF0TURJdE1EVlVNVFE2TVRJNk1qVXJNREU2TURBOEwzTjBSWFowT25kb1pXNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGtGa2IySmxJRkJvYjNSdmMyaHZjQ0JEUXlBb1YybHVaRzkzY3lrOEwzTjBSWFowT25OdlpuUjNZWEpsUVdkbGJuUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGphR0Z1WjJWa1BpODhMM04wUlhaME9tTm9ZVzVuWldRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbXhwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9teHBJSEprWmpwd1lYSnpaVlI1Y0dVOUlsSmxjMjkxY21ObElqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tRmpkR2x2Ymo1amIyNTJaWEowWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbkJoY21GdFpYUmxjbk0rWm5KdmJTQmhjSEJzYVdOaGRHbHZiaTkyYm1RdVlXUnZZbVV1Y0dodmRHOXphRzl3SUhSdklHbHRZV2RsTDNCdVp6d3ZjM1JGZG5RNmNHRnlZVzFsZEdWeWN6NEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4eVpHWTZiR2tnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZV04wYVc5dVBtUmxjbWwyWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbkJoY21GdFpYUmxjbk0rWTI5dWRtVnlkR1ZrSUdaeWIyMGdZWEJ3YkdsallYUnBiMjR2ZG01a0xtRmtiMkpsTG5Cb2IzUnZjMmh2Y0NCMGJ5QnBiV0ZuWlM5d2JtYzhMM04wUlhaME9uQmhjbUZ0WlhSbGNuTStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT214cFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbXhwSUhKa1pqcHdZWEp6WlZSNWNHVTlJbEpsYzI5MWNtTmxJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbUZqZEdsdmJqNXpZWFpsWkR3dmMzUkZkblE2WVdOMGFXOXVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPalk1T1RNM1pHWmpMVEpqTnpRdFlUVTBZUzA1T1RJekxUUXlNbVpoTkROa01qbGpORHd2YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbmRvWlc0K01qQXhOQzB3TWkwd05WUXhORG94TWpveU5Tc3dNVG93TUR3dmMzUkZkblE2ZDJobGJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uTnZablIzWVhKbFFXZGxiblErUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESUNoWGFXNWtiM2R6S1R3dmMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tTm9ZVzVuWldRK0x6d3ZjM1JGZG5RNlkyaGhibWRsWkQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT2xObGNUNEtJQ0FnSUNBZ0lDQWdQQzk0YlhCTlRUcElhWE4wYjNKNVBnb2dJQ0FnSUNBZ0lDQThlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMGdjbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4YzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPak01WTJFM01UbGtMVGRqTTJVdE5USTBZUzFpWmpVMUxUYzBaV1l5WXpVek1UUmhOend2YzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ1BITjBVbVZtT21SdlkzVnRaVzUwU1VRK2VHMXdMbVJwWkRwRlFUYzJNa1k1TmpjME9ETkZNekV4T1RRNFFrUXhNMFV5UWtVM09UbEJNVHd2YzNSU1pXWTZaRzlqZFcxbGJuUkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ1BITjBVbVZtT205eWFXZHBibUZzUkc5amRXMWxiblJKUkQ1NGJYQXVaR2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzl6ZEZKbFpqcHZjbWxuYVc1aGJFUnZZM1Z0Wlc1MFNVUStDaUFnSUNBZ0lDQWdJRHd2ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjArQ2lBZ0lDQWdJQ0FnSUR4d2FHOTBiM05vYjNBNlEyOXNiM0pOYjJSbFBqTThMM0JvYjNSdmMyaHZjRHBEYjJ4dmNrMXZaR1UrQ2lBZ0lDQWdJQ0FnSUR4d2FHOTBiM05vYjNBNlNVTkRVSEp2Wm1sc1pUNXpVa2RDSUVsRlF6WXhPVFkyTFRJdU1Ud3ZjR2h2ZEc5emFHOXdPa2xEUTFCeWIyWnBiR1UrQ2lBZ0lDQWdJQ0FnSUR4MGFXWm1Pazl5YVdWdWRHRjBhVzl1UGpFOEwzUnBabVk2VDNKcFpXNTBZWFJwYjI0K0NpQWdJQ0FnSUNBZ0lEeDBhV1ptT2xoU1pYTnZiSFYwYVc5dVBqY3lNREE1TUM4eE1EQXdNRHd2ZEdsbVpqcFlVbVZ6YjJ4MWRHbHZiajRLSUNBZ0lDQWdJQ0FnUEhScFptWTZXVkpsYzI5c2RYUnBiMjQrTnpJd01Ea3dMekV3TURBd1BDOTBhV1ptT2xsU1pYTnZiSFYwYVc5dVBnb2dJQ0FnSUNBZ0lDQThkR2xtWmpwU1pYTnZiSFYwYVc5dVZXNXBkRDR5UEM5MGFXWm1PbEpsYzI5c2RYUnBiMjVWYm1sMFBnb2dJQ0FnSUNBZ0lDQThaWGhwWmpwRGIyeHZjbE53WVdObFBqRThMMlY0YVdZNlEyOXNiM0pUY0dGalpUNEtJQ0FnSUNBZ0lDQWdQR1Y0YVdZNlVHbDRaV3hZUkdsdFpXNXphVzl1UGpJMFBDOWxlR2xtT2xCcGVHVnNXRVJwYldWdWMybHZiajRLSUNBZ0lDQWdJQ0FnUEdWNGFXWTZVR2w0Wld4WlJHbHRaVzV6YVc5dVBqSTBQQzlsZUdsbU9sQnBlR1ZzV1VScGJXVnVjMmx2Ymo0S0lDQWdJQ0FnUEM5eVpHWTZSR1Z6WTNKcGNIUnBiMjQrQ2lBZ0lEd3ZjbVJtT2xKRVJqNEtQQzk0T25odGNHMWxkR0UrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDancvZUhCaFkydGxkQ0JsYm1ROUluY2lQejR5a25pbkFBQUFJR05JVWswQUFIb2xBQUNBZ3dBQStmOEFBSURwQUFCMU1BQUE2bUFBQURxWUFBQVhiNUpmeFVZQUFBWXBTVVJCVkhqYWZGWnRURnZuRlg3T2VhK051ZGlZMkh3YW00Q0JsZ1F3WGRLUkVES1VvWWcwamJSSjI5UkoyVloxbWpSRlV4U3BBM1ZUZmt6SmZrUWJTN3NwVTZydHg1WjJVdHBwU2NqYUh4dkx1aWF0V2kyakxFb01JVURDaDIzZzJnYmo3K3RQdVB2aE91cmF3UGwxZGM5OW4rYzU1ejMzZlY0NmNlSUVaRmtHQURBemlBZ0FRRVJvZS85Wks0R1BNL0FjZ2JzSVhBY0FCQ2dNdmtmQXFBYTg5ZURvSnlGOExvZ0lxcXFDaG9hR1lEQVlIcjhrSXRTOHVjOGlJSDZpQWE5SWtBbzVFQVFYOHBxbWdVVkJDQmdnWUZnRGh2MC9HQXNCZ0tacElDSmtNaG5RNE9BZ1pGa0dFWUdaVVhtcCswY1MrQ0tCd1dBMERWUlBPZzVabDJxNnphSHlKbG5WQU1RWFZUa3dIclVxSDBYc3ZuK3RkUUFBTVFEZ3BQTFMyTVZpRlk4cmtHVVp6SXphUy90L3hxQ3pHZ2d0ejllNjk3enNuS2hvTFV0aW00ak9xL0xFNng3WDBuc2gxNmRFWjVhL08zYTJTQ0FPSGp3SW5VNkh1amQ2VGhKNG1DRFErYjJHMjMydjd2NnZ3YXJQYlFuOE1HbE1yK1gwa3BFM1dyNVp0NWhMNUhQaHFZU2RRSWZLSit5aHhEUEtXQzZYZytqdDdVWEQ1YjVLQnQxa0NIUzg1TGpkOC9PbjNOdXBmbmhGYVpqNHJXZmYxQjk4QjFSL2huVW1LZDM2YmR0Q05sNGcwZW40ZWRORS9jWHdMcThxTVRNSVBBUXdtby9XdUh2T2JBOCs5YzU4ay9kS3REMFR5WldYTjVZR0E3ZWo3ZXBLeHNwTS8vN1NvTk9kV2MvSnlxMndpd2hEelB4VDhjUDBqeXMzVk1NN09tTDAvNzd6bjRZZHVpM2I4dWlLMGpEN1JyQTc3YzlXZDU3Y2VmUHBGKzJUNmJXc0ZQV2thaVBUQ1d2VHNacEhGVStYclMrOEczQVIwOEY2WCsxRkp2QnhRUXpIUU9XazJTbXJXNEZQWC9VMkxWd1B1RFpqK2ZKS2wya2hQcGV5QXFBOXJ6Ui9ZcXd1aVdYWDh0YU4vQ2FiR2tyVnVxOVlKbGtRUURqT0FKNWpBaHo5VnQ5VzRONS9yTnA4SSt2dE1WL2FabTR6TG5VTk50MHVyZFluRjY4SFdvSmo0V28xbUxHVU5ScjhMRWdEZ05xZUNoOHhRSUtPc2dDN2lBalZlODNyVDl6UWE4dU5NMjh1NzBrc3Blc3N1OHE4enEvVjNOY1pwVnpiOSswem1WaE92dnZyaGFNVnpySmcwemVxN3hNVkNDd2RwbldTR0JxalV5SndMVEZnYnZ4aWUzdzMxdW9XUjFZNzRyNjByZHhacXJSOHE4NXQyVzJNR0NwMTJibS9LQzNoeWFTVGlNaHh1R3JLY2FocXBiak9hRE9vRWhPRW9GcUpRQ0NKdnFBODVJNmJmVGREalFsZjJsYnhWTmxTNnd0MTl5eTdqUkhaWmxEbnJpbk5qLzZzSE1obk53Mk9nY283Tzc5ZTVmbS94UXl3UkJCQ0VBdXduNGdROTZia1lqNFZ5dXE5TjFaM0JqNE9kNWJzME1YdC9kWloyMWN0aXFGYW4xNzRxOTg1UCtMZnArVTFnN1hET04vMWN0UDQ1OFdsVmpMeUpoT0lTWkUwd00wUzFRZnVSQzNsVGprSkFLS0V0TkM5ZUlPaFNoOXhITFpPSlJaVEZ1WERzRW9TdExrUi83Njh1bW1zYUpHOVBiOW9lKzlKK3hhZVNWb2tpUURTSnBoQW81dWFCdVdqaUtQNFFUcVMxY1VXVTdheWVzTjY2d3UyMmZyRDF2bVZXNkdXNlQ4dTllVmpHeVp6cyt3NzhOcXUwYTJtYnZWdTFLRUpRQWdlWlJMMGxpUVl5eCtHT21LZVFwdTByTVlzQUpQTkVGR0QyZExvZExJeTZjOVlzN0c4eWVTVWwzdGYyL1gzcmNCVkpTT3YzNGwzc0NCb2dpN3oxTEgvckJIamw0SUo5My9uY1FGQW5qZUltSkQwWjh6dUN3dTlxM2RqRFhxVGxBS0lENXh2Kzl0MlI4bjhWY1VGQmxqUThHeWZlNDBCWUJNNER3REx0OEt1ZTc5WmNGa2J6ZkVkYlViditvTjRjOUtUdHNmbTFNYllRcXFoKzJ6clZaWUtzLzdFZitieWltdDFQT1lpSmhEaFBCRkJJaUlFWGh4ZnM3L2RmWW9JRithdUJmWVRFL3BlYngvVjhocUJQMk9EdkQzNHl2dWgvV0NBbVU3NUJ4NnNJZ2FJL3Y1KzZQVjZKTHFVc1lyN2RwREFvZWhzMGg3M3BIVFdydktnVGhZYlJTdDlVbVNqZWYzTXBhVXZCejRPNzJVbUFEZ1RPUEpndUdpWm9yKy9IeVVsSldCbUpGeitEOHhUdGxVaU9wYndwbXJtcndlZVNYclQrZzExazRTQk4zUkdLVWNBVkNWZEZoeVAxbnJlRGJZLy9OUHlFWFVsVS9QcDRYWXljR1Q2VjBVeDJXd1dkTzdjT1pTV2xrSUk4ZGlYN1NQUE5nRGFLZGJ4b05BeHdBVEJBRWtFRWdTV0NFUUFxUEFNd3F2TWRDRXdNTzB0VnFacFdzR1RUNTgrRGFQUitQaEdJWVFBQUFnaDBQN0IzaW9XL0IwaUdpQ0dpd1hiQ3VPSEZTSnlzNkFiWUZ5ZTJUK3hXaFQzV1lKRUlvSC9EUUJNdzNrZXM4T0pQZ0FBQUFCSlJVNUVya0pnZ2c9PScpO1xcbn1cXG5cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1lZGl0LW1vZGUgYnV0dG9uLnZpcy1idXR0b24udmlzLWVkaXQudmlzLWVkaXQtbW9kZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmNmY2ZjO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2NjY2NjYztcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIGJ1dHRvbi52aXMtYnV0dG9uLnZpcy1jb25uZWN0IHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCZ0FBQUFZQ0FZQUFBRGdkejM0QUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUVFT2FWUllkRmhOVERwamIyMHVZV1J2WW1VdWVHMXdBQUFBQUFBOFAzaHdZV05yWlhRZ1ltVm5hVzQ5SXUrN3Z5SWdhV1E5SWxjMVRUQk5jRU5sYUdsSWVuSmxVM3BPVkdONmEyTTVaQ0kvUGdvOGVEcDRiWEJ0WlhSaElIaHRiRzV6T25nOUltRmtiMkpsT201ek9tMWxkR0V2SWlCNE9uaHRjSFJyUFNKQlpHOWlaU0JZVFZBZ1EyOXlaU0ExTGpVdFl6QXlNU0EzT1M0eE5UUTVNVEVzSURJd01UTXZNVEF2TWprdE1URTZORGM2TVRZZ0lDQWdJQ0FnSUNJK0NpQWdJRHh5WkdZNlVrUkdJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUkrQ2lBZ0lDQWdJRHh5WkdZNlJHVnpZM0pwY0hScGIyNGdjbVJtT21GaWIzVjBQU0lpQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T25odGNEMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02WkdNOUltaDBkSEE2THk5d2RYSnNMbTl5Wnk5a1l5OWxiR1Z0Wlc1MGN5OHhMakV2SWdvZ0lDQWdJQ0FnSUNBZ0lDQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZjM1JGZG5ROUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlVWMlpXNTBJeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T25Cb2IzUnZjMmh2Y0QwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOXdhRzkwYjNOb2IzQXZNUzR3THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmRHbG1aajBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5MGFXWm1MekV1TUM4aUNpQWdJQ0FnSUNBZ0lDQWdJSGh0Ykc1ek9tVjRhV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdlpYaHBaaTh4TGpBdklqNEtJQ0FnSUNBZ0lDQWdQSGh0Y0RwRGNtVmhkRzl5Vkc5dmJENUJaRzlpWlNCUWFHOTBiM05vYjNBZ1EwTWdLRmRwYm1SdmQzTXBQQzk0YlhBNlEzSmxZWFJ2Y2xSdmIydytDaUFnSUNBZ0lDQWdJRHg0YlhBNlEzSmxZWFJsUkdGMFpUNHlNREUwTFRBeExUSXlWREU1T2pJME9qVXhLekF4T2pBd1BDOTRiWEE2UTNKbFlYUmxSR0YwWlQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBOWlhSaFpHRjBZVVJoZEdVK01qQXhOQzB3TWkwd05GUXhORG96T0RvMU55c3dNVG93TUR3dmVHMXdPazFsZEdGa1lYUmhSR0YwWlQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBOYjJScFpubEVZWFJsUGpJd01UUXRNREl0TURSVU1UUTZNemc2TlRjck1ERTZNREE4TDNodGNEcE5iMlJwWm5sRVlYUmxQZ29nSUNBZ0lDQWdJQ0E4WkdNNlptOXliV0YwUG1sdFlXZGxMM0J1Wnp3dlpHTTZabTl5YldGMFBnb2dJQ0FnSUNBZ0lDQThlRzF3VFUwNlNXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qbG1ZalV3TURVMExXRTNPREV0TVdRME9DMDVaVGxsTFRVMlpXUTVZemhsWWpkak5qd3ZlRzF3VFUwNlNXNXpkR0Z1WTJWSlJENEtJQ0FnSUNBZ0lDQWdQSGh0Y0UxTk9rUnZZM1Z0Wlc1MFNVUStlRzF3TG1ScFpEcEZRVGMyTWtZNU5qYzBPRE5GTXpFeE9UUTRRa1F4TTBVeVFrVTNPVGxCTVR3dmVHMXdUVTA2Ukc5amRXMWxiblJKUkQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRTFOT2s5eWFXZHBibUZzUkc5amRXMWxiblJKUkQ1NGJYQXVaR2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzk0YlhCTlRUcFBjbWxuYVc1aGJFUnZZM1Z0Wlc1MFNVUStDaUFnSUNBZ0lDQWdJRHg0YlhCTlRUcElhWE4wYjNKNVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9sTmxjVDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEprWmpwc2FTQnlaR1k2Y0dGeWMyVlVlWEJsUFNKU1pYTnZkWEpqWlNJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwaFkzUnBiMjQrWTNKbFlYUmxaRHd2YzNSRmRuUTZZV04wYVc5dVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmFXNXpkR0Z1WTJWSlJENTRiWEF1YVdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5emRFVjJkRHBwYm5OMFlXNWpaVWxFUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2ZDJobGJqNHlNREUwTFRBeExUSXlWREU1T2pJME9qVXhLekF4T2pBd1BDOXpkRVYyZERwM2FHVnVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQ1QlpHOWlaU0JRYUc5MGIzTm9iM0FnUTFNMklDaFhhVzVrYjNkektUd3ZjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHlaR1k2YkdrZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WVdOMGFXOXVQbk5oZG1Wa1BDOXpkRVYyZERwaFkzUnBiMjQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBwYm5OMFlXNWpaVWxFUG5odGNDNXBhV1E2UlVFMk1FRXlORVV4T1RnMFJUTXhNVUZFUVVaRlJrVTJSVU16TXpORk1ETThMM04wUlhaME9tbHVjM1JoYm1ObFNVUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcDNhR1Z1UGpJd01UUXRNREV0TWpOVU1UazZNVGc2TURjck1ERTZNREE4TDNOMFJYWjBPbmRvWlc0K0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQa0ZrYjJKbElGQm9iM1J2YzJodmNDQkRVellnS0ZkcGJtUnZkM01wUEM5emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNlkyaGhibWRsWkQ0dlBDOXpkRVYyZERwamFHRnVaMlZrUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4TDNKa1pqcHNhVDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSEprWmpwc2FTQnlaR1k2Y0dGeWMyVlVlWEJsUFNKU1pYTnZkWEpqWlNJK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwaFkzUnBiMjQrYzJGMlpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21sdWMzUmhibU5sU1VRK2VHMXdMbWxwWkRvM1pXUmhNakkwTUMweVlUUXhMVE5sTkRRdFlXTTJNeTFpTnpOaVlURTVPV0kzWTJFOEwzTjBSWFowT21sdWMzUmhibU5sU1VRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwM2FHVnVQakl3TVRRdE1ESXRNRFJVTVRRNk16ZzZOVGNyTURFNk1EQThMM04wUlhaME9uZG9aVzQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBrRmtiMkpsSUZCb2IzUnZjMmh2Y0NCRFF5QW9WMmx1Wkc5M2N5azhMM04wUlhaME9uTnZablIzWVhKbFFXZGxiblErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBqYUdGdVoyVmtQaTg4TDNOMFJYWjBPbU5vWVc1blpXUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT214cFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbXhwSUhKa1pqcHdZWEp6WlZSNWNHVTlJbEpsYzI5MWNtTmxJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbUZqZEdsdmJqNWpiMjUyWlhKMFpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25CaGNtRnRaWFJsY25NK1puSnZiU0JoY0hCc2FXTmhkR2x2Ymk5MmJtUXVZV1J2WW1VdWNHaHZkRzl6YUc5d0lIUnZJR2x0WVdkbEwzQnVaend2YzNSRmRuUTZjR0Z5WVcxbGRHVnljejRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQQzl5WkdZNmJHaytDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHlaR1k2YkdrZ2NtUm1PbkJoY25ObFZIbHdaVDBpVW1WemIzVnlZMlVpUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WVdOMGFXOXVQbVJsY21sMlpXUThMM04wUlhaME9tRmpkR2x2Ymo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25CaGNtRnRaWFJsY25NK1kyOXVkbVZ5ZEdWa0lHWnliMjBnWVhCd2JHbGpZWFJwYjI0dmRtNWtMbUZrYjJKbExuQm9iM1J2YzJodmNDQjBieUJwYldGblpTOXdibWM4TDNOMFJYWjBPbkJoY21GdFpYUmxjbk0rQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9teHBQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT214cElISmtaanB3WVhKelpWUjVjR1U5SWxKbGMyOTFjbU5sSWo0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT21GamRHbHZiajV6WVhabFpEd3ZjM1JGZG5RNllXTjBhVzl1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2psbVlqVXdNRFUwTFdFM09ERXRNV1EwT0MwNVpUbGxMVFUyWldRNVl6aGxZamRqTmp3dmMzUkZkblE2YVc1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBSWFowT25kb1pXNCtNakF4TkMwd01pMHdORlF4TkRvek9EbzFOeXN3TVRvd01Ed3ZjM1JGZG5RNmQyaGxiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbk52Wm5SM1lYSmxRV2RsYm5RK1FXUnZZbVVnVUdodmRHOXphRzl3SUVORElDaFhhVzVrYjNkektUd3ZjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbU5vWVc1blpXUStMend2YzNSRmRuUTZZMmhoYm1kbFpENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJRHd2Y21SbU9sTmxjVDRLSUNBZ0lDQWdJQ0FnUEM5NGJYQk5UVHBJYVhOMGIzSjVQZ29nSUNBZ0lDQWdJQ0E4ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjBnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBOGMzUlNaV1k2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pkbFpHRXlNalF3TFRKaE5ERXRNMlUwTkMxaFl6WXpMV0kzTTJKaE1UazVZamRqWVR3dmMzUlNaV1k2YVc1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdQSE4wVW1WbU9tUnZZM1Z0Wlc1MFNVUStlRzF3TG1ScFpEcEZRVGMyTWtZNU5qYzBPRE5GTXpFeE9UUTRRa1F4TTBVeVFrVTNPVGxCTVR3dmMzUlNaV1k2Wkc5amRXMWxiblJKUkQ0S0lDQWdJQ0FnSUNBZ0lDQWdQSE4wVW1WbU9tOXlhV2RwYm1Gc1JHOWpkVzFsYm5SSlJENTRiWEF1Wkdsa09qY3pRall5UVVGRU9URTRNMFV6TVRFNU5EaENSREV6UlRKQ1JUYzVPVUV4UEM5emRGSmxaanB2Y21sbmFXNWhiRVJ2WTNWdFpXNTBTVVErQ2lBZ0lDQWdJQ0FnSUR3dmVHMXdUVTA2UkdWeWFYWmxaRVp5YjIwK0NpQWdJQ0FnSUNBZ0lEeHdhRzkwYjNOb2IzQTZRMjlzYjNKTmIyUmxQak04TDNCb2IzUnZjMmh2Y0RwRGIyeHZjazF2WkdVK0NpQWdJQ0FnSUNBZ0lEeHdhRzkwYjNOb2IzQTZTVU5EVUhKdlptbHNaVDV6VWtkQ0lFbEZRell4T1RZMkxUSXVNVHd2Y0dodmRHOXphRzl3T2tsRFExQnliMlpwYkdVK0NpQWdJQ0FnSUNBZ0lEeDBhV1ptT2s5eWFXVnVkR0YwYVc5dVBqRThMM1JwWm1ZNlQzSnBaVzUwWVhScGIyNCtDaUFnSUNBZ0lDQWdJRHgwYVdabU9saFNaWE52YkhWMGFXOXVQamN5TURBNU1DOHhNREF3TUR3dmRHbG1aanBZVW1WemIyeDFkR2x2Ymo0S0lDQWdJQ0FnSUNBZ1BIUnBabVk2V1ZKbGMyOXNkWFJwYjI0K056SXdNRGt3THpFd01EQXdQQzkwYVdabU9sbFNaWE52YkhWMGFXOXVQZ29nSUNBZ0lDQWdJQ0E4ZEdsbVpqcFNaWE52YkhWMGFXOXVWVzVwZEQ0eVBDOTBhV1ptT2xKbGMyOXNkWFJwYjI1VmJtbDBQZ29nSUNBZ0lDQWdJQ0E4WlhocFpqcERiMnh2Y2xOd1lXTmxQakU4TDJWNGFXWTZRMjlzYjNKVGNHRmpaVDRLSUNBZ0lDQWdJQ0FnUEdWNGFXWTZVR2w0Wld4WVJHbHRaVzV6YVc5dVBqSTBQQzlsZUdsbU9sQnBlR1ZzV0VScGJXVnVjMmx2Ymo0S0lDQWdJQ0FnSUNBZ1BHVjRhV1k2VUdsNFpXeFpSR2x0Wlc1emFXOXVQakkwUEM5bGVHbG1PbEJwZUdWc1dVUnBiV1Z1YzJsdmJqNEtJQ0FnSUNBZ1BDOXlaR1k2UkdWelkzSnBjSFJwYjI0K0NpQWdJRHd2Y21SbU9sSkVSajRLUEM5NE9uaHRjRzFsZEdFK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2p3L2VIQmhZMnRsZENCbGJtUTlJbmNpUHo0dWJ4cytBQUFBSUdOSVVrMEFBSG9sQUFDQWd3QUErZjhBQUlEcEFBQjFNQUFBNm1BQUFEcVlBQUFYYjVKZnhVWUFBQVV0U1VSQlZIamFqSlovYk5UMUdjZGZ6L1A1M1BWNkI0VzdWbHRMcWRBYXBsSU9pTU9veXh4SkNTcy9Hdi95QjRnekpyb0Fvc21tRGtsd2tZV1IwYlFzZG1reWtvb2pUcGNzV1lMeEQvbFJaZE1Ra1RIUnRrTFpScUcwdElWZTc2NjJ2VHU0M24zMngvVktaL2poODljbjM4L3p2TjdQNS9sODh6d2YyYmx6Sno2ZkR3QVJRVVNtMW44czMxQ00wL1ZBbmJObXNVUHVBc0RwZ0VPK0JnNEM3Ly9peXY1aHZtTWlRaXFWUXBxYW12QjZ2Vk53RWVHMUpadENCcllpL01ya0F3RE5namh3QWxieklDQkxBMHJEYjArLzgzOUM2WFFhYVd4c3BMQ3c4RHA4NmNiTm1xVkZKUWRkRTZLemRqWjlEODlnK0I2ZlN5Q09jeW4xbnhpbCtPOXhLZzVIcVdGU0hHWExqclA3Vy9JQ3FWUUsyYk5uRHo2ZkR4Rmg2NUtOdnhiSERoRjRySmoyYlhQbytJR2ZjVzVoNXhMNGY5OVArRkNFTUlBb2I3NXg5dDBkQU1sa0VsTlhWNGUxbHRlWGJOcWlRb01hZU9GT2pyZFU4NjhTRDJsdVl5RVA2ZFVoK3NZbVNIZU9VNkdPNVo4Vkx4NStOTlp4SXBQSjVBUzJMM3VwUk9Db0N2ejhMbzd2bmtmNzdjQUhocGl6L3pJTDl2V3o4TDhwL052dXBtTTBRN3BqbkFvTHF6OHREcmM4TW5RcVlWVVZoVmRGNExFZzdiK3J2RG44d0REbEgwV29QcHVrTEpJbVNCYU13amNKcW13V3RzMmpQWkxHLzhrd1lWRmVWZFhYWmNGZjR5VkRjMmNOS2ZCRm1EOVgrMG5jQ1A1OEY0OGVHK0ZlbzJDQVVrdnM0ZGwwVi91SnZkWExpaVYrdXQrK243WUxTZnhQZk1NRzU0Q2h6QjNXSWVzVldCMmk4MmJ3MUFSNmZKUjdDNFZzZllpdjZ1L2szQTluRWdQNHpYa2U4RGlZSHlBT01LK1F4UElnblo5R3FTSHIxaXRRSjhESzJmVGVyRFErUy9iSFJYUUphSFNDd05JWjJYaCs3K1MzVkFtd05NQkEvdHVQWnRFcmdLcXVVbWRNV0lGbFJVUnZkYW1STkVYR3dJV3JsUDQ3cFRNekxpdW54Z2hHTXdUTHZjVFdsSEFwNzdzNFFOU3JZTVF0c3M2Wk1nV3FDbTVjSG9ESE8xbmJrNks4ekVOOCszemF0djJIbjFiNTlFcUpaZHhtWVVFUmc5UDlLd3BJaUFPVGRXVVdCWHVMekIvdlpHM1AxVW40UE5wMmQxTWJteUQ0NVRXQ3h1Q3NRbTB4NTZiSEdIRllFWnd4b2s3dG9BQTlTZnczaENjb0wvTk93aTlRTzV3bVdPMWo0SkVnWnhUa29kbWNXUkdrZjNwY1gwcjh4b0FhQml4S3U0VTUveHduZE0rMHRwQXZTNm1QK1BaSzJuYjFVQnZQRUt3S01MRHZQajRFU0djNTVsR3kzMDNzZEpLUWRaQjJya01kY3RBQi80Z3pOKy9RMkVOTmQ0THlVaS94TitiVHRxdVgydGhrNW5rNHdJM2dBRitPTU5jQTFuRlFEZksrQlk1R3Fia3dXYWJUWTVRWmhYV2xuTngxbnRyWTFSejg3ZnV2dzI5bS9TbjhKK1BVR0FGajVUMTliYUExSXNwdUJacDdjeDF4NFN3RzFjRWYrbGdSU1JPczhqR3diK0h0NFFCL0dTU3NBaFlhbm8zOUxXSUJ4TkVJYlAxNGhQRHVpeVMyVnRKdUhYUWxLS3Z4TS9qaVhEcS9EL3hQbHdpZkdNa0paQjJOSW9LcHI2OW54ZWlaeExIaWNGU0ZWV2ZHcUJpZElQM0xTanJXbHREOTRDeXVmRi80a1FnUHVWejJMejkzK2REUmE5ZXU1UVE4SGc4L2lYZWUrRHk0Q0tNczd4cW40bndLejlJaXJoUXFtVnVCNDJtOGV5K3g3TE1vRDZpQU9ONzgyZUNoaHFtUnVYZnZYZ0tCQUtxS3F0STAvOG5OS3JRSTRCVllYa3pIZ3pQcEM4OGdXdUhML2NhWHJoTG9HaU4wYXBTS3IwWlpSQlpNN3EydzVabkxSMW9BbkhPTWpZMGhyYTJ0RkJRVVlJeVptc3R2VlQxWjZlRGxBdUVWcTdtZXJ4bXd1ZU5QRFh5OVB2eWJqS1A1bWN0SExrNC9YVEtaUkpxYm0vSDcvVk53MVZ5RU1ZYlc0Rk4zV05Xbm5jaEtveTVzSGVWR0JSWDZWV2kzeW1GeDdyMTFJeDhNVFgveTVDMlJTUEMvQVFCNjFlcm93YnBxU3dBQUFBQkpSVTVFcmtKZ2dnPT0nKTtcXG59XFxuXFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIGJ1dHRvbi52aXMtYnV0dG9uLnZpcy1kZWxldGUge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJnQUFBQVlDQVlBQUFEZ2R6MzRBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBRUVPYVZSWWRGaE5URHBqYjIwdVlXUnZZbVV1ZUcxd0FBQUFBQUE4UDNod1lXTnJaWFFnWW1WbmFXNDlJdSs3dnlJZ2FXUTlJbGMxVFRCTmNFTmxhR2xJZW5KbFUzcE9WR042YTJNNVpDSS9QZ284ZURwNGJYQnRaWFJoSUhodGJHNXpPbmc5SW1Ga2IySmxPbTV6T20xbGRHRXZJaUI0T25odGNIUnJQU0pCWkc5aVpTQllUVkFnUTI5eVpTQTFMalV0WXpBeU1TQTNPUzR4TlRRNU1URXNJREl3TVRNdk1UQXZNamt0TVRFNk5EYzZNVFlnSUNBZ0lDQWdJQ0krQ2lBZ0lEeHlaR1k2VWtSR0lIaHRiRzV6T25Ka1pqMGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNVGs1T1M4d01pOHlNaTF5WkdZdGMzbHVkR0Y0TFc1ekl5SStDaUFnSUNBZ0lEeHlaR1k2UkdWelkzSnBjSFJwYjI0Z2NtUm1PbUZpYjNWMFBTSWlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbmh0Y0QwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0x5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZaR005SW1oMGRIQTZMeTl3ZFhKc0xtOXlaeTlrWXk5bGJHVnRaVzUwY3k4eExqRXZJZ29nSUNBZ0lDQWdJQ0FnSUNCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmMzUkZkblE5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVVYyWlc1MEl5SUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlDaUFnSUNBZ0lDQWdJQ0FnSUhodGJHNXpPbkJvYjNSdmMyaHZjRDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5d2FHOTBiM05vYjNBdk1TNHdMeUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02ZEdsbVpqMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzkwYVdabUx6RXVNQzhpQ2lBZ0lDQWdJQ0FnSUNBZ0lIaHRiRzV6T21WNGFXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2WlhocFppOHhMakF2SWo0S0lDQWdJQ0FnSUNBZ1BIaHRjRHBEY21WaGRHOXlWRzl2YkQ1QlpHOWlaU0JRYUc5MGIzTm9iM0FnUTBNZ0tGZHBibVJ2ZDNNcFBDOTRiWEE2UTNKbFlYUnZjbFJ2YjJ3K0NpQWdJQ0FnSUNBZ0lEeDRiWEE2UTNKbFlYUmxSR0YwWlQ0eU1ERTBMVEF4TFRJeVZERTVPakkwT2pVeEt6QXhPakF3UEM5NGJYQTZRM0psWVhSbFJHRjBaVDRLSUNBZ0lDQWdJQ0FnUEhodGNEcE5aWFJoWkdGMFlVUmhkR1UrTWpBeE5DMHdNaTB3TkZReE5EbzBNVG93TkNzd01Ub3dNRHd2ZUcxd09rMWxkR0ZrWVhSaFJHRjBaVDRLSUNBZ0lDQWdJQ0FnUEhodGNEcE5iMlJwWm5sRVlYUmxQakl3TVRRdE1ESXRNRFJVTVRRNk5ERTZNRFFyTURFNk1EQThMM2h0Y0RwTmIyUnBabmxFWVhSbFBnb2dJQ0FnSUNBZ0lDQThaR002Wm05eWJXRjBQbWx0WVdkbEwzQnVaend2WkdNNlptOXliV0YwUGdvZ0lDQWdJQ0FnSUNBOGVHMXdUVTA2U1c1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pjM05Ea3pZbVV4TFRFeVpHSXRPVGcwTkMxaU5EWXlMVGcyTkdWbU5HSXpNek0zTVR3dmVHMXdUVTA2U1c1emRHRnVZMlZKUkQ0S0lDQWdJQ0FnSUNBZ1BIaHRjRTFOT2tSdlkzVnRaVzUwU1VRK2VHMXdMbVJwWkRwRlFUYzJNa1k1TmpjME9ETkZNekV4T1RRNFFrUXhNMFV5UWtVM09UbEJNVHd2ZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDRLSUNBZ0lDQWdJQ0FnUEhodGNFMU5Pazl5YVdkcGJtRnNSRzlqZFcxbGJuUkpSRDU0YlhBdVpHbGtPamN6UWpZeVFVRkVPVEU0TTBVek1URTVORGhDUkRFelJUSkNSVGM1T1VFeFBDOTRiWEJOVFRwUGNtbG5hVzVoYkVSdlkzVnRaVzUwU1VRK0NpQWdJQ0FnSUNBZ0lEeDRiWEJOVFRwSWFYTjBiM0o1UGdvZ0lDQWdJQ0FnSUNBZ0lDQThjbVJtT2xObGNUNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BISmtaanBzYVNCeVpHWTZjR0Z5YzJWVWVYQmxQU0pTWlhOdmRYSmpaU0krQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBoWTNScGIyNCtZM0psWVhSbFpEd3ZjM1JGZG5RNllXTjBhVzl1UGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2YVc1emRHRnVZMlZKUkQ1NGJYQXVhV2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzl6ZEVWMmREcHBibk4wWVc1alpVbEVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZkMmhsYmo0eU1ERTBMVEF4TFRJeVZERTVPakkwT2pVeEt6QXhPakF3UEM5emRFVjJkRHAzYUdWdVBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQThjM1JGZG5RNmMyOW1kSGRoY21WQloyVnVkRDVCWkc5aVpTQlFhRzkwYjNOb2IzQWdRMU0ySUNoWGFXNWtiM2R6S1R3dmMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4eVpHWTZiR2tnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZV04wYVc5dVBuTmhkbVZrUEM5emRFVjJkRHBoWTNScGIyNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHBibk4wWVc1alpVbEVQbmh0Y0M1cGFXUTZSVUUyTUVFeU5FVXhPVGcwUlRNeE1VRkVRVVpGUmtVMlJVTXpNek5GTURNOEwzTjBSWFowT21sdWMzUmhibU5sU1VRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lEeHpkRVYyZERwM2FHVnVQakl3TVRRdE1ERXRNak5VTVRrNk1UZzZNRGNyTURFNk1EQThMM04wUlhaME9uZG9aVzQrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHB6YjJaMGQyRnlaVUZuWlc1MFBrRmtiMkpsSUZCb2IzUnZjMmh2Y0NCRFV6WWdLRmRwYm1SdmQzTXBQQzl6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGMzUkZkblE2WTJoaGJtZGxaRDR2UEM5emRFVjJkRHBqYUdGdVoyVmtQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQThMM0prWmpwc2FUNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BISmtaanBzYVNCeVpHWTZjR0Z5YzJWVWVYQmxQU0pTWlhOdmRYSmpaU0krQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHBoWTNScGIyNCtjMkYyWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbWx1YzNSaGJtTmxTVVErZUcxd0xtbHBaRG93Tm1FM05XWXdNeTA0TURkaExXVXpOR1l0WWprMVppMWpaR1UyTWpNME16ZzRPR1k4TDNOMFJYWjBPbWx1YzNSaGJtTmxTVVErQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4emRFVjJkRHAzYUdWdVBqSXdNVFF0TURJdE1EUlVNVFE2TkRFNk1EUXJNREU2TURBOEwzTjBSWFowT25kb1pXNCtDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcHpiMlowZDJGeVpVRm5aVzUwUGtGa2IySmxJRkJvYjNSdmMyaHZjQ0JEUXlBb1YybHVaRzkzY3lrOEwzTjBSWFowT25OdlpuUjNZWEpsUVdkbGJuUStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZEVWMmREcGphR0Z1WjJWa1BpODhMM04wUlhaME9tTm9ZVzVuWldRK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dmNtUm1PbXhwUGdvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4Y21SbU9teHBJSEprWmpwd1lYSnpaVlI1Y0dVOUlsSmxjMjkxY21ObElqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tRmpkR2x2Ymo1amIyNTJaWEowWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbkJoY21GdFpYUmxjbk0rWm5KdmJTQmhjSEJzYVdOaGRHbHZiaTkyYm1RdVlXUnZZbVV1Y0dodmRHOXphRzl3SUhSdklHbHRZV2RsTDNCdVp6d3ZjM1JGZG5RNmNHRnlZVzFsZEdWeWN6NEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1BDOXlaR1k2YkdrK0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUR4eVpHWTZiR2tnY21SbU9uQmhjbk5sVkhsd1pUMGlVbVZ6YjNWeVkyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZZV04wYVc5dVBtUmxjbWwyWldROEwzTjBSWFowT21GamRHbHZiajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbkJoY21GdFpYUmxjbk0rWTI5dWRtVnlkR1ZrSUdaeWIyMGdZWEJ3YkdsallYUnBiMjR2ZG01a0xtRmtiMkpsTG5Cb2IzUnZjMmh2Y0NCMGJ5QnBiV0ZuWlM5d2JtYzhMM04wUlhaME9uQmhjbUZ0WlhSbGNuTStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT214cFBnb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNtUm1PbXhwSUhKa1pqcHdZWEp6WlZSNWNHVTlJbEpsYzI5MWNtTmxJajRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbUZqZEdsdmJqNXpZWFpsWkR3dmMzUkZkblE2WVdOMGFXOXVQZ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0E4YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPamMzTkRrelltVXhMVEV5WkdJdE9UZzBOQzFpTkRZeUxUZzJOR1ZtTkdJek16TTNNVHd2YzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhOMFJYWjBPbmRvWlc0K01qQXhOQzB3TWkwd05GUXhORG8wTVRvd05Dc3dNVG93TUR3dmMzUkZkblE2ZDJobGJqNEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9uTnZablIzWVhKbFFXZGxiblErUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESUNoWGFXNWtiM2R6S1R3dmMzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWRENEtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdQSE4wUlhaME9tTm9ZVzVuWldRK0x6d3ZjM1JGZG5RNlkyaGhibWRsWkQ0S0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnUEM5eVpHWTZiR2srQ2lBZ0lDQWdJQ0FnSUNBZ0lEd3ZjbVJtT2xObGNUNEtJQ0FnSUNBZ0lDQWdQQzk0YlhCTlRUcElhWE4wYjNKNVBnb2dJQ0FnSUNBZ0lDQThlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMGdjbVJtT25CaGNuTmxWSGx3WlQwaVVtVnpiM1Z5WTJVaVBnb2dJQ0FnSUNBZ0lDQWdJQ0E4YzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDU0YlhBdWFXbGtPakEyWVRjMVpqQXpMVGd3TjJFdFpUTTBaaTFpT1RWbUxXTmtaVFl5TXpRek9EZzRaand2YzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ1BITjBVbVZtT21SdlkzVnRaVzUwU1VRK2VHMXdMbVJwWkRwRlFUYzJNa1k1TmpjME9ETkZNekV4T1RRNFFrUXhNMFV5UWtVM09UbEJNVHd2YzNSU1pXWTZaRzlqZFcxbGJuUkpSRDRLSUNBZ0lDQWdJQ0FnSUNBZ1BITjBVbVZtT205eWFXZHBibUZzUkc5amRXMWxiblJKUkQ1NGJYQXVaR2xrT2pjelFqWXlRVUZFT1RFNE0wVXpNVEU1TkRoQ1JERXpSVEpDUlRjNU9VRXhQQzl6ZEZKbFpqcHZjbWxuYVc1aGJFUnZZM1Z0Wlc1MFNVUStDaUFnSUNBZ0lDQWdJRHd2ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjArQ2lBZ0lDQWdJQ0FnSUR4d2FHOTBiM05vYjNBNlEyOXNiM0pOYjJSbFBqTThMM0JvYjNSdmMyaHZjRHBEYjJ4dmNrMXZaR1UrQ2lBZ0lDQWdJQ0FnSUR4d2FHOTBiM05vYjNBNlNVTkRVSEp2Wm1sc1pUNXpVa2RDSUVsRlF6WXhPVFkyTFRJdU1Ud3ZjR2h2ZEc5emFHOXdPa2xEUTFCeWIyWnBiR1UrQ2lBZ0lDQWdJQ0FnSUR4MGFXWm1Pazl5YVdWdWRHRjBhVzl1UGpFOEwzUnBabVk2VDNKcFpXNTBZWFJwYjI0K0NpQWdJQ0FnSUNBZ0lEeDBhV1ptT2xoU1pYTnZiSFYwYVc5dVBqY3lNREE1TUM4eE1EQXdNRHd2ZEdsbVpqcFlVbVZ6YjJ4MWRHbHZiajRLSUNBZ0lDQWdJQ0FnUEhScFptWTZXVkpsYzI5c2RYUnBiMjQrTnpJd01Ea3dMekV3TURBd1BDOTBhV1ptT2xsU1pYTnZiSFYwYVc5dVBnb2dJQ0FnSUNBZ0lDQThkR2xtWmpwU1pYTnZiSFYwYVc5dVZXNXBkRDR5UEM5MGFXWm1PbEpsYzI5c2RYUnBiMjVWYm1sMFBnb2dJQ0FnSUNBZ0lDQThaWGhwWmpwRGIyeHZjbE53WVdObFBqRThMMlY0YVdZNlEyOXNiM0pUY0dGalpUNEtJQ0FnSUNBZ0lDQWdQR1Y0YVdZNlVHbDRaV3hZUkdsdFpXNXphVzl1UGpJMFBDOWxlR2xtT2xCcGVHVnNXRVJwYldWdWMybHZiajRLSUNBZ0lDQWdJQ0FnUEdWNGFXWTZVR2w0Wld4WlJHbHRaVzV6YVc5dVBqSTBQQzlsZUdsbU9sQnBlR1ZzV1VScGJXVnVjMmx2Ymo0S0lDQWdJQ0FnUEM5eVpHWTZSR1Z6WTNKcGNIUnBiMjQrQ2lBZ0lEd3ZjbVJtT2xKRVJqNEtQQzk0T25odGNHMWxkR0UrQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDancvZUhCaFkydGxkQ0JsYm1ROUluY2lQejRhWUp6WUFBQUFJR05JVWswQUFIb2xBQUNBZ3dBQStmOEFBSURwQUFCMU1BQUE2bUFBQURxWUFBQVhiNUpmeFVZQUFBWUdTVVJCVkhqYWxKWjdVSlRuRmNaLzczbS83MlBkSlkxUmJob1FwNmxrWFJBdm1JWXhkQ1VhZExWT296UE50R09iYXAxSnNLaXBqaVNoYmRvUmJlS0VpUUhwUUszeGoweGEwM2FhbVRiYVRHeUFZVjFRR2VxRmkrSnlpWkZMQWxtRVNCa1dSbVMzZnl6c2xHa21uWjUvdi9NODczT2U3NXp6dnFxb3FBaWJ6UWFBaUtDVUFrQXBSZEhJSy9ORnN4Mk5SOTFuT1NJTEFERG9KeXpOYU00eHhidHZQSGgwaUMrSmlZa0oxT0hEaDRtSmlVRXBGU1hQdi96aVBDMjhUSWlYRENPU3JBQ2xRRFNFcHNDd0pQSWhyRUJSUXBpU3l0WGxRd0RoY0JpbEZQZnUzVU1WRnhkanQ5dWpGVHpmY0xCQURDb0VFQUZyMVpicnJOamNoMnZ0RUltUEJnSG9iN2ZUY1dFK2JWWEpOSi9OaUZRbEVHTHZpZVhIS21ZcUdCOGZSeDA1Y2dTYnpZYUlzUHZ5d1Y4cEtGYUE3Zkd0TFR6ejYxWVdwby94VlRIUWJ1ZnNxNWxjZXo5eld1V2hrNW12RndNRWcwSDArdlhyTVUyVG4xd3AzQ3RDaVE1RGpHZDNBL20vdjhJRENaUDhyNGlObXlScld4L2ovNXFrdHlrWnBYS3pBalZEVnhQekdxZW1wdERyMXExalgzTlJuSUphcmNES0syaGdSMlVMWFJmbmN2N1VZdjd4cG92aG5oaVc1TXora2VmZVNLTzZMSjFBMXh6RXVrL09qbTRtUmlicHVaYU1aVzNPQ3RSVU5ENjBObWlJQ0NJVVNoaXN4N2Eyc0xNaVFuNHM3N3VFUWdJYWJucWRmSElsZ1QxL3FRZWc4dnM1ZEhoZENOQjF3WW4zUklpQzk5NWoyNnN0akFic05IK1lpWkpDRVNuUzFZL1h4SVh1OHI0WUlQdi9Wa1ZzM0NUblR5Mm1zMzR4cm8xK3NwOXBvNnN4bFR1MzR1bHRtc1BWdnk2aXM4NkZDSGdPK0REczQ5enBqdWZCcENHK3NlWU9DOU9IYVRpZGllaWNiOW91VkFoS3RvdUFzZUk3MTBtYTdwTHVxd21nWWZIcUFGdCs2V2RMb1EvTEJsMTFMbTdWdWRBYTh2YjcyUENpbjlUbEFXSXNHR2hMQUNEK2tTQVpudXNZQmlpMVhRQVBZV0RsbHQ2b3YybHJCa0RCUjIrNk9mdWFrMi8vM00rRy9UNHdBQVBXN2ZQaEtmUlRWZXFrOXFRYkZLUm1EVVR4UzNON1FZR1ltd3pDa3FrbEJHbFBERWNUTnYrc2c5dE5DYlRYdXZCV3VqRTBiSHJaajlKRTFCL3dVMVBtNVB3Sk42WUJTOWEya1Z2UUVjV25yaDVHVEZEM2x4a1lrcVJNZ1lRbHdWbGRVdkRuZW43M0xIVFV1cWl0ZEtNMGVBcjlBRlFmZDFKL3lvMmFKbisyc240V2RuNXFFRk9ESnNrZ0JJang1VDB1Q3JRQTA4cG5JalM5UEVSRGpQbmZPS1hBTUVCRUNVb0dFSUhCaisyemt0NzZVUTZkWGhlR0FldjMrY2c3NEtmNnVKUHFjaWNiZnVvbmQ3Y1B5NFNPaXk3K3REOW5Gdlp1cngwMEtPazNDTkVDK21FK3ZqU1BCYzdJV3FncVRhUFQ2MElNY08veHNYR2EzSGZLalJnUmRibDcvS0RnMGp0dWJqZTZhSGo3YzdKM2RnTFEyem9Qd3dROTFTb29PUWRBVzFWS1ZNSHR5MGtBNUJiNDhCeWNKbi9MaldGR2JMdjR0aHZ2YjUza0Z2akorWEVkV2tQZmpRVlIvQ2NOS1lnR01jOEpXdDVGYTJqK01JUFB1eUkycGE0SW9IU2t0NnZMSXVSYVE5cTMya2h6dDRHQ3h0TnU2azQ2R2VpSVIybElmRFFRc2FmUHpxMUxHUkdMOUdrOWQrdnJ3ZXd2ZkhQUU9vZXhRVmp4ZEIvYXVrL3ptYVVNZHNmejZiVlV0SWFsVDdieHZlUDFaSGg2R1BEUFllU3plRDY5a2NwSWZ4eW1GV0xOcmthK2xqaEJUV2tXd3oySmlKVDg0WUhuejJpUHgwUDIwUGttUkY1aTZIWWl3WkZKc24vWXpkZXpiekUzY1FpYlk1eFYyNjZ6NlJmWG9oYWtiK3hCOUNqYW5DRDlxVGJXN0dyazRXVjM4VlptMGw2ZGhRaUV3OXRhSFN1RHFyUzBGSWZEd1hNM1g5bUhNc3ZSQWsvc2F1RHBReTM4UCtHdHpPVEdCOW1FcGtEMEMyZFM4bjh6T2pxSzluZzhXSlpGVStKVGphc0d2YUNOWFBwdkpCUG9NbG0wT29ETk1mV1Z4T05mV05TVVBVWjdUVVE1NnRDWmxQd1NnTW5KU1ZScGFTbXhzYkZFMXJhdzgyWnhBWlpSUVVpQllVS0dwNVVsT1gya3JCem1vVVZqaUlLaEhnZTlyZlBvK1djeTNaZVhJWUFTZ0wxL1g1UmZNWE12ajQ2T29zckx5N0haYkdpdFVVb2hJdXpvZW0wUm9mQUxhT3NnaGdXR2preTBNaUpUTDhiMGxPdkk4aE4xREtYS1AwamQzVE5UV0RnY0poZ01vbzRlUFlyRDRZaStLbWFlTGxwcm5ydFhGbzloL0FBbEcxQXFFOHlGbUJyQytqTzBiZ0g5RVZwTy8xRjJEYzVnLy9PQXNiRXgvajBBZitVU3NReW5MMVVBQUFBQVNVVk9SSzVDWUlJPScpO1xcbn1cXG4vKiB0b3AgcmlnaHQgYm90dG9tIGxlZnQgKi9cXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1tYW5pcHVsYXRpb24gZGl2LnZpcy1sYWJlbCxcXG5kaXYudmlzLW5ldHdvcmsgZGl2LnZpcy1lZGl0LW1vZGUgZGl2LnZpcy1sYWJlbCB7XFxuICBtYXJnaW46IDAgMCAwIDIzcHg7XFxuICBsaW5lLWhlaWdodDogMjVweDtcXG59XFxuZGl2LnZpcy1uZXR3b3JrIGRpdi52aXMtbWFuaXB1bGF0aW9uIGRpdi52aXMtc2VwYXJhdG9yLWxpbmUge1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB3aWR0aDogMXB4O1xcbiAgaGVpZ2h0OiAyMXB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2JkYmRiZDtcXG4gIG1hcmdpbjogMHB4IDdweCAwIDE1cHg7IC8qdG9wIHJpZ2h0IGJvdHRvbSBsZWZ0Ki9cXG59XFxuXFxuLyogVE9ETzogaXMgdGhpcyByZWR1bmRhbnQ/XFxuZGl2Lm5ldHdvcmstbmF2aWdhdGlvbl93cmFwcGVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuKi9cXG5cIjtcbnN0eWxlSW5qZWN0KGNzc18yNDh6KTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIHN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnZXRJdGVyYXRvck1ldGhvZCQxKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChpc0FycmF5JDIobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQzMjsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gc2xpY2UoX2NvbnRleHQzMiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDMyLCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tJDMobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbi8qKlxuICogQ2xlYXJzIHRoZSB0b29sYmFyIGRpdiBlbGVtZW50IG9mIGNoaWxkcmVuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgTWFuaXB1bGF0aW9uU3lzdGVtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICogQHBhcmFtIHtTZWxlY3Rpb25IYW5kbGVyfSBzZWxlY3Rpb25IYW5kbGVyXG4gICAqIEBwYXJhbSB7SW50ZXJhY3Rpb25IYW5kbGVyfSBpbnRlcmFjdGlvbkhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIE1hbmlwdWxhdGlvblN5c3RlbShib2R5LCBjYW52YXMsIHNlbGVjdGlvbkhhbmRsZXIsIGludGVyYWN0aW9uSGFuZGxlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIF9jb250ZXh0LFxuICAgICAgICBfY29udGV4dDI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFuaXB1bGF0aW9uU3lzdGVtKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyID0gc2VsZWN0aW9uSGFuZGxlcjtcbiAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlciA9IGludGVyYWN0aW9uSGFuZGxlcjtcbiAgICB0aGlzLmVkaXRNb2RlID0gZmFsc2U7XG4gICAgdGhpcy5tYW5pcHVsYXRpb25EaXYgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lZGl0TW9kZURpdiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNsb3NlRGl2ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RvbUV2ZW50TGlzdGVuZXJDbGVhbnVwUXVldWUgPSBbXTtcbiAgICB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zID0ge307XG4gICAgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucyA9IFtdO1xuICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICB0aGlzLnRlbXBvcmFyeUlkcyA9IHtcbiAgICAgIG5vZGVzOiBbXSxcbiAgICAgIGVkZ2VzOiBbXVxuICAgIH07XG4gICAgdGhpcy5ndWlFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5pbk1vZGUgPSBmYWxzZTtcbiAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgaW5pdGlhbGx5QWN0aXZlOiBmYWxzZSxcbiAgICAgIGFkZE5vZGU6IHRydWUsXG4gICAgICBhZGRFZGdlOiB0cnVlLFxuICAgICAgZWRpdE5vZGU6IHVuZGVmaW5lZCxcbiAgICAgIGVkaXRFZGdlOiB0cnVlLFxuICAgICAgZGVsZXRlTm9kZTogdHJ1ZSxcbiAgICAgIGRlbGV0ZUVkZ2U6IHRydWUsXG4gICAgICBjb250cm9sTm9kZVN0eWxlOiB7XG4gICAgICAgIHNoYXBlOiBcImRvdFwiLFxuICAgICAgICBzaXplOiA2LFxuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IFwiI2ZmMDAwMFwiLFxuICAgICAgICAgIGJvcmRlcjogXCIjM2MzYzNjXCIsXG4gICAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiMwN2Y5NjhcIixcbiAgICAgICAgICAgIGJvcmRlcjogXCIjM2MzYzNjXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJvcmRlcldpZHRoOiAyLFxuICAgICAgICBib3JkZXJXaWR0aFNlbGVjdGVkOiAyXG4gICAgICB9XG4gICAgfTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX2NsZWFuKCk7XG4gICAgfSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwgYmluZCQ2KF9jb250ZXh0ID0gdGhpcy5fcmVzdG9yZSkuY2FsbChfY29udGV4dCwgdGhpcykpO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3Jlc2V0RGF0YVwiLCBiaW5kJDYoX2NvbnRleHQyID0gdGhpcy5fcmVzdG9yZSkuY2FsbChfY29udGV4dDIsIHRoaXMpKTtcbiAgfVxuICAvKipcbiAgICogSWYgc29tZXRoaW5nIGNoYW5nZXMgaW4gdGhlIGRhdGEgZHVyaW5nIGVkaXRpbmcsIHN3aXRjaCBiYWNrIHRvIHRoZSBpbml0aWFsIGRhdGFtYW5pcHVsYXRpb24gc3RhdGUgYW5kIGNsb3NlIGFsbCBlZGl0IG1vZGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhNYW5pcHVsYXRpb25TeXN0ZW0sIFt7XG4gICAga2V5OiBcIl9yZXN0b3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN0b3JlKCkge1xuICAgICAgaWYgKHRoaXMuaW5Nb2RlICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmluaXRpYWxseUFjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgT3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYWxsT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxPcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgYWxsT3B0aW9ucywgZ2xvYmFsT3B0aW9ucykge1xuICAgICAgaWYgKGFsbE9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYWxsT3B0aW9ucy5sb2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGUgPSBhbGxPcHRpb25zLmxvY2FsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlID0gZ2xvYmFsT3B0aW9ucy5sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWxsT3B0aW9ucy5sb2NhbGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlcyA9IGFsbE9wdGlvbnMubG9jYWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlcyA9IGdsb2JhbE9wdGlvbnMubG9jYWxlcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IG9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIGRlZXBFeHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5pdGlhbGx5QWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lZGl0TW9kZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXR1cCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBlZGl0LW1vZGUuIERyYXdzIHRoZSBET00gcmVxdWlyZWQgYW5kIGNsZWFucyB1cCBhZnRlciBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlRWRpdE1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlRWRpdE1vZGUoKSB7XG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIEVkaXQgTW9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlRWRpdE1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgRWRpdCBNb2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlRWRpdE1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgICAgdGhpcy5lZGl0TW9kZSA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblxuICAgICAgICB0aGlzLl9jcmVhdGVFZGl0QnV0dG9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG1haW4gdG9vbGJhci4gUmVtb3ZlcyBmdW5jdGlvbnMgYm91bmQgdG8gdGhlIHNlbGVjdCBldmVudC4gQmluZHMgYWxsIHRoZSBidXR0b25zIG9mIHRoZSB0b29sYmFyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNob3dNYW5pcHVsYXRvclRvb2xiYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpIHtcbiAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICB0aGlzLl9jbGVhbigpOyAvLyByZXNldCBnbG9iYWwgdmFyaWFibGVzXG5cblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTsgLy8gaWYgdGhlIGd1aSBpcyBlbmFibGVkLCBkcmF3IGFsbCBlbGVtZW50cy5cblxuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgX2NvbnRleHQzLCBfY29udGV4dDQ7XG5cbiAgICAgICAgLy8gYSBfcmVzdG9yZSB3aWxsIGhpZGUgdGhlc2UgbWVudXNcbiAgICAgICAgdGhpcy5lZGl0TW9kZSA9IHRydWU7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdmFyIHNlbGVjdGVkTm9kZUNvdW50ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZUNvdW50KCk7XG4gICAgICAgIHZhciBzZWxlY3RlZEVkZ2VDb3VudCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VDb3VudCgpO1xuICAgICAgICB2YXIgc2VsZWN0ZWRUb3RhbENvdW50ID0gc2VsZWN0ZWROb2RlQ291bnQgKyBzZWxlY3RlZEVkZ2VDb3VudDtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICB2YXIgbmVlZFNlcGVyYXRvciA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkTm9kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVBZGROb2RlQnV0dG9uKGxvY2FsZSk7XG5cbiAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkRWRnZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9jcmVhdGVBZGRFZGdlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZWN0ZWROb2RlQ291bnQgPT09IDEgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5lZGl0Tm9kZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmVlZFNlcGVyYXRvciA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fY3JlYXRlRWRpdE5vZGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZEVkZ2VDb3VudCA9PT0gMSAmJiBzZWxlY3RlZE5vZGVDb3VudCA9PT0gMCAmJiB0aGlzLm9wdGlvbnMuZWRpdEVkZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmVlZFNlcGVyYXRvciA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fY3JlYXRlRWRpdEVkZ2VCdXR0b24obG9jYWxlKTtcbiAgICAgICAgfSAvLyByZW1vdmUgYnV0dG9uc1xuXG5cbiAgICAgICAgaWYgKHNlbGVjdGVkVG90YWxDb3VudCAhPT0gMCkge1xuICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGVDb3VudCA+IDAgJiYgdGhpcy5vcHRpb25zLmRlbGV0ZU5vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoNCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZURlbGV0ZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWROb2RlQ291bnQgPT09IDAgJiYgdGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoNCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZURlbGV0ZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBiaW5kIHRoZSBjbG9zZSBidXR0b25cblxuXG4gICAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKHRoaXMuY2xvc2VEaXYsIGJpbmQkNihfY29udGV4dDMgPSB0aGlzLnRvZ2dsZUVkaXRNb2RlKS5jYWxsKF9jb250ZXh0MywgdGhpcykpOyAvLyByZWZyZXNoIHRoaXMgYmFyIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gc2VsZWN0ZWRcblxuXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRFdmVudChcInNlbGVjdFwiLCBiaW5kJDYoX2NvbnRleHQ0ID0gdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKS5jYWxsKF9jb250ZXh0NCwgdGhpcykpO1xuICAgICAgfSAvLyByZWRyYXcgdG8gc2hvdyBhbnkgcG9zc2libGUgY2hhbmdlc1xuXG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIHRvb2xiYXIgZm9yIGFkZGluZyBOb2Rlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTm9kZU1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTm9kZU1vZGUoKSB7XG4gICAgICB2YXIgX2NvbnRleHQ2O1xuXG4gICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH0gLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcblxuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICB0aGlzLmluTW9kZSA9IFwiYWRkTm9kZVwiO1xuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDU7XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoKTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVEZXNjcmlwdGlvbihsb2NhbGVbXCJhZGREZXNjcmlwdGlvblwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiYWRkRGVzY3JpcHRpb25cIl0pOyAvLyBiaW5kIHRoZSBjbG9zZSBidXR0b25cblxuXG4gICAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKHRoaXMuY2xvc2VEaXYsIGJpbmQkNihfY29udGV4dDUgPSB0aGlzLnRvZ2dsZUVkaXRNb2RlKS5jYWxsKF9jb250ZXh0NSwgdGhpcykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kRXZlbnQoXCJjbGlja1wiLCBiaW5kJDYoX2NvbnRleHQ2ID0gdGhpcy5fcGVyZm9ybUFkZE5vZGUpLmNhbGwoX2NvbnRleHQ2LCB0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNhbGwgdGhlIGJvdW5kIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgZWRpdGluZyBvZiB0aGUgbm9kZS4gVGhlIG5vZGUgaGFzIHRvIGJlIHNlbGVjdGVkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZWRpdE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdE5vZGUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9IC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG5cblxuICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2RlcygpWzBdO1xuXG4gICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaW5Nb2RlID0gXCJlZGl0Tm9kZVwiO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmVkaXROb2RlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZGVlcEV4dGVuZCh7fSwgbm9kZS5vcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgICBkYXRhLnggPSBub2RlLng7XG4gICAgICAgICAgICBkYXRhLnkgPSBub2RlLnk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdE5vZGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0Tm9kZShkYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczIuaW5Nb2RlID09PSBcImVkaXROb2RlXCIpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGlmIGZvciB3aGF0ZXZlciByZWFzb24gdGhlIG1vZGUgaGFzIGNoYW5nZXMgKGR1ZSB0byBkYXRhc2V0IGNoYW5nZSkgZGlzcmVnYXJkIHRoZSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgX3RoaXMyLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkudXBkYXRlKGZpbmFsaXplZERhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF90aGlzMi5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIGZvciBlZGl0IGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSwgY2FsbGJhY2spXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVtcImVkaXRDbHVzdGVyRXJyb3JcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImVkaXRDbHVzdGVyRXJyb3JcIl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmdW5jdGlvbiBoYXMgYmVlbiBjb25maWd1cmVkIHRvIGhhbmRsZSB0aGUgZWRpdGluZyBvZiBub2Rlcy5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgdGhlIHRvb2xiYXIgdG8gY29ubmVjdCBub2Rlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWRnZU1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWRnZU1vZGUoKSB7XG4gICAgICB2YXIgX2NvbnRleHQ4LCBfY29udGV4dDksIF9jb250ZXh0MTAsIF9jb250ZXh0MTEsIF9jb250ZXh0MTI7XG5cbiAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNudCBhbHJlYWR5LlxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfSAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuXG5cbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIHRoaXMuaW5Nb2RlID0gXCJhZGRFZGdlXCI7XG5cbiAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NztcblxuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlQmFja0J1dHRvbihsb2NhbGUpO1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigpO1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZURlc2NyaXB0aW9uKGxvY2FsZVtcImVkZ2VEZXNjcmlwdGlvblwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZWRnZURlc2NyaXB0aW9uXCJdKTsgLy8gYmluZCB0aGUgY2xvc2UgYnV0dG9uXG5cblxuICAgICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyh0aGlzLmNsb3NlRGl2LCBiaW5kJDYoX2NvbnRleHQ3ID0gdGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbChfY29udGV4dDcsIHRoaXMpKTtcbiAgICAgIH0gLy8gdGVtcG9yYXJpbHkgb3ZlcmxvYWQgZnVuY3Rpb25zXG5cblxuICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25Ub3VjaFwiLCBiaW5kJDYoX2NvbnRleHQ4ID0gdGhpcy5faGFuZGxlQ29ubmVjdCkuY2FsbChfY29udGV4dDgsIHRoaXMpKTtcblxuICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnRW5kXCIsIGJpbmQkNihfY29udGV4dDkgPSB0aGlzLl9maW5pc2hDb25uZWN0KS5jYWxsKF9jb250ZXh0OSwgdGhpcykpO1xuXG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdcIiwgYmluZCQ2KF9jb250ZXh0MTAgPSB0aGlzLl9kcmFnQ29udHJvbE5vZGUpLmNhbGwoX2NvbnRleHQxMCwgdGhpcykpO1xuXG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvblJlbGVhc2VcIiwgYmluZCQ2KF9jb250ZXh0MTEgPSB0aGlzLl9maW5pc2hDb25uZWN0KS5jYWxsKF9jb250ZXh0MTEsIHRoaXMpKTtcblxuICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnU3RhcnRcIiwgYmluZCQ2KF9jb250ZXh0MTIgPSB0aGlzLl9kcmFnU3RhcnRFZGdlKS5jYWxsKF9jb250ZXh0MTIsIHRoaXMpKTtcblxuICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25Ib2xkXCIsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY3JlYXRlIHRoZSB0b29sYmFyIHRvIGVkaXQgZWRnZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVkaXRFZGdlTW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0RWRnZU1vZGUoKSB7XG4gICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2Fzbid0IGFscmVhZHkuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9IC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG5cblxuICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgdGhpcy5pbk1vZGUgPSBcImVkaXRFZGdlXCI7XG5cbiAgICAgIGlmIChfdHlwZW9mKHRoaXMub3B0aW9ucy5lZGl0RWRnZSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5lZGl0RWRnZS5lZGl0V2l0aG91dERyYWcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLmVkZ2VCZWluZ0VkaXRlZElkID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZUlkcygpWzBdO1xuXG4gICAgICAgIGlmICh0aGlzLmVkZ2VCZWluZ0VkaXRlZElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXTtcblxuICAgICAgICAgIHRoaXMuX3BlcmZvcm1FZGl0RWRnZShlZGdlLmZyb20uaWQsIGVkZ2UudG8uaWQpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MTM7XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoKTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVEZXNjcmlwdGlvbihsb2NhbGVbXCJlZGl0RWRnZURlc2NyaXB0aW9uXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJlZGl0RWRnZURlc2NyaXB0aW9uXCJdKTsgLy8gYmluZCB0aGUgY2xvc2UgYnV0dG9uXG5cblxuICAgICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyh0aGlzLmNsb3NlRGl2LCBiaW5kJDYoX2NvbnRleHQxMyA9IHRoaXMudG9nZ2xlRWRpdE1vZGUpLmNhbGwoX2NvbnRleHQxMywgdGhpcykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVkZ2VCZWluZ0VkaXRlZElkID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZUlkcygpWzBdO1xuXG4gICAgICBpZiAodGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfY29udGV4dDE0LCBfY29udGV4dDE1LCBfY29udGV4dDE2LCBfY29udGV4dDE3O1xuXG4gICAgICAgIHZhciBfZWRnZSA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXTsgLy8gY3JlYXRlIGNvbnRyb2wgbm9kZXNcblxuICAgICAgICB2YXIgY29udHJvbE5vZGVGcm9tID0gdGhpcy5fZ2V0TmV3VGFyZ2V0Tm9kZShfZWRnZS5mcm9tLngsIF9lZGdlLmZyb20ueSk7XG5cbiAgICAgICAgdmFyIGNvbnRyb2xOb2RlVG8gPSB0aGlzLl9nZXROZXdUYXJnZXROb2RlKF9lZGdlLnRvLngsIF9lZGdlLnRvLnkpO1xuXG4gICAgICAgIHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLnB1c2goY29udHJvbE5vZGVGcm9tLmlkKTtcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMucHVzaChjb250cm9sTm9kZVRvLmlkKTtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW2NvbnRyb2xOb2RlRnJvbS5pZF0gPSBjb250cm9sTm9kZUZyb207XG4gICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKGNvbnRyb2xOb2RlRnJvbS5pZCk7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tjb250cm9sTm9kZVRvLmlkXSA9IGNvbnRyb2xOb2RlVG87XG4gICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKGNvbnRyb2xOb2RlVG8uaWQpOyAvLyB0ZW1wb3JhcmlseSBvdmVybG9hZCBVSSBmdW5jdGlvbnMsIGNsZWFuZWQgdXAgYXV0b21hdGljYWxseSBiZWNhdXNlIG9mIF90ZW1wb3JhcnlCaW5kVUlcblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvblRvdWNoXCIsIGJpbmQkNihfY29udGV4dDE0ID0gdGhpcy5fY29udHJvbE5vZGVUb3VjaCkuY2FsbChfY29udGV4dDE0LCB0aGlzKSk7IC8vIHVzZWQgdG8gZ2V0IHRoZSBwb3NpdGlvblxuXG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25UYXBcIiwgZnVuY3Rpb24gKCkge30pOyAvLyBkaXNhYmxlZFxuXG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25Ib2xkXCIsIGZ1bmN0aW9uICgpIHt9KTsgLy8gZGlzYWJsZWRcblxuXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ1N0YXJ0XCIsIGJpbmQkNihfY29udGV4dDE1ID0gdGhpcy5fY29udHJvbE5vZGVEcmFnU3RhcnQpLmNhbGwoX2NvbnRleHQxNSwgdGhpcykpOyAvLyB1c2VkIHRvIHNlbGVjdCBjb250cm9sIG5vZGVcblxuXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ1wiLCBiaW5kJDYoX2NvbnRleHQxNiA9IHRoaXMuX2NvbnRyb2xOb2RlRHJhZykuY2FsbChfY29udGV4dDE2LCB0aGlzKSk7IC8vIHVzZWQgdG8gZHJhZyBjb250cm9sIG5vZGVcblxuXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ0VuZFwiLCBiaW5kJDYoX2NvbnRleHQxNyA9IHRoaXMuX2NvbnRyb2xOb2RlRHJhZ0VuZCkuY2FsbChfY29udGV4dDE3LCB0aGlzKSk7IC8vIHVzZWQgdG8gY29ubmVjdCBvciByZXZlcnQgY29udHJvbCBub2Rlc1xuXG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25Nb3VzZU1vdmVcIiwgZnVuY3Rpb24gKCkge30pOyAvLyBkaXNhYmxlZFxuICAgICAgICAvLyBjcmVhdGUgZnVuY3Rpb24gdG8gcG9zaXRpb24gY29udHJvbCBub2RlcyBjb3JyZWN0bHkgb24gbW92ZW1lbnRcbiAgICAgICAgLy8gYXV0b21hdGljYWxseSBjbGVhbmVkIHVwIGJlY2F1c2Ugd2UgdXNlIHRoZSB0ZW1wb3JhcnkgYmluZFxuXG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZEV2ZW50KFwiYmVmb3JlRHJhd2luZ1wiLCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IF9lZGdlLmVkZ2VUeXBlLmZpbmRCb3JkZXJQb3NpdGlvbnMoY3R4KTtcblxuICAgICAgICAgIGlmIChjb250cm9sTm9kZUZyb20uc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250cm9sTm9kZUZyb20ueCA9IHBvc2l0aW9ucy5mcm9tLng7XG4gICAgICAgICAgICBjb250cm9sTm9kZUZyb20ueSA9IHBvc2l0aW9ucy5mcm9tLnk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRyb2xOb2RlVG8uc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250cm9sTm9kZVRvLnggPSBwb3NpdGlvbnMudG8ueDtcbiAgICAgICAgICAgIGNvbnRyb2xOb2RlVG8ueSA9IHBvc2l0aW9ucy50by55O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogZGVsZXRlIGV2ZXJ5dGhpbmcgaW4gdGhlIHNlbGVjdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlU2VsZWN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlU2VsZWN0ZWQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9IC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG5cblxuICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgdGhpcy5pbk1vZGUgPSBcImRlbGV0ZVwiO1xuICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2RlSWRzKCk7XG4gICAgICB2YXIgc2VsZWN0ZWRFZGdlcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VJZHMoKTtcbiAgICAgIHZhciBkZWxldGVGdW5jdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHNlbGVjdGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3NlbGVjdGVkTm9kZXNbaV1dLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bXCJkZWxldGVDbHVzdGVyRXJyb3JcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImRlbGV0ZUNsdXN0ZXJFcnJvclwiXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZGVsZXRlRnVuY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZEVkZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZGVsZXRlRWRnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZGVsZXRlRnVuY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGVsZXRlRWRnZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRlbGV0ZUZ1bmN0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgbm9kZXM6IHNlbGVjdGVkTm9kZXMsXG4gICAgICAgICAgZWRnZXM6IHNlbGVjdGVkRWRnZXNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZGVsZXRlRnVuY3Rpb24ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgZGVsZXRlRnVuY3Rpb24oZGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczMuaW5Nb2RlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGZvciB3aGF0ZXZlciByZWFzb24gdGhlIG1vZGUgaGFzIGNoYW5nZXMgKGR1ZSB0byBkYXRhc2V0IGNoYW5nZSkgZGlzcmVnYXJkIHRoZSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBfdGhpczMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5yZW1vdmUoZmluYWxpemVkRGF0YS5lZGdlcyk7XG5cbiAgICAgICAgICAgICAgX3RoaXMzLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkucmVtb3ZlKGZpbmFsaXplZERhdGEubm9kZXMpO1xuXG4gICAgICAgICAgICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcblxuICAgICAgICAgICAgICBfdGhpczMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuXG4gICAgICAgICAgICAgIF90aGlzMy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIGZvciBkZWxldGUgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLCBjYWxsYmFjaylcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5yZW1vdmUoc2VsZWN0ZWRFZGdlcyk7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5yZW1vdmUoc2VsZWN0ZWROb2Rlcyk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH0gLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFBSSVZBVEUgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLy9cblxuICAgIC8qKlxuICAgICAqIGRyYXcgb3IgcmVtb3ZlIHRoZSBET01cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0dXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIC8vIEVuYWJsZSB0aGUgR1VJXG4gICAgICAgIHRoaXMuZ3VpRW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlV3JhcHBlcnMoKTtcblxuICAgICAgICBpZiAodGhpcy5lZGl0TW9kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVFZGl0QnV0dG9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZU1hbmlwdWxhdGlvbkRPTSgpOyAvLyBkaXNhYmxlIHRoZSBndWlcblxuXG4gICAgICAgIHRoaXMuZ3VpRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgdGhlIGRpdiBvdmVybGF5cyB0aGF0IGNvbnRhaW4gdGhlIERPTVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVXcmFwcGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlV3JhcHBlcnMoKSB7XG4gICAgICAvLyBsb2FkIHRoZSBtYW5pcHVsYXRvciBIVE1MIGVsZW1lbnRzLiBBbGwgc3R5bGluZyBkb25lIGluIGNzcy5cbiAgICAgIGlmICh0aGlzLm1hbmlwdWxhdGlvbkRpdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuY2xhc3NOYW1lID0gXCJ2aXMtbWFuaXB1bGF0aW9uXCI7XG5cbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcbiAgICAgIH0gLy8gY29udGFpbmVyIGZvciB0aGUgZWRpdCBidXR0b24uXG5cblxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGVEaXYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmVkaXRNb2RlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5jbGFzc05hbWUgPSBcInZpcy1lZGl0LW1vZGVcIjtcblxuICAgICAgICBpZiAodGhpcy5lZGl0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgfSAvLyBjb250YWluZXIgZm9yIHRoZSBjbG9zZSBkaXYgYnV0dG9uXG5cblxuICAgICAgaWYgKHRoaXMuY2xvc2VEaXYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX3RoaXMkb3B0aW9ucyRsb2NhbGVzLCBfdGhpcyRvcHRpb25zJGxvY2FsZXMyO1xuXG4gICAgICAgIHRoaXMuY2xvc2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LmNsYXNzTmFtZSA9IFwidmlzLWNsb3NlXCI7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCAoX3RoaXMkb3B0aW9ucyRsb2NhbGVzID0gKF90aGlzJG9wdGlvbnMkbG9jYWxlczIgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXSkgPT09IG51bGwgfHwgX3RoaXMkb3B0aW9ucyRsb2NhbGVzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkb3B0aW9ucyRsb2NhbGVzMltcImNsb3NlXCJdKSAhPT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zJGxvY2FsZXMgIT09IHZvaWQgMCA/IF90aGlzJG9wdGlvbnMkbG9jYWxlcyA6IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJjbG9zZVwiXSk7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheSA9IHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuY2xvc2VEaXYpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSBhIG5ldyB0YXJnZXQgbm9kZS4gVXNlZCBmb3IgY3JlYXRpbmcgbmV3IGVkZ2VzIGFuZCBlZGl0aW5nIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXROZXdUYXJnZXROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXROZXdUYXJnZXROb2RlKHgsIHkpIHtcbiAgICAgIHZhciBjb250cm9sTm9kZVN0eWxlID0gZGVlcEV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLmNvbnRyb2xOb2RlU3R5bGUpO1xuICAgICAgY29udHJvbE5vZGVTdHlsZS5pZCA9IFwidGFyZ2V0Tm9kZVwiICsgdjQoKTtcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGUuaGlkZGVuID0gZmFsc2U7XG4gICAgICBjb250cm9sTm9kZVN0eWxlLnBoeXNpY3MgPSBmYWxzZTtcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGUueCA9IHg7XG4gICAgICBjb250cm9sTm9kZVN0eWxlLnkgPSB5OyAvLyB3ZSBoYXZlIHRvIGRlZmluZSB0aGUgYm91bmRpbmcgYm94IGluIG9yZGVyIGZvciB0aGUgbm9kZXMgdG8gYmUgZHJhd24gaW1tZWRpYXRlbHlcblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUoY29udHJvbE5vZGVTdHlsZSk7XG4gICAgICBub2RlLnNoYXBlLmJvdW5kaW5nQm94ID0ge1xuICAgICAgICBsZWZ0OiB4LFxuICAgICAgICByaWdodDogeCxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICBib3R0b206IHlcbiAgICAgIH07XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBlZGl0IGJ1dHRvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUVkaXRCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXRCdXR0b24oKSB7XG4gICAgICB2YXIgX2NvbnRleHQxODtcblxuICAgICAgLy8gcmVzdG9yZSBldmVyeXRoaW5nIHRvIGl0J3Mgb3JpZ2luYWwgc3RhdGUgKGlmIGFwcGxpY2FibGUpXG4gICAgICB0aGlzLl9jbGVhbigpOyAvLyByZXNldCB0aGUgbWFuaXB1bGF0aW9uRE9NXG5cblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTsgLy8gZW1wdHkgdGhlIGVkaXRNb2RlRGl2XG5cbiAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmVkaXRNb2RlRGl2KTsgLy8gY3JlYXRlIHRoZSBjb250ZW50cyBmb3IgdGhlIGVkaXRNb2RlIGJ1dHRvblxuXG4gICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG5cbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJlZGl0TW9kZVwiLCBcInZpcy1lZGl0IHZpcy1lZGl0LW1vZGVcIiwgbG9jYWxlW1wiZWRpdFwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZWRpdFwiXSk7XG5cbiAgICAgIHRoaXMuZWRpdE1vZGVEaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTsgLy8gYmluZCBhIGhhbW1lciBsaXN0ZW5lciB0byB0aGUgYnV0dG9uLCBjYWxsaW5nIHRoZSBmdW5jdGlvbiB0b2dnbGVFZGl0TW9kZS5cblxuICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoYnV0dG9uLCBiaW5kJDYoX2NvbnRleHQxOCA9IHRoaXMudG9nZ2xlRWRpdE1vZGUpLmNhbGwoX2NvbnRleHQxOCwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGNsZWFucyB1cCBhZnRlciBldmVyeXRoaW5nIHRoaXMgbW9kdWxlIGRvZXMuIFRlbXBvcmFyeSBlbGVtZW50cywgZnVuY3Rpb25zIGFuZCBldmVudHMgYXJlIHJlbW92ZWQsIHBoeXNpY3MgcmVzdG9yZWQsIGhhbW1lcnMgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2xlYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFuKCkge1xuICAgICAgLy8gbm90IGluIG1vZGVcbiAgICAgIHRoaXMuaW5Nb2RlID0gZmFsc2U7IC8vIF9jbGVhbiB0aGUgZGl2c1xuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmVkaXRNb2RlRGl2KTtcbiAgICAgICAgcmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMubWFuaXB1bGF0aW9uRGl2KTsgLy8gcmVtb3ZlcyBhbGwgdGhlIGJpbmRpbmdzIGFuZCBvdmVybG9hZHNcblxuICAgICAgICB0aGlzLl9jbGVhbnVwRE9NRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIH0gLy8gcmVtb3ZlIHRlbXBvcmFyeSBub2RlcyBhbmQgZWRnZXNcblxuXG4gICAgICB0aGlzLl9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcygpOyAvLyByZXN0b3JlIG92ZXJsb2FkZWQgVUkgZnVuY3Rpb25zXG5cblxuICAgICAgdGhpcy5fdW5iaW5kVGVtcG9yYXJ5VUlzKCk7IC8vIHJlbW92ZSB0aGUgdGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnNcblxuXG4gICAgICB0aGlzLl91bmJpbmRUZW1wb3JhcnlFdmVudHMoKTsgLy8gcmVzdG9yZSB0aGUgcGh5c2ljcyBpZiByZXF1aXJlZFxuXG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZXN0b3JlUGh5c2ljc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRWFjaCBkb20gZWxlbWVudCBoYXMgaXQncyBvd24gaGFtbWVyLiBUaGV5IGFyZSBzdG9yZWQgaW4gdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzLiBUaGlzIGNsZWFucyB0aGVtIHVwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jbGVhbnVwRE9NRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFudXBET01FdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfY29udGV4dDE5O1xuXG4gICAgICAvLyBfY2xlYW4gRE9NIGV2ZW50IGxpc3RlbmVyIGJpbmRpbmdzXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3BsaWNlJDEoX2NvbnRleHQxOSA9IHRoaXMuX2RvbUV2ZW50TGlzdGVuZXJDbGVhbnVwUXVldWUpLmNhbGwoX2NvbnRleHQxOSwgMCkpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBET00gZWxlbWVudHMgY3JlYXRlZCBieSB0aGlzIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlTWFuaXB1bGF0aW9uRE9NXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVNYW5pcHVsYXRpb25ET00oKSB7XG4gICAgICAvLyByZW1vdmVzIGFsbCB0aGUgYmluZGluZ3MgYW5kIG92ZXJsb2Fkc1xuICAgICAgdGhpcy5fY2xlYW4oKTsgLy8gZW1wdHkgdGhlIG1hbmlwdWxhdGlvbiBkaXZzXG5cblxuICAgICAgcmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcbiAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmVkaXRNb2RlRGl2KTtcbiAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmNsb3NlRGl2KTsgLy8gcmVtb3ZlIHRoZSBtYW5pcHVsYXRpb24gZGl2c1xuXG4gICAgICBpZiAodGhpcy5tYW5pcHVsYXRpb25EaXYpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUucmVtb3ZlQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25EaXYpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZURpdikge1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLmVkaXRNb2RlRGl2KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2xvc2VEaXYpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUucmVtb3ZlQ2hpbGQodGhpcy5jbG9zZURpdik7XG4gICAgICB9IC8vIHNldCB0aGUgcmVmZXJlbmNlcyB0byB1bmRlZmluZWRcblxuXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZWRpdE1vZGVEaXYgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmNsb3NlRGl2ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSBzZXBlcmF0b3IgbGluZS4gdGhlIGluZGV4IGlzIHRvIGRpZmZlcmVudGlhdGUgaW4gdGhlIG1hbmlwdWxhdGlvbiBkb21cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVNlcGVyYXRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlU2VwZXJhdG9yKCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01bXCJzZXBlcmF0b3JMaW5lRGl2XCIgKyBpbmRleF0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01bXCJzZXBlcmF0b3JMaW5lRGl2XCIgKyBpbmRleF0uY2xhc3NOYW1lID0gXCJ2aXMtc2VwYXJhdG9yLWxpbmVcIjtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKHRoaXMubWFuaXB1bGF0aW9uRE9NW1wic2VwZXJhdG9yTGluZURpdlwiICsgaW5kZXhdKTtcbiAgICB9IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gICAgRE9NIGZ1bmN0aW9ucyBmb3IgYnV0dG9ucyAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9jYWxlfSBsb2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUFkZE5vZGVCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUFkZE5vZGVCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyMDtcblxuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcImFkZE5vZGVcIiwgXCJ2aXMtYWRkXCIsIGxvY2FsZVtcImFkZE5vZGVcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImFkZE5vZGVcIl0pO1xuXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhidXR0b24sIGJpbmQkNihfY29udGV4dDIwID0gdGhpcy5hZGROb2RlTW9kZSkuY2FsbChfY29udGV4dDIwLCB0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQWRkRWRnZUJ1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQWRkRWRnZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBfY29udGV4dDIxO1xuXG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiYWRkRWRnZVwiLCBcInZpcy1jb25uZWN0XCIsIGxvY2FsZVtcImFkZEVkZ2VcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImFkZEVkZ2VcIl0pO1xuXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhidXR0b24sIGJpbmQkNihfY29udGV4dDIxID0gdGhpcy5hZGRFZGdlTW9kZSkuY2FsbChfY29udGV4dDIxLCB0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlRWRpdE5vZGVCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXROb2RlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIF9jb250ZXh0MjI7XG5cbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJlZGl0Tm9kZVwiLCBcInZpcy1lZGl0XCIsIGxvY2FsZVtcImVkaXROb2RlXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJlZGl0Tm9kZVwiXSk7XG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGJ1dHRvbiwgYmluZCQ2KF9jb250ZXh0MjIgPSB0aGlzLmVkaXROb2RlKS5jYWxsKF9jb250ZXh0MjIsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVFZGl0RWRnZUJ1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRWRpdEVkZ2VCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyMztcblxuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcImVkaXRFZGdlXCIsIFwidmlzLWVkaXRcIiwgbG9jYWxlW1wiZWRpdEVkZ2VcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImVkaXRFZGdlXCJdKTtcblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoYnV0dG9uLCBiaW5kJDYoX2NvbnRleHQyMyA9IHRoaXMuZWRpdEVkZ2VNb2RlKS5jYWxsKF9jb250ZXh0MjMsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVEZWxldGVCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZURlbGV0ZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBfY29udGV4dDI0O1xuXG4gICAgICB2YXIgZGVsZXRlQnRuQ2xhc3M7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgIGRlbGV0ZUJ0bkNsYXNzID0gXCJ2aXMtZGVsZXRlLXJ0bFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQnRuQ2xhc3MgPSBcInZpcy1kZWxldGVcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcImRlbGV0ZVwiLCBkZWxldGVCdG5DbGFzcywgbG9jYWxlW1wiZGVsXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJkZWxcIl0pO1xuXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhidXR0b24sIGJpbmQkNihfY29udGV4dDI0ID0gdGhpcy5kZWxldGVTZWxlY3RlZCkuY2FsbChfY29udGV4dDI0LCB0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQmFja0J1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQmFja0J1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBfY29udGV4dDI1O1xuXG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiYmFja1wiLCBcInZpcy1iYWNrXCIsIGxvY2FsZVtcImJhY2tcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImJhY2tcIl0pO1xuXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhidXR0b24sIGJpbmQkNihfY29udGV4dDI1ID0gdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKS5jYWxsKF9jb250ZXh0MjUsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7bGFiZWx9IGxhYmVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsQ2xhc3NOYW1lXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVCdXR0b24oaWQsIGNsYXNzTmFtZSwgbGFiZWwpIHtcbiAgICAgIHZhciBsYWJlbENsYXNzTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJ2aXMtbGFiZWxcIjtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJEaXZcIl0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkRpdlwiXS5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gXCIgKyBjbGFzc05hbWU7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArIFwiTGFiZWxcIl0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkxhYmVsXCJdLmNsYXNzTmFtZSA9IGxhYmVsQ2xhc3NOYW1lO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkxhYmVsXCJdLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkRpdlwiXS5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArIFwiTGFiZWxcIl0pO1xuICAgICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJEaXZcIl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZURlc2NyaXB0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVEZXNjcmlwdGlvbihsYWJlbCkge1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01bXCJkZXNjcmlwdGlvbkxhYmVsXCJdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW1wiZGVzY3JpcHRpb25MYWJlbFwiXS5jbGFzc05hbWUgPSBcInZpcy1ub25lXCI7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtcImRlc2NyaXB0aW9uTGFiZWxcIl0uaW5uZXJUZXh0ID0gbGFiZWw7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRPTVtcImRlc2NyaXB0aW9uTGFiZWxcIl0pO1xuICAgIH0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRW5kIG9mIERPTSBmdW5jdGlvbnMgZm9yIGJ1dHRvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIHRoaXMgYmluZHMgYW4gZXZlbnQgdW50aWwgY2xlYW51cCBieSB0aGUgY2xlYW4gZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV3RnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3RlbXBvcmFyeUJpbmRFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdGVtcG9yYXJ5QmluZEV2ZW50KGV2ZW50LCBuZXdGdW5jdGlvbikge1xuICAgICAgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucy5wdXNoKHtcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBib3VuZEZ1bmN0aW9uOiBuZXdGdW5jdGlvblxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihldmVudCwgbmV3RnVuY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGlzIG92ZXJyaWRlcyBhbiBVSSBmdW5jdGlvbiB1bnRpbCBjbGVhbnVwIGJ5IHRoZSBjbGVhbiBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFVJZnVuY3Rpb25OYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV3RnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3RlbXBvcmFyeUJpbmRVSVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdGVtcG9yYXJ5QmluZFVJKFVJZnVuY3Rpb25OYW1lLCBuZXdGdW5jdGlvbikge1xuICAgICAgaWYgKHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW1VJZnVuY3Rpb25OYW1lXSA9IHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV07XG4gICAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV0gPSBuZXdGdW5jdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgVUkgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QuIFR5cG8/IFlvdSB0cmllZDogXCIgKyBVSWZ1bmN0aW9uTmFtZSArIFwiIHBvc3NpYmxlIGFyZTogXCIgKyBzdHJpbmdpZnkkMShrZXlzJDQodGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIHRoZSBvdmVycmlkZGVuIFVJIGZ1bmN0aW9ucyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdW5iaW5kVGVtcG9yYXJ5VUlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bmJpbmRUZW1wb3JhcnlVSXMoKSB7XG4gICAgICBmb3IgKHZhciBmdW5jdGlvbk5hbWUgaW4gdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMsIGZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnNbZnVuY3Rpb25OYW1lXSA9IHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnNbZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgICBkZWxldGUgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9uc1tmdW5jdGlvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5iaW5kIHRoZSBldmVudHMgY3JlYXRlZCBieSBfdGVtcG9yYXJ5QmluZEV2ZW50XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VuYmluZFRlbXBvcmFyeUV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5iaW5kVGVtcG9yYXJ5RXZlbnRzKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zW2ldLmV2ZW50O1xuICAgICAgICB2YXIgYm91bmRGdW5jdGlvbiA9IHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnNbaV0uYm91bmRGdW5jdGlvbjtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKGV2ZW50TmFtZSwgYm91bmRGdW5jdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBhbiBoYW1tZXIgaW5zdGFuY2UgdG8gYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZG9tRWxlbWVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGJvdW5kRnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9iaW5kRWxlbWVudEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEVsZW1lbnRFdmVudHMoZG9tRWxlbWVudCwgYm91bmRGdW5jdGlvbikge1xuICAgICAgLy8gQmluZCB0b3VjaCBldmVudHMuXG4gICAgICB2YXIgaGFtbWVyID0gbmV3IEhhbW1lcihkb21FbGVtZW50LCB7fSk7XG4gICAgICBvblRvdWNoKGhhbW1lciwgYm91bmRGdW5jdGlvbik7XG5cbiAgICAgIHRoaXMuX2RvbUV2ZW50TGlzdGVuZXJDbGVhbnVwUXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhhbW1lci5kZXN0cm95KCk7XG4gICAgICB9KTsgLy8gQmluZCBrZXlib2FyZCBldmVudHMuXG5cblxuICAgICAgdmFyIGtleXVwTGlzdGVuZXIgPSBmdW5jdGlvbiBrZXl1cExpc3RlbmVyKF9yZWYpIHtcbiAgICAgICAgdmFyIGtleUNvZGUgPSBfcmVmLmtleUNvZGUsXG4gICAgICAgICAgICBrZXkgPSBfcmVmLmtleTtcblxuICAgICAgICBpZiAoa2V5ID09PSBcIkVudGVyXCIgfHwga2V5ID09PSBcIiBcIiB8fCBrZXlDb2RlID09PSAxMyB8fCBrZXlDb2RlID09PSAzMikge1xuICAgICAgICAgIGJvdW5kRnVuY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwga2V5dXBMaXN0ZW5lciwgZmFsc2UpO1xuXG4gICAgICB0aGlzLl9kb21FdmVudExpc3RlbmVyQ2xlYW51cFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICBkb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBrZXl1cExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmVhdGx5IGNsZWFuIHVwIHRlbXBvcmFyeSBlZGdlcyBhbmQgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzKCkge1xuICAgICAgLy8gX2NsZWFuIHRlbXBvcmFyeSBlZGdlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRlbXBvcmFyeUlkcy5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2NvbnRleHQyNjtcblxuICAgICAgICB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbaV1dLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuYm9keS5lZGdlc1t0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1tpXV07XG5cbiAgICAgICAgdmFyIGluZGV4VGVtcEVkZ2UgPSBpbmRleE9mKF9jb250ZXh0MjYgPSB0aGlzLmJvZHkuZWRnZUluZGljZXMpLmNhbGwoX2NvbnRleHQyNiwgdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbaV0pO1xuXG4gICAgICAgIGlmIChpbmRleFRlbXBFZGdlICE9PSAtMSkge1xuICAgICAgICAgIHZhciBfY29udGV4dDI3O1xuXG4gICAgICAgICAgc3BsaWNlJDEoX2NvbnRleHQyNyA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcykuY2FsbChfY29udGV4dDI3LCBpbmRleFRlbXBFZGdlLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBfY2xlYW4gdGVtcG9yYXJ5IG5vZGVzXG5cblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX2NvbnRleHQyODtcblxuICAgICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzW19pXV07XG5cbiAgICAgICAgdmFyIGluZGV4VGVtcE5vZGUgPSBpbmRleE9mKF9jb250ZXh0MjggPSB0aGlzLmJvZHkubm9kZUluZGljZXMpLmNhbGwoX2NvbnRleHQyOCwgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbX2ldKTtcblxuICAgICAgICBpZiAoaW5kZXhUZW1wTm9kZSAhPT0gLTEpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQyOTtcblxuICAgICAgICAgIHNwbGljZSQxKF9jb250ZXh0MjkgPSB0aGlzLmJvZHkubm9kZUluZGljZXMpLmNhbGwoX2NvbnRleHQyOSwgaW5kZXhUZW1wTm9kZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50ZW1wb3JhcnlJZHMgPSB7XG4gICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgZWRnZXM6IFtdXG4gICAgICB9O1xuICAgIH0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVQgRURHRSBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICogdGhlIHRvdWNoIGlzIHVzZWQgdG8gZ2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgaW5pdGlhbCBjbGlja1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jb250cm9sTm9kZVRvdWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250cm9sTm9kZVRvdWNoKGV2ZW50KSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgIHRoaXMubGFzdFRvdWNoID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbiA9IGFzc2lnbiQyKHt9LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbik7IC8vIGNvcHkgdGhlIG9iamVjdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGUgZHJhZyBzdGFydCBpcyB1c2VkIHRvIG1hcmsgb25lIG9mIHRoZSBjb250cm9sIG5vZGVzIGFzIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jb250cm9sTm9kZURyYWdTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVEcmFnU3RhcnQoKSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMubGFzdFRvdWNoO1xuXG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG5cbiAgICAgIHZhciBmcm9tID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdXTtcbiAgICAgIHZhciB0byA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1sxXV07XG4gICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXTtcbiAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBmcm9tU2VsZWN0ID0gZnJvbS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcbiAgICAgIHZhciB0b1NlbGVjdCA9IHRvLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuXG4gICAgICBpZiAoZnJvbVNlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgPSBmcm9tO1xuICAgICAgICBlZGdlLmVkZ2VUeXBlLmZyb20gPSBmcm9tO1xuICAgICAgfSBlbHNlIGlmICh0b1NlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgPSB0bztcbiAgICAgICAgZWRnZS5lZGdlVHlwZS50byA9IHRvO1xuICAgICAgfSAvLyB3ZSB1c2UgdGhlIHNlbGVjdGlvbiB0byBmaW5kIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgZHJhZ2dlZC4gV2UgZXhwbGljaXRseSBzZWxlY3QgaXQgaGVyZS5cblxuXG4gICAgICBpZiAodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE9iamVjdCh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZHJhZ2dpbmcgdGhlIGNvbnRyb2wgbm9kZXMgb3IgdGhlIGNhbnZhc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jb250cm9sTm9kZURyYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRyb2xOb2RlRHJhZyhldmVudCkge1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImRpc2FibGVQaHlzaWNzXCIpO1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKTtcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS54ID0gcG9zLng7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS55ID0gcG9zLnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5vbkRyYWcoZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY29ubmVjdGluZyBvciByZXN0b3JpbmcgdGhlIGNvbnRyb2wgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbnRyb2xOb2RlRHJhZ0VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVEcmFnRW5kKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuXG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG5cbiAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdOyAvLyBpZiB0aGUgbm9kZSB0aGF0IHdhcyBkcmFnZ2VkIGlzIG5vdCBhIGNvbnRyb2wgbm9kZSwgcmV0dXJuXG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHdlIHVzZSB0aGUgc2VsZWN0aW9uIHRvIGZpbmQgdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBkcmFnZ2VkLiBXZSBleHBsaWNpdGx5IERFc2VsZWN0IHRoZSBjb250cm9sIG5vZGUgaGVyZS5cblxuXG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcblxuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZUlkcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG5cbiAgICAgIHZhciBub2RlID0gdW5kZWZpbmVkO1xuXG4gICAgICBmb3IgKHZhciBpID0gb3ZlcmxhcHBpbmdOb2RlSWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChvdmVybGFwcGluZ05vZGVJZHNbaV0gIT09IHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS5pZCkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2RlSWRzW2ldXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBwZXJmb3JtIHRoZSBjb25uZWN0aW9uXG5cblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVtcImNyZWF0ZUVkZ2VFcnJvclwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiY3JlYXRlRWRnZUVycm9yXCJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXV07XG5cbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlLmlkID09PSBmcm9tLmlkKSB7XG4gICAgICAgICAgICB0aGlzLl9wZXJmb3JtRWRpdEVkZ2Uobm9kZS5pZCwgZWRnZS50by5pZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1FZGl0RWRnZShlZGdlLmZyb20uaWQsIG5vZGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRnZS51cGRhdGVFZGdlVHlwZSgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVzdG9yZVBoeXNpY3NcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgIH0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVORCBPRiBFRElUIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEFERCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiB0aGUgZnVuY3Rpb24gYm91bmQgdG8gdGhlIHNlbGVjdGlvbiBldmVudC4gSXQgY2hlY2tzIGlmIHlvdSB3YW50IHRvIGNvbm5lY3QgYSBjbHVzdGVyIGFuZCBjaGFuZ2VzIHRoZSBkZXNjcmlwdGlvblxuICAgICAqIHRvIHdhbGsgdGhlIHVzZXIgdGhyb3VnaCB0aGUgcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVDb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDb25uZWN0KGV2ZW50KSB7XG4gICAgICAvLyBjaGVjayB0byBhdm9pZCBkb3VibGUgZmlyZWluZyBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy50b3VjaFRpbWUgPiAxMDApIHtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2ggPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb24gPSBhc3NpZ24kMih7fSwgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24pOyAvLyBjb3B5IHRoZSBvYmplY3RcblxuICAgICAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5kcmFnLnBvaW50ZXIgPSB0aGlzLmxhc3RUb3VjaDsgLy8gRHJhZyBwb2ludGVyIGlzIG5vdCB1cGRhdGVkIHdoZW4gYWRkaW5nIGVkZ2VzXG5cbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIuZHJhZy50cmFuc2xhdGlvbiA9IHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uO1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMubGFzdFRvdWNoO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQocG9pbnRlcik7XG5cbiAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChub2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bXCJjcmVhdGVFZGdlRXJyb3JcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImNyZWF0ZUVkZ2VFcnJvclwiXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5vZGUgdGhlIHRlbXBvcmFyeSBsaW5lIGNhbiBsb29rIGF0XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRoaXMuX2dldE5ld1RhcmdldE5vZGUobm9kZS54LCBub2RlLnkpO1xuXG4gICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbdGFyZ2V0Tm9kZS5pZF0gPSB0YXJnZXROb2RlO1xuICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2godGFyZ2V0Tm9kZS5pZCk7IC8vIGNyZWF0ZSBhIHRlbXBvcmFyeSBlZGdlXG5cbiAgICAgICAgICAgIHZhciBjb25uZWN0aW9uRWRnZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZSh7XG4gICAgICAgICAgICAgIGlkOiBcImNvbm5lY3Rpb25FZGdlXCIgKyB2NCgpLFxuICAgICAgICAgICAgICBmcm9tOiBub2RlLmlkLFxuICAgICAgICAgICAgICB0bzogdGFyZ2V0Tm9kZS5pZCxcbiAgICAgICAgICAgICAgcGh5c2ljczogZmFsc2UsXG4gICAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb250aW51b3VzXCIsXG4gICAgICAgICAgICAgICAgcm91bmRuZXNzOiAwLjVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbY29ubmVjdGlvbkVkZ2UuaWRdID0gY29ubmVjdGlvbkVkZ2U7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZWRnZUluZGljZXMucHVzaChjb25uZWN0aW9uRWRnZS5pZCk7XG4gICAgICAgICAgICB0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKHRhcmdldE5vZGUuaWQpO1xuICAgICAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXMucHVzaChjb25uZWN0aW9uRWRnZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhZ0NvbnRyb2xOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmFnQ29udHJvbE5vZGUoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG5cbiAgICAgIHZhciBwb2ludGVyT2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTsgLy8gcmVtZW1iZXIgdGhlIGVkZ2UgaWRcblxuXG4gICAgICB2YXIgY29ubmVjdEZyb21JZCA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29ubmVjdEZyb21JZCA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXV0uZnJvbUlkO1xuICAgICAgfSAvLyBnZXQgdGhlIG92ZXJsYXBwaW5nIG5vZGUgYnV0IE5PVCB0aGUgdGVtcG9yYXJ5IG5vZGU7XG5cblxuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZUlkcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG5cbiAgICAgIHZhciBub2RlID0gdW5kZWZpbmVkO1xuXG4gICAgICBmb3IgKHZhciBpID0gb3ZlcmxhcHBpbmdOb2RlSWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBfY29udGV4dDMwO1xuXG4gICAgICAgIC8vIGlmIHRoZSBub2RlIGlkIGlzIE5PVCBhIHRlbXBvcmFyeSBub2RlLCBhY2NlcHQgdGhlIG5vZGUuXG4gICAgICAgIGlmIChpbmRleE9mKF9jb250ZXh0MzAgPSB0aGlzLnRlbXBvcmFyeUlkcy5ub2RlcykuY2FsbChfY29udGV4dDMwLCBvdmVybGFwcGluZ05vZGVJZHNbaV0pID09PSAtMSkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2RlSWRzW2ldXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldmVudC5jb250cm9sRWRnZSA9IHtcbiAgICAgICAgZnJvbTogY29ubmVjdEZyb21JZCxcbiAgICAgICAgdG86IG5vZGUgPyBub2RlLmlkIDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImNvbnRyb2xOb2RlRHJhZ2dpbmdcIiwgZXZlbnQsIHBvaW50ZXIpO1xuXG4gICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXV07IC8vIHRoZXJlIGlzIG9ubHkgb25lIHRlbXAgbm9kZSBpbiB0aGUgYWRkIGVkZ2UgbW9kZS5cblxuICAgICAgICB0YXJnZXROb2RlLnggPSB0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLngpO1xuICAgICAgICB0YXJnZXROb2RlLnkgPSB0aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLnkpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLm9uRHJhZyhldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdGhlIG5ldyBlZGdlIHRvIHRoZSB0YXJnZXQgaWYgb25lIGV4aXN0cywgb3RoZXJ3aXNlIHJlbW92ZSB0ZW1wIGxpbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmluaXNoQ29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluaXNoQ29ubmVjdChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcblxuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpOyAvLyByZW1lbWJlciB0aGUgZWRnZSBpZFxuXG5cbiAgICAgIHZhciBjb25uZWN0RnJvbUlkID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25uZWN0RnJvbUlkID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdXS5mcm9tSWQ7XG4gICAgICB9IC8vIGdldCB0aGUgb3ZlcmxhcHBpbmcgbm9kZSBidXQgTk9UIHRoZSB0ZW1wb3Jhcnkgbm9kZTtcblxuXG4gICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlSWRzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcblxuICAgICAgdmFyIG5vZGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSBvdmVybGFwcGluZ05vZGVJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MzE7XG5cbiAgICAgICAgLy8gaWYgdGhlIG5vZGUgaWQgaXMgTk9UIGEgdGVtcG9yYXJ5IG5vZGUsIGFjY2VwdCB0aGUgbm9kZS5cbiAgICAgICAgaWYgKGluZGV4T2YoX2NvbnRleHQzMSA9IHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzKS5jYWxsKF9jb250ZXh0MzEsIG92ZXJsYXBwaW5nTm9kZUlkc1tpXSkgPT09IC0xKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tvdmVybGFwcGluZ05vZGVJZHNbaV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIGNsZWFuIHRlbXBvcmFyeSBub2RlcyBhbmQgZWRnZXMuXG5cblxuICAgICAgdGhpcy5fY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXMoKTsgLy8gcGVyZm9ybSB0aGUgY29ubmVjdGlvblxuXG5cbiAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bXCJjcmVhdGVFZGdlRXJyb3JcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImNyZWF0ZUVkZ2VFcnJvclwiXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tjb25uZWN0RnJvbUlkXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYm9keS5ub2Rlc1tub2RlLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wZXJmb3JtQWRkRWRnZShjb25uZWN0RnJvbUlkLCBub2RlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXZlbnQuY29udHJvbEVkZ2UgPSB7XG4gICAgICAgIGZyb206IGNvbm5lY3RGcm9tSWQsXG4gICAgICAgIHRvOiBub2RlID8gbm9kZS5pZCA6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJjb250cm9sTm9kZURyYWdFbmRcIiwgZXZlbnQsIHBvaW50ZXIpOyAvLyBObyBuZWVkIHRvIGRvIF9nZW5lcmF0ZWNsaWNrZXZlbnQoJ2RyYWdFbmQnKSBoZXJlLCB0aGUgcmVndWxhciBkcmFnRW5kIGV2ZW50IGZpcmVzLlxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhZ1N0YXJ0RWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhZ1N0YXJ0RWRnZShldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmxhc3RUb3VjaDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnU3RhcnRcIiwgZXZlbnQsIHBvaW50ZXIsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgfSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU5EIE9GIEFERCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUGVyZm9ybWluZyBhbGwgdGhlIGFjdHVhbCBkYXRhIG1hbmlwdWxhdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5vZGUgb24gdGhlIHNwZWNpZmllZCBsb2NhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNsaWNrRGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGVyZm9ybUFkZE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1BZGROb2RlKGNsaWNrRGF0YSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHtcbiAgICAgICAgaWQ6IHY0KCksXG4gICAgICAgIHg6IGNsaWNrRGF0YS5wb2ludGVyLmNhbnZhcy54LFxuICAgICAgICB5OiBjbGlja0RhdGEucG9pbnRlci5jYW52YXMueSxcbiAgICAgICAgbGFiZWw6IFwibmV3XCJcbiAgICAgIH07XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmFkZE5vZGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFkZE5vZGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmFkZE5vZGUoZGVmYXVsdERhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICBpZiAoZmluYWxpemVkRGF0YSAhPT0gbnVsbCAmJiBmaW5hbGl6ZWREYXRhICE9PSB1bmRlZmluZWQgJiYgX3RoaXM0LmluTW9kZSA9PT0gXCJhZGROb2RlXCIpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgIF90aGlzNC5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLmFkZChmaW5hbGl6ZWREYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3RoaXM0LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZnVuY3Rpb24gZm9yIGFkZCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsY2FsbGJhY2spXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkuYWRkKGRlZmF1bHREYXRhKTtcbiAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNvbm5lY3QgdHdvIG5vZGVzIHdpdGggYSBuZXcgZWRnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gc291cmNlTm9kZUlkXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSB0YXJnZXROb2RlSWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BlcmZvcm1BZGRFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtQWRkRWRnZShzb3VyY2VOb2RlSWQsIHRhcmdldE5vZGVJZCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHtcbiAgICAgICAgZnJvbTogc291cmNlTm9kZUlkLFxuICAgICAgICB0bzogdGFyZ2V0Tm9kZUlkXG4gICAgICB9O1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hZGRFZGdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGRFZGdlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5hZGRFZGdlKGRlZmF1bHREYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgIT09IG51bGwgJiYgZmluYWxpemVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIF90aGlzNS5pbk1vZGUgPT09IFwiYWRkRWRnZVwiKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGZvciB3aGF0ZXZlciByZWFzb24gdGhlIG1vZGUgaGFzIGNoYW5nZXMgKGR1ZSB0byBkYXRhc2V0IGNoYW5nZSkgZGlzcmVnYXJkIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICBfdGhpczUuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5hZGQoZmluYWxpemVkRGF0YSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM1LnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcblxuICAgICAgICAgICAgICBfdGhpczUuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgY29ubmVjdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsY2FsbGJhY2spXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkuYWRkKGRlZmF1bHREYXRhKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25uZWN0IHR3byBub2RlcyB3aXRoIGEgbmV3IGVkZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHNvdXJjZU5vZGVJZFxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gdGFyZ2V0Tm9kZUlkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wZXJmb3JtRWRpdEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1FZGl0RWRnZShzb3VyY2VOb2RlSWQsIHRhcmdldE5vZGVJZCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHtcbiAgICAgICAgaWQ6IHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQsXG4gICAgICAgIGZyb206IHNvdXJjZU5vZGVJZCxcbiAgICAgICAgdG86IHRhcmdldE5vZGVJZCxcbiAgICAgICAgbGFiZWw6IHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldCh0aGlzLmVkZ2VCZWluZ0VkaXRlZElkKS5sYWJlbFxuICAgICAgfTtcbiAgICAgIHZhciBlZUZ1bmN0ID0gdGhpcy5vcHRpb25zLmVkaXRFZGdlO1xuXG4gICAgICBpZiAoX3R5cGVvZihlZUZ1bmN0KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBlZUZ1bmN0ID0gZWVGdW5jdC5lZGl0V2l0aG91dERyYWc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZWVGdW5jdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChlZUZ1bmN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGVlRnVuY3QoZGVmYXVsdERhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICBpZiAoZmluYWxpemVkRGF0YSA9PT0gbnVsbCB8fCBmaW5hbGl6ZWREYXRhID09PSB1bmRlZmluZWQgfHwgX3RoaXM2LmluTW9kZSAhPT0gXCJlZGl0RWRnZVwiKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGZvciB3aGF0ZXZlciByZWFzb24gdGhlIG1vZGUgaGFzIGNoYW5nZXMgKGR1ZSB0byBkYXRhc2V0IGNoYW5nZSkgZGlzcmVnYXJkIHRoZSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBfdGhpczYuYm9keS5lZGdlc1tkZWZhdWx0RGF0YS5pZF0udXBkYXRlRWRnZVR5cGUoKTtcblxuICAgICAgICAgICAgICBfdGhpczYuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuXG4gICAgICAgICAgICAgIF90aGlzNi5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczYuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS51cGRhdGUoZmluYWxpemVkRGF0YSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM2LnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcblxuICAgICAgICAgICAgICBfdGhpczYuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgZWRpdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsIGNhbGxiYWNrKVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZShkZWZhdWx0RGF0YSk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFuaXB1bGF0aW9uU3lzdGVtO1xufSgpO1xuXG4vKipcclxuICogVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIHBvc3NpYmxlIG9wdGlvbnMuIEl0IHdpbGwgY2hlY2sgaWYgdGhlIHR5cGVzIGFyZSBjb3JyZWN0LCBpZiByZXF1aXJlZCBpZiB0aGUgb3B0aW9uIGlzIG9uZVxyXG4gKiBvZiB0aGUgYWxsb3dlZCB2YWx1ZXMuXHJcbiAqXHJcbiAqIF9fYW55X18gbWVhbnMgdGhhdCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgZG9lcyBub3QgbWF0dGVyLlxyXG4gKiBfX3R5cGVfXyBpcyBhIHJlcXVpcmVkIGZpZWxkIGZvciBhbGwgb2JqZWN0cyBhbmQgY29udGFpbnMgdGhlIGFsbG93ZWQgdHlwZXMgb2YgYWxsIG9iamVjdHNcclxuICovXG52YXIgc3RyaW5nID0gXCJzdHJpbmdcIjtcbnZhciBib29sID0gXCJib29sZWFuXCI7XG52YXIgbnVtYmVyID0gXCJudW1iZXJcIjtcbnZhciBhcnJheSA9IFwiYXJyYXlcIjtcbnZhciBvYmplY3QgPSBcIm9iamVjdFwiOyAvLyBzaG91bGQgb25seSBiZSBpbiBhIF9fdHlwZV9fIHByb3BlcnR5XG5cbnZhciBkb20gPSBcImRvbVwiO1xudmFyIGFueSA9IFwiYW55XCI7IC8vIExpc3Qgb2YgZW5kcG9pbnRzXG5cbnZhciBlbmRQb2ludHMgPSBbXCJhcnJvd1wiLCBcImJhclwiLCBcImJveFwiLCBcImNpcmNsZVwiLCBcImNyb3dcIiwgXCJjdXJ2ZVwiLCBcImRpYW1vbmRcIiwgXCJpbWFnZVwiLCBcImludl9jdXJ2ZVwiLCBcImludl90cmlhbmdsZVwiLCBcInRyaWFuZ2xlXCIsIFwidmVlXCJdO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uIC0tIFRoZSBfXypfXyBmb3JtYXQgaXMgdXNlZCB0byBwcmV2ZW50IGNvbGxpc2lvbnMgd2l0aCBhY3R1YWwgb3B0aW9uIG5hbWVzLiAqL1xuXG52YXIgbm9kZU9wdGlvbnMgPSB7XG4gIGJvcmRlcldpZHRoOiB7XG4gICAgbnVtYmVyOiBudW1iZXJcbiAgfSxcbiAgYm9yZGVyV2lkdGhTZWxlY3RlZDoge1xuICAgIG51bWJlcjogbnVtYmVyLFxuICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICB9LFxuICBicm9rZW5JbWFnZToge1xuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICB9LFxuICBjaG9zZW46IHtcbiAgICBsYWJlbDoge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIG5vZGU6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sXG4gICAgfVxuICB9LFxuICBjb2xvcjoge1xuICAgIGJvcmRlcjoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGJhY2tncm91bmQ6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBoaWdobGlnaHQ6IHtcbiAgICAgIGJvcmRlcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIGhvdmVyOiB7XG4gICAgICBib3JkZXI6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH1cbiAgfSxcbiAgb3BhY2l0eToge1xuICAgIG51bWJlcjogbnVtYmVyLFxuICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICB9LFxuICBmaXhlZDoge1xuICAgIHg6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9XG4gIH0sXG4gIGZvbnQ6IHtcbiAgICBhbGlnbjoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGZhY2U6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgc3Ryb2tlV2lkdGg6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBzdHJva2VDb2xvcjoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIHZhZGp1c3Q6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBtdWx0aToge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBib2xkOiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBmYWNlOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgbW9kOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgdmFkanVzdDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgYm9sZGl0YWw6IHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGZhY2U6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBtb2Q6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICB2YWRqdXN0OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICBpdGFsOiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBmYWNlOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgbW9kOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgdmFkanVzdDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgbW9ubzoge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZmFjZToge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIG1vZDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfVxuICB9LFxuICBncm91cDoge1xuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIG51bWJlcjogbnVtYmVyLFxuICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICB9LFxuICBoZWlnaHRDb25zdHJhaW50OiB7XG4gICAgbWluaW11bToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHZhbGlnbjoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH1cbiAgfSxcbiAgaGlkZGVuOiB7XG4gICAgYm9vbGVhbjogYm9vbFxuICB9LFxuICBpY29uOiB7XG4gICAgZmFjZToge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGNvZGU6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICB3ZWlnaHQ6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgaWQ6IHtcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICBudW1iZXI6IG51bWJlclxuICB9LFxuICBpbWFnZToge1xuICAgIHNlbGVjdGVkOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgdW5zZWxlY3RlZDoge1xuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfVxuICB9LFxuICBpbWFnZVBhZGRpbmc6IHtcbiAgICB0b3A6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH1cbiAgfSxcbiAgbGFiZWw6IHtcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgfSxcbiAgbGFiZWxIaWdobGlnaHRCb2xkOiB7XG4gICAgYm9vbGVhbjogYm9vbFxuICB9LFxuICBsZXZlbDoge1xuICAgIG51bWJlcjogbnVtYmVyLFxuICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICB9LFxuICBtYXJnaW46IHtcbiAgICB0b3A6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH1cbiAgfSxcbiAgbWFzczoge1xuICAgIG51bWJlcjogbnVtYmVyXG4gIH0sXG4gIHBoeXNpY3M6IHtcbiAgICBib29sZWFuOiBib29sXG4gIH0sXG4gIHNjYWxpbmc6IHtcbiAgICBtaW46IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBtYXg6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBsYWJlbDoge1xuICAgICAgZW5hYmxlZDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgbWluOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbWF4OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbWF4VmlzaWJsZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGRyYXdUaHJlc2hvbGQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOiB7XG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9XG4gIH0sXG4gIHNoYWRvdzoge1xuICAgIGVuYWJsZWQ6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHg6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH1cbiAgfSxcbiAgc2hhcGU6IHtcbiAgICBzdHJpbmc6IFtcImN1c3RvbVwiLCBcImVsbGlwc2VcIiwgXCJjaXJjbGVcIiwgXCJkYXRhYmFzZVwiLCBcImJveFwiLCBcInRleHRcIiwgXCJpbWFnZVwiLCBcImNpcmN1bGFySW1hZ2VcIiwgXCJkaWFtb25kXCIsIFwiZG90XCIsIFwic3RhclwiLCBcInRyaWFuZ2xlXCIsIFwidHJpYW5nbGVEb3duXCIsIFwic3F1YXJlXCIsIFwiaWNvblwiLCBcImhleGFnb25cIl1cbiAgfSxcbiAgY3R4UmVuZGVyZXI6IHtcbiAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHNoYXBlUHJvcGVydGllczoge1xuICAgIGJvcmRlckRhc2hlczoge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGFycmF5OiBhcnJheVxuICAgIH0sXG4gICAgYm9yZGVyUmFkaXVzOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgdXNlSW1hZ2VTaXplOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICB1c2VCb3JkZXJXaXRoSW1hZ2U6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGNvb3JkaW5hdGVPcmlnaW46IHtcbiAgICAgIHN0cmluZzogW1wiY2VudGVyXCIsIFwidG9wLWxlZnRcIl1cbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgc2l6ZToge1xuICAgIG51bWJlcjogbnVtYmVyXG4gIH0sXG4gIHRpdGxlOiB7XG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgZG9tOiBkb20sXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIHZhbHVlOiB7XG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIHdpZHRoQ29uc3RyYWludDoge1xuICAgIG1pbmltdW06IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBtYXhpbXVtOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfVxuICB9LFxuICB4OiB7XG4gICAgbnVtYmVyOiBudW1iZXJcbiAgfSxcbiAgeToge1xuICAgIG51bWJlcjogbnVtYmVyXG4gIH0sXG4gIF9fdHlwZV9fOiB7XG4gICAgb2JqZWN0OiBvYmplY3RcbiAgfVxufTtcbnZhciBhbGxPcHRpb25zID0ge1xuICBjb25maWd1cmU6IHtcbiAgICBlbmFibGVkOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBmaWx0ZXI6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIGFycmF5OiBhcnJheSxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGNvbnRhaW5lcjoge1xuICAgICAgZG9tOiBkb21cbiAgICB9LFxuICAgIHNob3dCdXR0b246IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIGFycmF5OiBhcnJheSxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9XG4gIH0sXG4gIGVkZ2VzOiB7XG4gICAgYXJyb3dzOiB7XG4gICAgICB0bzoge1xuICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9LFxuICAgICAgICBzY2FsZUZhY3Rvcjoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICBzdHJpbmc6IGVuZFBvaW50c1xuICAgICAgICB9LFxuICAgICAgICBpbWFnZUhlaWdodDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlV2lkdGg6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBzcmM6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1pZGRsZToge1xuICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9LFxuICAgICAgICBzY2FsZUZhY3Rvcjoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICBzdHJpbmc6IGVuZFBvaW50c1xuICAgICAgICB9LFxuICAgICAgICBpbWFnZVdpZHRoOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2VIZWlnaHQ6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBzcmM6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZyb206IHtcbiAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgc3RyaW5nOiBlbmRQb2ludHNcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2VXaWR0aDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlSGVpZ2h0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgc3JjOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBzdHJpbmc6IFtcImZyb21cIiwgXCJ0b1wiLCBcIm1pZGRsZVwiXSxcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIGVuZFBvaW50T2Zmc2V0OiB7XG4gICAgICBmcm9tOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgdG86IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH1cbiAgICB9LFxuICAgIGFycm93U3RyaWtldGhyb3VnaDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgYmFja2dyb3VuZDoge1xuICAgICAgZW5hYmxlZDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZGFzaGVzOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIGFycmF5OiBhcnJheVxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICBjaG9zZW46IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICBlZGdlOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBpbmhlcml0OiB7XG4gICAgICAgIHN0cmluZzogW1wiZnJvbVwiLCBcInRvXCIsIFwiYm90aFwiXSxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhc2hlczoge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGFycmF5OiBhcnJheVxuICAgIH0sXG4gICAgZm9udDoge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZmFjZToge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzdHJva2VXaWR0aDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHN0cm9rZUNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgYWxpZ246IHtcbiAgICAgICAgc3RyaW5nOiBbXCJob3Jpem9udGFsXCIsIFwidG9wXCIsIFwibWlkZGxlXCIsIFwiYm90dG9tXCJdXG4gICAgICB9LFxuICAgICAgdmFkanVzdDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIG11bHRpOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgYm9sZDoge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBmYWNlOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgbW9kOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgdmFkanVzdDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJvbGRpdGFsOiB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGZhY2U6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBtb2Q6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICB2YWRqdXN0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXRhbDoge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBmYWNlOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgbW9kOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgdmFkanVzdDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1vbm86IHtcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgZmFjZToge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIG1vZDoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIGhpZGRlbjoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgaG92ZXJXaWR0aDoge1xuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIixcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBsYWJlbDoge1xuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgbGVuZ3RoOiB7XG4gICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgcGh5c2ljczoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgc2NhbGluZzoge1xuICAgICAgbWluOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbWF4OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfSxcbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgbWF4VmlzaWJsZToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGRyYXdUaHJlc2hvbGQ6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGN1c3RvbVNjYWxpbmdGdW5jdGlvbjoge1xuICAgICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdGlvbldpZHRoOiB7XG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiLFxuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHNlbGZSZWZlcmVuY2VTaXplOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgc2VsZlJlZmVyZW5jZToge1xuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGFuZ2xlOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgcmVuZGVyQmVoaW5kVGhlTm9kZToge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgeDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgc21vb3RoOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICB0eXBlOiB7XG4gICAgICAgIHN0cmluZzogW1wiZHluYW1pY1wiLCBcImNvbnRpbnVvdXNcIiwgXCJkaXNjcmV0ZVwiLCBcImRpYWdvbmFsQ3Jvc3NcIiwgXCJzdHJhaWdodENyb3NzXCIsIFwiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCIsIFwiY3VydmVkQ1dcIiwgXCJjdXJ2ZWRDQ1dcIiwgXCJjdWJpY0JlemllclwiXVxuICAgICAgfSxcbiAgICAgIHJvdW5kbmVzczoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGZvcmNlRGlyZWN0aW9uOiB7XG4gICAgICAgIHN0cmluZzogW1wiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCIsIFwibm9uZVwiXSxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICB0aXRsZToge1xuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIHdpZHRoOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgd2lkdGhDb25zdHJhaW50OiB7XG4gICAgICBtYXhpbXVtOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9XG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgZ3JvdXBzOiB7XG4gICAgdXNlRGVmYXVsdEdyb3Vwczoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgX19hbnlfXzogbm9kZU9wdGlvbnMsXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBpbnRlcmFjdGlvbjoge1xuICAgIGRyYWdOb2Rlczoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgZHJhZ1ZpZXc6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGhpZGVFZGdlc09uRHJhZzoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgaGlkZUVkZ2VzT25ab29tOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBoaWRlTm9kZXNPbkRyYWc6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGhvdmVyOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBrZXlib2FyZDoge1xuICAgICAgZW5hYmxlZDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgc3BlZWQ6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICB6b29tOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmluZFRvV2luZG93OiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBhdXRvRm9jdXM6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICBtdWx0aXNlbGVjdDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgbmF2aWdhdGlvbkJ1dHRvbnM6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHNlbGVjdGFibGU6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHNlbGVjdENvbm5lY3RlZEVkZ2VzOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBob3ZlckNvbm5lY3RlZEVkZ2VzOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICB0b29sdGlwRGVsYXk6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICB6b29tVmlldzoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgem9vbVNwZWVkOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBsYXlvdXQ6IHtcbiAgICByYW5kb21TZWVkOiB7XG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCIsXG4gICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBpbXByb3ZlZExheW91dDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgY2x1c3RlclRocmVzaG9sZDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGhpZXJhcmNoaWNhbDoge1xuICAgICAgZW5hYmxlZDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgbGV2ZWxTZXBhcmF0aW9uOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbm9kZVNwYWNpbmc6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICB0cmVlU3BhY2luZzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGJsb2NrU2hpZnRpbmc6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIGVkZ2VNaW5pbWl6YXRpb246IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBkaXJlY3Rpb246IHtcbiAgICAgICAgc3RyaW5nOiBbXCJVRFwiLCBcIkRVXCIsIFwiTFJcIiwgXCJSTFwiXVxuICAgICAgfSxcbiAgICAgIHNvcnRNZXRob2Q6IHtcbiAgICAgICAgc3RyaW5nOiBbXCJodWJzaXplXCIsIFwiZGlyZWN0ZWRcIl1cbiAgICAgIH0sXG4gICAgICBzaGFrZVRvd2FyZHM6IHtcbiAgICAgICAgc3RyaW5nOiBbXCJsZWF2ZXNcIiwgXCJyb290c1wiXVxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9XG4gIH0sXG4gIG1hbmlwdWxhdGlvbjoge1xuICAgIGVuYWJsZWQ6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGluaXRpYWxseUFjdGl2ZToge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgYWRkTm9kZToge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGFkZEVkZ2U6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBlZGl0Tm9kZToge1xuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgZWRpdEVkZ2U6IHtcbiAgICAgIGVkaXRXaXRob3V0RHJhZzoge1xuICAgICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbGV0ZU5vZGU6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBkZWxldGVFZGdlOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgY29udHJvbE5vZGVTdHlsZTogbm9kZU9wdGlvbnMsXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH1cbiAgfSxcbiAgbm9kZXM6IG5vZGVPcHRpb25zLFxuICBwaHlzaWNzOiB7XG4gICAgZW5hYmxlZDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgYmFybmVzSHV0OiB7XG4gICAgICB0aGV0YToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nTGVuZ3RoOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBkYW1waW5nOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgYXZvaWRPdmVybGFwOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIGZvcmNlQXRsYXMyQmFzZWQ6IHtcbiAgICAgIHRoZXRhOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgY2VudHJhbEdyYXZpdHk6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdMZW5ndGg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdDb25zdGFudDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGRhbXBpbmc6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBhdm9pZE92ZXJsYXA6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgcmVwdWxzaW9uOiB7XG4gICAgICBjZW50cmFsR3Jhdml0eToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0xlbmd0aDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbm9kZURpc3RhbmNlOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZGFtcGluZzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBoaWVyYXJjaGljYWxSZXB1bHNpb246IHtcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nTGVuZ3RoOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBub2RlRGlzdGFuY2U6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBkYW1waW5nOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgYXZvaWRPdmVybGFwOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIG1heFZlbG9jaXR5OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgbWluVmVsb2NpdHk6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBzb2x2ZXI6IHtcbiAgICAgIHN0cmluZzogW1wiYmFybmVzSHV0XCIsIFwicmVwdWxzaW9uXCIsIFwiaGllcmFyY2hpY2FsUmVwdWxzaW9uXCIsIFwiZm9yY2VBdGxhczJCYXNlZFwiXVxuICAgIH0sXG4gICAgc3RhYmlsaXphdGlvbjoge1xuICAgICAgZW5hYmxlZDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgaXRlcmF0aW9uczoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHVwZGF0ZUludGVydmFsOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgb25seUR5bmFtaWNFZGdlczoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgZml0OiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgdGltZXN0ZXA6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBhZGFwdGl2ZVRpbWVzdGVwOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICB3aW5kOiB7XG4gICAgICB4OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sXG4gICAgfVxuICB9LFxuICAvL2dsb2JhbHMgOlxuICBhdXRvUmVzaXplOiB7XG4gICAgYm9vbGVhbjogYm9vbFxuICB9LFxuICBjbGlja1RvVXNlOiB7XG4gICAgYm9vbGVhbjogYm9vbFxuICB9LFxuICBsb2NhbGU6IHtcbiAgICBzdHJpbmc6IHN0cmluZ1xuICB9LFxuICBsb2NhbGVzOiB7XG4gICAgX19hbnlfXzoge1xuICAgICAgYW55OiBhbnlcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgaGVpZ2h0OiB7XG4gICAgc3RyaW5nOiBzdHJpbmdcbiAgfSxcbiAgd2lkdGg6IHtcbiAgICBzdHJpbmc6IHN0cmluZ1xuICB9LFxuICBfX3R5cGVfXzoge1xuICAgIG9iamVjdDogb2JqZWN0XG4gIH1cbn07XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuXG4vKipcclxuICogVGhpcyBwcm92aWRlcyByYW5nZXMsIGluaXRpYWwgdmFsdWVzLCBzdGVwcyBhbmQgZHJvcGRvd24gbWVudSBjaG9pY2VzIGZvciB0aGVcclxuICogY29uZmlndXJhdGlvbi5cclxuICpcclxuICogQHJlbWFya3NcclxuICogQ2hlY2tib3g6IGBib29sZWFuYFxyXG4gKiAgIFRoZSB2YWx1ZSBzdXBsbGllZCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUuXHJcbiAqXHJcbiAqIFRleHQgZmllbGQ6IGBzdHJpbmdgXHJcbiAqICAgVGhlIHBhc3NlZCB0ZXh0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS4gQW55IHRleHQgd2lsbCBiZVxyXG4gKiAgIGFjY2VwdGVkIGFmdGVyd2FyZHMuXHJcbiAqXHJcbiAqIE51bWJlciByYW5nZTogYFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdYFxyXG4gKiAgIFRoZSBtZWFuaW5ncyBhcmUgYFtpbml0aWFsIHZhbHVlLCBtaW4sIG1heCwgc3RlcF1gLlxyXG4gKlxyXG4gKiBEcm9wZG93bjogYFtFeGNsdWRlPHN0cmluZywgXCJjb2xvclwiPiwgLi4uKHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4pW11dYFxyXG4gKiAgIFRyYW5zbGF0aW9ucyBmb3IgcGVvcGxlIHdpdGggcG9vciB1bmRlcnN0YW5kaW5nIG9mIFR5cGVTY3JpcHQ6IHRoZSBmaXJzdFxyXG4gKiAgIHZhbHVlIGFsd2F5cyBoYXMgdG8gYmUgYSBzdHJpbmcgYnV0IG5ldmVyIGBcImNvbG9yXCJgLCB0aGUgcmVzdCBjYW4gYmUgYW55XHJcbiAqICAgY29tYmluYXRpb24gb2Ygc3RyaW5ncywgbnVtYmVycyBhbmQgYm9vbGVhbnMuXHJcbiAqXHJcbiAqIENvbG9yIHBpY2tlcjogYFtcImNvbG9yXCIsIHN0cmluZ11gXHJcbiAqICAgVGhlIGZpcnN0IHZhbHVlIHNheXMgdGhpcyB3aWxsIGJlIGEgY29sb3IgcGlja2VyIG5vdCBhIGRyb3Bkb3duIG1lbnUuIFRoZVxyXG4gKiAgIG5leHQgdmFsdWUgaXMgdGhlIGluaXRpYWwgY29sb3IuXHJcbiAqL1xuXG52YXIgY29uZmlndXJlT3B0aW9ucyA9IHtcbiAgbm9kZXM6IHtcbiAgICBib3JkZXJXaWR0aDogWzEsIDAsIDEwLCAxXSxcbiAgICBib3JkZXJXaWR0aFNlbGVjdGVkOiBbMiwgMCwgMTAsIDFdLFxuICAgIGNvbG9yOiB7XG4gICAgICBib3JkZXI6IFtcImNvbG9yXCIsIFwiIzJCN0NFOVwiXSxcbiAgICAgIGJhY2tncm91bmQ6IFtcImNvbG9yXCIsIFwiIzk3QzJGQ1wiXSxcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFtcImNvbG9yXCIsIFwiIzJCN0NFOVwiXSxcbiAgICAgICAgYmFja2dyb3VuZDogW1wiY29sb3JcIiwgXCIjRDJFNUZGXCJdXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBbXCJjb2xvclwiLCBcIiMyQjdDRTlcIl0sXG4gICAgICAgIGJhY2tncm91bmQ6IFtcImNvbG9yXCIsIFwiI0QyRTVGRlwiXVxuICAgICAgfVxuICAgIH0sXG4gICAgb3BhY2l0eTogWzAsIDAsIDEsIDAuMV0sXG4gICAgZml4ZWQ6IHtcbiAgICAgIHg6IGZhbHNlLFxuICAgICAgeTogZmFsc2VcbiAgICB9LFxuICAgIGZvbnQ6IHtcbiAgICAgIGNvbG9yOiBbXCJjb2xvclwiLCBcIiMzNDM0MzRcIl0sXG4gICAgICBzaXplOiBbMTQsIDAsIDEwMCwgMV0sXG4gICAgICBmYWNlOiBbXCJhcmlhbFwiLCBcInZlcmRhbmFcIiwgXCJ0YWhvbWFcIl0sXG4gICAgICBiYWNrZ3JvdW5kOiBbXCJjb2xvclwiLCBcIm5vbmVcIl0sXG4gICAgICBzdHJva2VXaWR0aDogWzAsIDAsIDUwLCAxXSxcbiAgICAgIHN0cm9rZUNvbG9yOiBbXCJjb2xvclwiLCBcIiNmZmZmZmZcIl1cbiAgICB9LFxuICAgIC8vZ3JvdXA6ICdzdHJpbmcnLFxuICAgIGhpZGRlbjogZmFsc2UsXG4gICAgbGFiZWxIaWdobGlnaHRCb2xkOiB0cnVlLFxuICAgIC8vaWNvbjoge1xuICAgIC8vICBmYWNlOiAnc3RyaW5nJywgIC8vJ0ZvbnRBd2Vzb21lJyxcbiAgICAvLyAgY29kZTogJ3N0cmluZycsICAvLydcXHVmMDA3JyxcbiAgICAvLyAgc2l6ZTogWzUwLCAwLCAyMDAsIDFdLCAgLy81MCxcbiAgICAvLyAgY29sb3I6IFsnY29sb3InLCcjMkI3Q0U5J10gICAvLycjYWEwMGZmJ1xuICAgIC8vfSxcbiAgICAvL2ltYWdlOiAnc3RyaW5nJywgLy8gLS0+IFVSTFxuICAgIHBoeXNpY3M6IHRydWUsXG4gICAgc2NhbGluZzoge1xuICAgICAgbWluOiBbMTAsIDAsIDIwMCwgMV0sXG4gICAgICBtYXg6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBtaW46IFsxNCwgMCwgMjAwLCAxXSxcbiAgICAgICAgbWF4OiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgIG1heFZpc2libGU6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgZHJhd1RocmVzaG9sZDogWzUsIDAsIDIwLCAxXVxuICAgICAgfVxuICAgIH0sXG4gICAgc2hhZG93OiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGNvbG9yOiBcInJnYmEoMCwwLDAsMC41KVwiLFxuICAgICAgc2l6ZTogWzEwLCAwLCAyMCwgMV0sXG4gICAgICB4OiBbNSwgLTMwLCAzMCwgMV0sXG4gICAgICB5OiBbNSwgLTMwLCAzMCwgMV1cbiAgICB9LFxuICAgIHNoYXBlOiBbXCJlbGxpcHNlXCIsIFwiYm94XCIsIFwiY2lyY2xlXCIsIFwiZGF0YWJhc2VcIiwgXCJkaWFtb25kXCIsIFwiZG90XCIsIFwic3F1YXJlXCIsIFwic3RhclwiLCBcInRleHRcIiwgXCJ0cmlhbmdsZVwiLCBcInRyaWFuZ2xlRG93blwiLCBcImhleGFnb25cIl0sXG4gICAgc2hhcGVQcm9wZXJ0aWVzOiB7XG4gICAgICBib3JkZXJEYXNoZXM6IGZhbHNlLFxuICAgICAgYm9yZGVyUmFkaXVzOiBbNiwgMCwgMjAsIDFdLFxuICAgICAgaW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgIHVzZUltYWdlU2l6ZTogZmFsc2VcbiAgICB9LFxuICAgIHNpemU6IFsyNSwgMCwgMjAwLCAxXVxuICB9LFxuICBlZGdlczoge1xuICAgIGFycm93czoge1xuICAgICAgdG86IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNjYWxlRmFjdG9yOiBbMSwgMCwgMywgMC4wNV0sXG4gICAgICAgIHR5cGU6IFwiYXJyb3dcIlxuICAgICAgfSxcbiAgICAgIG1pZGRsZToge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IFsxLCAwLCAzLCAwLjA1XSxcbiAgICAgICAgdHlwZTogXCJhcnJvd1wiXG4gICAgICB9LFxuICAgICAgZnJvbToge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IFsxLCAwLCAzLCAwLjA1XSxcbiAgICAgICAgdHlwZTogXCJhcnJvd1wiXG4gICAgICB9XG4gICAgfSxcbiAgICBlbmRQb2ludE9mZnNldDoge1xuICAgICAgZnJvbTogWzAsIC0xMCwgMTAsIDFdLFxuICAgICAgdG86IFswLCAtMTAsIDEwLCAxXVxuICAgIH0sXG4gICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB0cnVlLFxuICAgIGNvbG9yOiB7XG4gICAgICBjb2xvcjogW1wiY29sb3JcIiwgXCIjODQ4NDg0XCJdLFxuICAgICAgaGlnaGxpZ2h0OiBbXCJjb2xvclwiLCBcIiM4NDg0ODRcIl0sXG4gICAgICBob3ZlcjogW1wiY29sb3JcIiwgXCIjODQ4NDg0XCJdLFxuICAgICAgaW5oZXJpdDogW1wiZnJvbVwiLCBcInRvXCIsIFwiYm90aFwiLCB0cnVlLCBmYWxzZV0sXG4gICAgICBvcGFjaXR5OiBbMSwgMCwgMSwgMC4wNV1cbiAgICB9LFxuICAgIGRhc2hlczogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgY29sb3I6IFtcImNvbG9yXCIsIFwiIzM0MzQzNFwiXSxcbiAgICAgIHNpemU6IFsxNCwgMCwgMTAwLCAxXSxcbiAgICAgIGZhY2U6IFtcImFyaWFsXCIsIFwidmVyZGFuYVwiLCBcInRhaG9tYVwiXSxcbiAgICAgIGJhY2tncm91bmQ6IFtcImNvbG9yXCIsIFwibm9uZVwiXSxcbiAgICAgIHN0cm9rZVdpZHRoOiBbMiwgMCwgNTAsIDFdLFxuICAgICAgc3Ryb2tlQ29sb3I6IFtcImNvbG9yXCIsIFwiI2ZmZmZmZlwiXSxcbiAgICAgIGFsaWduOiBbXCJob3Jpem9udGFsXCIsIFwidG9wXCIsIFwibWlkZGxlXCIsIFwiYm90dG9tXCJdXG4gICAgfSxcbiAgICBoaWRkZW46IGZhbHNlLFxuICAgIGhvdmVyV2lkdGg6IFsxLjUsIDAsIDUsIDAuMV0sXG4gICAgbGFiZWxIaWdobGlnaHRCb2xkOiB0cnVlLFxuICAgIHBoeXNpY3M6IHRydWUsXG4gICAgc2NhbGluZzoge1xuICAgICAgbWluOiBbMSwgMCwgMTAwLCAxXSxcbiAgICAgIG1heDogWzE1LCAwLCAxMDAsIDFdLFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgbWluOiBbMTQsIDAsIDIwMCwgMV0sXG4gICAgICAgIG1heDogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgICBtYXhWaXNpYmxlOiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgIGRyYXdUaHJlc2hvbGQ6IFs1LCAwLCAyMCwgMV1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdGlvbldpZHRoOiBbMS41LCAwLCA1LCAwLjFdLFxuICAgIHNlbGZSZWZlcmVuY2VTaXplOiBbMjAsIDAsIDIwMCwgMV0sXG4gICAgc2VsZlJlZmVyZW5jZToge1xuICAgICAgc2l6ZTogWzIwLCAwLCAyMDAsIDFdLFxuICAgICAgYW5nbGU6IFtNYXRoLlBJIC8gMiwgLTYgKiBNYXRoLlBJLCA2ICogTWF0aC5QSSwgTWF0aC5QSSAvIDhdLFxuICAgICAgcmVuZGVyQmVoaW5kVGhlTm9kZTogdHJ1ZVxuICAgIH0sXG4gICAgc2hhZG93OiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGNvbG9yOiBcInJnYmEoMCwwLDAsMC41KVwiLFxuICAgICAgc2l6ZTogWzEwLCAwLCAyMCwgMV0sXG4gICAgICB4OiBbNSwgLTMwLCAzMCwgMV0sXG4gICAgICB5OiBbNSwgLTMwLCAzMCwgMV1cbiAgICB9LFxuICAgIHNtb290aDoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIHR5cGU6IFtcImR5bmFtaWNcIiwgXCJjb250aW51b3VzXCIsIFwiZGlzY3JldGVcIiwgXCJkaWFnb25hbENyb3NzXCIsIFwic3RyYWlnaHRDcm9zc1wiLCBcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiLCBcImN1cnZlZENXXCIsIFwiY3VydmVkQ0NXXCIsIFwiY3ViaWNCZXppZXJcIl0sXG4gICAgICBmb3JjZURpcmVjdGlvbjogW1wiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCIsIFwibm9uZVwiXSxcbiAgICAgIHJvdW5kbmVzczogWzAuNSwgMCwgMSwgMC4wNV1cbiAgICB9LFxuICAgIHdpZHRoOiBbMSwgMCwgMzAsIDFdXG4gIH0sXG4gIGxheW91dDoge1xuICAgIC8vcmFuZG9tU2VlZDogWzAsIDAsIDUwMCwgMV0sXG4gICAgLy9pbXByb3ZlZExheW91dDogdHJ1ZSxcbiAgICBoaWVyYXJjaGljYWw6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgbGV2ZWxTZXBhcmF0aW9uOiBbMTUwLCAyMCwgNTAwLCA1XSxcbiAgICAgIG5vZGVTcGFjaW5nOiBbMTAwLCAyMCwgNTAwLCA1XSxcbiAgICAgIHRyZWVTcGFjaW5nOiBbMjAwLCAyMCwgNTAwLCA1XSxcbiAgICAgIGJsb2NrU2hpZnRpbmc6IHRydWUsXG4gICAgICBlZGdlTWluaW1pemF0aW9uOiB0cnVlLFxuICAgICAgcGFyZW50Q2VudHJhbGl6YXRpb246IHRydWUsXG4gICAgICBkaXJlY3Rpb246IFtcIlVEXCIsIFwiRFVcIiwgXCJMUlwiLCBcIlJMXCJdLFxuICAgICAgc29ydE1ldGhvZDogW1wiaHVic2l6ZVwiLCBcImRpcmVjdGVkXCJdLFxuICAgICAgc2hha2VUb3dhcmRzOiBbXCJsZWF2ZXNcIiwgXCJyb290c1wiXSAvLyBsZWF2ZXMsIHJvb3RzXG5cbiAgICB9XG4gIH0sXG4gIGludGVyYWN0aW9uOiB7XG4gICAgZHJhZ05vZGVzOiB0cnVlLFxuICAgIGRyYWdWaWV3OiB0cnVlLFxuICAgIGhpZGVFZGdlc09uRHJhZzogZmFsc2UsXG4gICAgaGlkZUVkZ2VzT25ab29tOiBmYWxzZSxcbiAgICBoaWRlTm9kZXNPbkRyYWc6IGZhbHNlLFxuICAgIGhvdmVyOiBmYWxzZSxcbiAgICBrZXlib2FyZDoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBzcGVlZDoge1xuICAgICAgICB4OiBbMTAsIDAsIDQwLCAxXSxcbiAgICAgICAgeTogWzEwLCAwLCA0MCwgMV0sXG4gICAgICAgIHpvb206IFswLjAyLCAwLCAwLjEsIDAuMDA1XVxuICAgICAgfSxcbiAgICAgIGJpbmRUb1dpbmRvdzogdHJ1ZSxcbiAgICAgIGF1dG9Gb2N1czogdHJ1ZVxuICAgIH0sXG4gICAgbXVsdGlzZWxlY3Q6IGZhbHNlLFxuICAgIG5hdmlnYXRpb25CdXR0b25zOiBmYWxzZSxcbiAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgIHNlbGVjdENvbm5lY3RlZEVkZ2VzOiB0cnVlLFxuICAgIGhvdmVyQ29ubmVjdGVkRWRnZXM6IHRydWUsXG4gICAgdG9vbHRpcERlbGF5OiBbMzAwLCAwLCAxMDAwLCAyNV0sXG4gICAgem9vbVZpZXc6IHRydWUsXG4gICAgem9vbVNwZWVkOiBbMSwgMC4xLCAyLCAwLjFdXG4gIH0sXG4gIG1hbmlwdWxhdGlvbjoge1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIGluaXRpYWxseUFjdGl2ZTogZmFsc2VcbiAgfSxcbiAgcGh5c2ljczoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgYmFybmVzSHV0OiB7XG4gICAgICB0aGV0YTogWzAuNSwgMC4xLCAxLCAwLjA1XSxcbiAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogWy0yMDAwLCAtMzAwMDAsIDAsIDUwXSxcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4zLCAwLCAxMCwgMC4wNV0sXG4gICAgICBzcHJpbmdMZW5ndGg6IFs5NSwgMCwgNTAwLCA1XSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiBbMC4wNCwgMCwgMS4yLCAwLjAwNV0sXG4gICAgICBkYW1waW5nOiBbMC4wOSwgMCwgMSwgMC4wMV0sXG4gICAgICBhdm9pZE92ZXJsYXA6IFswLCAwLCAxLCAwLjAxXVxuICAgIH0sXG4gICAgZm9yY2VBdGxhczJCYXNlZDoge1xuICAgICAgdGhldGE6IFswLjUsIDAuMSwgMSwgMC4wNV0sXG4gICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IFstNTAsIC01MDAsIDAsIDFdLFxuICAgICAgY2VudHJhbEdyYXZpdHk6IFswLjAxLCAwLCAxLCAwLjAwNV0sXG4gICAgICBzcHJpbmdMZW5ndGg6IFs5NSwgMCwgNTAwLCA1XSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiBbMC4wOCwgMCwgMS4yLCAwLjAwNV0sXG4gICAgICBkYW1waW5nOiBbMC40LCAwLCAxLCAwLjAxXSxcbiAgICAgIGF2b2lkT3ZlcmxhcDogWzAsIDAsIDEsIDAuMDFdXG4gICAgfSxcbiAgICByZXB1bHNpb246IHtcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4yLCAwLCAxMCwgMC4wNV0sXG4gICAgICBzcHJpbmdMZW5ndGg6IFsyMDAsIDAsIDUwMCwgNV0sXG4gICAgICBzcHJpbmdDb25zdGFudDogWzAuMDUsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgbm9kZURpc3RhbmNlOiBbMTAwLCAwLCA1MDAsIDVdLFxuICAgICAgZGFtcGluZzogWzAuMDksIDAsIDEsIDAuMDFdXG4gICAgfSxcbiAgICBoaWVyYXJjaGljYWxSZXB1bHNpb246IHtcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4yLCAwLCAxMCwgMC4wNV0sXG4gICAgICBzcHJpbmdMZW5ndGg6IFsxMDAsIDAsIDUwMCwgNV0sXG4gICAgICBzcHJpbmdDb25zdGFudDogWzAuMDEsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgbm9kZURpc3RhbmNlOiBbMTIwLCAwLCA1MDAsIDVdLFxuICAgICAgZGFtcGluZzogWzAuMDksIDAsIDEsIDAuMDFdLFxuICAgICAgYXZvaWRPdmVybGFwOiBbMCwgMCwgMSwgMC4wMV1cbiAgICB9LFxuICAgIG1heFZlbG9jaXR5OiBbNTAsIDAsIDE1MCwgMV0sXG4gICAgbWluVmVsb2NpdHk6IFswLjEsIDAuMDEsIDAuNSwgMC4wMV0sXG4gICAgc29sdmVyOiBbXCJiYXJuZXNIdXRcIiwgXCJmb3JjZUF0bGFzMkJhc2VkXCIsIFwicmVwdWxzaW9uXCIsIFwiaGllcmFyY2hpY2FsUmVwdWxzaW9uXCJdLFxuICAgIHRpbWVzdGVwOiBbMC41LCAwLjAxLCAxLCAwLjAxXSxcbiAgICB3aW5kOiB7XG4gICAgICB4OiBbMCwgLTEwLCAxMCwgMC4xXSxcbiAgICAgIHk6IFswLCAtMTAsIDEwLCAwLjFdXG4gICAgfSAvL2FkYXB0aXZlVGltZXN0ZXA6IHRydWVcblxuICB9XG59O1xudmFyIGNvbmZpZ3VyYXRvckhpZGVPcHRpb24gPSBmdW5jdGlvbiBjb25maWd1cmF0b3JIaWRlT3B0aW9uKHBhcmVudFBhdGgsIG9wdGlvbk5hbWUsIG9wdGlvbnMpIHtcbiAgdmFyIF9jb250ZXh0O1xuXG4gIGlmIChpbmNsdWRlcyhwYXJlbnRQYXRoKS5jYWxsKHBhcmVudFBhdGgsIFwicGh5c2ljc1wiKSAmJiBpbmNsdWRlcyhfY29udGV4dCA9IGNvbmZpZ3VyZU9wdGlvbnMucGh5c2ljcy5zb2x2ZXIpLmNhbGwoX2NvbnRleHQsIG9wdGlvbk5hbWUpICYmIG9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgIT09IG9wdGlvbk5hbWUgJiYgb3B0aW9uTmFtZSAhPT0gXCJ3aW5kXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBvcHRpb25zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGNvbmZpZ3VyYXRvckhpZGVPcHRpb246IGNvbmZpZ3VyYXRvckhpZGVPcHRpb24sXG5cdGFsbE9wdGlvbnM6IGFsbE9wdGlvbnMsXG5cdGNvbmZpZ3VyZU9wdGlvbnM6IGNvbmZpZ3VyZU9wdGlvbnNcbn0pO1xuXG4vKipcbiAqICBUaGUgRmxveWTigJNXYXJzaGFsbCBhbGdvcml0aG0gaXMgYW4gYWxnb3JpdGhtIGZvciBmaW5kaW5nIHNob3J0ZXN0IHBhdGhzIGluXG4gKiAgYSB3ZWlnaHRlZCBncmFwaCB3aXRoIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGVkZ2Ugd2VpZ2h0cyAoYnV0IHdpdGggbm8gbmVnYXRpdmVcbiAqICBjeWNsZXMpLiAtIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zsb3lk4oCTV2Fyc2hhbGxfYWxnb3JpdGhtXG4gKi9cbnZhciBGbG95ZFdhcnNoYWxsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIEZsb3lkV2Fyc2hhbGwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZsb3lkV2Fyc2hhbGwpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNBcnJheVxuICAgKiBAcGFyYW0ge0FycmF5LjxFZGdlPn0gZWRnZXNBcnJheVxuICAgKiBAcmV0dXJucyB7e319XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEZsb3lkV2Fyc2hhbGwsIFt7XG4gICAga2V5OiBcImdldERpc3RhbmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaXN0YW5jZXMoYm9keSwgbm9kZXNBcnJheSwgZWRnZXNBcnJheSkge1xuICAgICAgdmFyIERfbWF0cml4ID0ge307XG4gICAgICB2YXIgZWRnZXMgPSBib2R5LmVkZ2VzOyAvLyBwcmVwYXJlIG1hdHJpeCB3aXRoIGxhcmdlIG51bWJlcnNcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNBcnJheVtpXTtcbiAgICAgICAgdmFyIGNlbGwgPSB7fTtcbiAgICAgICAgRF9tYXRyaXhbbm9kZV0gPSBjZWxsO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXNBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNlbGxbbm9kZXNBcnJheVtqXV0gPSBpID09IGogPyAwIDogMWU5O1xuICAgICAgICB9XG4gICAgICB9IC8vIHB1dCB0aGUgd2VpZ2h0cyBmb3IgdGhlIGVkZ2VzIGluLiBUaGlzIGFzc3VtZXMgdW5pZGlyZWN0aW9uYWxpdHkuXG5cblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVkZ2VzQXJyYXkubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZXNBcnJheVtfaV1dOyAvLyBlZGdlIGhhcyB0byBiZSBjb25uZWN0ZWQgaWYgaXQgY291bnRzIHRvIHRoZSBkaXN0YW5jZXMuIElmIGl0IGlzIGNvbm5lY3RlZCB0byBpbm5lciBjbHVzdGVycyBpdCB3aWxsIGNyYXNoIHNvIHdlIGFsc28gY2hlY2sgaWYgaXQgaXMgaW4gdGhlIERfbWF0cml4XG5cbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlICYmIERfbWF0cml4W2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkICYmIERfbWF0cml4W2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIERfbWF0cml4W2VkZ2UuZnJvbUlkXVtlZGdlLnRvSWRdID0gMTtcbiAgICAgICAgICBEX21hdHJpeFtlZGdlLnRvSWRdW2VkZ2UuZnJvbUlkXSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGVDb3VudCA9IG5vZGVzQXJyYXkubGVuZ3RoOyAvLyBBZGFwdGVkIEZsb3lkV2Fyc2hhbGwgYmFzZWQgb24gdW5pZGlyZWN0aW9uYWxpdHkgdG8gZ3JlYXRseSByZWR1Y2UgY29tcGxleGl0eS5cblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBub2RlQ291bnQ7IGsrKykge1xuICAgICAgICB2YXIga25vZGUgPSBub2Rlc0FycmF5W2tdO1xuICAgICAgICB2YXIga2NvbG0gPSBEX21hdHJpeFtrbm9kZV07XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZUNvdW50IC0gMTsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgaW5vZGUgPSBub2Rlc0FycmF5W19pMl07XG4gICAgICAgICAgdmFyIGljb2xtID0gRF9tYXRyaXhbaW5vZGVdO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2ogPSBfaTIgKyAxOyBfaiA8IG5vZGVDb3VudDsgX2orKykge1xuICAgICAgICAgICAgdmFyIGpub2RlID0gbm9kZXNBcnJheVtfal07XG4gICAgICAgICAgICB2YXIgamNvbG0gPSBEX21hdHJpeFtqbm9kZV07XG4gICAgICAgICAgICB2YXIgdmFsID0gTWF0aC5taW4oaWNvbG1bam5vZGVdLCBpY29sbVtrbm9kZV0gKyBrY29sbVtqbm9kZV0pO1xuICAgICAgICAgICAgaWNvbG1bam5vZGVdID0gdmFsO1xuICAgICAgICAgICAgamNvbG1baW5vZGVdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gRF9tYXRyaXg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZsb3lkV2Fyc2hhbGw7XG59KCk7XG5cbi8qKlxuICogS2FtYWRhS2F3YWkgcG9zaXRpb25zIHRoZSBub2RlcyBpbml0aWFsbHkgYmFzZWQgb25cbiAqXG4gKiBcIkFOIEFMR09SSVRITSBGT1IgRFJBV0lORyBHRU5FUkFMIFVORElSRUNURUQgR1JBUEhTXCJcbiAqIC0tIFRvbWloaXNhIEtBTUFEQSBhbmQgU2F0b3J1IEtBV0FJIGluIDE5ODlcbiAqXG4gKiBQb3NzaWJsZSBvcHRpbWl6YXRpb25zIGluIHRoZSBkaXN0YW5jZSBjYWxjdWxhdGlvbiBjYW4gYmUgaW1wbGVtZW50ZWQuXG4gKi9cblxudmFyIEthbWFkYUthd2FpID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlZGdlTGVuZ3RoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlZGdlU3RyZW5ndGhcbiAgICovXG4gIGZ1bmN0aW9uIEthbWFkYUthd2FpKGJvZHksIGVkZ2VMZW5ndGgsIGVkZ2VTdHJlbmd0aCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBLYW1hZGFLYXdhaSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuc3ByaW5nTGVuZ3RoID0gZWRnZUxlbmd0aDtcbiAgICB0aGlzLnNwcmluZ0NvbnN0YW50ID0gZWRnZVN0cmVuZ3RoO1xuICAgIHRoaXMuZGlzdGFuY2VTb2x2ZXIgPSBuZXcgRmxveWRXYXJzaGFsbCgpO1xuICB9XG4gIC8qKlxuICAgKiBOb3Qgc3VyZSBpZiBuZWVkZWQgYnV0IGNhbiBiZSB1c2VkIHRvIHVwZGF0ZSB0aGUgc3ByaW5nIGxlbmd0aCBhbmQgc3ByaW5nIGNvbnN0YW50XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEthbWFkYUthd2FpLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3ByaW5nTGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5zcHJpbmdMZW5ndGggPSBvcHRpb25zLnNwcmluZ0xlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnNwcmluZ0NvbnN0YW50KSB7XG4gICAgICAgICAgdGhpcy5zcHJpbmdDb25zdGFudCA9IG9wdGlvbnMuc3ByaW5nQ29uc3RhbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gdGhlIHN5c3RlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx2aXMuRWRnZT59IGVkZ2VzQXJyYXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVDbHVzdGVycz1mYWxzZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKG5vZGVzQXJyYXksIGVkZ2VzQXJyYXkpIHtcbiAgICAgIHZhciBpZ25vcmVDbHVzdGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICAvLyBnZXQgZGlzdGFuY2UgbWF0cml4XG4gICAgICB2YXIgRF9tYXRyaXggPSB0aGlzLmRpc3RhbmNlU29sdmVyLmdldERpc3RhbmNlcyh0aGlzLmJvZHksIG5vZGVzQXJyYXksIGVkZ2VzQXJyYXkpOyAvLyBkaXN0YW5jZSBtYXRyaXhcbiAgICAgIC8vIGdldCB0aGUgTCBNYXRyaXhcblxuICAgICAgdGhpcy5fY3JlYXRlTF9tYXRyaXgoRF9tYXRyaXgpOyAvLyBnZXQgdGhlIEsgTWF0cml4XG5cblxuICAgICAgdGhpcy5fY3JlYXRlS19tYXRyaXgoRF9tYXRyaXgpOyAvLyBpbml0aWFsIEUgTWF0cml4XG5cblxuICAgICAgdGhpcy5fY3JlYXRlRV9tYXRyaXgoKTsgLy8gY2FsY3VsYXRlIHBvc2l0aW9uc1xuXG5cbiAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjAxO1xuICAgICAgdmFyIGlubmVyVGhyZXNob2xkID0gMTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBtYXhJdGVyYXRpb25zID0gTWF0aC5tYXgoMTAwMCwgTWF0aC5taW4oMTAgKiB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoLCA2MDAwKSk7XG4gICAgICB2YXIgbWF4SW5uZXJJdGVyYXRpb25zID0gNTtcbiAgICAgIHZhciBtYXhFbmVyZ3kgPSAxZTk7XG4gICAgICB2YXIgaGlnaEVfbm9kZUlkID0gMCxcbiAgICAgICAgICBkRV9keCA9IDAsXG4gICAgICAgICAgZEVfZHkgPSAwLFxuICAgICAgICAgIGRlbHRhX20gPSAwLFxuICAgICAgICAgIHN1Ykl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgICB3aGlsZSAobWF4RW5lcmd5ID4gdGhyZXNob2xkICYmIGl0ZXJhdGlvbnMgPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMgKz0gMTtcblxuICAgICAgICB2YXIgX3RoaXMkX2dldEhpZ2hlc3RFbmVyID0gdGhpcy5fZ2V0SGlnaGVzdEVuZXJneU5vZGUoaWdub3JlQ2x1c3RlcnMpO1xuXG4gICAgICAgIHZhciBfdGhpcyRfZ2V0SGlnaGVzdEVuZXIyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldEhpZ2hlc3RFbmVyLCA0KTtcblxuICAgICAgICBoaWdoRV9ub2RlSWQgPSBfdGhpcyRfZ2V0SGlnaGVzdEVuZXIyWzBdO1xuICAgICAgICBtYXhFbmVyZ3kgPSBfdGhpcyRfZ2V0SGlnaGVzdEVuZXIyWzFdO1xuICAgICAgICBkRV9keCA9IF90aGlzJF9nZXRIaWdoZXN0RW5lcjJbMl07XG4gICAgICAgIGRFX2R5ID0gX3RoaXMkX2dldEhpZ2hlc3RFbmVyMlszXTtcbiAgICAgICAgZGVsdGFfbSA9IG1heEVuZXJneTtcbiAgICAgICAgc3ViSXRlcmF0aW9ucyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGRlbHRhX20gPiBpbm5lclRocmVzaG9sZCAmJiBzdWJJdGVyYXRpb25zIDwgbWF4SW5uZXJJdGVyYXRpb25zKSB7XG4gICAgICAgICAgc3ViSXRlcmF0aW9ucyArPSAxO1xuXG4gICAgICAgICAgdGhpcy5fbW92ZU5vZGUoaGlnaEVfbm9kZUlkLCBkRV9keCwgZEVfZHkpO1xuXG4gICAgICAgICAgdmFyIF90aGlzJF9nZXRFbmVyZ3kgPSB0aGlzLl9nZXRFbmVyZ3koaGlnaEVfbm9kZUlkKTtcblxuICAgICAgICAgIHZhciBfdGhpcyRfZ2V0RW5lcmd5MiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRFbmVyZ3ksIDMpO1xuXG4gICAgICAgICAgZGVsdGFfbSA9IF90aGlzJF9nZXRFbmVyZ3kyWzBdO1xuICAgICAgICAgIGRFX2R4ID0gX3RoaXMkX2dldEVuZXJneTJbMV07XG4gICAgICAgICAgZEVfZHkgPSBfdGhpcyRfZ2V0RW5lcmd5MlsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIG5vZGUgd2l0aCB0aGUgaGlnaGVzdCBlbmVyZ3lcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaWdub3JlQ2x1c3RlcnNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRIaWdoZXN0RW5lcmd5Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SGlnaGVzdEVuZXJneU5vZGUoaWdub3JlQ2x1c3RlcnMpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIG1heEVuZXJneSA9IDA7XG4gICAgICB2YXIgbWF4RW5lcmd5Tm9kZUlkID0gbm9kZXNBcnJheVswXTtcbiAgICAgIHZhciBkRV9keF9tYXggPSAwLFxuICAgICAgICAgIGRFX2R5X21heCA9IDA7XG5cbiAgICAgIGZvciAodmFyIG5vZGVJZHggPSAwOyBub2RlSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IG5vZGVJZHgrKykge1xuICAgICAgICB2YXIgbSA9IG5vZGVzQXJyYXlbbm9kZUlkeF07IC8vIGJ5IG5vdCBldmFsdWF0aW5nIG5vZGVzIHdpdGggcHJlZGVmaW5lZCBwb3NpdGlvbnMgd2Ugc2hvdWxkIG9ubHkgbW92ZSBub2RlcyB0aGF0IGhhdmUgbm8gcG9zaXRpb25zLlxuXG4gICAgICAgIGlmIChub2Rlc1ttXS5wcmVkZWZpbmVkUG9zaXRpb24gIT09IHRydWUgfHwgbm9kZXNbbV0uaXNDbHVzdGVyID09PSB0cnVlICYmIGlnbm9yZUNsdXN0ZXJzID09PSB0cnVlIHx8IG5vZGVzW21dLm9wdGlvbnMuZml4ZWQueCAhPT0gdHJ1ZSB8fCBub2Rlc1ttXS5vcHRpb25zLmZpeGVkLnkgIT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkX2dldEVuZXJneTMgPSB0aGlzLl9nZXRFbmVyZ3kobSksXG4gICAgICAgICAgICAgIF90aGlzJF9nZXRFbmVyZ3k0ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldEVuZXJneTMsIDMpLFxuICAgICAgICAgICAgICBkZWx0YV9tID0gX3RoaXMkX2dldEVuZXJneTRbMF0sXG4gICAgICAgICAgICAgIGRFX2R4ID0gX3RoaXMkX2dldEVuZXJneTRbMV0sXG4gICAgICAgICAgICAgIGRFX2R5ID0gX3RoaXMkX2dldEVuZXJneTRbMl07XG5cbiAgICAgICAgICBpZiAobWF4RW5lcmd5IDwgZGVsdGFfbSkge1xuICAgICAgICAgICAgbWF4RW5lcmd5ID0gZGVsdGFfbTtcbiAgICAgICAgICAgIG1heEVuZXJneU5vZGVJZCA9IG07XG4gICAgICAgICAgICBkRV9keF9tYXggPSBkRV9keDtcbiAgICAgICAgICAgIGRFX2R5X21heCA9IGRFX2R5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW21heEVuZXJneU5vZGVJZCwgbWF4RW5lcmd5LCBkRV9keF9tYXgsIGRFX2R5X21heF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0aGUgZW5lcmd5IG9mIGEgc2luZ2xlIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEVuZXJneVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RW5lcmd5KG0pIHtcbiAgICAgIHZhciBfdGhpcyRFX3N1bXMkbSA9IF9zbGljZWRUb0FycmF5KHRoaXMuRV9zdW1zW21dLCAyKSxcbiAgICAgICAgICBkRV9keCA9IF90aGlzJEVfc3VtcyRtWzBdLFxuICAgICAgICAgIGRFX2R5ID0gX3RoaXMkRV9zdW1zJG1bMV07XG5cbiAgICAgIHZhciBkZWx0YV9tID0gTWF0aC5zcXJ0KE1hdGgucG93KGRFX2R4LCAyKSArIE1hdGgucG93KGRFX2R5LCAyKSk7XG4gICAgICByZXR1cm4gW2RlbHRhX20sIGRFX2R4LCBkRV9keV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1vdmUgdGhlIG5vZGUgYmFzZWQgb24gaXQncyBlbmVyZ3lcbiAgICAgKiB0aGUgZHggYW5kIGR5IGFyZSBjYWxjdWxhdGVkIGZyb20gdGhlIGxpbmVhciBzeXN0ZW0gcHJvcG9zZWQgYnkgS2FtYWRhIGFuZCBLYXdhaVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZEVfZHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZEVfZHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21vdmVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlTm9kZShtLCBkRV9keCwgZEVfZHkpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGQyRV9keDIgPSAwO1xuICAgICAgdmFyIGQyRV9keGR5ID0gMDtcbiAgICAgIHZhciBkMkVfZHkyID0gMDtcbiAgICAgIHZhciB4X20gPSBub2Rlc1ttXS54O1xuICAgICAgdmFyIHlfbSA9IG5vZGVzW21dLnk7XG4gICAgICB2YXIga20gPSB0aGlzLktfbWF0cml4W21dO1xuICAgICAgdmFyIGxtID0gdGhpcy5MX21hdHJpeFttXTtcblxuICAgICAgZm9yICh2YXIgaUlkeCA9IDA7IGlJZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgaUlkeCsrKSB7XG4gICAgICAgIHZhciBpID0gbm9kZXNBcnJheVtpSWR4XTtcblxuICAgICAgICBpZiAoaSAhPT0gbSkge1xuICAgICAgICAgIHZhciB4X2kgPSBub2Rlc1tpXS54O1xuICAgICAgICAgIHZhciB5X2kgPSBub2Rlc1tpXS55O1xuICAgICAgICAgIHZhciBrbWF0ID0ga21baV07XG4gICAgICAgICAgdmFyIGxtYXQgPSBsbVtpXTtcbiAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxLjAgLyBNYXRoLnBvdyhNYXRoLnBvdyh4X20gLSB4X2ksIDIpICsgTWF0aC5wb3coeV9tIC0geV9pLCAyKSwgMS41KTtcbiAgICAgICAgICBkMkVfZHgyICs9IGttYXQgKiAoMSAtIGxtYXQgKiBNYXRoLnBvdyh5X20gLSB5X2ksIDIpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgIGQyRV9keGR5ICs9IGttYXQgKiAobG1hdCAqICh4X20gLSB4X2kpICogKHlfbSAtIHlfaSkgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgZDJFX2R5MiArPSBrbWF0ICogKDEgLSBsbWF0ICogTWF0aC5wb3coeF9tIC0geF9pLCAyKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBtYWtlIHRoZSB2YXJpYWJsZSBuYW1lcyBlYXNpZXIgdG8gbWFrZSB0aGUgc29sdmluZyBvZiB0aGUgbGluZWFyIHN5c3RlbSBlYXNpZXIgdG8gcmVhZFxuXG5cbiAgICAgIHZhciBBID0gZDJFX2R4MixcbiAgICAgICAgICBCID0gZDJFX2R4ZHksXG4gICAgICAgICAgQyA9IGRFX2R4LFxuICAgICAgICAgIEQgPSBkMkVfZHkyLFxuICAgICAgICAgIEUgPSBkRV9keTsgLy8gc29sdmUgdGhlIGxpbmVhciBzeXN0ZW0gZm9yIGR4IGFuZCBkeVxuXG4gICAgICB2YXIgZHkgPSAoQyAvIEEgKyBFIC8gQikgLyAoQiAvIEEgLSBEIC8gQik7XG4gICAgICB2YXIgZHggPSAtKEIgKiBkeSArIEMpIC8gQTsgLy8gbW92ZSB0aGUgbm9kZVxuXG4gICAgICBub2Rlc1ttXS54ICs9IGR4O1xuICAgICAgbm9kZXNbbV0ueSArPSBkeTsgLy8gUmVjYWxjdWxhdGUgRV9tYXRyaXggKHNob3VsZCBiZSBpbmNyZW1lbnRhbClcblxuICAgICAgdGhpcy5fdXBkYXRlRV9tYXRyaXgobSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgTCBtYXRyaXg6IGVkZ2UgbGVuZ3RoIHRpbWVzIHNob3J0ZXN0IHBhdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBEX21hdHJpeFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlTF9tYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUxfbWF0cml4KERfbWF0cml4KSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBlZGdlTGVuZ3RoID0gdGhpcy5zcHJpbmdMZW5ndGg7XG4gICAgICB0aGlzLkxfbWF0cml4ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLkxfbWF0cml4W25vZGVzQXJyYXlbaV1dID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlc0FycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdGhpcy5MX21hdHJpeFtub2Rlc0FycmF5W2ldXVtub2Rlc0FycmF5W2pdXSA9IGVkZ2VMZW5ndGggKiBEX21hdHJpeFtub2Rlc0FycmF5W2ldXVtub2Rlc0FycmF5W2pdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIEsgbWF0cml4OiBzcHJpbmcgY29uc3RhbnRzIHRpbWVzIHNob3J0ZXN0IHBhdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBEX21hdHJpeFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlS19tYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUtfbWF0cml4KERfbWF0cml4KSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBlZGdlU3RyZW5ndGggPSB0aGlzLnNwcmluZ0NvbnN0YW50O1xuICAgICAgdGhpcy5LX21hdHJpeCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5LX21hdHJpeFtub2Rlc0FycmF5W2ldXSA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXNBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRoaXMuS19tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV0gPSBlZGdlU3RyZW5ndGggKiBNYXRoLnBvdyhEX21hdHJpeFtub2Rlc0FycmF5W2ldXVtub2Rlc0FycmF5W2pdXSwgLTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgbWF0cml4IHdpdGggYWxsIGVuZXJnaWVzIGJldHdlZW4gbm9kZXNcbiAgICAgKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUVfbWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFX21hdHJpeCgpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdGhpcy5FX21hdHJpeCA9IHt9O1xuICAgICAgdGhpcy5FX3N1bXMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgbUlkeCA9IDA7IG1JZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgbUlkeCsrKSB7XG4gICAgICAgIHRoaXMuRV9tYXRyaXhbbm9kZXNBcnJheVttSWR4XV0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX21JZHggPSAwOyBfbUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBfbUlkeCsrKSB7XG4gICAgICAgIHZhciBtID0gbm9kZXNBcnJheVtfbUlkeF07XG4gICAgICAgIHZhciB4X20gPSBub2Rlc1ttXS54O1xuICAgICAgICB2YXIgeV9tID0gbm9kZXNbbV0ueTtcbiAgICAgICAgdmFyIGRFX2R4ID0gMDtcbiAgICAgICAgdmFyIGRFX2R5ID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpSWR4ID0gX21JZHg7IGlJZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgaUlkeCsrKSB7XG4gICAgICAgICAgdmFyIGkgPSBub2Rlc0FycmF5W2lJZHhdO1xuXG4gICAgICAgICAgaWYgKGkgIT09IG0pIHtcbiAgICAgICAgICAgIHZhciB4X2kgPSBub2Rlc1tpXS54O1xuICAgICAgICAgICAgdmFyIHlfaSA9IG5vZGVzW2ldLnk7XG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxLjAgLyBNYXRoLnNxcnQoTWF0aC5wb3coeF9tIC0geF9pLCAyKSArIE1hdGgucG93KHlfbSAtIHlfaSwgMikpO1xuICAgICAgICAgICAgdGhpcy5FX21hdHJpeFttXVtpSWR4XSA9IFt0aGlzLktfbWF0cml4W21dW2ldICogKHhfbSAtIHhfaSAtIHRoaXMuTF9tYXRyaXhbbV1baV0gKiAoeF9tIC0geF9pKSAqIGRlbm9taW5hdG9yKSwgdGhpcy5LX21hdHJpeFttXVtpXSAqICh5X20gLSB5X2kgLSB0aGlzLkxfbWF0cml4W21dW2ldICogKHlfbSAtIHlfaSkgKiBkZW5vbWluYXRvcildO1xuICAgICAgICAgICAgdGhpcy5FX21hdHJpeFtpXVtfbUlkeF0gPSB0aGlzLkVfbWF0cml4W21dW2lJZHhdO1xuICAgICAgICAgICAgZEVfZHggKz0gdGhpcy5FX21hdHJpeFttXVtpSWR4XVswXTtcbiAgICAgICAgICAgIGRFX2R5ICs9IHRoaXMuRV9tYXRyaXhbbV1baUlkeF1bMV07XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vU3RvcmUgc3VtXG5cblxuICAgICAgICB0aGlzLkVfc3Vtc1ttXSA9IFtkRV9keCwgZEVfZHldO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbWV0aG9kLCBqdXN0IGRvaW5nIHNpbmdsZSBjb2x1bW4gKHJvd3MgYXJlIGF1dG8tdXBkYXRlZCkgKHVwZGF0ZSBhbGwgc3VtcylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVFX21hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlRV9tYXRyaXgobSkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgY29sbSA9IHRoaXMuRV9tYXRyaXhbbV07XG4gICAgICB2YXIga2NvbG0gPSB0aGlzLktfbWF0cml4W21dO1xuICAgICAgdmFyIGxjb2xtID0gdGhpcy5MX21hdHJpeFttXTtcbiAgICAgIHZhciB4X20gPSBub2Rlc1ttXS54O1xuICAgICAgdmFyIHlfbSA9IG5vZGVzW21dLnk7XG4gICAgICB2YXIgZEVfZHggPSAwO1xuICAgICAgdmFyIGRFX2R5ID0gMDtcblxuICAgICAgZm9yICh2YXIgaUlkeCA9IDA7IGlJZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgaUlkeCsrKSB7XG4gICAgICAgIHZhciBpID0gbm9kZXNBcnJheVtpSWR4XTtcblxuICAgICAgICBpZiAoaSAhPT0gbSkge1xuICAgICAgICAgIC8vS2VlcCBvbGQgZW5lcmd5IHZhbHVlIGZvciBzdW0gbW9kaWZpY2F0aW9uIGJlbG93XG4gICAgICAgICAgdmFyIGNlbGwgPSBjb2xtW2lJZHhdO1xuICAgICAgICAgIHZhciBvbGREeCA9IGNlbGxbMF07XG4gICAgICAgICAgdmFyIG9sZER5ID0gY2VsbFsxXTsgLy9DYWxjIG5ldyBlbmVyZ3k6XG5cbiAgICAgICAgICB2YXIgeF9pID0gbm9kZXNbaV0ueDtcbiAgICAgICAgICB2YXIgeV9pID0gbm9kZXNbaV0ueTtcbiAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxLjAgLyBNYXRoLnNxcnQoTWF0aC5wb3coeF9tIC0geF9pLCAyKSArIE1hdGgucG93KHlfbSAtIHlfaSwgMikpO1xuICAgICAgICAgIHZhciBkeCA9IGtjb2xtW2ldICogKHhfbSAtIHhfaSAtIGxjb2xtW2ldICogKHhfbSAtIHhfaSkgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgdmFyIGR5ID0ga2NvbG1baV0gKiAoeV9tIC0geV9pIC0gbGNvbG1baV0gKiAoeV9tIC0geV9pKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICBjb2xtW2lJZHhdID0gW2R4LCBkeV07XG4gICAgICAgICAgZEVfZHggKz0gZHg7XG4gICAgICAgICAgZEVfZHkgKz0gZHk7IC8vYWRkIG5ldyBlbmVyZ3kgdG8gc3VtIG9mIGVhY2ggY29sdW1uXG5cbiAgICAgICAgICB2YXIgc3VtID0gdGhpcy5FX3N1bXNbaV07XG4gICAgICAgICAgc3VtWzBdICs9IGR4IC0gb2xkRHg7XG4gICAgICAgICAgc3VtWzFdICs9IGR5IC0gb2xkRHk7XG4gICAgICAgIH1cbiAgICAgIH0gLy9TdG9yZSBzdW0gYXQgLTEgaW5kZXhcblxuXG4gICAgICB0aGlzLkVfc3Vtc1ttXSA9IFtkRV9keCwgZEVfZHldO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBLYW1hZGFLYXdhaTtcbn0oKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXR3b3JrIHZpc3VhbGl6YXRpb24sIGRpc3BsYXlpbmcgbm9kZXMgYW5kIGVkZ2VzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICAgVGhlIERPTSBlbGVtZW50IGluIHdoaWNoIHRoZSBOZXR3b3JrIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGNyZWF0ZWQuIE5vcm1hbGx5IGEgZGl2IGVsZW1lbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YSAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5fSBub2Rlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXl9IGVkZ2VzXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICAgIE9wdGlvbnNcbiAqIEBjbGFzcyBOZXR3b3JrXG4gKi9cblxuZnVuY3Rpb24gTmV0d29yayhjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIF9jb250ZXh0LFxuICAgICAgX2NvbnRleHQyLFxuICAgICAgX2NvbnRleHQzLFxuICAgICAgX2NvbnRleHQ0LFxuICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOZXR3b3JrKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkNvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvclwiKTtcbiAgfSAvLyBzZXQgY29uc3RhbnQgdmFsdWVzXG5cblxuICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBsb2NhbGU6IFwiZW5cIixcbiAgICBsb2NhbGVzOiBsb2NhbGVzLFxuICAgIGNsaWNrVG9Vc2U6IGZhbHNlXG4gIH07XG5cbiAgYXNzaWduJDIodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgLyoqXG4gICAqIENvbnRhaW5lcnMgZm9yIG5vZGVzIGFuZCBlZGdlcy5cbiAgICpcbiAgICogJ2VkZ2VzJyBhbmQgJ25vZGVzJyBjb250YWluIHRoZSBmdWxsIGRlZmluaXRpb25zIG9mIGFsbCB0aGUgbmV0d29yayBlbGVtZW50cy5cbiAgICogJ25vZGVJbmRpY2VzJyBhbmQgJ2VkZ2VJbmRpY2VzJyBjb250YWluIHRoZSBpZCdzIG9mIHRoZSBhY3RpdmUgZWxlbWVudHMuXG4gICAqXG4gICAqIFRoZSBkaXN0aW5jdGlvbiBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgYSBkZWZpbmVkIG5vZGUgbmVlZCBub3QgYmUgYWN0aXZlLCBpLmUuXG4gICAqIHZpc2libGUgb24gdGhlIGNhbnZhcy4gVGhpcyBoYXBwZW5zIGluIHBhcnRpY3VsYXIgd2hlbiBjbHVzdGVycyBhcmUgZGVmaW5lZCwgaW5cbiAgICogdGhhdCBjYXNlIHRoZXJlIHdpbGwgYmUgbm9kZXMgYW5kIGVkZ2VzIG5vdCBkaXNwbGF5ZWQuXG4gICAqIFRoZSBib3R0b20gbGluZSBpcyB0aGF0IGFsbCBjb2RlIHdpdGggYWN0aW9ucyByZWxhdGVkIHRvIHZpc2liaWxpdHksICptdXN0KiB1c2VcbiAgICogJ25vZGVJbmRpY2VzJyBhbmQgJ2VkZ2VJbmRpY2VzJywgbm90ICdub2RlcycgYW5kICdlZGdlcycgZGlyZWN0bHkuXG4gICAqL1xuXG5cbiAgdGhpcy5ib2R5ID0ge1xuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIC8vIFNlZSBjb21tZW50IGFib3ZlIGZvciBmb2xsb3dpbmcgZmllbGRzXG4gICAgbm9kZXM6IHt9LFxuICAgIG5vZGVJbmRpY2VzOiBbXSxcbiAgICBlZGdlczoge30sXG4gICAgZWRnZUluZGljZXM6IFtdLFxuICAgIGVtaXR0ZXI6IHtcbiAgICAgIG9uOiBiaW5kJDYoX2NvbnRleHQgPSB0aGlzLm9uKS5jYWxsKF9jb250ZXh0LCB0aGlzKSxcbiAgICAgIG9mZjogYmluZCQ2KF9jb250ZXh0MiA9IHRoaXMub2ZmKS5jYWxsKF9jb250ZXh0MiwgdGhpcyksXG4gICAgICBlbWl0OiBiaW5kJDYoX2NvbnRleHQzID0gdGhpcy5lbWl0KS5jYWxsKF9jb250ZXh0MywgdGhpcyksXG4gICAgICBvbmNlOiBiaW5kJDYoX2NvbnRleHQ0ID0gdGhpcy5vbmNlKS5jYWxsKF9jb250ZXh0NCwgdGhpcylcbiAgICB9LFxuICAgIGV2ZW50TGlzdGVuZXJzOiB7XG4gICAgICBvblRhcDogZnVuY3Rpb24gb25UYXAoKSB7fSxcbiAgICAgIG9uVG91Y2g6IGZ1bmN0aW9uIG9uVG91Y2goKSB7fSxcbiAgICAgIG9uRG91YmxlVGFwOiBmdW5jdGlvbiBvbkRvdWJsZVRhcCgpIHt9LFxuICAgICAgb25Ib2xkOiBmdW5jdGlvbiBvbkhvbGQoKSB7fSxcbiAgICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHt9LFxuICAgICAgb25EcmFnOiBmdW5jdGlvbiBvbkRyYWcoKSB7fSxcbiAgICAgIG9uRHJhZ0VuZDogZnVuY3Rpb24gb25EcmFnRW5kKCkge30sXG4gICAgICBvbk1vdXNlV2hlZWw6IGZ1bmN0aW9uIG9uTW91c2VXaGVlbCgpIHt9LFxuICAgICAgb25QaW5jaDogZnVuY3Rpb24gb25QaW5jaCgpIHt9LFxuICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCkge30sXG4gICAgICBvblJlbGVhc2U6IGZ1bmN0aW9uIG9uUmVsZWFzZSgpIHt9LFxuICAgICAgb25Db250ZXh0OiBmdW5jdGlvbiBvbkNvbnRleHQoKSB7fVxuICAgIH0sXG4gICAgZGF0YToge1xuICAgICAgbm9kZXM6IG51bGwsXG4gICAgICAvLyBBIERhdGFTZXQgb3IgRGF0YVZpZXdcbiAgICAgIGVkZ2VzOiBudWxsIC8vIEEgRGF0YVNldCBvciBEYXRhVmlld1xuXG4gICAgfSxcbiAgICBmdW5jdGlvbnM6IHtcbiAgICAgIGNyZWF0ZU5vZGU6IGZ1bmN0aW9uIGNyZWF0ZU5vZGUoKSB7fSxcbiAgICAgIGNyZWF0ZUVkZ2U6IGZ1bmN0aW9uIGNyZWF0ZUVkZ2UoKSB7fSxcbiAgICAgIGdldFBvaW50ZXI6IGZ1bmN0aW9uIGdldFBvaW50ZXIoKSB7fVxuICAgIH0sXG4gICAgbW9kdWxlczoge30sXG4gICAgdmlldzoge1xuICAgICAgc2NhbGU6IDEsXG4gICAgICB0cmFuc2xhdGlvbjoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3Rpb25Cb3g6IHtcbiAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIGJpbmQgdGhlIGV2ZW50IGxpc3RlbmVyc1xuXG4gIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7IC8vIHNldHRpbmcgdXAgYWxsIG1vZHVsZXNcblxuICB0aGlzLmltYWdlcyA9IG5ldyBJbWFnZXMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICB9KTsgLy8gb2JqZWN0IHdpdGggaW1hZ2VzXG5cbiAgdGhpcy5ncm91cHMgPSBuZXcgR3JvdXBzKCk7IC8vIG9iamVjdCB3aXRoIGdyb3Vwc1xuXG4gIHRoaXMuY2FudmFzID0gbmV3IENhbnZhcyh0aGlzLmJvZHkpOyAvLyBET00gaGFuZGxlclxuXG4gIHRoaXMuc2VsZWN0aW9uSGFuZGxlciA9IG5ldyBTZWxlY3Rpb25IYW5kbGVyKHRoaXMuYm9keSwgdGhpcy5jYW52YXMpOyAvLyBTZWxlY3Rpb24gaGFuZGxlclxuXG4gIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyID0gbmV3IEludGVyYWN0aW9uSGFuZGxlcih0aGlzLmJvZHksIHRoaXMuY2FudmFzLCB0aGlzLnNlbGVjdGlvbkhhbmRsZXIpOyAvLyBJbnRlcmFjdGlvbiBoYW5kbGVyIGhhbmRsZXMgYWxsIHRoZSBoYW1tZXIgYmluZGluZ3MgKHRoYXQgYXJlIGJvdW5kIGJ5IGNhbnZhcyksIGtleVxuXG4gIHRoaXMudmlldyA9IG5ldyBWaWV3KHRoaXMuYm9keSwgdGhpcy5jYW52YXMpOyAvLyBjYW1lcmEgaGFuZGxlciwgZG9lcyBhbmltYXRpb25zIGFuZCB6b29tc1xuXG4gIHRoaXMucmVuZGVyZXIgPSBuZXcgQ2FudmFzUmVuZGVyZXIodGhpcy5ib2R5LCB0aGlzLmNhbnZhcyk7IC8vIHJlbmRlcmVyLCBzdGFydHMgcmVuZGVybG9vcCwgaGFzIGV2ZW50cyB0aGF0IG1vZHVsZXMgY2FuIGhvb2sgaW50b1xuXG4gIHRoaXMucGh5c2ljcyA9IG5ldyBQaHlzaWNzRW5naW5lKHRoaXMuYm9keSk7IC8vIHBoeXNpY3MgZW5naW5lLCBkb2VzIGFsbCB0aGUgc2ltdWxhdGlvbnNcblxuICB0aGlzLmxheW91dEVuZ2luZSA9IG5ldyBMYXlvdXRFbmdpbmUodGhpcy5ib2R5KTsgLy8gbGF5b3V0IGVuZ2luZSBmb3IgaW5pdGFsIGxheW91dCBhbmQgaGllcmFyY2hpY2FsIGxheW91dFxuXG4gIHRoaXMuY2x1c3RlcmluZyA9IG5ldyBDbHVzdGVyRW5naW5lKHRoaXMuYm9keSk7IC8vIGNsdXN0ZXJpbmcgYXBpXG5cbiAgdGhpcy5tYW5pcHVsYXRpb24gPSBuZXcgTWFuaXB1bGF0aW9uU3lzdGVtKHRoaXMuYm9keSwgdGhpcy5jYW52YXMsIHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIpOyAvLyBkYXRhIG1hbmlwdWxhdGlvbiBzeXN0ZW1cblxuICB0aGlzLm5vZGVzSGFuZGxlciA9IG5ldyBOb2Rlc0hhbmRsZXIodGhpcy5ib2R5LCB0aGlzLmltYWdlcywgdGhpcy5ncm91cHMsIHRoaXMubGF5b3V0RW5naW5lKTsgLy8gSGFuZGxlIGFkZGluZywgZGVsZXRpbmcgYW5kIHVwZGF0aW5nIG9mIG5vZGVzIGFzIHdlbGwgYXMgZ2xvYmFsIG9wdGlvbnNcblxuICB0aGlzLmVkZ2VzSGFuZGxlciA9IG5ldyBFZGdlc0hhbmRsZXIodGhpcy5ib2R5LCB0aGlzLmltYWdlcywgdGhpcy5ncm91cHMpOyAvLyBIYW5kbGUgYWRkaW5nLCBkZWxldGluZyBhbmQgdXBkYXRpbmcgb2YgZWRnZXMgYXMgd2VsbCBhcyBnbG9iYWwgb3B0aW9uc1xuXG4gIHRoaXMuYm9keS5tb2R1bGVzW1wia2FtYWRhS2F3YWlcIl0gPSBuZXcgS2FtYWRhS2F3YWkodGhpcy5ib2R5LCAxNTAsIDAuMDUpOyAvLyBMYXlvdXRpbmcgYWxnb3JpdGhtLlxuXG4gIHRoaXMuYm9keS5tb2R1bGVzW1wiY2x1c3RlcmluZ1wiXSA9IHRoaXMuY2x1c3RlcmluZzsgLy8gY3JlYXRlIHRoZSBET00gZWxlbWVudHNcblxuICB0aGlzLmNhbnZhcy5fY3JlYXRlKCk7IC8vIGFwcGx5IG9wdGlvbnNcblxuXG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTsgLy8gbG9hZCBkYXRhICh0aGUgZGlzYWJsZSBzdGFydCB2YXJpYWJsZSB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBlbmFibGVkIGNsdXN0ZXJpbmcpXG5cbiAgdGhpcy5zZXREYXRhKGRhdGEpO1xufSAvLyBFeHRlbmQgTmV0d29yayB3aXRoIGFuIEVtaXR0ZXIgbWl4aW5cblxuRW1pdHRlcihOZXR3b3JrLnByb3RvdHlwZSk7XG4vKipcbiAqIFNldCBvcHRpb25zXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5OZXR3b3JrLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgaWYgKG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkOyAvLyBUaGlzIGVuc3VyZXMgdGhhdCBvcHRpb25zIGhhbmRsaW5nIGRvZXNuJ3QgY3Jhc2ggaW4gdGhlIGhhbmRsaW5nXG4gIH1cblxuICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGVycm9yRm91bmQgPSBWYWxpZGF0b3IudmFsaWRhdGUob3B0aW9ucywgYWxsT3B0aW9ucyk7XG5cbiAgICBpZiAoZXJyb3JGb3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIiVjRXJyb3JzIGhhdmUgYmVlbiBmb3VuZCBpbiB0aGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3QuXCIsIFZBTElEQVRPUl9QUklOVF9TVFlMRSk7XG4gICAgfSAvLyBjb3B5IHRoZSBnbG9iYWwgZmllbGRzIG92ZXJcblxuXG4gICAgdmFyIGZpZWxkcyA9IFtcImxvY2FsZVwiLCBcImxvY2FsZXNcIiwgXCJjbGlja1RvVXNlXCJdO1xuICAgIHNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBub3JtYWxpemUgdGhlIGxvY2FsZSBvciB1c2UgRW5nbGlzaFxuXG4gICAgaWYgKG9wdGlvbnMubG9jYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMubG9jYWxlID0gbm9ybWFsaXplTGFuZ3VhZ2VDb2RlKG9wdGlvbnMubG9jYWxlcyB8fCB0aGlzLm9wdGlvbnMubG9jYWxlcywgb3B0aW9ucy5sb2NhbGUpO1xuICAgIH0gLy8gdGhlIGhpZXJhcmNoaWNhbCBzeXN0ZW0gY2FuIGFkYXB0IHRoZSBlZGdlcyBhbmQgdGhlIHBoeXNpY3MgdG8gaXQncyBvd24gb3B0aW9ucyBiZWNhdXNlIG5vdCBhbGwgY29tYmluYXRpb25zIHdvcmsgd2l0aCB0aGUgaGllcmFyaWNoaWNhbCBzeXN0ZW0uXG5cblxuICAgIG9wdGlvbnMgPSB0aGlzLmxheW91dEVuZ2luZS5zZXRPcHRpb25zKG9wdGlvbnMubGF5b3V0LCBvcHRpb25zKTtcbiAgICB0aGlzLmNhbnZhcy5zZXRPcHRpb25zKG9wdGlvbnMpOyAvLyBvcHRpb25zIGZvciBjYW52YXMgYXJlIGluIGdsb2JhbHNcbiAgICAvLyBwYXNzIHRoZSBvcHRpb25zIHRvIHRoZSBtb2R1bGVzXG5cbiAgICB0aGlzLmdyb3Vwcy5zZXRPcHRpb25zKG9wdGlvbnMuZ3JvdXBzKTtcbiAgICB0aGlzLm5vZGVzSGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnMubm9kZXMpO1xuICAgIHRoaXMuZWRnZXNIYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5lZGdlcyk7XG4gICAgdGhpcy5waHlzaWNzLnNldE9wdGlvbnMob3B0aW9ucy5waHlzaWNzKTtcbiAgICB0aGlzLm1hbmlwdWxhdGlvbi5zZXRPcHRpb25zKG9wdGlvbnMubWFuaXB1bGF0aW9uLCBvcHRpb25zLCB0aGlzLm9wdGlvbnMpOyAvLyBtYW5pcHVsYXRpb24gdXNlcyB0aGUgbG9jYWxlcyBpbiB0aGUgZ2xvYmFsc1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLmludGVyYWN0aW9uKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldE9wdGlvbnMob3B0aW9ucy5pbnRlcmFjdGlvbik7IC8vIG9wdGlvbnMgZm9yIHJlbmRlcmluZyBhcmUgaW4gaW50ZXJhY3Rpb25cblxuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnMuaW50ZXJhY3Rpb24pOyAvLyBvcHRpb25zIGZvciBzZWxlY3Rpb24gYXJlIGluIGludGVyYWN0aW9uXG4gICAgLy8gcmVsb2FkIHRoZSBzZXR0aW5ncyBvZiB0aGUgbm9kZXMgdG8gYXBwbHkgY2hhbmdlcyBpbiBncm91cHMgdGhhdCBhcmUgbm90IHJlZmVyZW5jZWQgYnkgcG9pbnRlci5cblxuICAgIGlmIChvcHRpb25zLmdyb3VwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVmcmVzaE5vZGVzXCIpO1xuICAgIH0gLy8gdGhlc2UgdHdvIGRvIG5vdCBoYXZlIG9wdGlvbnMgYXQgdGhlIG1vbWVudCwgaGVyZSBmb3IgY29tcGxldGVuZXNzXG4gICAgLy90aGlzLnZpZXcuc2V0T3B0aW9ucyhvcHRpb25zLnZpZXcpO1xuICAgIC8vdGhpcy5jbHVzdGVyaW5nLnNldE9wdGlvbnMob3B0aW9ucy5jbHVzdGVyaW5nKTtcblxuXG4gICAgaWYgKFwiY29uZmlndXJlXCIgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmNvbmZpZ3VyYXRvcikge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRvciA9IG5ldyBDb25maWd1cmF0b3IodGhpcywgdGhpcy5ib2R5LmNvbnRhaW5lciwgY29uZmlndXJlT3B0aW9ucywgdGhpcy5jYW52YXMucGl4ZWxSYXRpbywgY29uZmlndXJhdG9ySGlkZU9wdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29uZmlndXJhdG9yLnNldE9wdGlvbnMob3B0aW9ucy5jb25maWd1cmUpO1xuICAgIH0gLy8gaWYgdGhlIGNvbmZpZ3VyYXRpb24gc3lzdGVtIGlzIGVuYWJsZWQsIGNvcHkgYWxsIG9wdGlvbnMgYW5kIHB1dCB0aGVtIGludG8gdGhlIGNvbmZpZyBzeXN0ZW1cblxuXG4gICAgaWYgKHRoaXMuY29uZmlndXJhdG9yICYmIHRoaXMuY29uZmlndXJhdG9yLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIG5ldHdvcmtPcHRpb25zID0ge1xuICAgICAgICBub2Rlczoge30sXG4gICAgICAgIGVkZ2VzOiB7fSxcbiAgICAgICAgbGF5b3V0OiB7fSxcbiAgICAgICAgaW50ZXJhY3Rpb246IHt9LFxuICAgICAgICBtYW5pcHVsYXRpb246IHt9LFxuICAgICAgICBwaHlzaWNzOiB7fSxcbiAgICAgICAgZ2xvYmFsOiB7fVxuICAgICAgfTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMubm9kZXMsIHRoaXMubm9kZXNIYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5lZGdlcywgdGhpcy5lZGdlc0hhbmRsZXIub3B0aW9ucyk7XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmxheW91dCwgdGhpcy5sYXlvdXRFbmdpbmUub3B0aW9ucyk7IC8vIGxvYWQgdGhlIHNlbGVjdGlvbkhhbmRsZXIgYW5kIHJlbmRlciBkZWZhdWx0IG9wdGlvbnMgaW4gdG8gdGhlIGludGVyYWN0aW9uIGdyb3VwXG5cbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuaW50ZXJhY3Rpb24sIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5vcHRpb25zKTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuaW50ZXJhY3Rpb24sIHRoaXMucmVuZGVyZXIub3B0aW9ucyk7XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmludGVyYWN0aW9uLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5vcHRpb25zKTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMubWFuaXB1bGF0aW9uLCB0aGlzLm1hbmlwdWxhdGlvbi5vcHRpb25zKTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMucGh5c2ljcywgdGhpcy5waHlzaWNzLm9wdGlvbnMpOyAvLyBsb2FkIGdsb2JhbHMgaW50byB0aGUgZ2xvYmFsIG9iamVjdFxuXG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmdsb2JhbCwgdGhpcy5jYW52YXMub3B0aW9ucyk7XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmdsb2JhbCwgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuY29uZmlndXJhdG9yLnNldE1vZHVsZU9wdGlvbnMobmV0d29ya09wdGlvbnMpO1xuICAgIH0gLy8gaGFuZGxlIG5ldHdvcmsgZ2xvYmFsIG9wdGlvbnNcblxuXG4gICAgaWYgKG9wdGlvbnMuY2xpY2tUb1VzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3B0aW9ucy5jbGlja1RvVXNlID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2YXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmF0b3IgPSBuZXcgQWN0aXZhdG9yKHRoaXMuY2FudmFzLmZyYW1lKTtcbiAgICAgICAgICB0aGlzLmFjdGl2YXRvci5vbihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJhY3RpdmF0ZVwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2YXRvci5kZXN0cm95KCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYWN0aXZhdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImFjdGl2YXRlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYWN0aXZhdGVcIik7XG4gICAgfVxuXG4gICAgdGhpcy5jYW52YXMuc2V0U2l6ZSgpOyAvLyBzdGFydCB0aGUgcGh5c2ljcyBzaW11bGF0aW9uLiBDYW4gYmUgc2FmZWx5IGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cblxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG4gIH1cbn07XG4vKipcbiAqIFVwZGF0ZSB0aGUgdmlzaWJsZSBub2RlcyBhbmQgZWRnZXMgbGlzdCB3aXRoIHRoZSBtb3N0IHJlY2VudCBub2RlIHN0YXRlLlxuICpcbiAqIFZpc2libGUgbm9kZXMgYXJlIHN0b3JlZCBpbiB0aGlzLmJvZHkubm9kZUluZGljZXMuXG4gKiBWaXNpYmxlIGVkZ2VzIGFyZSBzdG9yZWQgaW4gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLlxuICogQSBub2RlIG9yIGVkZ2VzIGlzIHZpc2libGUgaWYgaXQgaXMgbm90IGhpZGRlbiBvciBjbHVzdGVyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuXG5cbk5ldHdvcmsucHJvdG90eXBlLl91cGRhdGVWaXNpYmxlSW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gIHRoaXMuYm9keS5ub2RlSW5kaWNlcyA9IFtdO1xuICB0aGlzLmJvZHkuZWRnZUluZGljZXMgPSBbXTtcblxuICBmb3IgKHZhciBub2RlSWQgaW4gbm9kZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVzLCBub2RlSWQpKSB7XG4gICAgICBpZiAoIXRoaXMuY2x1c3RlcmluZy5faXNDbHVzdGVyZWROb2RlKG5vZGVJZCkgJiYgbm9kZXNbbm9kZUlkXS5vcHRpb25zLmhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2gobm9kZXNbbm9kZUlkXS5pZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgZWRnZUlkIGluIGVkZ2VzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlZGdlcywgZWRnZUlkKSkge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlSWRdOyAvLyBJdCBjYW4gaGFwcGVuIHRoYXQgdGhpcyBpcyBleGVjdXRlZCAqYWZ0ZXIqIGEgbm9kZSBlZGdlIGhhcyBiZWVuIHJlbW92ZWQsXG4gICAgICAvLyBidXQgKmJlZm9yZSogdGhlIGVkZ2UgaXRzZWxmIGhhcyBiZWVuIHJlbW92ZWQuIFRha2luZyB0aGlzIGludG8gYWNjb3VudC5cblxuICAgICAgdmFyIGZyb21Ob2RlID0gbm9kZXNbZWRnZS5mcm9tSWRdO1xuICAgICAgdmFyIHRvTm9kZSA9IG5vZGVzW2VkZ2UudG9JZF07XG4gICAgICB2YXIgZWRnZU5vZGVzUHJlc2VudCA9IGZyb21Ob2RlICE9PSB1bmRlZmluZWQgJiYgdG9Ob2RlICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgaXNWaXNpYmxlID0gIXRoaXMuY2x1c3RlcmluZy5faXNDbHVzdGVyZWRFZGdlKGVkZ2VJZCkgJiYgZWRnZS5vcHRpb25zLmhpZGRlbiA9PT0gZmFsc2UgJiYgZWRnZU5vZGVzUHJlc2VudCAmJiBmcm9tTm9kZS5vcHRpb25zLmhpZGRlbiA9PT0gZmFsc2UgJiYgLy8gQWxzbyBoaWRkZW4gaWYgYW55IG9mIGl0cyBjb25uZWN0aW5nIG5vZGVzIGFyZSBoaWRkZW5cbiAgICAgIHRvTm9kZS5vcHRpb25zLmhpZGRlbiA9PT0gZmFsc2U7IC8vIGlkZW1cblxuICAgICAgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgICB0aGlzLmJvZHkuZWRnZUluZGljZXMucHVzaChlZGdlLmlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEJpbmQgYWxsIGV2ZW50c1xuICovXG5cblxuTmV0d29yay5wcm90b3R5cGUuYmluZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAvLyBUaGlzIGV2ZW50IHdpbGwgdHJpZ2dlciBhIHJlYnVpbGRpbmcgb2YgdGhlIGNhY2hlIGV2ZXJ5dGhpbmcuXG4gIC8vIFVzZWQgd2hlbiBub2RlcyBvciBlZGdlcyBoYXZlIGJlZW4gYWRkZWQgb3IgcmVtb3ZlZC5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgIF90aGlzMy5lZGdlc0hhbmRsZXIuX3VwZGF0ZVN0YXRlKCk7XG5cbiAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YVVwZGF0ZWRcIik7XG4gIH0pOyAvLyB0aGlzIGlzIGNhbGxlZCB3aGVuIG9wdGlvbnMgb2YgRVhJU1RJTkcgbm9kZXMgb3IgZWRnZXMgaGF2ZSBjaGFuZ2VkLlxuXG4gIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFVcGRhdGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBPcmRlciBpbXBvcnRhbnQgaW4gZm9sbG93aW5nIGJsb2NrXG4gICAgX3RoaXMzLmNsdXN0ZXJpbmcuX3VwZGF0ZVN0YXRlKCk7XG5cbiAgICBfdGhpczMuX3VwZGF0ZVZpc2libGVJbmRpY2VzKCk7XG5cbiAgICBfdGhpczMuX3VwZGF0ZVZhbHVlUmFuZ2UoX3RoaXMzLmJvZHkubm9kZXMpO1xuXG4gICAgX3RoaXMzLl91cGRhdGVWYWx1ZVJhbmdlKF90aGlzMy5ib2R5LmVkZ2VzKTsgLy8gc3RhcnQgc2ltdWxhdGlvbiAoY2FuIGJlIGNhbGxlZCBzYWZlbHksIGV2ZW4gaWYgYWxyZWFkeSBydW5uaW5nKVxuXG5cbiAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG5cbiAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBTZXQgbm9kZXMgYW5kIGVkZ2VzLCBhbmQgb3B0aW9uYWxseSBvcHRpb25zIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBbbm9kZXNdIEFycmF5IHdpdGggbm9kZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IFtlZGdlc10gQXJyYXkgd2l0aCBlZGdlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IFtkb3RdIFN0cmluZyBjb250YWluaW5nIGRhdGEgaW4gRE9UIGZvcm1hdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IFtnZXBoaV0gU3RyaW5nIGNvbnRhaW5pbmcgZGF0YSBpbiBnZXBoaSBKU09OIGZvcm1hdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPcHRpb25zfSBbb3B0aW9uc10gT2JqZWN0IHdpdGggb3B0aW9uc1xuICovXG5cblxuTmV0d29yay5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIC8vIHJlc2V0IHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlc2V0UGh5c2ljc1wiKTtcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNldERhdGFcIik7IC8vIHVuc2VsZWN0IGFsbCB0byBlbnN1cmUgbm8gc2VsZWN0aW9ucyBmcm9tIG9sZCBkYXRhIGFyZSBjYXJyaWVkIG92ZXIuXG5cbiAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG5cbiAgaWYgKGRhdGEgJiYgZGF0YS5kb3QgJiYgKGRhdGEubm9kZXMgfHwgZGF0YS5lZGdlcykpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0RhdGEgbXVzdCBjb250YWluIGVpdGhlciBwYXJhbWV0ZXIgXCJkb3RcIiBvciAnICsgJyBwYXJhbWV0ZXIgcGFpciBcIm5vZGVzXCIgYW5kIFwiZWRnZXNcIiwgYnV0IG5vdCBib3RoLicpO1xuICB9IC8vIHNldCBvcHRpb25zXG5cblxuICB0aGlzLnNldE9wdGlvbnMoZGF0YSAmJiBkYXRhLm9wdGlvbnMpOyAvLyBzZXQgYWxsIGRhdGFcblxuICBpZiAoZGF0YSAmJiBkYXRhLmRvdCkge1xuICAgIGNvbnNvbGUud2FybihcIlRoZSBkb3QgcHJvcGVydHkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgc3RhdGljIGNvbnZlcnREb3QgbWV0aG9kIHRvIGNvbnZlcnQgRE9UIGludG8gdmlzLm5ldHdvcmsgZm9ybWF0IGFuZCB1c2UgdGhlIG5vcm1hbCBkYXRhIGZvcm1hdCB3aXRoIG5vZGVzIGFuZCBlZGdlcy4gVGhpcyBjb252ZXJ0ZXIgaXMgdXNlZCBsaWtlIHRoaXM6IHZhciBkYXRhID0gdmlzLm5ldHdvcmsuY29udmVydERvdChkb3RTdHJpbmcpO1wiKTsgLy8gcGFyc2UgRE9UIGZpbGVcblxuICAgIHZhciBkb3REYXRhID0gRE9UVG9HcmFwaChkYXRhLmRvdCk7XG4gICAgdGhpcy5zZXREYXRhKGRvdERhdGEpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChkYXRhICYmIGRhdGEuZ2VwaGkpIHtcbiAgICAvLyBwYXJzZSBET1QgZmlsZVxuICAgIGNvbnNvbGUud2FybihcIlRoZSBnZXBoaSBwcm9wZXJ0eSBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBzdGF0aWMgY29udmVydEdlcGhpIG1ldGhvZCB0byBjb252ZXJ0IGdlcGhpIGludG8gdmlzLm5ldHdvcmsgZm9ybWF0IGFuZCB1c2UgdGhlIG5vcm1hbCBkYXRhIGZvcm1hdCB3aXRoIG5vZGVzIGFuZCBlZGdlcy4gVGhpcyBjb252ZXJ0ZXIgaXMgdXNlZCBsaWtlIHRoaXM6IHZhciBkYXRhID0gdmlzLm5ldHdvcmsuY29udmVydEdlcGhpKGdlcGhpSnNvbik7XCIpO1xuICAgIHZhciBnZXBoaURhdGEgPSBwYXJzZUdlcGhpKGRhdGEuZ2VwaGkpO1xuICAgIHRoaXMuc2V0RGF0YShnZXBoaURhdGEpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5vZGVzSGFuZGxlci5zZXREYXRhKGRhdGEgJiYgZGF0YS5ub2RlcywgdHJ1ZSk7XG4gICAgdGhpcy5lZGdlc0hhbmRsZXIuc2V0RGF0YShkYXRhICYmIGRhdGEuZWRnZXMsIHRydWUpO1xuICB9IC8vIGVtaXQgY2hhbmdlIGluIGRhdGFcblxuXG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7IC8vIGVtaXQgZGF0YSBsb2FkZWRcblxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFMb2FkZWRcIik7IC8vIGZpbmQgYSBzdGFibGUgcG9zaXRpb24gb3Igc3RhcnQgYW5pbWF0aW5nIHRvIGEgc3RhYmxlIHBvc2l0aW9uXG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImluaXRQaHlzaWNzXCIpO1xufTtcbi8qKlxuICogQ2xlYW5zIHVwIGFsbCBiaW5kaW5ncyBvZiB0aGUgbmV0d29yaywgcmVtb3ZpbmcgaXQgZnVsbHkgZnJvbSB0aGUgbWVtb3J5IElGIHRoZSB2YXJpYWJsZSBpcyBzZXQgdG8gbnVsbCBhZnRlciBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gKiB2YXIgbmV0d29yayA9IG5ldyB2aXMuTmV0d29yayguLik7XG4gKiBuZXR3b3JrLmRlc3Ryb3koKTtcbiAqIG5ldHdvcmsgPSBudWxsO1xuICovXG5cblxuTmV0d29yay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImRlc3Ryb3lcIik7IC8vIGNsZWFyIGV2ZW50c1xuXG4gIHRoaXMuYm9keS5lbWl0dGVyLm9mZigpO1xuICB0aGlzLm9mZigpOyAvLyBkZWxldGUgbW9kdWxlc1xuXG4gIGRlbGV0ZSB0aGlzLmdyb3VwcztcbiAgZGVsZXRlIHRoaXMuY2FudmFzO1xuICBkZWxldGUgdGhpcy5zZWxlY3Rpb25IYW5kbGVyO1xuICBkZWxldGUgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXI7XG4gIGRlbGV0ZSB0aGlzLnZpZXc7XG4gIGRlbGV0ZSB0aGlzLnJlbmRlcmVyO1xuICBkZWxldGUgdGhpcy5waHlzaWNzO1xuICBkZWxldGUgdGhpcy5sYXlvdXRFbmdpbmU7XG4gIGRlbGV0ZSB0aGlzLmNsdXN0ZXJpbmc7XG4gIGRlbGV0ZSB0aGlzLm1hbmlwdWxhdGlvbjtcbiAgZGVsZXRlIHRoaXMubm9kZXNIYW5kbGVyO1xuICBkZWxldGUgdGhpcy5lZGdlc0hhbmRsZXI7XG4gIGRlbGV0ZSB0aGlzLmNvbmZpZ3VyYXRvcjtcbiAgZGVsZXRlIHRoaXMuaW1hZ2VzO1xuXG4gIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIG5vZGVJZCkpIGNvbnRpbnVlO1xuICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgfVxuXG4gIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkuZWRnZXMsIGVkZ2VJZCkpIGNvbnRpbnVlO1xuICAgIGRlbGV0ZSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgfSAvLyByZW1vdmUgdGhlIGNvbnRhaW5lciBhbmQgZXZlcnl0aGluZyBpbnNpZGUgaXQgcmVjdXJzaXZlbHlcblxuXG4gIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmJvZHkuY29udGFpbmVyKTtcbn07XG4vKipcbiAqIFVwZGF0ZSB0aGUgdmFsdWVzIG9mIGFsbCBvYmplY3QgaW4gdGhlIGdpdmVuIGFycmF5IGFjY29yZGluZyB0byB0aGUgY3VycmVudFxuICogdmFsdWUgcmFuZ2Ugb2YgdGhlIG9iamVjdHMgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXQgb2YgRWRnZXMgb3IgTm9kZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdHMgbXVzdCBoYXZlIGEgbWV0aG9kIGdldFZhbHVlKCkgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlUmFuZ2UobWluLCBtYXgpLlxuICogQHByaXZhdGVcbiAqL1xuXG5cbk5ldHdvcmsucHJvdG90eXBlLl91cGRhdGVWYWx1ZVJhbmdlID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgaWQ7IC8vIGRldGVybWluZSB0aGUgcmFuZ2Ugb2YgdGhlIG9iamVjdHNcblxuICB2YXIgdmFsdWVNaW4gPSB1bmRlZmluZWQ7XG4gIHZhciB2YWx1ZU1heCA9IHVuZGVmaW5lZDtcbiAgdmFyIHZhbHVlVG90YWwgPSAwO1xuXG4gIGZvciAoaWQgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGlkKSkge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2lkXS5nZXRWYWx1ZSgpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZU1pbiA9IHZhbHVlTWluID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IE1hdGgubWluKHZhbHVlLCB2YWx1ZU1pbik7XG4gICAgICAgIHZhbHVlTWF4ID0gdmFsdWVNYXggPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogTWF0aC5tYXgodmFsdWUsIHZhbHVlTWF4KTtcbiAgICAgICAgdmFsdWVUb3RhbCArPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gYWRqdXN0IHRoZSByYW5nZSBvZiBhbGwgb2JqZWN0c1xuXG5cbiAgaWYgKHZhbHVlTWluICE9PSB1bmRlZmluZWQgJiYgdmFsdWVNYXggIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoaWQgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaWQpKSB7XG4gICAgICAgIG9ialtpZF0uc2V0VmFsdWVSYW5nZSh2YWx1ZU1pbiwgdmFsdWVNYXgsIHZhbHVlVG90YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIE5ldHdvcmsgaXMgYWN0aXZlLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxuTmV0d29yay5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5hY3RpdmF0b3IgfHwgdGhpcy5hY3RpdmF0b3IuYWN0aXZlO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2FudmFzLnNldFNpemUuYXBwbHkodGhpcy5jYW52YXMsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5jYW52YXNUb0RPTSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2FudmFzLmNhbnZhc1RvRE9NLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuRE9NdG9DYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcy5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcbn07XG4vKipcbiAqIE5vZGVzIGNhbiBiZSBpbiBjbHVzdGVycy4gQ2x1c3RlcnMgY2FuIGFsc28gYmUgaW4gY2x1c3RlcnMuIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbmQgYXJyYXkgb2ZcbiAqIG5vZGVJZHMgc2hvd2luZyB3aGVyZSB0aGUgbm9kZSBpcy5cbiAqXG4gKiBJZiBhbnkgbm9kZUlkIGluIHRoZSBjaGFpbiwgZXNwZWNpYWxseSB0aGUgZmlyc3QgcGFzc2VkIGluIGFzIGEgcGFyYW1ldGVyLCBpcyBub3QgcHJlc2VudCBpblxuICogdGhlIGN1cnJlbnQgbm9kZXMgbGlzdCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQuXG4gKlxuICogRXhhbXBsZTpcbiAqIGNsdXN0ZXIgJ0EnIGNvbnRhaW5zIGNsdXN0ZXIgJ0InLFxuICogY2x1c3RlciAnQicgY29udGFpbnMgY2x1c3RlciAnQycsXG4gKiBjbHVzdGVyICdDJyBjb250YWlucyBub2RlICdmcmVkJy5cbiAqIGBqc25ldHdvcmsuY2x1c3RlcmluZy5maW5kTm9kZSgnZnJlZCcpYCB3aWxsIHJldHVybiBgWydBJywnQicsJ0MnLCdmcmVkJ11gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbm9kZUlkXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cblxuXG5OZXR3b3JrLnByb3RvdHlwZS5maW5kTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5maW5kTm9kZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5pc0NsdXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuaXNDbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLm9wZW5DbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLm9wZW5DbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXROb2Rlc0luQ2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXROb2Rlc0luQ2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyQnlDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmNsdXN0ZXJCeUNvbm5lY3Rpb24uYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuY2x1c3RlckJ5SHVic2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyQnlIdWJzaXplLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnVwZGF0ZUNsdXN0ZXJlZE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcudXBkYXRlQ2x1c3RlcmVkTm9kZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRDbHVzdGVyZWRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXRDbHVzdGVyZWRFZGdlcy5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRCYXNlRWRnZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXRCYXNlRWRnZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRCYXNlRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuZ2V0QmFzZUVkZ2VzLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnVwZGF0ZUVkZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcudXBkYXRlRWRnZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuLyoqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIGNsdXN0ZXIgYWxsIG5vZGVzIHdpdGggMSBlZGdlIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBjb25uZWN0ZWQgbm9kZS5cbiAqIFRoZSBvcHRpb25zIG9iamVjdCBpcyBleHBsYWluZWQgaW4gZnVsbCA8YSBkYXRhLXNjcm9sbD1cIlwiIGRhdGEtb3B0aW9ucz1cInsgJnF1b3Q7ZWFzaW5nJnF1b3Q7OiAmcXVvdDtlYXNlSW5DdWJpYyZxdW90OyB9XCIgaHJlZj1cIiNvcHRpb25zT2JqZWN0XCI+YmVsb3c8L2E+LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuXG5OZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyT3V0bGllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3Rlck91dGxpZXJzLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldFNlZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxheW91dEVuZ2luZS5nZXRTZWVkLmFwcGx5KHRoaXMubGF5b3V0RW5naW5lLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZW5hYmxlRWRpdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lbmFibGVFZGl0TW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmRpc2FibGVFZGl0TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmRpc2FibGVFZGl0TW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmFkZE5vZGVNb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uYWRkTm9kZU1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5lZGl0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVkaXROb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZWRpdE5vZGVNb2RlID0gZnVuY3Rpb24gKCkge1xuICBjb25zb2xlLndhcm4oXCJEZXByZWNhdGVkOiBQbGVhc2UgdXNlIGVkaXROb2RlIGluc3RlYWQgb2YgZWRpdE5vZGVNb2RlLlwiKTtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVkaXROb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuYWRkRWRnZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5hZGRFZGdlTW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmVkaXRFZGdlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVkaXRFZGdlTW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmRlbGV0ZVNlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZGVsZXRlU2VsZWN0ZWQuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRQb3NpdGlvbnMuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldFBvc2l0aW9uLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuc3RvcmVQb3NpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5zdG9yZVBvc2l0aW9ucy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLm1vdmVOb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIubW92ZU5vZGUuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldEJvdW5kaW5nQm94LmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkTm9kZXMgPSBmdW5jdGlvbiAob2JqZWN0SWQpIHtcbiAgaWYgKHRoaXMuYm9keS5ub2Rlc1tvYmplY3RJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRDb25uZWN0ZWROb2Rlcy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlc0hhbmRsZXIuZ2V0Q29ubmVjdGVkTm9kZXMuYXBwbHkodGhpcy5lZGdlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIH1cbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldENvbm5lY3RlZEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0Q29ubmVjdGVkRWRnZXMuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5zdGFydFNpbXVsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBoeXNpY3Muc3RhcnRTaW11bGF0aW9uLmFwcGx5KHRoaXMucGh5c2ljcywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnN0b3BTaW11bGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5waHlzaWNzLnN0b3BTaW11bGF0aW9uLmFwcGx5KHRoaXMucGh5c2ljcywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnN0YWJpbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGh5c2ljcy5zdGFiaWxpemUuYXBwbHkodGhpcy5waHlzaWNzLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGlvbi5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2V0U2VsZWN0aW9uLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldFNlbGVjdGVkTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2RlSWRzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldFNlbGVjdGVkRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlSWRzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldE5vZGVBdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0LmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcblxuICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIG5vZGUuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBub2RlLmlkO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRFZGdlQXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldEVkZ2VBdC5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGVkZ2UgIT09IHVuZGVmaW5lZCAmJiBlZGdlLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZWRnZS5pZDtcbiAgfVxuXG4gIHJldHVybiBlZGdlO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuc2VsZWN0Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0Tm9kZXMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuc2VsZWN0RWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0RWRnZXMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUudW5zZWxlY3RBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbC5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5jb21taXRXaXRob3V0RW1pdHRpbmcuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyKTtcbiAgdGhpcy5yZWRyYXcoKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVkcmF3LmFwcGx5KHRoaXMucmVuZGVyZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5nZXRTY2FsZS5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRWaWV3UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZpZXcuZ2V0Vmlld1Bvc2l0aW9uLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmZpdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5maXQuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3Lm1vdmVUby5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5mb2N1cy5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5yZWxlYXNlTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5yZWxlYXNlTm9kZS5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRPcHRpb25zRnJvbUNvbmZpZ3VyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICBpZiAodGhpcy5jb25maWd1cmF0b3IpIHtcbiAgICBvcHRpb25zID0gdGhpcy5jb25maWd1cmF0b3IuZ2V0T3B0aW9ucy5hcHBseSh0aGlzLmNvbmZpZ3VyYXRvcik7XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucztcbn07XG5cbnZhciBwYXJzZURPVE5ldHdvcmsgPSBET1RUb0dyYXBoO1xuLy8gb3ZlcmZsb3cgaW4gVU1EIGJ1aWxkcy4gVGhleSBhbGwgZXhwb3J0IHZpcyBuYW1lc3BhY2UgdGhlcmVmb3JlIHJlZXhwb3J0aW5nXG4vLyBsZWFkcyB0byBsb2FkaW5nIHZpcyB0byBsb2FkIHZpcyB0byBsb2FkIHZpc+KAplxuXG5leHBvcnQgeyBEYXRhU2V0LCBEYXRhVmlldywgTmV0d29yaywgSW1hZ2VzIGFzIE5ldHdvcmtJbWFnZXMsIFF1ZXVlLCBpbmRleCBhcyBkYXRhLCBkb3RwYXJzZXIgYXMgbmV0d29ya0RPVFBhcnNlciwgZ2VwaGlQYXJzZXIgYXMgbmV0d29ya0dlcGhpUGFyc2VyLCBvcHRpb25zIGFzIG5ldHdvcmtPcHRpb25zLCBwYXJzZURPVE5ldHdvcmssIHBhcnNlR2VwaGkgYXMgcGFyc2VHZXBoaU5ldHdvcmsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpcy1uZXR3b3JrLmpzLm1hcFxuIiwiZXhwb3J0ICogZnJvbSBcIi4vZXNtXCI7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuX193ZWJwYWNrX3JlcXVpcmVfXy5jID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fO1xuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlLnBhdGhzID0gW107XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiIiwiLy8gbW9kdWxlIGNhY2hlIGFyZSB1c2VkIHNvIGVudHJ5IGlubGluaW5nIGlzIGRpc2FibGVkXG4vLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL3Zpc19kYXdnLnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9